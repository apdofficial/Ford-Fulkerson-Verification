(get-info :version)
; (:version "4.8.6")
; Started: 2022-06-14 20:18:16
; Silicon.version: 1.1-SNAPSHOT (cd20cf02@(detached))
; Input file: -
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Boogie: default
(set-option :auto_config false) ; Usually a good idea
(set-option :smt.restart_strategy 0)
(set-option :smt.restart_factor |1.5|)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :smt.delay_units_threshold 16)
(set-option :nnf.sk_hack true)
(set-option :type_check true)
(set-option :smt.bv.reflect true)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.qi.cost "(+ weight generation)")
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :smt.phase_selection 0) ; default: 3, Boogie: 0
(set-option :sat.phase caching)
(set-option :sat.random_seed 0)
(set-option :nlsat.randomize true)
(set-option :nlsat.seed 0)
(set-option :nlsat.shuffle_vars false)
(set-option :fp.spacer.order_children 0) ; Not available with Z3 4.5
(set-option :fp.spacer.random_seed 0) ; Not available with Z3 4.5
(set-option :smt.arith.random_initial_value true) ; Boogie: true
(set-option :smt.random_seed 0)
(set-option :sls.random_offset true)
(set-option :sls.random_seed 0)
(set-option :sls.restart_init false)
(set-option :sls.walksat_ucb true)
(set-option :model.v2 true)
; 
; ; /preamble.smt2
(declare-datatypes () ((
    $Snap ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM)
(declare-sort $PPM)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm) (ub $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))
         (< p $Perm.Write)))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Seq<Int>>)
(declare-sort Seq<Int>)
(declare-sort Set<Seq<Seq<Int>>>)
(declare-sort Set<option<array>>)
(declare-sort Set<Seq<Int>>)
(declare-sort Set<Int>)
(declare-sort Set<Bool>)
(declare-sort Set<$Ref>)
(declare-sort Set<$Snap>)
(declare-sort t_null)
(declare-sort any)
(declare-sort void)
(declare-sort option<any>)
(declare-sort option<array>)
(declare-sort array)
(declare-sort $FVF<Int>)
(declare-sort $FVF<option<array>>)
(declare-sort $FVF<Bool>)
(declare-sort $FVF<Seq<Seq<Int>>>)
(declare-sort $FVF<Seq<Int>>)
(declare-sort $FVF<$Ref>)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Seq<Int>>To$Snap (Seq<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Seq<Int>> ($Snap) Seq<Seq<Int>>)
(assert (forall ((x Seq<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSeq<Seq<Int>>($SortWrappers.Seq<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Seq<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSeq<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Seq<Int>>To$Snap($SortWrappers.$SnapToSeq<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSeq<Seq<Int>> x))
    :qid |$Snap.Seq<Seq<Int>>To$SnapToSeq<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<Seq<Seq<Int>>>To$Snap (Set<Seq<Seq<Int>>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Seq<Seq<Int>>> ($Snap) Set<Seq<Seq<Int>>>)
(assert (forall ((x Set<Seq<Seq<Int>>>)) (!
    (= x ($SortWrappers.$SnapToSet<Seq<Seq<Int>>>($SortWrappers.Set<Seq<Seq<Int>>>To$Snap x)))
    :pattern (($SortWrappers.Set<Seq<Seq<Int>>>To$Snap x))
    :qid |$Snap.$SnapToSet<Seq<Seq<Int>>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Seq<Seq<Int>>>To$Snap($SortWrappers.$SnapToSet<Seq<Seq<Int>>> x)))
    :pattern (($SortWrappers.$SnapToSet<Seq<Seq<Int>>> x))
    :qid |$Snap.Set<Seq<Seq<Int>>>To$SnapToSet<Seq<Seq<Int>>>|
    )))
(declare-fun $SortWrappers.Set<option<array>>To$Snap (Set<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<option<array>> ($Snap) Set<option<array>>)
(assert (forall ((x Set<option<array>>)) (!
    (= x ($SortWrappers.$SnapToSet<option<array>>($SortWrappers.Set<option<array>>To$Snap x)))
    :pattern (($SortWrappers.Set<option<array>>To$Snap x))
    :qid |$Snap.$SnapToSet<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<option<array>>To$Snap($SortWrappers.$SnapToSet<option<array>> x)))
    :pattern (($SortWrappers.$SnapToSet<option<array>> x))
    :qid |$Snap.Set<option<array>>To$SnapToSet<option<array>>|
    )))
(declare-fun $SortWrappers.Set<Seq<Int>>To$Snap (Set<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Seq<Int>> ($Snap) Set<Seq<Int>>)
(assert (forall ((x Set<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSet<Seq<Int>>($SortWrappers.Set<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Set<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSet<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Seq<Int>>To$Snap($SortWrappers.$SnapToSet<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSet<Seq<Int>> x))
    :qid |$Snap.Set<Seq<Int>>To$SnapToSet<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.t_nullTo$Snap (t_null) $Snap)
(declare-fun $SortWrappers.$SnapTot_null ($Snap) t_null)
(assert (forall ((x t_null)) (!
    (= x ($SortWrappers.$SnapTot_null($SortWrappers.t_nullTo$Snap x)))
    :pattern (($SortWrappers.t_nullTo$Snap x))
    :qid |$Snap.$SnapTot_nullTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.t_nullTo$Snap($SortWrappers.$SnapTot_null x)))
    :pattern (($SortWrappers.$SnapTot_null x))
    :qid |$Snap.t_nullTo$SnapTot_null|
    )))
(declare-fun $SortWrappers.anyTo$Snap (any) $Snap)
(declare-fun $SortWrappers.$SnapToany ($Snap) any)
(assert (forall ((x any)) (!
    (= x ($SortWrappers.$SnapToany($SortWrappers.anyTo$Snap x)))
    :pattern (($SortWrappers.anyTo$Snap x))
    :qid |$Snap.$SnapToanyTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.anyTo$Snap($SortWrappers.$SnapToany x)))
    :pattern (($SortWrappers.$SnapToany x))
    :qid |$Snap.anyTo$SnapToany|
    )))
(declare-fun $SortWrappers.voidTo$Snap (void) $Snap)
(declare-fun $SortWrappers.$SnapTovoid ($Snap) void)
(assert (forall ((x void)) (!
    (= x ($SortWrappers.$SnapTovoid($SortWrappers.voidTo$Snap x)))
    :pattern (($SortWrappers.voidTo$Snap x))
    :qid |$Snap.$SnapTovoidTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.voidTo$Snap($SortWrappers.$SnapTovoid x)))
    :pattern (($SortWrappers.$SnapTovoid x))
    :qid |$Snap.voidTo$SnapTovoid|
    )))
(declare-fun $SortWrappers.option<any>To$Snap (option<any>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<any> ($Snap) option<any>)
(assert (forall ((x option<any>)) (!
    (= x ($SortWrappers.$SnapTooption<any>($SortWrappers.option<any>To$Snap x)))
    :pattern (($SortWrappers.option<any>To$Snap x))
    :qid |$Snap.$SnapTooption<any>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<any>To$Snap($SortWrappers.$SnapTooption<any> x)))
    :pattern (($SortWrappers.$SnapTooption<any> x))
    :qid |$Snap.option<any>To$SnapTooption<any>|
    )))
(declare-fun $SortWrappers.option<array>To$Snap (option<array>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<array> ($Snap) option<array>)
(assert (forall ((x option<array>)) (!
    (= x ($SortWrappers.$SnapTooption<array>($SortWrappers.option<array>To$Snap x)))
    :pattern (($SortWrappers.option<array>To$Snap x))
    :qid |$Snap.$SnapTooption<array>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<array>To$Snap($SortWrappers.$SnapTooption<array> x)))
    :pattern (($SortWrappers.$SnapTooption<array> x))
    :qid |$Snap.option<array>To$SnapTooption<array>|
    )))
(declare-fun $SortWrappers.arrayTo$Snap (array) $Snap)
(declare-fun $SortWrappers.$SnapToarray ($Snap) array)
(assert (forall ((x array)) (!
    (= x ($SortWrappers.$SnapToarray($SortWrappers.arrayTo$Snap x)))
    :pattern (($SortWrappers.arrayTo$Snap x))
    :qid |$Snap.$SnapToarrayTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.arrayTo$Snap($SortWrappers.$SnapToarray x)))
    :pattern (($SortWrappers.$SnapToarray x))
    :qid |$Snap.arrayTo$SnapToarray|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<Int>To$Snap ($FVF<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Int> ($Snap) $FVF<Int>)
(assert (forall ((x $FVF<Int>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Int>($SortWrappers.$FVF<Int>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Int>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Int>To$Snap($SortWrappers.$SnapTo$FVF<Int> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Int> x))
    :qid |$Snap.$FVF<Int>To$SnapTo$FVF<Int>|
    )))
(declare-fun $SortWrappers.$FVF<option<array>>To$Snap ($FVF<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<option<array>> ($Snap) $FVF<option<array>>)
(assert (forall ((x $FVF<option<array>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<option<array>>($SortWrappers.$FVF<option<array>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<option<array>>To$Snap($SortWrappers.$SnapTo$FVF<option<array>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<option<array>> x))
    :qid |$Snap.$FVF<option<array>>To$SnapTo$FVF<option<array>>|
    )))
(declare-fun $SortWrappers.$FVF<Bool>To$Snap ($FVF<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Bool> ($Snap) $FVF<Bool>)
(assert (forall ((x $FVF<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Bool>($SortWrappers.$FVF<Bool>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Bool>To$Snap($SortWrappers.$SnapTo$FVF<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Bool> x))
    :qid |$Snap.$FVF<Bool>To$SnapTo$FVF<Bool>|
    )))
(declare-fun $SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap ($FVF<Seq<Seq<Int>>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> ($Snap) $FVF<Seq<Seq<Int>>>)
(assert (forall ((x $FVF<Seq<Seq<Int>>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>>($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Seq<Seq<Int>>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> x))
    :qid |$Snap.$FVF<Seq<Seq<Int>>>To$SnapTo$FVF<Seq<Seq<Int>>>|
    )))
(declare-fun $SortWrappers.$FVF<Seq<Int>>To$Snap ($FVF<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Seq<Int>> ($Snap) $FVF<Seq<Int>>)
(assert (forall ((x $FVF<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Seq<Int>>($SortWrappers.$FVF<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Seq<Int>>To$Snap($SortWrappers.$SnapTo$FVF<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Seq<Int>> x))
    :qid |$Snap.$FVF<Seq<Int>>To$SnapTo$FVF<Seq<Int>>|
    )))
(declare-fun $SortWrappers.$FVF<$Ref>To$Snap ($FVF<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<$Ref> ($Snap) $FVF<$Ref>)
(assert (forall ((x $FVF<$Ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<$Ref>($SortWrappers.$FVF<$Ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<$Ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<$Ref>To$Snap($SortWrappers.$SnapTo$FVF<$Ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<$Ref> x))
    :qid |$Snap.$FVF<$Ref>To$SnapTo$FVF<$Ref>|
    )))
; ////////// Symbols
(declare-fun Set_in (Seq<Seq<Int>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_card (Set<Seq<Seq<Int>>>) Int)
(declare-const Set_empty Set<Seq<Seq<Int>>>)
(declare-fun Set_singleton (Seq<Seq<Int>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_unionone (Set<Seq<Seq<Int>>> Seq<Seq<Int>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_union (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_disjoint (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_difference (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_intersection (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_subset (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_equal (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_in (option<array> Set<option<array>>) Bool)
(declare-fun Set_card (Set<option<array>>) Int)
(declare-const Set_empty Set<option<array>>)
(declare-fun Set_singleton (option<array>) Set<option<array>>)
(declare-fun Set_unionone (Set<option<array>> option<array>) Set<option<array>>)
(declare-fun Set_union (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_disjoint (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_difference (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_intersection (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_subset (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_equal (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_in (Seq<Int> Set<Seq<Int>>) Bool)
(declare-fun Set_card (Set<Seq<Int>>) Int)
(declare-const Set_empty Set<Seq<Int>>)
(declare-fun Set_singleton (Seq<Int>) Set<Seq<Int>>)
(declare-fun Set_unionone (Set<Seq<Int>> Seq<Int>) Set<Seq<Int>>)
(declare-fun Set_union (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_disjoint (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_difference (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_intersection (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_subset (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_equal (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_disjoint (Set<Int> Set<Int>) Bool)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_disjoint (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_disjoint (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_disjoint (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Seq_length (Seq<Seq<Int>>) Int)
(declare-const Seq_empty Seq<Seq<Int>>)
(declare-fun Seq_singleton (Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_build (Seq<Seq<Int>> Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_index (Seq<Seq<Int>> Int) Seq<Int>)
(declare-fun Seq_append (Seq<Seq<Int>> Seq<Seq<Int>>) Seq<Seq<Int>>)
(declare-fun Seq_update (Seq<Seq<Int>> Int Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_contains (Seq<Seq<Int>> Seq<Int>) Bool)
(declare-fun Seq_take (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_drop (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_equal (Seq<Seq<Int>> Seq<Seq<Int>>) Bool)
(declare-fun Seq_sameuntil (Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_build (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_sameuntil (Seq<Int> Seq<Int> Int) Bool)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun array_loc<Ref> (array Int) $Ref)
(declare-fun alen<Int> (array) Int)
(declare-fun loc_inv_1<array> ($Ref) array)
(declare-fun loc_inv_2<Int> ($Ref) Int)
(declare-const None<option<array>> option<array>)
(declare-fun some<option<array>> (array) option<array>)
(declare-fun option_get<array> (option<array>) array)
(declare-const v_null<t_null> t_null)
(declare-const None<option<any>> option<any>)
(declare-fun some<option<any>> (any) option<any>)
(declare-fun option_get<any> (option<any>) any)
(declare-const unit<void> void)
; /field_value_functions_declarations.smt2 [int: Int]
(declare-fun $FVF.domain_int ($FVF<Int>) Set<$Ref>)
(declare-fun $FVF.lookup_int ($FVF<Int> $Ref) Int)
(declare-fun $FVF.after_int ($FVF<Int> $FVF<Int>) Bool)
(declare-fun $FVF.loc_int (Int $Ref) Bool)
(declare-fun $FVF.perm_int ($FPM $Ref) $Perm)
(declare-const $fvfTOP_int $FVF<Int>)
; /field_value_functions_declarations.smt2 [option$array$: option[array]]
(declare-fun $FVF.domain_option$array$ ($FVF<option<array>>) Set<$Ref>)
(declare-fun $FVF.lookup_option$array$ ($FVF<option<array>> $Ref) option<array>)
(declare-fun $FVF.after_option$array$ ($FVF<option<array>> $FVF<option<array>>) Bool)
(declare-fun $FVF.loc_option$array$ (option<array> $Ref) Bool)
(declare-fun $FVF.perm_option$array$ ($FPM $Ref) $Perm)
(declare-const $fvfTOP_option$array$ $FVF<option<array>>)
; /field_value_functions_declarations.smt2 [bool: Bool]
(declare-fun $FVF.domain_bool ($FVF<Bool>) Set<$Ref>)
(declare-fun $FVF.lookup_bool ($FVF<Bool> $Ref) Bool)
(declare-fun $FVF.after_bool ($FVF<Bool> $FVF<Bool>) Bool)
(declare-fun $FVF.loc_bool (Bool $Ref) Bool)
(declare-fun $FVF.perm_bool ($FPM $Ref) $Perm)
(declare-const $fvfTOP_bool $FVF<Bool>)
; /field_value_functions_declarations.smt2 [Gf_seq: Seq[Seq[Int]]]
(declare-fun $FVF.domain_Gf_seq ($FVF<Seq<Seq<Int>>>) Set<$Ref>)
(declare-fun $FVF.lookup_Gf_seq ($FVF<Seq<Seq<Int>>> $Ref) Seq<Seq<Int>>)
(declare-fun $FVF.after_Gf_seq ($FVF<Seq<Seq<Int>>> $FVF<Seq<Seq<Int>>>) Bool)
(declare-fun $FVF.loc_Gf_seq (Seq<Seq<Int>> $Ref) Bool)
(declare-fun $FVF.perm_Gf_seq ($FPM $Ref) $Perm)
(declare-const $fvfTOP_Gf_seq $FVF<Seq<Seq<Int>>>)
; /field_value_functions_declarations.smt2 [P_seq: Seq[Int]]
(declare-fun $FVF.domain_P_seq ($FVF<Seq<Int>>) Set<$Ref>)
(declare-fun $FVF.lookup_P_seq ($FVF<Seq<Int>> $Ref) Seq<Int>)
(declare-fun $FVF.after_P_seq ($FVF<Seq<Int>> $FVF<Seq<Int>>) Bool)
(declare-fun $FVF.loc_P_seq (Seq<Int> $Ref) Bool)
(declare-fun $FVF.perm_P_seq ($FPM $Ref) $Perm)
(declare-const $fvfTOP_P_seq $FVF<Seq<Int>>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun valid_graph_vertices1 ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%limited ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun SquareIntMatrix ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SumOutgoingFlow ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumOutgoingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumOutgoingFlow%stateless ($Ref Seq<Seq<Int>> Int Int) Bool)
(declare-fun SumIncomingFlow ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumIncomingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumIncomingFlow%stateless ($Ref Seq<Seq<Int>> Int Int) Bool)
(declare-fun AugPath ($Snap $Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%stateless ($Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun aloc ($Snap array Int) $Ref)
(declare-fun aloc%limited ($Snap array Int) $Ref)
(declare-fun aloc%stateless (array Int) Bool)
(declare-fun opt_get1 ($Snap option<array>) array)
(declare-fun opt_get1%limited ($Snap option<array>) array)
(declare-fun opt_get1%stateless (option<array>) Bool)
(declare-fun NonNegativeCapacities ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun FlowConservation ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun any_as ($Snap any) any)
(declare-fun any_as%limited ($Snap any) any)
(declare-fun any_as%stateless (any) Bool)
(declare-fun opt_get ($Snap option<any>) any)
(declare-fun opt_get%limited ($Snap option<any>) any)
(declare-fun opt_get%stateless (option<any>) Bool)
(declare-fun ExAugPath ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun initializeSeqWithZeros ($Snap $Ref Seq<Int> Int) Seq<Int>)
(declare-fun initializeSeqWithZeros%limited ($Snap $Ref Seq<Int> Int) Seq<Int>)
(declare-fun initializeSeqWithZeros%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%stateless ($Ref option<array> Int) Bool)
(declare-fun FlowNetwork ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun scale ($Snap $Perm) $Perm)
(declare-fun scale%limited ($Snap $Perm) $Perm)
(declare-fun scale%stateless ($Perm) Bool)
(declare-fun Flow ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun Flow%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun Flow%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun as_any ($Snap any) any)
(declare-fun as_any%limited ($Snap any) any)
(declare-fun as_any%stateless (any) Bool)
(declare-fun type ($Snap $Ref) Int)
(declare-fun type%limited ($Snap $Ref) Int)
(declare-fun type%stateless ($Ref) Bool)
(declare-fun opt_or_else ($Snap option<any> any) any)
(declare-fun opt_or_else%limited ($Snap option<any> any) any)
(declare-fun opt_or_else%stateless (option<any> any) Bool)
(declare-fun subtype ($Snap Int Int) Bool)
(declare-fun subtype%limited ($Snap Int Int) Bool)
(declare-fun subtype%stateless (Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun lock_inv_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_inv_Object%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_Object%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Seq<Int>>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Seq<Int>>)) 0))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Seq[Int]]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Seq[Int]]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_append|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append (as Seq_empty  Seq<Seq<Int>>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Seq<Int>>) s))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Seq<Int>>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Seq<Int>>)))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Seq[Int]]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :qid |$Seq[Seq[Int]]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_build|)))
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Int]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Int]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Int]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Int]_prog.seq_length_over_append|)))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Int]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append (as Seq_empty  Seq<Int>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Int>) s))
  :qid |$Seq[Int]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Int>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Int>)))
  :qid |$Seq[Int]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Int]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Int]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Int]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Int]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Int)) (!
  (not (Seq_contains (as Seq_empty  Seq<Int>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Int>) e))
  :qid |$Seq[Int]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (e Int)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Int]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Int>) (e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Int]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Int]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Int]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Int]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Int]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Int]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Int>) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_build|)))
(assert (forall ((min_ Int) (max Int)) (!
  (ite
    (< min_ max)
    (= (Seq_length (Seq_range min_ max)) (- max min_))
    (= (Seq_length (Seq_range min_ max)) 0))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (i Int)) (!
  (implies
    (and (<= 0 i) (< i (- max min_)))
    (= (Seq_index (Seq_range min_ max) i) (+ min_ i)))
  :pattern ((Seq_index (Seq_range min_ max) i))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (e Int)) (!
  (= (Seq_contains (Seq_range min_ max) e) (and (<= min_ e) (< e max)))
  :pattern ((Seq_contains (Seq_range min_ max) e))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<Seq<Seq<Int>>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Seq[Int]]]_prog.card_non_negative|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (not (Set_in e (as Set_empty  Set<Seq<Seq<Int>>>)))
  :pattern ((Set_in e (as Set_empty  Set<Seq<Seq<Int>>>)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_empty_set|)))
(assert (forall ((s Set<Seq<Seq<Int>>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Seq<Seq<Int>>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Seq<Seq<Int>>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Seq[Int]]]_prog.empty_set_cardinality|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_singleton_set|)))
(assert (forall ((e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_singleton_set_equality|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_unionone_same|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_unionone_other|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Seq[Seq[Int]]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_difference|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.subset_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.equality_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.native_equality|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.cardinality_difference|)))
(assert (forall ((s Set<option<array>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.card_non_negative|)))
(assert (forall ((e option<array>)) (!
  (not (Set_in e (as Set_empty  Set<option<array>>)))
  :pattern ((Set_in e (as Set_empty  Set<option<array>>)))
  :qid |$Set[option[array]]_prog.in_empty_set|)))
(assert (forall ((s Set<option<array>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<option<array>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e option<array>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.empty_set_cardinality|)))
(assert (forall ((e option<array>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[option[array]]_prog.in_singleton_set|)))
(assert (forall ((e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[option[array]]_prog.in_singleton_set_equality|)))
(assert (forall ((e option<array>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[option[array]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[option[array]]_prog.in_unionone_same|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[option[array]]_prog.in_unionone_other|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[option[array]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[option[array]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[option[array]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e option<array>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[option[array]]_prog.subset_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e option<array>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.equality_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.native_equality|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e option<array>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[option[array]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_difference|)))
(assert (forall ((s Set<Seq<Int>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Int]]_prog.card_non_negative|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Set_in e (as Set_empty  Set<Seq<Int>>)))
  :pattern ((Set_in e (as Set_empty  Set<Seq<Int>>)))
  :qid |$Set[Seq[Int]]_prog.in_empty_set|)))
(assert (forall ((s Set<Seq<Int>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Seq<Int>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Seq<Int>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Int]]_prog.empty_set_cardinality|)))
(assert (forall ((e Seq<Int>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Seq[Int]]_prog.in_singleton_set|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Seq[Int]]_prog.in_singleton_set_equality|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Seq[Int]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Seq[Int]]_prog.in_unionone_same|)))
(assert (forall ((s Set<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Seq[Int]]_prog.in_unionone_other|)))
(assert (forall ((s Set<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Seq[Int]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Int]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Int]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Seq[Int]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Seq[Int]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Seq[Int]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Int]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Seq[Int]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Seq[Int]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Seq[Int]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Seq[Int]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Seq[Int]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Seq[Int]]_prog.in_difference|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Int]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Seq<Int>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Seq[Int]]_prog.subset_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Seq<Int>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Int]]_prog.equality_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Int]]_prog.native_equality|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Seq<Int>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Seq[Int]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Seq[Int]]_prog.cardinality_difference|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.card_non_negative|)))
(assert (forall ((e Int)) (!
  (not (Set_in e (as Set_empty  Set<Int>)))
  :pattern ((Set_in e (as Set_empty  Set<Int>)))
  :qid |$Set[Int]_prog.in_empty_set|)))
(assert (forall ((s Set<Int>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Int)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.empty_set_cardinality|)))
(assert (forall ((e Int)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Int]_prog.in_singleton_set|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Int]_prog.in_singleton_set_equality|)))
(assert (forall ((e Int)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Int]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Int]_prog.in_unionone_same|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Int]_prog.in_unionone_other|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Int]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Int]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Int]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Int]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Int]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Int)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Int]_prog.subset_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Int)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.equality_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.native_equality|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Int)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Int]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.cardinality_difference|)))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.card_non_negative|)))
(assert (forall ((e Bool)) (!
  (not (Set_in e (as Set_empty  Set<Bool>)))
  :pattern ((Set_in e (as Set_empty  Set<Bool>)))
  :qid |$Set[Bool]_prog.in_empty_set|)))
(assert (forall ((s Set<Bool>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Bool)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.empty_set_cardinality|)))
(assert (forall ((e Bool)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Bool]_prog.in_singleton_set|)))
(assert (forall ((e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Bool]_prog.in_singleton_set_equality|)))
(assert (forall ((e Bool)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Bool]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Bool]_prog.in_unionone_same|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Bool]_prog.in_unionone_other|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Bool]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Bool]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Bool]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Bool)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Bool]_prog.subset_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Bool)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.equality_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.native_equality|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Bool)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Bool]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.card_non_negative|)))
(assert (forall ((e $Ref)) (!
  (not (Set_in e (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in e (as Set_empty  Set<$Ref>)))
  :qid |$Set[Ref]_prog.in_empty_set|)))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Ref)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.empty_set_cardinality|)))
(assert (forall ((e $Ref)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Ref]_prog.in_singleton_set|)))
(assert (forall ((e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Ref]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Ref)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Ref]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Ref]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Ref]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Ref]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Ref]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Ref]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Ref)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Ref]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Ref)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.native_equality|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Ref)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Ref]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.card_non_negative|)))
(assert (forall ((e $Snap)) (!
  (not (Set_in e (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in e (as Set_empty  Set<$Snap>)))
  :qid |$Set[Snap]_prog.in_empty_set|)))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Snap)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.empty_set_cardinality|)))
(assert (forall ((e $Snap)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Snap]_prog.in_singleton_set|)))
(assert (forall ((e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Snap]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Snap)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Snap]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Snap]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Snap]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Snap]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Snap]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Snap]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Snap)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Snap]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Snap)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.native_equality|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Snap)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Snap]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_difference|)))
(assert (forall ((a2 array)) (!
  (forall ((i1 Int)) (!
    (and
      (= (loc_inv_1<array> (array_loc<Ref> a2 i1)) a2)
      (= (loc_inv_2<Int> (array_loc<Ref> a2 i1)) i1))
    :pattern ((loc_inv_1<array> (array_loc<Ref> a2 i1)))
    :pattern ((loc_inv_2<Int> (array_loc<Ref> a2 i1)))
    ))
  
  )))
(assert (forall ((a2 array)) (!
  (>= (alen<Int> a2) 0)
  :pattern ((alen<Int> a2))
  )))
(assert (forall ((x1 array)) (!
  (not (= (as None<option<array>>  option<array>) (some<option<array>> x1)))
  :pattern ((some<option<array>> x1))
  )))
(assert (forall ((x1 array)) (!
  (= (option_get<array> (some<option<array>> x1)) x1)
  :pattern ((option_get<array> (some<option<array>> x1)))
  )))
(assert (forall ((opt1 option<array>)) (!
  (= (some<option<array>> (option_get<array> opt1)) opt1)
  :pattern ((some<option<array>> (option_get<array> opt1)))
  )))
(assert (forall ((v t_null)) (!
  (= (as v_null<t_null>  t_null) v)
  
  )))
(assert (forall ((x1 any)) (!
  (not (= (as None<option<any>>  option<any>) (some<option<any>> x1)))
  :pattern ((some<option<any>> x1))
  )))
(assert (forall ((x1 any)) (!
  (= (option_get<any> (some<option<any>> x1)) x1)
  :pattern ((option_get<any> (some<option<any>> x1)))
  )))
(assert (forall ((opt1 option<any>)) (!
  (= (some<option<any>> (option_get<any> opt1)) opt1)
  :pattern ((some<option<any>> (option_get<any> opt1)))
  )))
(assert (forall ((v void)) (!
  (= (as unit<void>  void) v)
  
  )))
; /field_value_functions_axioms.smt2 [int: Int]
(assert (forall ((vs $FVF<Int>) (ws $FVF<Int>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_int vs) ($FVF.domain_int ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_int vs))
            (= ($FVF.lookup_int vs x) ($FVF.lookup_int ws x)))
          :pattern (($FVF.lookup_int vs x) ($FVF.lookup_int ws x))
          :qid |qp.$FVF<Int>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Int>To$Snap vs)
              ($SortWrappers.$FVF<Int>To$Snap ws)
              )
    :qid |qp.$FVF<Int>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_int pm r))
    :pattern ($FVF.perm_int pm r))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_int f r) true)
    :pattern ($FVF.loc_int f r))))
; /field_value_functions_axioms.smt2 [option$array$: option[array]]
(assert (forall ((vs $FVF<option<array>>) (ws $FVF<option<array>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_option$array$ vs) ($FVF.domain_option$array$ ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_option$array$ vs))
            (= ($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x)))
          :pattern (($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x))
          :qid |qp.$FVF<option<array>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap vs)
              ($SortWrappers.$FVF<option<array>>To$Snap ws)
              )
    :qid |qp.$FVF<option<array>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_option$array$ pm r))
    :pattern ($FVF.perm_option$array$ pm r))))
(assert (forall ((r $Ref) (f option<array>)) (!
    (= ($FVF.loc_option$array$ f r) true)
    :pattern ($FVF.loc_option$array$ f r))))
; /field_value_functions_axioms.smt2 [bool: Bool]
(assert (forall ((vs $FVF<Bool>) (ws $FVF<Bool>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_bool vs) ($FVF.domain_bool ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_bool vs))
            (= ($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x)))
          :pattern (($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x))
          :qid |qp.$FVF<Bool>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap vs)
              ($SortWrappers.$FVF<Bool>To$Snap ws)
              )
    :qid |qp.$FVF<Bool>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_bool pm r))
    :pattern ($FVF.perm_bool pm r))))
(assert (forall ((r $Ref) (f Bool)) (!
    (= ($FVF.loc_bool f r) true)
    :pattern ($FVF.loc_bool f r))))
; /field_value_functions_axioms.smt2 [Gf_seq: Seq[Seq[Int]]]
(assert (forall ((vs $FVF<Seq<Seq<Int>>>) (ws $FVF<Seq<Seq<Int>>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_Gf_seq vs) ($FVF.domain_Gf_seq ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_Gf_seq vs))
            (= ($FVF.lookup_Gf_seq vs x) ($FVF.lookup_Gf_seq ws x)))
          :pattern (($FVF.lookup_Gf_seq vs x) ($FVF.lookup_Gf_seq ws x))
          :qid |qp.$FVF<Seq<Seq<Int>>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap vs)
              ($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap ws)
              )
    :qid |qp.$FVF<Seq<Seq<Int>>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_Gf_seq pm r))
    :pattern ($FVF.perm_Gf_seq pm r))))
(assert (forall ((r $Ref) (f Seq<Seq<Int>>)) (!
    (= ($FVF.loc_Gf_seq f r) true)
    :pattern ($FVF.loc_Gf_seq f r))))
; /field_value_functions_axioms.smt2 [P_seq: Seq[Int]]
(assert (forall ((vs $FVF<Seq<Int>>) (ws $FVF<Seq<Int>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_P_seq vs) ($FVF.domain_P_seq ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_P_seq vs))
            (= ($FVF.lookup_P_seq vs x) ($FVF.lookup_P_seq ws x)))
          :pattern (($FVF.lookup_P_seq vs x) ($FVF.lookup_P_seq ws x))
          :qid |qp.$FVF<Seq<Int>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Seq<Int>>To$Snap vs)
              ($SortWrappers.$FVF<Seq<Int>>To$Snap ws)
              )
    :qid |qp.$FVF<Seq<Int>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_P_seq pm r))
    :pattern ($FVF.perm_P_seq pm r))))
(assert (forall ((r $Ref) (f Seq<Int>)) (!
    (= ($FVF.loc_P_seq f r) true)
    :pattern ($FVF.loc_P_seq f r))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun $k@113@00 () $Perm)
(declare-fun inv@114@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@115@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (=
    (valid_graph_vertices1%limited s@$ this@0@00 p@1@00 V@2@00)
    (valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  :pattern ((valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (valid_graph_vertices1%stateless this@0@00 p@1@00 V@2@00)
  :pattern ((valid_graph_vertices1%limited s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (implies
    (not (= this@0@00 $Ref.null))
    (=
      (valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00)
      (and
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@1@00)))
            (<= 0 (Seq_index p@1@00 unknown_)))
          :pattern ((Seq_index p@1@00 unknown_))
          ))
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@1@00)))
            (< (Seq_index p@1@00 unknown_) V@2@00))
          :pattern ((Seq_index p@1@00 unknown_))
          )))))
  :pattern ((valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (=
    (SquareIntMatrix%limited s@$ this@4@00 G@5@00 V@6@00)
    (SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  :pattern ((SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (SquareIntMatrix%stateless this@4@00 G@5@00 V@6@00)
  :pattern ((SquareIntMatrix%limited s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (implies
    (not (= this@4@00 $Ref.null))
    (=
      (SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00)
      (and
        (= (Seq_length G@5@00) V@6@00)
        (forall ((e Seq<Int>)) (!
          (implies (Seq_contains G@5@00 e) (= (Seq_length e) V@6@00))
          :pattern ((Seq_contains G@5@00 e))
          :pattern ((Seq_length e))
          )))))
  :pattern ((SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (n@10@00 Int) (v@11@00 Int)) (!
  (=
    (SumOutgoingFlow%limited s@$ this@8@00 G@9@00 n@10@00 v@11@00)
    (SumOutgoingFlow s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  :pattern ((SumOutgoingFlow s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (n@10@00 Int) (v@11@00 Int)) (!
  (SumOutgoingFlow%stateless this@8@00 G@9@00 n@10@00 v@11@00)
  :pattern ((SumOutgoingFlow%limited s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  )))
(assert (forall ((s@$ $Snap) (this@13@00 $Ref) (G@14@00 Seq<Seq<Int>>) (n@15@00 Int) (v@16@00 Int)) (!
  (=
    (SumIncomingFlow%limited s@$ this@13@00 G@14@00 n@15@00 v@16@00)
    (SumIncomingFlow s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  :pattern ((SumIncomingFlow s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  )))
(assert (forall ((s@$ $Snap) (this@13@00 $Ref) (G@14@00 Seq<Seq<Int>>) (n@15@00 Int) (v@16@00 Int)) (!
  (SumIncomingFlow%stateless this@13@00 G@14@00 n@15@00 v@16@00)
  :pattern ((SumIncomingFlow%limited s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (=
    (AugPath%limited s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
    (AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  :pattern ((AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (AugPath%stateless this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
  :pattern ((AugPath%limited s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (implies
    (and
      (not (= this@18@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@18@00 G@19@00 V@20@00))
    (=
      (AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
      (and
        (and
          (and
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (not
                (=
                  (Seq_index P@23@00 0)
                  (Seq_index P@23@00 (- (Seq_length P@23@00) 1)))))
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (valid_graph_vertices1 $Snap.unit this@18@00 P@23@00 V@20@00)))
          (and
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (forall ((unknown_ Int)) (!
                (implies
                  (and (<= 0 unknown_) (< unknown_ (Seq_length P@23@00)))
                  (<= 0 (Seq_index P@23@00 unknown_)))
                :pattern ((Seq_index P@23@00 unknown_))
                )))
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (forall ((unknown_ Int)) (!
                (implies
                  (and (<= 0 unknown_) (< unknown_ (Seq_length P@23@00)))
                  (< (Seq_index P@23@00 unknown_) V@20@00))
                :pattern ((Seq_index P@23@00 unknown_))
                )))))
        (implies
          (and
            (and
              (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
              (< t@22@00 V@20@00))
            (< 1 (Seq_length P@23@00)))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j (- (Seq_length P@23@00) 1)))
              (<
                0
                (Seq_index
                  (Seq_index G@19@00 (Seq_index P@23@00 j))
                  (Seq_index P@23@00 (+ j 1)))))
            :pattern ((Seq_index G@19@00 (Seq_index P@23@00 j)))
            ))))))
  :pattern ((AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (= (aloc%limited s@$ a2@25@00 i1@26@00) (aloc s@$ a2@25@00 i1@26@00))
  :pattern ((aloc s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (aloc%stateless a2@25@00 i1@26@00)
  :pattern ((aloc%limited s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (let ((result@27@00 (aloc%limited s@$ a2@25@00 i1@26@00))) (implies
    (and (<= 0 i1@26@00) (< i1@26@00 (alen<Int> a2@25@00)))
    (and
      (= (loc_inv_1<array> result@27@00) a2@25@00)
      (= (loc_inv_2<Int> result@27@00) i1@26@00))))
  :pattern ((aloc%limited s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (implies
    (and (<= 0 i1@26@00) (< i1@26@00 (alen<Int> a2@25@00)))
    (= (aloc s@$ a2@25@00 i1@26@00) (array_loc<Ref> a2@25@00 i1@26@00)))
  :pattern ((aloc s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (= (opt_get1%limited s@$ opt1@28@00) (opt_get1 s@$ opt1@28@00))
  :pattern ((opt_get1 s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (opt_get1%stateless opt1@28@00)
  :pattern ((opt_get1%limited s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (let ((result@29@00 (opt_get1%limited s@$ opt1@28@00))) (implies
    (not (= opt1@28@00 (as None<option<array>>  option<array>)))
    (= (some<option<array>> result@29@00) opt1@28@00)))
  :pattern ((opt_get1%limited s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (implies
    (not (= opt1@28@00 (as None<option<array>>  option<array>)))
    (= (opt_get1 s@$ opt1@28@00) (option_get<array> opt1@28@00)))
  :pattern ((opt_get1 s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (this@30@00 $Ref) (G@31@00 Seq<Seq<Int>>) (V@32@00 Int)) (!
  (=
    (NonNegativeCapacities%limited s@$ this@30@00 G@31@00 V@32@00)
    (NonNegativeCapacities s@$ this@30@00 G@31@00 V@32@00))
  :pattern ((NonNegativeCapacities s@$ this@30@00 G@31@00 V@32@00))
  )))
(assert (forall ((s@$ $Snap) (this@30@00 $Ref) (G@31@00 Seq<Seq<Int>>) (V@32@00 Int)) (!
  (NonNegativeCapacities%stateless this@30@00 G@31@00 V@32@00)
  :pattern ((NonNegativeCapacities%limited s@$ this@30@00 G@31@00 V@32@00))
  )))
(assert (forall ((s@$ $Snap) (this@34@00 $Ref) (G@35@00 Seq<Seq<Int>>) (V@36@00 Int)) (!
  (=
    (SkewSymetry%limited s@$ this@34@00 G@35@00 V@36@00)
    (SkewSymetry s@$ this@34@00 G@35@00 V@36@00))
  :pattern ((SkewSymetry s@$ this@34@00 G@35@00 V@36@00))
  )))
(assert (forall ((s@$ $Snap) (this@34@00 $Ref) (G@35@00 Seq<Seq<Int>>) (V@36@00 Int)) (!
  (SkewSymetry%stateless this@34@00 G@35@00 V@36@00)
  :pattern ((SkewSymetry%limited s@$ this@34@00 G@35@00 V@36@00))
  )))
(assert (forall ((s@$ $Snap) (this@38@00 $Ref) (G@39@00 Seq<Seq<Int>>) (Gf@40@00 Seq<Seq<Int>>) (V@41@00 Int)) (!
  (=
    (CapacityConstraint%limited s@$ this@38@00 G@39@00 Gf@40@00 V@41@00)
    (CapacityConstraint s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  :pattern ((CapacityConstraint s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  )))
(assert (forall ((s@$ $Snap) (this@38@00 $Ref) (G@39@00 Seq<Seq<Int>>) (Gf@40@00 Seq<Seq<Int>>) (V@41@00 Int)) (!
  (CapacityConstraint%stateless this@38@00 G@39@00 Gf@40@00 V@41@00)
  :pattern ((CapacityConstraint%limited s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  )))
(assert (forall ((s@$ $Snap) (this@43@00 $Ref) (G@44@00 Seq<Seq<Int>>) (V@45@00 Int) (s@46@00 Int) (t@47@00 Int)) (!
  (=
    (FlowConservation%limited s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00)
    (FlowConservation s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  :pattern ((FlowConservation s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  )))
(assert (forall ((s@$ $Snap) (this@43@00 $Ref) (G@44@00 Seq<Seq<Int>>) (V@45@00 Int) (s@46@00 Int) (t@47@00 Int)) (!
  (FlowConservation%stateless this@43@00 G@44@00 V@45@00 s@46@00 t@47@00)
  :pattern ((FlowConservation%limited s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  )))
(assert (forall ((s@$ $Snap) (t@49@00 any)) (!
  (= (any_as%limited s@$ t@49@00) (any_as s@$ t@49@00))
  :pattern ((any_as s@$ t@49@00))
  )))
(assert (forall ((s@$ $Snap) (t@49@00 any)) (!
  (any_as%stateless t@49@00)
  :pattern ((any_as%limited s@$ t@49@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (= (opt_get%limited s@$ opt1@51@00) (opt_get s@$ opt1@51@00))
  :pattern ((opt_get s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (opt_get%stateless opt1@51@00)
  :pattern ((opt_get%limited s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (let ((result@52@00 (opt_get%limited s@$ opt1@51@00))) (implies
    (not (= opt1@51@00 (as None<option<any>>  option<any>)))
    (= (some<option<any>> result@52@00) opt1@51@00)))
  :pattern ((opt_get%limited s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (implies
    (not (= opt1@51@00 (as None<option<any>>  option<any>)))
    (= (opt_get s@$ opt1@51@00) (option_get<any> opt1@51@00)))
  :pattern ((opt_get s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (=
    (ExAugPath%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
    (ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  :pattern ((ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (ExAugPath%stateless this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
  :pattern ((ExAugPath%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (implies
    (and
      (not (= this@53@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@53@00 G@54@00 V@55@00))
    (=
      (ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
      (exists ((P Seq<Int>)) (!
        (and
          (AugPath ($Snap.combine $Snap.unit $Snap.unit) this@53@00 G@54@00 V@55@00 s@56@00 t@57@00 P)
          (<= (Seq_length P) V@55@00))
        :pattern ((AugPath%limited ($Snap.combine $Snap.unit $Snap.unit) this@53@00 G@54@00 V@55@00 s@56@00 t@57@00 P))
        :pattern ((Seq_length P))
        ))))
  :pattern ((ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (Seq_equal
    (initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00)
    (initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  :pattern ((initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (initializeSeqWithZeros%stateless this@59@00 p@60@00 n@61@00)
  :pattern ((initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (let ((result@62@00 (initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))) (implies
    (and (not (= this@59@00 $Ref.null)) (<= n@61@00 (Seq_length p@60@00)))
    (and
      (implies
        (< n@61@00 0)
        (=
          (Seq_length
            (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 n@61@00))
          0))
      (implies
        (<= 0 n@61@00)
        (=
          (Seq_length
            (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 n@61@00))
          n@61@00))
      (forall ((i1 Int)) (!
        (implies (and (<= 0 i1) (< i1 n@61@00)) (= (Seq_index p@60@00 i1) 0))
        :pattern ((Seq_index p@60@00 i1))
        )))))
  :pattern ((initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (implies
    (and (not (= this@59@00 $Ref.null)) (<= n@61@00 (Seq_length p@60@00)))
    (Seq_equal
      (initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00)
      (ite
        (< 0 n@61@00)
        (Seq_append
          (Seq_singleton 0)
          (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 (-
            n@61@00
            1)))
        (as Seq_empty  Seq<Int>))))
  :pattern ((initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (=
    (valid_graph_vertices%limited s@$ this@63@00 p@64@00 V@65@00)
    (valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  :pattern ((valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (valid_graph_vertices%stateless this@63@00 p@64@00 V@65@00)
  :pattern ((valid_graph_vertices%limited s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (and
    (forall ((i1@112@00 Int)) (!
      (implies
        (and (and (< i1@112@00 V@65@00) (<= 0 i1@112@00)) (< $Perm.No $k@113@00))
        (=
          (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@64@00) i1@112@00))
          i1@112@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) i1@112@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r) V@65@00)
            (<= 0 (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r)))
          (< $Perm.No $k@113@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r))
          r))
      :pattern ((inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r) V@65@00)
            (<= 0 (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r)))
          (< $Perm.No $k@113@00)
          false)
        (=
          ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
      :pattern (($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
      :qid |qp.fvfValDef0|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
      :pattern (($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r))
      :qid |qp.fvfResTrgDef1|))
    ($Perm.isReadVar $k@113@00 $Perm.Write)
    (implies
      (and
        (not (= this@63@00 $Ref.null))
        (not (= p@64@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit p@64@00)) V@65@00))
      (=
        (valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00)
        (and
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@64@00))))
              (<=
                0
                ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
            ))
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@64@00))))
              (<
                ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
                V@65@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
            ))))))
  :pattern ((valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (=
    (FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
    (FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  :pattern ((FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (FlowNetwork%stateless this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
  :pattern ((FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (let ((result@73@00 (FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))) (implies
    (and
      (not (= this@67@00 $Ref.null))
      (= V@70@00 (Seq_length G@68@00))
      (= V@70@00 (Seq_length Gf@69@00))
      (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))
    (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00)))
  :pattern ((FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (implies
    (and
      (not (= this@67@00 $Ref.null))
      (= V@70@00 (Seq_length G@68@00))
      (= V@70@00 (Seq_length Gf@69@00))
      (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))
    (=
      (FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
      (and
        (and
          (SquareIntMatrix $Snap.unit this@67@00 G@68@00 V@70@00)
          (SquareIntMatrix $Snap.unit this@67@00 Gf@69@00 V@70@00))
        (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))))
  :pattern ((FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (= (scale%limited s@$ amount@74@00) (scale s@$ amount@74@00))
  :pattern ((scale s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (scale%stateless amount@74@00)
  :pattern ((scale%limited s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (implies (>= amount@74@00 $Perm.No) (= (scale s@$ amount@74@00) amount@74@00))
  :pattern ((scale s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (=
    (Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00)
    (Flow s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  :pattern ((Flow s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (Flow%stateless this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00)
  :pattern ((Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (let ((result@82@00 (Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))) (implies
    (and
      (not (= this@76@00 $Ref.null))
      (= V@79@00 (Seq_length G@77@00))
      (= V@79@00 (Seq_length Gf@78@00)))
    (and
      (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@76@00 G@77@00 V@79@00 s@80@00 t@81@00)
      (CapacityConstraint ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit $Snap.unit)) this@76@00 G@77@00 Gf@78@00 V@79@00))))
  :pattern ((Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (= (as_any%limited s@$ t@83@00) (as_any s@$ t@83@00))
  :pattern ((as_any s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (as_any%stateless t@83@00)
  :pattern ((as_any%limited s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (let ((result@84@00 (as_any%limited s@$ t@83@00))) (=
    (any_as $Snap.unit result@84@00)
    t@83@00))
  :pattern ((as_any%limited s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (= (type%limited s@$ type1@85@00) (type s@$ type1@85@00))
  :pattern ((type s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (type%stateless type1@85@00)
  :pattern ((type%limited s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (let ((result@86@00 (type%limited s@$ type1@85@00))) (and
    (<= 0 result@86@00)
    (< result@86@00 3)
    (implies (= type1@85@00 $Ref.null) (= result@86@00 0))
    (implies (not (= type1@85@00 $Ref.null)) (not (= result@86@00 0)))))
  :pattern ((type%limited s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (=
    (opt_or_else%limited s@$ opt1@87@00 alt@88@00)
    (opt_or_else s@$ opt1@87@00 alt@88@00))
  :pattern ((opt_or_else s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (opt_or_else%stateless opt1@87@00 alt@88@00)
  :pattern ((opt_or_else%limited s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (let ((result@89@00 (opt_or_else%limited s@$ opt1@87@00 alt@88@00))) (and
    (implies
      (= opt1@87@00 (as None<option<any>>  option<any>))
      (= result@89@00 alt@88@00))
    (implies
      (not (= opt1@87@00 (as None<option<any>>  option<any>)))
      (= result@89@00 (opt_get $Snap.unit opt1@87@00)))))
  :pattern ((opt_or_else%limited s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (=
    (opt_or_else s@$ opt1@87@00 alt@88@00)
    (ite
      (= opt1@87@00 (as None<option<any>>  option<any>))
      alt@88@00
      (opt_get $Snap.unit opt1@87@00)))
  :pattern ((opt_or_else s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (=
    (subtype%limited s@$ subtype1@90@00 subtype2@91@00)
    (subtype s@$ subtype1@90@00 subtype2@91@00))
  :pattern ((subtype s@$ subtype1@90@00 subtype2@91@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (subtype%stateless subtype1@90@00 subtype2@91@00)
  :pattern ((subtype%limited s@$ subtype1@90@00 subtype2@91@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (implies
    (and
      (<= 0 subtype1@90@00)
      (< subtype1@90@00 3)
      (<= 0 subtype2@91@00)
      (<= subtype2@91@00 2))
    (=
      (subtype s@$ subtype1@90@00 subtype2@91@00)
      (and
        (implies (= subtype1@90@00 2) (= subtype2@91@00 2))
        (implies (= subtype1@90@00 1) (= subtype2@91@00 1)))))
  :pattern ((subtype s@$ subtype1@90@00 subtype2@91@00))
  )))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- make_array ----------
(declare-const tid@0@07 Int)
(declare-const dim0@1@07 Int)
(declare-const dim1@2@07 Int)
(declare-const exc@3@07 $Ref)
(declare-const res@4@07 option<array>)
(declare-const tid@5@07 Int)
(declare-const dim0@6@07 Int)
(declare-const dim1@7@07 Int)
(declare-const exc@8@07 $Ref)
(declare-const res@9@07 option<array>)
(push) ; 1
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@10@07 $Snap)
(assert (= $t@10@07 ($Snap.combine ($Snap.first $t@10@07) ($Snap.second $t@10@07))))
(assert (= ($Snap.first $t@10@07) $Snap.unit))
; [eval] exc == null
(assert (= exc@8@07 $Ref.null))
(assert (=
  ($Snap.second $t@10@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@10@07))
    ($Snap.second ($Snap.second $t@10@07)))))
(assert (= ($Snap.first ($Snap.second $t@10@07)) $Snap.unit))
; [eval] exc == null ==> res != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@8@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17
;  :arith-assert-lower      2
;  :arith-assert-upper      2
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 1
;  :datatype-occurs-check   2
;  :datatype-splits         1
;  :decisions               1
;  :final-checks            3
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.18
;  :mk-bool-var             415
;  :num-allocs              158376
;  :num-checks              2
;  :quant-instantiations    2
;  :rlimit-count            180702)
; [then-branch: 0 | exc@8@07 == Null | live]
; [else-branch: 0 | exc@8@07 != Null | dead]
(push) ; 4
; [then-branch: 0 | exc@8@07 == Null]
; [eval] res != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@8@07 $Ref.null)
  (not (= res@9@07 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@10@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@10@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@10@07))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(res)) == dim0
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@8@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25
;  :arith-assert-lower      2
;  :arith-assert-upper      2
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    4
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   4
;  :datatype-splits         2
;  :decisions               2
;  :final-checks            5
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             419
;  :num-allocs              158861
;  :num-checks              3
;  :quant-instantiations    2
;  :rlimit-count            181381)
; [then-branch: 1 | exc@8@07 == Null | live]
; [else-branch: 1 | exc@8@07 != Null | dead]
(push) ; 4
; [then-branch: 1 | exc@8@07 == Null]
; [eval] alen(opt_get1(res)) == dim0
; [eval] alen(opt_get1(res))
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@9@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25
;  :arith-assert-lower      2
;  :arith-assert-upper      2
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    4
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   4
;  :datatype-splits         2
;  :decisions               2
;  :final-checks            5
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             419
;  :num-allocs              158934
;  :num-checks              4
;  :quant-instantiations    2
;  :rlimit-count            181402)
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@8@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@9@07)) dim0@6@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@10@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= exc@8@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               38
;  :arith-assert-lower      3
;  :arith-assert-upper      2
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   6
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            7
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.21
;  :mk-bool-var             428
;  :num-allocs              159567
;  :num-checks              5
;  :quant-instantiations    7
;  :rlimit-count            182172)
; [then-branch: 2 | exc@8@07 == Null | live]
; [else-branch: 2 | exc@8@07 != Null | dead]
(push) ; 3
; [then-branch: 2 | exc@8@07 == Null]
(declare-const i0@11@07 Int)
(push) ; 4
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 5
; [then-branch: 3 | 0 <= i0@11@07 | live]
; [else-branch: 3 | !(0 <= i0@11@07) | live]
(push) ; 6
; [then-branch: 3 | 0 <= i0@11@07]
(assert (<= 0 i0@11@07))
; [eval] i0 < dim0
(pop) ; 6
(push) ; 6
; [else-branch: 3 | !(0 <= i0@11@07)]
(assert (not (<= 0 i0@11@07)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i0@11@07 dim0@6@07) (<= 0 i0@11@07)))
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@9@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               39
;  :arith-assert-lower      5
;  :arith-assert-upper      4
;  :arith-eq-adapter        3
;  :arith-fixed-eqs         1
;  :arith-pivots            1
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   6
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            7
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.22
;  :mk-bool-var             432
;  :num-allocs              159735
;  :num-checks              6
;  :quant-instantiations    7
;  :rlimit-count            182360)
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i0@11@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               39
;  :arith-assert-lower      5
;  :arith-assert-upper      4
;  :arith-eq-adapter        3
;  :arith-fixed-eqs         1
;  :arith-pivots            1
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   6
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            7
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.22
;  :mk-bool-var             432
;  :num-allocs              159758
;  :num-checks              7
;  :quant-instantiations    7
;  :rlimit-count            182391)
(assert (< i0@11@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(pop) ; 5
; Joined path conditions
(assert (< i0@11@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(declare-const sm@12@07 $FVF<option<array>>)
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(pop) ; 4
(declare-fun inv@13@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@11@07 Int)) (!
  (and
    (not (= res@9@07 (as None<option<array>>  option<array>)))
    (< i0@11@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@07))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@11@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@11@07)))
  :qid |option$array$-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i01@11@07 Int) (i02@11@07 Int)) (!
  (implies
    (and
      (and (< i01@11@07 dim0@6@07) (<= 0 i01@11@07))
      (and (< i02@11@07 dim0@6@07) (<= 0 i02@11@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i01@11@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i02@11@07)))
    (= i01@11@07 i02@11@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               70
;  :arith-add-rows          14
;  :arith-assert-diseq      3
;  :arith-assert-lower      12
;  :arith-assert-upper      8
;  :arith-conflicts         2
;  :arith-eq-adapter        5
;  :arith-fixed-eqs         2
;  :arith-offset-eqs        1
;  :arith-pivots            10
;  :conflicts               3
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   6
;  :datatype-splits         4
;  :decisions               6
;  :del-clause              18
;  :final-checks            7
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.25
;  :mk-bool-var             460
;  :mk-clause               18
;  :num-allocs              160516
;  :num-checks              8
;  :propagations            20
;  :quant-instantiations    16
;  :rlimit-count            183800)
; Definitional axioms for inverse functions
(assert (forall ((i0@11@07 Int)) (!
  (implies
    (and (< i0@11@07 dim0@6@07) (<= 0 i0@11@07))
    (=
      (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@11@07))
      i0@11@07))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@07))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@11@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@11@07)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@13@07 r) dim0@6@07) (<= 0 (inv@13@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) (inv@13@07 r))
      r))
  :pattern ((inv@13@07 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@11@07 Int)) (!
  (implies
    (and (< i0@11@07 dim0@6@07) (<= 0 i0@11@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@11@07)
        $Ref.null)))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@07))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@11@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@11@07)))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@14@07 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@13@07 r) dim0@6@07) (<= 0 (inv@13@07 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@07))))) r))
  :qid |qp.fvfValDef1|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@07))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef2|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@13@07 r) dim0@6@07) (<= 0 (inv@13@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) r) r))
  :pattern ((inv@13@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@8@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               81
;  :arith-add-rows          14
;  :arith-assert-diseq      3
;  :arith-assert-lower      12
;  :arith-assert-upper      8
;  :arith-conflicts         2
;  :arith-eq-adapter        5
;  :arith-fixed-eqs         2
;  :arith-offset-eqs        1
;  :arith-pivots            10
;  :conflicts               3
;  :datatype-accessor-ax    7
;  :datatype-constructor-ax 6
;  :datatype-occurs-check   9
;  :datatype-splits         6
;  :decisions               8
;  :del-clause              18
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.27
;  :mk-bool-var             470
;  :mk-clause               18
;  :num-allocs              161981
;  :num-checks              9
;  :propagations            20
;  :quant-instantiations    16
;  :rlimit-count            186506)
; [then-branch: 4 | exc@8@07 == Null | live]
; [else-branch: 4 | exc@8@07 != Null | dead]
(push) ; 5
; [then-branch: 4 | exc@8@07 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array]))
(declare-const i0@15@07 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array])
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 5 | 0 <= i0@15@07 | live]
; [else-branch: 5 | !(0 <= i0@15@07) | live]
(push) ; 8
; [then-branch: 5 | 0 <= i0@15@07]
(assert (<= 0 i0@15@07))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 5 | !(0 <= i0@15@07)]
(assert (not (<= 0 i0@15@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 6 | i0@15@07 < dim0@6@07 && 0 <= i0@15@07 | live]
; [else-branch: 6 | !(i0@15@07 < dim0@6@07 && 0 <= i0@15@07) | live]
(push) ; 8
; [then-branch: 6 | i0@15@07 < dim0@6@07 && 0 <= i0@15@07]
(assert (and (< i0@15@07 dim0@6@07) (<= 0 i0@15@07)))
; [eval] aloc(opt_get1(res), i0).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@9@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               82
;  :arith-add-rows          15
;  :arith-assert-diseq      3
;  :arith-assert-lower      14
;  :arith-assert-upper      10
;  :arith-conflicts         2
;  :arith-eq-adapter        6
;  :arith-fixed-eqs         3
;  :arith-offset-eqs        1
;  :arith-pivots            12
;  :conflicts               3
;  :datatype-accessor-ax    7
;  :datatype-constructor-ax 6
;  :datatype-occurs-check   9
;  :datatype-splits         6
;  :decisions               8
;  :del-clause              18
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.27
;  :mk-bool-var             474
;  :mk-clause               18
;  :num-allocs              162159
;  :num-checks              10
;  :propagations            20
;  :quant-instantiations    16
;  :rlimit-count            186718)
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@15@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               82
;  :arith-add-rows          15
;  :arith-assert-diseq      3
;  :arith-assert-lower      14
;  :arith-assert-upper      10
;  :arith-conflicts         2
;  :arith-eq-adapter        6
;  :arith-fixed-eqs         3
;  :arith-offset-eqs        1
;  :arith-pivots            12
;  :conflicts               3
;  :datatype-accessor-ax    7
;  :datatype-constructor-ax 6
;  :datatype-occurs-check   9
;  :datatype-splits         6
;  :decisions               8
;  :del-clause              18
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.27
;  :mk-bool-var             474
;  :mk-clause               18
;  :num-allocs              162184
;  :num-checks              11
;  :propagations            20
;  :quant-instantiations    16
;  :rlimit-count            186749)
(assert (< i0@15@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(pop) ; 9
; Joined path conditions
(assert (< i0@15@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)))
(push) ; 9
(assert (not (and
  (<
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07))
    dim0@6@07)
  (<=
    0
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               94
;  :arith-add-rows          18
;  :arith-assert-diseq      3
;  :arith-assert-lower      15
;  :arith-assert-upper      11
;  :arith-bound-prop        3
;  :arith-conflicts         2
;  :arith-eq-adapter        7
;  :arith-fixed-eqs         4
;  :arith-offset-eqs        4
;  :arith-pivots            13
;  :conflicts               4
;  :datatype-accessor-ax    7
;  :datatype-constructor-ax 6
;  :datatype-occurs-check   9
;  :datatype-splits         6
;  :decisions               8
;  :del-clause              18
;  :final-checks            9
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.29
;  :mk-bool-var             491
;  :mk-clause               29
;  :num-allocs              162504
;  :num-checks              12
;  :propagations            26
;  :quant-instantiations    26
;  :rlimit-count            187352)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 6 | !(i0@15@07 < dim0@6@07 && 0 <= i0@15@07)]
(assert (not (and (< i0@15@07 dim0@6@07) (<= 0 i0@15@07))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@15@07 dim0@6@07) (<= 0 i0@15@07))
  (and
    (< i0@15@07 dim0@6@07)
    (<= 0 i0@15@07)
    (not (= res@9@07 (as None<option<array>>  option<array>)))
    (< i0@15@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@15@07 Int)) (!
  (implies
    (and (< i0@15@07 dim0@6@07) (<= 0 i0@15@07))
    (and
      (< i0@15@07 dim0@6@07)
      (<= 0 i0@15@07)
      (not (= res@9@07 (as None<option<array>>  option<array>)))
      (< i0@15@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@8@07 $Ref.null)
  (forall ((i0@15@07 Int)) (!
    (implies
      (and (< i0@15@07 dim0@6@07) (<= 0 i0@15@07))
      (and
        (< i0@15@07 dim0@6@07)
        (<= 0 i0@15@07)
        (not (= res@9@07 (as None<option<array>>  option<array>)))
        (< i0@15@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@8@07 $Ref.null)
  (forall ((i0@15@07 Int)) (!
    (implies
      (and (< i0@15@07 dim0@6@07) (<= 0 i0@15@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07))
          (as None<option<array>>  option<array>))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@15@07)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@8@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               105
;  :arith-add-rows          19
;  :arith-assert-diseq      3
;  :arith-assert-lower      15
;  :arith-assert-upper      11
;  :arith-bound-prop        3
;  :arith-conflicts         2
;  :arith-eq-adapter        7
;  :arith-fixed-eqs         4
;  :arith-offset-eqs        4
;  :arith-pivots            16
;  :conflicts               4
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   12
;  :datatype-splits         8
;  :decisions               10
;  :del-clause              29
;  :final-checks            11
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.29
;  :mk-bool-var             497
;  :mk-clause               29
;  :num-allocs              163446
;  :num-checks              13
;  :propagations            26
;  :quant-instantiations    26
;  :rlimit-count            188813)
; [then-branch: 7 | exc@8@07 == Null | live]
; [else-branch: 7 | exc@8@07 != Null | dead]
(push) ; 5
; [then-branch: 7 | exc@8@07 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1)
(declare-const i0@16@07 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 8 | 0 <= i0@16@07 | live]
; [else-branch: 8 | !(0 <= i0@16@07) | live]
(push) ; 8
; [then-branch: 8 | 0 <= i0@16@07]
(assert (<= 0 i0@16@07))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 8 | !(0 <= i0@16@07)]
(assert (not (<= 0 i0@16@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 9 | i0@16@07 < dim0@6@07 && 0 <= i0@16@07 | live]
; [else-branch: 9 | !(i0@16@07 < dim0@6@07 && 0 <= i0@16@07) | live]
(push) ; 8
; [then-branch: 9 | i0@16@07 < dim0@6@07 && 0 <= i0@16@07]
(assert (and (< i0@16@07 dim0@6@07) (<= 0 i0@16@07)))
; [eval] alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1
; [eval] alen(opt_get1(aloc(opt_get1(res), i0).option$array$))
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@9@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               106
;  :arith-add-rows          20
;  :arith-assert-diseq      3
;  :arith-assert-lower      17
;  :arith-assert-upper      13
;  :arith-bound-prop        3
;  :arith-conflicts         2
;  :arith-eq-adapter        8
;  :arith-fixed-eqs         5
;  :arith-offset-eqs        4
;  :arith-pivots            18
;  :conflicts               4
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   12
;  :datatype-splits         8
;  :decisions               10
;  :del-clause              29
;  :final-checks            11
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.29
;  :mk-bool-var             501
;  :mk-clause               29
;  :num-allocs              163571
;  :num-checks              14
;  :propagations            26
;  :quant-instantiations    26
;  :rlimit-count            189023)
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@16@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               106
;  :arith-add-rows          20
;  :arith-assert-diseq      3
;  :arith-assert-lower      17
;  :arith-assert-upper      13
;  :arith-bound-prop        3
;  :arith-conflicts         2
;  :arith-eq-adapter        8
;  :arith-fixed-eqs         5
;  :arith-offset-eqs        4
;  :arith-pivots            18
;  :conflicts               4
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   12
;  :datatype-splits         8
;  :decisions               10
;  :del-clause              29
;  :final-checks            11
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.29
;  :mk-bool-var             501
;  :mk-clause               29
;  :num-allocs              163596
;  :num-checks              15
;  :propagations            26
;  :quant-instantiations    26
;  :rlimit-count            189054)
(assert (< i0@16@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(pop) ; 9
; Joined path conditions
(assert (< i0@16@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)))
(push) ; 9
(assert (not (and
  (<
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
    dim0@6@07)
  (<=
    0
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               120
;  :arith-add-rows          23
;  :arith-assert-diseq      3
;  :arith-assert-lower      18
;  :arith-assert-upper      14
;  :arith-bound-prop        6
;  :arith-conflicts         2
;  :arith-eq-adapter        9
;  :arith-fixed-eqs         6
;  :arith-offset-eqs        7
;  :arith-pivots            19
;  :conflicts               5
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   12
;  :datatype-splits         8
;  :decisions               10
;  :del-clause              29
;  :final-checks            11
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.31
;  :mk-bool-var             521
;  :mk-clause               41
;  :num-allocs              163874
;  :num-checks              16
;  :propagations            32
;  :quant-instantiations    38
;  :rlimit-count            189706)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               120
;  :arith-add-rows          23
;  :arith-assert-diseq      3
;  :arith-assert-lower      18
;  :arith-assert-upper      14
;  :arith-bound-prop        6
;  :arith-conflicts         2
;  :arith-eq-adapter        9
;  :arith-fixed-eqs         6
;  :arith-offset-eqs        7
;  :arith-pivots            19
;  :conflicts               6
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   12
;  :datatype-splits         8
;  :decisions               10
;  :del-clause              29
;  :final-checks            11
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.31
;  :mk-bool-var             521
;  :mk-clause               41
;  :num-allocs              163964
;  :num-checks              17
;  :propagations            32
;  :quant-instantiations    38
;  :rlimit-count            189801)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 9 | !(i0@16@07 < dim0@6@07 && 0 <= i0@16@07)]
(assert (not (and (< i0@16@07 dim0@6@07) (<= 0 i0@16@07))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@16@07 dim0@6@07) (<= 0 i0@16@07))
  (and
    (< i0@16@07 dim0@6@07)
    (<= 0 i0@16@07)
    (not (= res@9@07 (as None<option<array>>  option<array>)))
    (< i0@16@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@16@07 Int)) (!
  (implies
    (and (< i0@16@07 dim0@6@07) (<= 0 i0@16@07))
    (and
      (< i0@16@07 dim0@6@07)
      (<= 0 i0@16@07)
      (not (= res@9@07 (as None<option<array>>  option<array>)))
      (< i0@16@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
          (as None<option<array>>  option<array>)))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@8@07 $Ref.null)
  (forall ((i0@16@07 Int)) (!
    (implies
      (and (< i0@16@07 dim0@6@07) (<= 0 i0@16@07))
      (and
        (< i0@16@07 dim0@6@07)
        (<= 0 i0@16@07)
        (not (= res@9@07 (as None<option<array>>  option<array>)))
        (< i0@16@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))
            (as None<option<array>>  option<array>)))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@8@07 $Ref.null)
  (forall ((i0@16@07 Int)) (!
    (implies
      (and (< i0@16@07 dim0@6@07) (<= 0 i0@16@07))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07))))
        dim1@7@07))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@16@07)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int, j0: Int :: { aloc(opt_get1(res), i0).option$array$,aloc(opt_get1(res), j0).option$array$ } 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@8@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               131
;  :arith-add-rows          24
;  :arith-assert-diseq      3
;  :arith-assert-lower      18
;  :arith-assert-upper      14
;  :arith-bound-prop        6
;  :arith-conflicts         2
;  :arith-eq-adapter        9
;  :arith-fixed-eqs         6
;  :arith-offset-eqs        7
;  :arith-pivots            22
;  :conflicts               6
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   15
;  :datatype-splits         10
;  :decisions               12
;  :del-clause              41
;  :final-checks            13
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.31
;  :mk-bool-var             527
;  :mk-clause               41
;  :num-allocs              164919
;  :num-checks              18
;  :propagations            32
;  :quant-instantiations    38
;  :rlimit-count            191364)
; [then-branch: 10 | exc@8@07 == Null | live]
; [else-branch: 10 | exc@8@07 != Null | dead]
(push) ; 5
; [then-branch: 10 | exc@8@07 == Null]
; [eval] (forall i0: Int, j0: Int :: { aloc(opt_get1(res), i0).option$array$,aloc(opt_get1(res), j0).option$array$ } 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0)
(declare-const i0@17@07 Int)
(declare-const j0@18@07 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0
; [eval] 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 11 | 0 <= i0@17@07 | live]
; [else-branch: 11 | !(0 <= i0@17@07) | live]
(push) ; 8
; [then-branch: 11 | 0 <= i0@17@07]
(assert (<= 0 i0@17@07))
; [eval] i0 < dim0
(push) ; 9
; [then-branch: 12 | i0@17@07 < dim0@6@07 | live]
; [else-branch: 12 | !(i0@17@07 < dim0@6@07) | live]
(push) ; 10
; [then-branch: 12 | i0@17@07 < dim0@6@07]
(assert (< i0@17@07 dim0@6@07))
; [eval] 0 <= j0
(push) ; 11
; [then-branch: 13 | 0 <= j0@18@07 | live]
; [else-branch: 13 | !(0 <= j0@18@07) | live]
(push) ; 12
; [then-branch: 13 | 0 <= j0@18@07]
(assert (<= 0 j0@18@07))
; [eval] j0 < dim0
(push) ; 13
; [then-branch: 14 | j0@18@07 < dim0@6@07 | live]
; [else-branch: 14 | !(j0@18@07 < dim0@6@07) | live]
(push) ; 14
; [then-branch: 14 | j0@18@07 < dim0@6@07]
(assert (< j0@18@07 dim0@6@07))
; [eval] aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 16
(assert (not (not (= res@9@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               132
;  :arith-add-rows          26
;  :arith-assert-diseq      3
;  :arith-assert-lower      21
;  :arith-assert-upper      17
;  :arith-bound-prop        6
;  :arith-conflicts         2
;  :arith-eq-adapter        10
;  :arith-fixed-eqs         7
;  :arith-offset-eqs        7
;  :arith-pivots            24
;  :conflicts               6
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   15
;  :datatype-splits         10
;  :decisions               12
;  :del-clause              41
;  :final-checks            13
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.31
;  :mk-bool-var             533
;  :mk-clause               41
;  :num-allocs              165288
;  :num-checks              19
;  :propagations            32
;  :quant-instantiations    38
;  :rlimit-count            191708)
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               132
;  :arith-add-rows          26
;  :arith-assert-diseq      3
;  :arith-assert-lower      21
;  :arith-assert-upper      17
;  :arith-bound-prop        6
;  :arith-conflicts         2
;  :arith-eq-adapter        10
;  :arith-fixed-eqs         7
;  :arith-offset-eqs        7
;  :arith-pivots            24
;  :conflicts               6
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   15
;  :datatype-splits         10
;  :decisions               12
;  :del-clause              41
;  :final-checks            13
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.31
;  :mk-bool-var             533
;  :mk-clause               41
;  :num-allocs              165313
;  :num-checks              20
;  :propagations            32
;  :quant-instantiations    38
;  :rlimit-count            191739)
(assert (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(pop) ; 15
; Joined path conditions
(assert (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)))
(push) ; 15
(assert (not (and
  (<
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
    dim0@6@07)
  (<=
    0
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148
;  :arith-add-rows          29
;  :arith-assert-diseq      3
;  :arith-assert-lower      23
;  :arith-assert-upper      18
;  :arith-bound-prop        9
;  :arith-conflicts         2
;  :arith-eq-adapter        11
;  :arith-fixed-eqs         8
;  :arith-offset-eqs        10
;  :arith-pivots            25
;  :conflicts               7
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   15
;  :datatype-splits         10
;  :decisions               12
;  :del-clause              41
;  :final-checks            13
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.33
;  :mk-bool-var             559
;  :mk-clause               54
;  :num-allocs              165625
;  :num-checks              21
;  :propagations            38
;  :quant-instantiations    57
;  :rlimit-count            192533)
; [eval] aloc(opt_get1(res), j0)
; [eval] opt_get1(res)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               148
;  :arith-add-rows          29
;  :arith-assert-diseq      3
;  :arith-assert-lower      23
;  :arith-assert-upper      18
;  :arith-bound-prop        9
;  :arith-conflicts         2
;  :arith-eq-adapter        11
;  :arith-fixed-eqs         8
;  :arith-offset-eqs        10
;  :arith-pivots            25
;  :conflicts               7
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   15
;  :datatype-splits         10
;  :decisions               12
;  :del-clause              41
;  :final-checks            13
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.33
;  :mk-bool-var             559
;  :mk-clause               54
;  :num-allocs              165656
;  :num-checks              22
;  :propagations            38
;  :quant-instantiations    57
;  :rlimit-count            192563)
(assert (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(pop) ; 15
; Joined path conditions
(assert (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
(push) ; 15
(assert (not (and
  (<
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07))
    dim0@6@07)
  (<=
    0
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               159
;  :arith-add-rows          35
;  :arith-assert-diseq      3
;  :arith-assert-lower      26
;  :arith-assert-upper      21
;  :arith-bound-prop        10
;  :arith-conflicts         3
;  :arith-eq-adapter        13
;  :arith-fixed-eqs         10
;  :arith-offset-eqs        10
;  :arith-pivots            28
;  :conflicts               8
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 10
;  :datatype-occurs-check   15
;  :datatype-splits         10
;  :decisions               12
;  :del-clause              41
;  :final-checks            13
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.36
;  :mk-bool-var             588
;  :mk-clause               67
;  :num-allocs              166061
;  :num-checks              23
;  :propagations            40
;  :quant-instantiations    75
;  :rlimit-count            193404)
(pop) ; 14
(push) ; 14
; [else-branch: 14 | !(j0@18@07 < dim0@6@07)]
(assert (not (< j0@18@07 dim0@6@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (< j0@18@07 dim0@6@07)
  (and
    (< j0@18@07 dim0@6@07)
    (not (= res@9@07 (as None<option<array>>  option<array>)))
    (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
    (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 13 | !(0 <= j0@18@07)]
(assert (not (<= 0 j0@18@07)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (<= 0 j0@18@07)
  (and
    (<= 0 j0@18@07)
    (implies
      (< j0@18@07 dim0@6@07)
      (and
        (< j0@18@07 dim0@6@07)
        (not (= res@9@07 (as None<option<array>>  option<array>)))
        (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
        (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 12 | !(i0@17@07 < dim0@6@07)]
(assert (not (< i0@17@07 dim0@6@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (< i0@17@07 dim0@6@07)
  (and
    (< i0@17@07 dim0@6@07)
    (implies
      (<= 0 j0@18@07)
      (and
        (<= 0 j0@18@07)
        (implies
          (< j0@18@07 dim0@6@07)
          (and
            (< j0@18@07 dim0@6@07)
            (not (= res@9@07 (as None<option<array>>  option<array>)))
            (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
            (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))))))))
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 11 | !(0 <= i0@17@07)]
(assert (not (<= 0 i0@17@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (<= 0 i0@17@07)
  (and
    (<= 0 i0@17@07)
    (implies
      (< i0@17@07 dim0@6@07)
      (and
        (< i0@17@07 dim0@6@07)
        (implies
          (<= 0 j0@18@07)
          (and
            (<= 0 j0@18@07)
            (implies
              (< j0@18@07 dim0@6@07)
              (and
                (< j0@18@07 dim0@6@07)
                (not (= res@9@07 (as None<option<array>>  option<array>)))
                (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
                (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))))))))))
; Joined path conditions
(push) ; 7
; [then-branch: 15 | Lookup(option$array$,sm@14@07,aloc((_, _), opt_get1(_, res@9@07), i0@17@07)) == Lookup(option$array$,sm@14@07,aloc((_, _), opt_get1(_, res@9@07), j0@18@07)) && j0@18@07 < dim0@6@07 && 0 <= j0@18@07 && i0@17@07 < dim0@6@07 && 0 <= i0@17@07 | live]
; [else-branch: 15 | !(Lookup(option$array$,sm@14@07,aloc((_, _), opt_get1(_, res@9@07), i0@17@07)) == Lookup(option$array$,sm@14@07,aloc((_, _), opt_get1(_, res@9@07), j0@18@07)) && j0@18@07 < dim0@6@07 && 0 <= j0@18@07 && i0@17@07 < dim0@6@07 && 0 <= i0@17@07) | live]
(push) ; 8
; [then-branch: 15 | Lookup(option$array$,sm@14@07,aloc((_, _), opt_get1(_, res@9@07), i0@17@07)) == Lookup(option$array$,sm@14@07,aloc((_, _), opt_get1(_, res@9@07), j0@18@07)) && j0@18@07 < dim0@6@07 && 0 <= j0@18@07 && i0@17@07 < dim0@6@07 && 0 <= i0@17@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
          ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
        (< j0@18@07 dim0@6@07))
      (<= 0 j0@18@07))
    (< i0@17@07 dim0@6@07))
  (<= 0 i0@17@07)))
; [eval] i0 == j0
(pop) ; 8
(push) ; 8
; [else-branch: 15 | !(Lookup(option$array$,sm@14@07,aloc((_, _), opt_get1(_, res@9@07), i0@17@07)) == Lookup(option$array$,sm@14@07,aloc((_, _), opt_get1(_, res@9@07), j0@18@07)) && j0@18@07 < dim0@6@07 && 0 <= j0@18@07 && i0@17@07 < dim0@6@07 && 0 <= i0@17@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
            ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
          (< j0@18@07 dim0@6@07))
        (<= 0 j0@18@07))
      (< i0@17@07 dim0@6@07))
    (<= 0 i0@17@07))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
            ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
          (< j0@18@07 dim0@6@07))
        (<= 0 j0@18@07))
      (< i0@17@07 dim0@6@07))
    (<= 0 i0@17@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
      ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
    (< j0@18@07 dim0@6@07)
    (<= 0 j0@18@07)
    (< i0@17@07 dim0@6@07)
    (<= 0 i0@17@07))))
; Joined path conditions
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@17@07 Int) (j0@18@07 Int)) (!
  (and
    (implies
      (<= 0 i0@17@07)
      (and
        (<= 0 i0@17@07)
        (implies
          (< i0@17@07 dim0@6@07)
          (and
            (< i0@17@07 dim0@6@07)
            (implies
              (<= 0 j0@18@07)
              (and
                (<= 0 j0@18@07)
                (implies
                  (< j0@18@07 dim0@6@07)
                  (and
                    (< j0@18@07 dim0@6@07)
                    (not (= res@9@07 (as None<option<array>>  option<array>)))
                    (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
                    (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
                ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
              (< j0@18@07 dim0@6@07))
            (<= 0 j0@18@07))
          (< i0@17@07 dim0@6@07))
        (<= 0 i0@17@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
          ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
        (< j0@18@07 dim0@6@07)
        (<= 0 j0@18@07)
        (< i0@17@07 dim0@6@07)
        (<= 0 i0@17@07))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@8@07 $Ref.null)
  (forall ((i0@17@07 Int) (j0@18@07 Int)) (!
    (and
      (implies
        (<= 0 i0@17@07)
        (and
          (<= 0 i0@17@07)
          (implies
            (< i0@17@07 dim0@6@07)
            (and
              (< i0@17@07 dim0@6@07)
              (implies
                (<= 0 j0@18@07)
                (and
                  (<= 0 j0@18@07)
                  (implies
                    (< j0@18@07 dim0@6@07)
                    (and
                      (< j0@18@07 dim0@6@07)
                      (not (= res@9@07 (as None<option<array>>  option<array>)))
                      (< i0@17@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
                      (< j0@18@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
                  ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
                (< j0@18@07 dim0@6@07))
              (<= 0 j0@18@07))
            (< i0@17@07 dim0@6@07))
          (<= 0 i0@17@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
            ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
          (< j0@18@07 dim0@6@07)
          (<= 0 j0@18@07)
          (< i0@17@07 dim0@6@07)
          (<= 0 i0@17@07))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@8@07 $Ref.null)
  (forall ((i0@17@07 Int) (j0@18@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07))
                ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
              (< j0@18@07 dim0@6@07))
            (<= 0 j0@18@07))
          (< i0@17@07 dim0@6@07))
        (<= 0 i0@17@07))
      (= i0@17@07 j0@18@07))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@17@07)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) j0@18@07)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07)))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@8@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               172
;  :arith-add-rows          42
;  :arith-assert-diseq      3
;  :arith-assert-lower      27
;  :arith-assert-upper      22
;  :arith-bound-prop        10
;  :arith-conflicts         3
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         11
;  :arith-offset-eqs        10
;  :arith-pivots            36
;  :conflicts               8
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   18
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              91
;  :final-checks            15
;  :max-generation          3
;  :max-memory              4.39
;  :memory                  4.38
;  :mk-bool-var             609
;  :mk-clause               91
;  :num-allocs              167328
;  :num-checks              24
;  :propagations            40
;  :quant-instantiations    75
;  :rlimit-count            196156)
; [then-branch: 16 | exc@8@07 == Null | live]
; [else-branch: 16 | exc@8@07 != Null | dead]
(push) ; 4
; [then-branch: 16 | exc@8@07 == Null]
(declare-const i0@19@07 Int)
(declare-const i1@20@07 Int)
(push) ; 5
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1)
; [eval] 0 <= i0
(push) ; 6
; [then-branch: 17 | 0 <= i0@19@07 | live]
; [else-branch: 17 | !(0 <= i0@19@07) | live]
(push) ; 7
; [then-branch: 17 | 0 <= i0@19@07]
(assert (<= 0 i0@19@07))
; [eval] i0 < dim0
(push) ; 8
; [then-branch: 18 | i0@19@07 < dim0@6@07 | live]
; [else-branch: 18 | !(i0@19@07 < dim0@6@07) | live]
(push) ; 9
; [then-branch: 18 | i0@19@07 < dim0@6@07]
(assert (< i0@19@07 dim0@6@07))
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 19 | 0 <= i1@20@07 | live]
; [else-branch: 19 | !(0 <= i1@20@07) | live]
(push) ; 11
; [then-branch: 19 | 0 <= i1@20@07]
(assert (<= 0 i1@20@07))
; [eval] i1 < dim1
(pop) ; 11
(push) ; 11
; [else-branch: 19 | !(0 <= i1@20@07)]
(assert (not (<= 0 i1@20@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 18 | !(i0@19@07 < dim0@6@07)]
(assert (not (< i0@19@07 dim0@6@07)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 17 | !(0 <= i0@19@07)]
(assert (not (<= 0 i0@19@07)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< i1@20@07 dim1@7@07) (<= 0 i1@20@07)) (< i0@19@07 dim0@6@07))
  (<= 0 i0@19@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 7
(assert (not (not (= res@9@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               174
;  :arith-add-rows          43
;  :arith-assert-diseq      3
;  :arith-assert-lower      33
;  :arith-assert-upper      26
;  :arith-bound-prop        10
;  :arith-conflicts         3
;  :arith-eq-adapter        16
;  :arith-fixed-eqs         13
;  :arith-offset-eqs        10
;  :arith-pivots            40
;  :conflicts               8
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   18
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              91
;  :final-checks            15
;  :max-generation          3
;  :max-memory              4.39
;  :memory                  4.39
;  :mk-bool-var             619
;  :mk-clause               91
;  :num-allocs              167658
;  :num-checks              25
;  :propagations            40
;  :quant-instantiations    75
;  :rlimit-count            196656)
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< i0@19@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               174
;  :arith-add-rows          43
;  :arith-assert-diseq      3
;  :arith-assert-lower      33
;  :arith-assert-upper      26
;  :arith-bound-prop        10
;  :arith-conflicts         3
;  :arith-eq-adapter        16
;  :arith-fixed-eqs         13
;  :arith-offset-eqs        10
;  :arith-pivots            40
;  :conflicts               8
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   18
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              91
;  :final-checks            15
;  :max-generation          3
;  :max-memory              4.39
;  :memory                  4.39
;  :mk-bool-var             619
;  :mk-clause               91
;  :num-allocs              167683
;  :num-checks              26
;  :propagations            40
;  :quant-instantiations    75
;  :rlimit-count            196687)
(assert (< i0@19@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(pop) ; 6
; Joined path conditions
(assert (< i0@19@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07)))
(push) ; 6
(assert (not (and
  (<
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))
    dim0@6@07)
  (<=
    0
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               192
;  :arith-add-rows          46
;  :arith-assert-diseq      3
;  :arith-assert-lower      36
;  :arith-assert-upper      28
;  :arith-bound-prop        13
;  :arith-conflicts         3
;  :arith-eq-adapter        18
;  :arith-fixed-eqs         15
;  :arith-offset-eqs        11
;  :arith-pivots            42
;  :conflicts               9
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   18
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              91
;  :final-checks            15
;  :max-generation          3
;  :max-memory              4.41
;  :memory                  4.41
;  :mk-bool-var             656
;  :mk-clause               105
;  :num-allocs              168029
;  :num-checks              27
;  :propagations            46
;  :quant-instantiations    95
;  :rlimit-count            197615)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               192
;  :arith-add-rows          46
;  :arith-assert-diseq      3
;  :arith-assert-lower      36
;  :arith-assert-upper      28
;  :arith-bound-prop        13
;  :arith-conflicts         3
;  :arith-eq-adapter        18
;  :arith-fixed-eqs         15
;  :arith-offset-eqs        11
;  :arith-pivots            42
;  :conflicts               10
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   18
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              91
;  :final-checks            15
;  :max-generation          3
;  :max-memory              4.42
;  :memory                  4.41
;  :mk-bool-var             656
;  :mk-clause               105
;  :num-allocs              168119
;  :num-checks              28
;  :propagations            46
;  :quant-instantiations    95
;  :rlimit-count            197710)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  i1@20@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               192
;  :arith-add-rows          49
;  :arith-assert-diseq      3
;  :arith-assert-lower      37
;  :arith-assert-upper      28
;  :arith-bound-prop        13
;  :arith-conflicts         4
;  :arith-eq-adapter        18
;  :arith-fixed-eqs         15
;  :arith-offset-eqs        11
;  :arith-pivots            44
;  :conflicts               11
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   18
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              91
;  :final-checks            15
;  :max-generation          3
;  :max-memory              4.42
;  :memory                  4.40
;  :mk-bool-var             657
;  :mk-clause               105
;  :num-allocs              168274
;  :num-checks              29
;  :propagations            46
;  :quant-instantiations    95
;  :rlimit-count            198004)
(assert (<
  i1@20@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))))))
(pop) ; 6
; Joined path conditions
(assert (<
  i1@20@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))))))
(declare-const sm@21@07 $FVF<Int>)
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 6
; Joined path conditions
(pop) ; 5
(declare-fun inv@22@07 ($Ref) Int)
(declare-fun inv@23@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@19@07 Int) (i1@20@07 Int)) (!
  (and
    (not (= res@9@07 (as None<option<array>>  option<array>)))
    (< i0@19@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))
        (as None<option<array>>  option<array>)))
    (<
      i1@20@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))))))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07)))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i01@19@07 Int) (i11@20@07 Int) (i02@19@07 Int) (i12@20@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@20@07 dim1@7@07) (<= 0 i11@20@07))
          (< i01@19@07 dim0@6@07))
        (<= 0 i01@19@07))
      (and
        (and
          (and (< i12@20@07 dim1@7@07) (<= 0 i12@20@07))
          (< i02@19@07 dim0@6@07))
        (<= 0 i02@19@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i01@19@07))) i11@20@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i02@19@07))) i12@20@07)))
    (and (= i01@19@07 i02@19@07) (= i11@20@07 i12@20@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               311
;  :arith-add-rows          99
;  :arith-assert-diseq      8
;  :arith-assert-lower      59
;  :arith-assert-upper      37
;  :arith-bound-prop        18
;  :arith-conflicts         5
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        16
;  :arith-pivots            71
;  :conflicts               18
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   18
;  :datatype-splits         13
;  :decisions               22
;  :del-clause              215
;  :final-checks            15
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             927
;  :mk-clause               215
;  :num-allocs              169865
;  :num-checks              30
;  :propagations            134
;  :quant-instantiations    188
;  :rlimit-count            203458
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i0@19@07 Int) (i1@20@07 Int)) (!
  (implies
    (and
      (and (and (< i1@20@07 dim1@7@07) (<= 0 i1@20@07)) (< i0@19@07 dim0@6@07))
      (<= 0 i0@19@07))
    (and
      (=
        (inv@22@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07))
        i0@19@07)
      (=
        (inv@23@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07))
        i1@20@07)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@23@07 r) dim1@7@07) (<= 0 (inv@23@07 r)))
        (< (inv@22@07 r) dim0@6@07))
      (<= 0 (inv@22@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) (inv@22@07 r)))) (inv@23@07 r))
      r))
  :pattern ((inv@22@07 r))
  :pattern ((inv@23@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@19@07 Int) (i1@20@07 Int)) (!
  (implies
    (and
      (and (and (< i1@20@07 dim1@7@07) (<= 0 i1@20@07)) (< i0@19@07 dim0@6@07))
      (<= 0 i0@19@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07)
        $Ref.null)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@19@07))) i1@20@07)))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@24@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@23@07 r) dim1@7@07) (<= 0 (inv@23@07 r)))
        (< (inv@22@07 r) dim0@6@07))
      (<= 0 (inv@22@07 r)))
    (=
      ($FVF.lookup_int (as sm@24@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@24@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@24@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@23@07 r) dim1@7@07) (<= 0 (inv@23@07 r)))
        (< (inv@22@07 r) dim0@6@07))
      (<= 0 (inv@22@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@24@07  $FVF<Int>) r) r))
  :pattern ((inv@22@07 r) (inv@23@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@07))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int, i1: Int :: { aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int } 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0)
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@8@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               317
;  :arith-add-rows          99
;  :arith-assert-diseq      8
;  :arith-assert-lower      59
;  :arith-assert-upper      37
;  :arith-bound-prop        18
;  :arith-conflicts         5
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        16
;  :arith-pivots            71
;  :conflicts               18
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              215
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.56
;  :memory                  4.55
;  :mk-bool-var             936
;  :mk-clause               215
;  :num-allocs              171335
;  :num-checks              31
;  :propagations            134
;  :quant-instantiations    188
;  :rlimit-count            207004)
; [then-branch: 20 | exc@8@07 == Null | live]
; [else-branch: 20 | exc@8@07 != Null | dead]
(push) ; 6
; [then-branch: 20 | exc@8@07 == Null]
; [eval] (forall i0: Int, i1: Int :: { aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int } 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0)
(declare-const i0@25@07 Int)
(declare-const i1@26@07 Int)
(push) ; 7
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1)
; [eval] 0 <= i0
(push) ; 8
; [then-branch: 21 | 0 <= i0@25@07 | live]
; [else-branch: 21 | !(0 <= i0@25@07) | live]
(push) ; 9
; [then-branch: 21 | 0 <= i0@25@07]
(assert (<= 0 i0@25@07))
; [eval] i0 < dim0
(push) ; 10
; [then-branch: 22 | i0@25@07 < dim0@6@07 | live]
; [else-branch: 22 | !(i0@25@07 < dim0@6@07) | live]
(push) ; 11
; [then-branch: 22 | i0@25@07 < dim0@6@07]
(assert (< i0@25@07 dim0@6@07))
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 23 | 0 <= i1@26@07 | live]
; [else-branch: 23 | !(0 <= i1@26@07) | live]
(push) ; 13
; [then-branch: 23 | 0 <= i1@26@07]
(assert (<= 0 i1@26@07))
; [eval] i1 < dim1
(pop) ; 13
(push) ; 13
; [else-branch: 23 | !(0 <= i1@26@07)]
(assert (not (<= 0 i1@26@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 22 | !(i0@25@07 < dim0@6@07)]
(assert (not (< i0@25@07 dim0@6@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 21 | !(0 <= i0@25@07)]
(assert (not (<= 0 i0@25@07)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 24 | i1@26@07 < dim1@7@07 && 0 <= i1@26@07 && i0@25@07 < dim0@6@07 && 0 <= i0@25@07 | live]
; [else-branch: 24 | !(i1@26@07 < dim1@7@07 && 0 <= i1@26@07 && i0@25@07 < dim0@6@07 && 0 <= i0@25@07) | live]
(push) ; 9
; [then-branch: 24 | i1@26@07 < dim1@7@07 && 0 <= i1@26@07 && i0@25@07 < dim0@6@07 && 0 <= i0@25@07]
(assert (and
  (and (and (< i1@26@07 dim1@7@07) (<= 0 i1@26@07)) (< i0@25@07 dim0@6@07))
  (<= 0 i0@25@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 11
(assert (not (not (= res@9@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               319
;  :arith-add-rows          99
;  :arith-assert-diseq      8
;  :arith-assert-lower      66
;  :arith-assert-upper      40
;  :arith-bound-prop        18
;  :arith-conflicts         5
;  :arith-eq-adapter        35
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        16
;  :arith-pivots            75
;  :conflicts               18
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              215
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.57
;  :memory                  4.56
;  :mk-bool-var             946
;  :mk-clause               215
;  :num-allocs              171656
;  :num-checks              32
;  :propagations            134
;  :quant-instantiations    188
;  :rlimit-count            207506)
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not (= res@9@07 (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (< i0@25@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               319
;  :arith-add-rows          99
;  :arith-assert-diseq      8
;  :arith-assert-lower      66
;  :arith-assert-upper      40
;  :arith-bound-prop        18
;  :arith-conflicts         5
;  :arith-eq-adapter        35
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        16
;  :arith-pivots            75
;  :conflicts               18
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              215
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.57
;  :memory                  4.56
;  :mk-bool-var             946
;  :mk-clause               215
;  :num-allocs              171675
;  :num-checks              33
;  :propagations            134
;  :quant-instantiations    188
;  :rlimit-count            207537)
(assert (< i0@25@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(pop) ; 10
; Joined path conditions
(assert (< i0@25@07 (alen<Int> (opt_get1 $Snap.unit res@9@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)))
(push) ; 10
(assert (not (and
  (<
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
    dim0@6@07)
  (<=
    0
    (inv@13@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               329
;  :arith-add-rows          105
;  :arith-assert-diseq      8
;  :arith-assert-lower      69
;  :arith-assert-upper      43
;  :arith-bound-prop        19
;  :arith-conflicts         6
;  :arith-eq-adapter        37
;  :arith-fixed-eqs         26
;  :arith-offset-eqs        16
;  :arith-pivots            78
;  :conflicts               19
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              215
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.58
;  :memory                  4.57
;  :mk-bool-var             982
;  :mk-clause               227
;  :num-allocs              171999
;  :num-checks              34
;  :propagations            136
;  :quant-instantiations    208
;  :rlimit-count            208489)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               329
;  :arith-add-rows          105
;  :arith-assert-diseq      8
;  :arith-assert-lower      69
;  :arith-assert-upper      43
;  :arith-bound-prop        19
;  :arith-conflicts         6
;  :arith-eq-adapter        37
;  :arith-fixed-eqs         26
;  :arith-offset-eqs        16
;  :arith-pivots            78
;  :conflicts               20
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              215
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.58
;  :memory                  4.57
;  :mk-bool-var             982
;  :mk-clause               227
;  :num-allocs              172088
;  :num-checks              35
;  :propagations            136
;  :quant-instantiations    208
;  :rlimit-count            208584)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  i1@26@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               329
;  :arith-add-rows          106
;  :arith-assert-diseq      8
;  :arith-assert-lower      70
;  :arith-assert-upper      43
;  :arith-bound-prop        19
;  :arith-conflicts         7
;  :arith-eq-adapter        37
;  :arith-fixed-eqs         26
;  :arith-offset-eqs        16
;  :arith-pivots            78
;  :conflicts               21
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              215
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.58
;  :memory                  4.57
;  :mk-bool-var             983
;  :mk-clause               227
;  :num-allocs              172249
;  :num-checks              36
;  :propagations            136
;  :quant-instantiations    208
;  :rlimit-count            208838)
(assert (<
  i1@26@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))))))
(pop) ; 10
; Joined path conditions
(assert (<
  i1@26@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@24@07  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)))
(push) ; 10
(assert (not (and
  (and
    (and
      (<
        (inv@23@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07))
        dim1@7@07)
      (<=
        0
        (inv@23@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07))))
    (<
      (inv@22@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07))
      dim0@6@07))
  (<=
    0
    (inv@22@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               346
;  :arith-add-rows          115
;  :arith-assert-diseq      8
;  :arith-assert-lower      72
;  :arith-assert-upper      47
;  :arith-bound-prop        22
;  :arith-conflicts         8
;  :arith-eq-adapter        39
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        18
;  :arith-pivots            81
;  :conflicts               22
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              215
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.60
;  :mk-bool-var             1011
;  :mk-clause               247
;  :num-allocs              172615
;  :num-checks              37
;  :propagations            146
;  :quant-instantiations    219
;  :rlimit-count            209920)
(pop) ; 9
(push) ; 9
; [else-branch: 24 | !(i1@26@07 < dim1@7@07 && 0 <= i1@26@07 && i0@25@07 < dim0@6@07 && 0 <= i0@25@07)]
(assert (not
  (and
    (and (and (< i1@26@07 dim1@7@07) (<= 0 i1@26@07)) (< i0@25@07 dim0@6@07))
    (<= 0 i0@25@07))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and (and (< i1@26@07 dim1@7@07) (<= 0 i1@26@07)) (< i0@25@07 dim0@6@07))
    (<= 0 i0@25@07))
  (and
    (< i1@26@07 dim1@7@07)
    (<= 0 i1@26@07)
    (< i0@25@07 dim0@6@07)
    (<= 0 i0@25@07)
    (not (= res@9@07 (as None<option<array>>  option<array>)))
    (< i0@25@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
        (as None<option<array>>  option<array>)))
    (<
      i1@26@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@24@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@25@07 Int) (i1@26@07 Int)) (!
  (implies
    (and
      (and (and (< i1@26@07 dim1@7@07) (<= 0 i1@26@07)) (< i0@25@07 dim0@6@07))
      (<= 0 i0@25@07))
    (and
      (< i1@26@07 dim1@7@07)
      (<= 0 i1@26@07)
      (< i0@25@07 dim0@6@07)
      (<= 0 i0@25@07)
      (not (= res@9@07 (as None<option<array>>  option<array>)))
      (< i0@25@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
          (as None<option<array>>  option<array>)))
      (<
        i1@26@07
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@24@07  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07))))
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@24@07  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@8@07 $Ref.null)
  (forall ((i0@25@07 Int) (i1@26@07 Int)) (!
    (implies
      (and
        (and (and (< i1@26@07 dim1@7@07) (<= 0 i1@26@07)) (< i0@25@07 dim0@6@07))
        (<= 0 i0@25@07))
      (and
        (< i1@26@07 dim1@7@07)
        (<= 0 i1@26@07)
        (< i0@25@07 dim0@6@07)
        (<= 0 i0@25@07)
        (not (= res@9@07 (as None<option<array>>  option<array>)))
        (< i0@25@07 (alen<Int> (opt_get1 $Snap.unit res@9@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))
            (as None<option<array>>  option<array>)))
        (<
          i1@26@07
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07)))))
        ($FVF.loc_int ($FVF.lookup_int (as sm@24@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07))))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@24@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@8@07 $Ref.null)
  (forall ((i0@25@07 Int) (i1@26@07 Int)) (!
    (implies
      (and
        (and (and (< i1@26@07 dim1@7@07) (<= 0 i1@26@07)) (< i0@25@07 dim0@6@07))
        (<= 0 i0@25@07))
      (=
        ($FVF.lookup_int (as sm@24@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07))
        0))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@24@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@14@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@9@07) i0@25@07))) i1@26@07)))
    :qid |prog.l<no position>|))))
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- hasAugmentingPath ----------
(declare-const this@27@07 $Ref)
(declare-const tid@28@07 Int)
(declare-const Gf@29@07 option<array>)
(declare-const V@30@07 Int)
(declare-const s@31@07 Int)
(declare-const t@32@07 Int)
(declare-const p@33@07 option<array>)
(declare-const exc@34@07 $Ref)
(declare-const res@35@07 Bool)
(declare-const this@36@07 $Ref)
(declare-const tid@37@07 Int)
(declare-const Gf@38@07 option<array>)
(declare-const V@39@07 Int)
(declare-const s@40@07 Int)
(declare-const t@41@07 Int)
(declare-const p@42@07 option<array>)
(declare-const exc@43@07 $Ref)
(declare-const res@44@07 Bool)
(push) ; 1
(declare-const $t@45@07 $Snap)
(assert (= $t@45@07 ($Snap.combine ($Snap.first $t@45@07) ($Snap.second $t@45@07))))
(assert (= ($Snap.first $t@45@07) $Snap.unit))
; [eval] this != null
(assert (not (= this@36@07 $Ref.null)))
(assert (=
  ($Snap.second $t@45@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@45@07))
    ($Snap.second ($Snap.second $t@45@07)))))
(assert (= ($Snap.first ($Snap.second $t@45@07)) $Snap.unit))
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= Gf@38@07 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second $t@45@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@45@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@45@07))) $Snap.unit))
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit Gf@38@07)) V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@45@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@45@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))
(declare-const i1@46@07 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 25 | 0 <= i1@46@07 | live]
; [else-branch: 25 | !(0 <= i1@46@07) | live]
(push) ; 4
; [then-branch: 25 | 0 <= i1@46@07]
(assert (<= 0 i1@46@07))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 25 | !(0 <= i1@46@07)]
(assert (not (<= 0 i1@46@07)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@46@07 V@39@07) (<= 0 i1@46@07)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@46@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               375
;  :arith-add-rows          133
;  :arith-assert-diseq      8
;  :arith-assert-lower      75
;  :arith-assert-upper      49
;  :arith-bound-prop        22
;  :arith-conflicts         8
;  :arith-eq-adapter        40
;  :arith-fixed-eqs         29
;  :arith-offset-eqs        18
;  :arith-pivots            91
;  :conflicts               22
;  :datatype-accessor-ax    15
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              247
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1031
;  :mk-clause               247
;  :num-allocs              173280
;  :num-checks              38
;  :propagations            146
;  :quant-instantiations    224
;  :rlimit-count            211465)
(assert (< i1@46@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 3
; Joined path conditions
(assert (< i1@46@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(declare-const $k@47@07 $Perm)
(assert ($Perm.isReadVar $k@47@07 $Perm.Write))
(pop) ; 2
(declare-fun inv@48@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@47@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@46@07 Int)) (!
  (< i1@46@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@46@07))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@46@07 Int)) (!
  (implies
    (and (< i1@46@07 V@39@07) (<= 0 i1@46@07))
    (or (= $k@47@07 $Perm.No) (< $Perm.No $k@47@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               377
;  :arith-add-rows          133
;  :arith-assert-diseq      9
;  :arith-assert-lower      77
;  :arith-assert-upper      50
;  :arith-bound-prop        22
;  :arith-conflicts         8
;  :arith-eq-adapter        41
;  :arith-fixed-eqs         29
;  :arith-offset-eqs        18
;  :arith-pivots            93
;  :conflicts               23
;  :datatype-accessor-ax    16
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              247
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1038
;  :mk-clause               249
;  :num-allocs              173767
;  :num-checks              39
;  :propagations            147
;  :quant-instantiations    224
;  :rlimit-count            212041)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@46@07 Int) (i12@46@07 Int)) (!
  (implies
    (and
      (and (and (< i11@46@07 V@39@07) (<= 0 i11@46@07)) (< $Perm.No $k@47@07))
      (and (and (< i12@46@07 V@39@07) (<= 0 i12@46@07)) (< $Perm.No $k@47@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@46@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@46@07)))
    (= i11@46@07 i12@46@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               389
;  :arith-add-rows          141
;  :arith-assert-diseq      11
;  :arith-assert-lower      82
;  :arith-assert-upper      52
;  :arith-bound-prop        23
;  :arith-conflicts         9
;  :arith-eq-adapter        43
;  :arith-fixed-eqs         30
;  :arith-offset-eqs        19
;  :arith-pivots            99
;  :conflicts               24
;  :datatype-accessor-ax    16
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              262
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1063
;  :mk-clause               264
;  :num-allocs              174128
;  :num-checks              40
;  :propagations            152
;  :quant-instantiations    234
;  :rlimit-count            212966)
; Definitional axioms for inverse functions
(assert (forall ((i1@46@07 Int)) (!
  (implies
    (and (and (< i1@46@07 V@39@07) (<= 0 i1@46@07)) (< $Perm.No $k@47@07))
    (=
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@46@07))
      i1@46@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@46@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
      (< $Perm.No $k@47@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@48@07 r))
      r))
  :pattern ((inv@48@07 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@46@07 Int)) (!
  (<= $Perm.No $k@47@07)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@46@07))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@46@07 Int)) (!
  (<= $k@47@07 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@46@07))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@46@07 Int)) (!
  (implies
    (and (and (< i1@46@07 V@39@07) (<= 0 i1@46@07)) (< $Perm.No $k@47@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@46@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@46@07))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@49@07 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
      (< $Perm.No $k@47@07)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@45@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@45@07))))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@45@07))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef7|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) r) r))
  :pattern ((inv@48@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@50@07 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 26 | 0 <= i1@50@07 | live]
; [else-branch: 26 | !(0 <= i1@50@07) | live]
(push) ; 4
; [then-branch: 26 | 0 <= i1@50@07]
(assert (<= 0 i1@50@07))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 26 | !(0 <= i1@50@07)]
(assert (not (<= 0 i1@50@07)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 27 | i1@50@07 < V@39@07 && 0 <= i1@50@07 | live]
; [else-branch: 27 | !(i1@50@07 < V@39@07 && 0 <= i1@50@07) | live]
(push) ; 4
; [then-branch: 27 | i1@50@07 < V@39@07 && 0 <= i1@50@07]
(assert (and (< i1@50@07 V@39@07) (<= 0 i1@50@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@50@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               397
;  :arith-add-rows          142
;  :arith-assert-diseq      11
;  :arith-assert-lower      84
;  :arith-assert-upper      55
;  :arith-bound-prop        23
;  :arith-conflicts         9
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         31
;  :arith-offset-eqs        19
;  :arith-pivots            101
;  :conflicts               24
;  :datatype-accessor-ax    17
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              262
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1077
;  :mk-clause               264
;  :num-allocs              175333
;  :num-checks              41
;  :propagations            152
;  :quant-instantiations    234
;  :rlimit-count            215334)
(assert (< i1@50@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 5
; Joined path conditions
(assert (< i1@50@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               409
;  :arith-add-rows          145
;  :arith-assert-diseq      11
;  :arith-assert-lower      85
;  :arith-assert-upper      56
;  :arith-bound-prop        26
;  :arith-conflicts         9
;  :arith-eq-adapter        45
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        22
;  :arith-pivots            102
;  :conflicts               25
;  :datatype-accessor-ax    17
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              262
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1094
;  :mk-clause               272
;  :num-allocs              175607
;  :num-checks              42
;  :propagations            156
;  :quant-instantiations    244
;  :rlimit-count            215962)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 27 | !(i1@50@07 < V@39@07 && 0 <= i1@50@07)]
(assert (not (and (< i1@50@07 V@39@07) (<= 0 i1@50@07))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@50@07 V@39@07) (<= 0 i1@50@07))
  (and
    (< i1@50@07 V@39@07)
    (<= 0 i1@50@07)
    (< i1@50@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@50@07 Int)) (!
  (implies
    (and (< i1@50@07 V@39@07) (<= 0 i1@50@07))
    (and
      (< i1@50@07 V@39@07)
      (<= 0 i1@50@07)
      (< i1@50@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@50@07 Int)) (!
  (implies
    (and (< i1@50@07 V@39@07) (<= 0 i1@50@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@50@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@51@07 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 28 | 0 <= i1@51@07 | live]
; [else-branch: 28 | !(0 <= i1@51@07) | live]
(push) ; 4
; [then-branch: 28 | 0 <= i1@51@07]
(assert (<= 0 i1@51@07))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 28 | !(0 <= i1@51@07)]
(assert (not (<= 0 i1@51@07)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 29 | i1@51@07 < V@39@07 && 0 <= i1@51@07 | live]
; [else-branch: 29 | !(i1@51@07 < V@39@07 && 0 <= i1@51@07) | live]
(push) ; 4
; [then-branch: 29 | i1@51@07 < V@39@07 && 0 <= i1@51@07]
(assert (and (< i1@51@07 V@39@07) (<= 0 i1@51@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@51@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               417
;  :arith-add-rows          147
;  :arith-assert-diseq      11
;  :arith-assert-lower      88
;  :arith-assert-upper      57
;  :arith-bound-prop        26
;  :arith-conflicts         9
;  :arith-eq-adapter        46
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        22
;  :arith-pivots            107
;  :conflicts               25
;  :datatype-accessor-ax    18
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              270
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1103
;  :mk-clause               272
;  :num-allocs              176186
;  :num-checks              43
;  :propagations            156
;  :quant-instantiations    244
;  :rlimit-count            217133)
(assert (< i1@51@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 5
; Joined path conditions
(assert (< i1@51@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               430
;  :arith-add-rows          150
;  :arith-assert-diseq      11
;  :arith-assert-lower      89
;  :arith-assert-upper      58
;  :arith-bound-prop        29
;  :arith-conflicts         9
;  :arith-eq-adapter        47
;  :arith-fixed-eqs         34
;  :arith-offset-eqs        25
;  :arith-pivots            108
;  :conflicts               26
;  :datatype-accessor-ax    18
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              270
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1123
;  :mk-clause               280
;  :num-allocs              176446
;  :num-checks              44
;  :propagations            160
;  :quant-instantiations    256
;  :rlimit-count            217802)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               430
;  :arith-add-rows          150
;  :arith-assert-diseq      11
;  :arith-assert-lower      89
;  :arith-assert-upper      58
;  :arith-bound-prop        29
;  :arith-conflicts         9
;  :arith-eq-adapter        47
;  :arith-fixed-eqs         34
;  :arith-offset-eqs        25
;  :arith-pivots            108
;  :conflicts               27
;  :datatype-accessor-ax    18
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              270
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1123
;  :mk-clause               280
;  :num-allocs              176535
;  :num-checks              45
;  :propagations            160
;  :quant-instantiations    256
;  :rlimit-count            217897)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 29 | !(i1@51@07 < V@39@07 && 0 <= i1@51@07)]
(assert (not (and (< i1@51@07 V@39@07) (<= 0 i1@51@07))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@51@07 V@39@07) (<= 0 i1@51@07))
  (and
    (< i1@51@07 V@39@07)
    (<= 0 i1@51@07)
    (< i1@51@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@51@07 Int)) (!
  (implies
    (and (< i1@51@07 V@39@07) (<= 0 i1@51@07))
    (and
      (< i1@51@07 V@39@07)
      (<= 0 i1@51@07)
      (< i1@51@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@51@07 Int)) (!
  (implies
    (and (< i1@51@07 V@39@07) (<= 0 i1@51@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@51@07)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@52@07 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@53@07 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 30 | 0 <= i1@52@07 | live]
; [else-branch: 30 | !(0 <= i1@52@07) | live]
(push) ; 5
; [then-branch: 30 | 0 <= i1@52@07]
(assert (<= 0 i1@52@07))
; [eval] i1 < V
(push) ; 6
; [then-branch: 31 | i1@52@07 < V@39@07 | live]
; [else-branch: 31 | !(i1@52@07 < V@39@07) | live]
(push) ; 7
; [then-branch: 31 | i1@52@07 < V@39@07]
(assert (< i1@52@07 V@39@07))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 32 | 0 <= i2@53@07 | live]
; [else-branch: 32 | !(0 <= i2@53@07) | live]
(push) ; 9
; [then-branch: 32 | 0 <= i2@53@07]
(assert (<= 0 i2@53@07))
; [eval] i2 < V
(push) ; 10
; [then-branch: 33 | i2@53@07 < V@39@07 | live]
; [else-branch: 33 | !(i2@53@07 < V@39@07) | live]
(push) ; 11
; [then-branch: 33 | i2@53@07 < V@39@07]
(assert (< i2@53@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               438
;  :arith-add-rows          153
;  :arith-assert-diseq      11
;  :arith-assert-lower      94
;  :arith-assert-upper      59
;  :arith-bound-prop        29
;  :arith-conflicts         9
;  :arith-eq-adapter        48
;  :arith-fixed-eqs         35
;  :arith-offset-eqs        25
;  :arith-pivots            112
;  :conflicts               27
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              278
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1134
;  :mk-clause               280
;  :num-allocs              177290
;  :num-checks              46
;  :propagations            160
;  :quant-instantiations    256
;  :rlimit-count            219300)
(assert (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               446
;  :arith-add-rows          155
;  :arith-assert-diseq      11
;  :arith-assert-lower      95
;  :arith-assert-upper      60
;  :arith-bound-prop        31
;  :arith-conflicts         9
;  :arith-eq-adapter        49
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        26
;  :arith-pivots            113
;  :conflicts               28
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              278
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1154
;  :mk-clause               288
;  :num-allocs              177550
;  :num-checks              47
;  :propagations            161
;  :quant-instantiations    268
;  :rlimit-count            219956)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               446
;  :arith-add-rows          155
;  :arith-assert-diseq      11
;  :arith-assert-lower      95
;  :arith-assert-upper      60
;  :arith-bound-prop        31
;  :arith-conflicts         9
;  :arith-eq-adapter        49
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        26
;  :arith-pivots            113
;  :conflicts               28
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              278
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.59
;  :mk-bool-var             1154
;  :mk-clause               288
;  :num-allocs              177575
;  :num-checks              48
;  :propagations            161
;  :quant-instantiations    268
;  :rlimit-count            219986)
(assert (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 12
; Joined path conditions
(assert (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               450
;  :arith-add-rows          160
;  :arith-assert-diseq      11
;  :arith-assert-lower      96
;  :arith-assert-upper      62
;  :arith-bound-prop        32
;  :arith-conflicts         10
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        26
;  :arith-pivots            115
;  :conflicts               29
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              278
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.61
;  :memory                  4.60
;  :mk-bool-var             1173
;  :mk-clause               295
;  :num-allocs              177840
;  :num-checks              49
;  :propagations            161
;  :quant-instantiations    279
;  :rlimit-count            220698)
(pop) ; 11
(push) ; 11
; [else-branch: 33 | !(i2@53@07 < V@39@07)]
(assert (not (< i2@53@07 V@39@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@53@07 V@39@07)
  (and
    (< i2@53@07 V@39@07)
    (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
    (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 32 | !(0 <= i2@53@07)]
(assert (not (<= 0 i2@53@07)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@53@07)
  (and
    (<= 0 i2@53@07)
    (implies
      (< i2@53@07 V@39@07)
      (and
        (< i2@53@07 V@39@07)
        (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
        (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 31 | !(i1@52@07 < V@39@07)]
(assert (not (< i1@52@07 V@39@07)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@52@07 V@39@07)
  (and
    (< i1@52@07 V@39@07)
    (implies
      (<= 0 i2@53@07)
      (and
        (<= 0 i2@53@07)
        (implies
          (< i2@53@07 V@39@07)
          (and
            (< i2@53@07 V@39@07)
            (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
            (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 30 | !(0 <= i1@52@07)]
(assert (not (<= 0 i1@52@07)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@52@07)
  (and
    (<= 0 i1@52@07)
    (implies
      (< i1@52@07 V@39@07)
      (and
        (< i1@52@07 V@39@07)
        (implies
          (<= 0 i2@53@07)
          (and
            (<= 0 i2@53@07)
            (implies
              (< i2@53@07 V@39@07)
              (and
                (< i2@53@07 V@39@07)
                (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
                (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 34 | Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@52@07)) == Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@53@07)) && i2@53@07 < V@39@07 && 0 <= i2@53@07 && i1@52@07 < V@39@07 && 0 <= i1@52@07 | live]
; [else-branch: 34 | !(Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@52@07)) == Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@53@07)) && i2@53@07 < V@39@07 && 0 <= i2@53@07 && i1@52@07 < V@39@07 && 0 <= i1@52@07) | live]
(push) ; 5
; [then-branch: 34 | Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@52@07)) == Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@53@07)) && i2@53@07 < V@39@07 && 0 <= i2@53@07 && i1@52@07 < V@39@07 && 0 <= i1@52@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
        (< i2@53@07 V@39@07))
      (<= 0 i2@53@07))
    (< i1@52@07 V@39@07))
  (<= 0 i1@52@07)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 34 | !(Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@52@07)) == Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@53@07)) && i2@53@07 < V@39@07 && 0 <= i2@53@07 && i1@52@07 < V@39@07 && 0 <= i1@52@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
          (< i2@53@07 V@39@07))
        (<= 0 i2@53@07))
      (< i1@52@07 V@39@07))
    (<= 0 i1@52@07))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
          (< i2@53@07 V@39@07))
        (<= 0 i2@53@07))
      (< i1@52@07 V@39@07))
    (<= 0 i1@52@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
      ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
    (< i2@53@07 V@39@07)
    (<= 0 i2@53@07)
    (< i1@52@07 V@39@07)
    (<= 0 i1@52@07))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@53@07 Int)) (!
  (and
    (implies
      (<= 0 i1@52@07)
      (and
        (<= 0 i1@52@07)
        (implies
          (< i1@52@07 V@39@07)
          (and
            (< i1@52@07 V@39@07)
            (implies
              (<= 0 i2@53@07)
              (and
                (<= 0 i2@53@07)
                (implies
                  (< i2@53@07 V@39@07)
                  (and
                    (< i2@53@07 V@39@07)
                    (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
                    (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
              (< i2@53@07 V@39@07))
            (<= 0 i2@53@07))
          (< i1@52@07 V@39@07))
        (<= 0 i1@52@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
        (< i2@53@07 V@39@07)
        (<= 0 i2@53@07)
        (< i1@52@07 V@39@07)
        (<= 0 i1@52@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@52@07 Int)) (!
  (forall ((i2@53@07 Int)) (!
    (and
      (implies
        (<= 0 i1@52@07)
        (and
          (<= 0 i1@52@07)
          (implies
            (< i1@52@07 V@39@07)
            (and
              (< i1@52@07 V@39@07)
              (implies
                (<= 0 i2@53@07)
                (and
                  (<= 0 i2@53@07)
                  (implies
                    (< i2@53@07 V@39@07)
                    (and
                      (< i2@53@07 V@39@07)
                      (< i1@52@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
                      (< i2@53@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
                  ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
                (< i2@53@07 V@39@07))
              (<= 0 i2@53@07))
            (< i1@52@07 V@39@07))
          (<= 0 i1@52@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
          (< i2@53@07 V@39@07)
          (<= 0 i2@53@07)
          (< i1@52@07 V@39@07)
          (<= 0 i1@52@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@52@07 Int)) (!
  (forall ((i2@53@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07)))
              (< i2@53@07 V@39@07))
            (<= 0 i2@53@07))
          (< i1@52@07 V@39@07))
        (<= 0 i1@52@07))
      (= i1@52@07 i2@53@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@53@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@52@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))
  $Snap.unit))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= p@42@07 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))
  $Snap.unit))
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit p@42@07)) V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (<= 0 s@40@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))
  $Snap.unit))
; [eval] s < V
(assert (< s@40@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))
  $Snap.unit))
; [eval] 0 <= t
(assert (<= 0 t@41@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))
  $Snap.unit))
; [eval] t < V
(assert (< t@41@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))))
(declare-const i1@54@07 Int)
(declare-const j1@55@07 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 35 | 0 <= i1@54@07 | live]
; [else-branch: 35 | !(0 <= i1@54@07) | live]
(push) ; 4
; [then-branch: 35 | 0 <= i1@54@07]
(assert (<= 0 i1@54@07))
; [eval] i1 < V
(push) ; 5
; [then-branch: 36 | i1@54@07 < V@39@07 | live]
; [else-branch: 36 | !(i1@54@07 < V@39@07) | live]
(push) ; 6
; [then-branch: 36 | i1@54@07 < V@39@07]
(assert (< i1@54@07 V@39@07))
; [eval] 0 <= j1
(push) ; 7
; [then-branch: 37 | 0 <= j1@55@07 | live]
; [else-branch: 37 | !(0 <= j1@55@07) | live]
(push) ; 8
; [then-branch: 37 | 0 <= j1@55@07]
(assert (<= 0 j1@55@07))
; [eval] j1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 37 | !(0 <= j1@55@07)]
(assert (not (<= 0 j1@55@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 36 | !(i1@54@07 < V@39@07)]
(assert (not (< i1@54@07 V@39@07)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 35 | !(0 <= i1@54@07)]
(assert (not (<= 0 i1@54@07)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@55@07 V@39@07) (<= 0 j1@55@07)) (< i1@54@07 V@39@07))
  (<= 0 i1@54@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@54@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               501
;  :arith-add-rows          173
;  :arith-assert-diseq      11
;  :arith-assert-lower      110
;  :arith-assert-upper      65
;  :arith-bound-prop        32
;  :arith-conflicts         10
;  :arith-eq-adapter        53
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        26
;  :arith-pivots            125
;  :conflicts               29
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              317
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.62
;  :memory                  4.61
;  :mk-bool-var             1227
;  :mk-clause               319
;  :num-allocs              179536
;  :num-checks              50
;  :propagations            161
;  :quant-instantiations    284
;  :rlimit-count            225092)
(assert (< i1@54@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 3
; Joined path conditions
(assert (< i1@54@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07)))
(push) ; 3
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               507
;  :arith-add-rows          180
;  :arith-assert-diseq      11
;  :arith-assert-lower      111
;  :arith-assert-upper      67
;  :arith-bound-prop        33
;  :arith-conflicts         11
;  :arith-eq-adapter        54
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        27
;  :arith-pivots            127
;  :conflicts               30
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              317
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.78
;  :mk-bool-var             1256
;  :mk-clause               326
;  :num-allocs              179898
;  :num-checks              51
;  :propagations            161
;  :quant-instantiations    299
;  :rlimit-count            226146)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               507
;  :arith-add-rows          180
;  :arith-assert-diseq      11
;  :arith-assert-lower      111
;  :arith-assert-upper      67
;  :arith-bound-prop        33
;  :arith-conflicts         11
;  :arith-eq-adapter        54
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        27
;  :arith-pivots            127
;  :conflicts               31
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              317
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.78
;  :mk-bool-var             1256
;  :mk-clause               326
;  :num-allocs              179988
;  :num-checks              52
;  :propagations            161
;  :quant-instantiations    299
;  :rlimit-count            226241)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j1@55@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               513
;  :arith-add-rows          186
;  :arith-assert-diseq      11
;  :arith-assert-lower      114
;  :arith-assert-upper      68
;  :arith-bound-prop        33
;  :arith-conflicts         12
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         42
;  :arith-offset-eqs        27
;  :arith-pivots            131
;  :conflicts               32
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              321
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.78
;  :mk-bool-var             1267
;  :mk-clause               330
;  :num-allocs              180181
;  :num-checks              53
;  :propagations            163
;  :quant-instantiations    306
;  :rlimit-count            226762)
(assert (<
  j1@55@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j1@55@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))))))
(pop) ; 2
(declare-fun inv@56@07 ($Ref) Int)
(declare-fun inv@57@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@54@07 Int) (j1@55@07 Int)) (!
  (and
    (< i1@54@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@55@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))) j1@55@07))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@54@07 Int) (j11@55@07 Int) (i12@54@07 Int) (j12@55@07 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@55@07 V@39@07) (<= 0 j11@55@07)) (< i11@54@07 V@39@07))
        (<= 0 i11@54@07))
      (and
        (and (and (< j12@55@07 V@39@07) (<= 0 j12@55@07)) (< i12@54@07 V@39@07))
        (<= 0 i12@54@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@54@07))) j11@55@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@54@07))) j12@55@07)))
    (and (= i11@54@07 i12@54@07) (= j11@55@07 j12@55@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               553
;  :arith-add-rows          208
;  :arith-assert-diseq      11
;  :arith-assert-lower      126
;  :arith-assert-upper      72
;  :arith-bound-prop        35
;  :arith-conflicts         12
;  :arith-eq-adapter        61
;  :arith-fixed-eqs         44
;  :arith-offset-eqs        28
;  :arith-pivots            143
;  :conflicts               33
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              387
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.83
;  :mk-bool-var             1399
;  :mk-clause               389
;  :num-allocs              181364
;  :num-checks              54
;  :propagations            187
;  :quant-instantiations    364
;  :rlimit-count            230457
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@54@07 Int) (j1@55@07 Int)) (!
  (implies
    (and
      (and (and (< j1@55@07 V@39@07) (<= 0 j1@55@07)) (< i1@54@07 V@39@07))
      (<= 0 i1@54@07))
    (and
      (=
        (inv@56@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))) j1@55@07))
        i1@54@07)
      (=
        (inv@57@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))) j1@55@07))
        j1@55@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))) j1@55@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
        (< (inv@56@07 r) V@39@07))
      (<= 0 (inv@56@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@56@07 r)))) (inv@57@07 r))
      r))
  :pattern ((inv@56@07 r))
  :pattern ((inv@57@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@54@07 Int) (j1@55@07 Int)) (!
  (implies
    (and
      (and (and (< j1@55@07 V@39@07) (<= 0 j1@55@07)) (< i1@54@07 V@39@07))
      (<= 0 i1@54@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))) j1@55@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@54@07))) j1@55@07))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@58@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
        (< (inv@56@07 r) V@39@07))
      (<= 0 (inv@56@07 r)))
    (=
      ($FVF.lookup_int (as sm@58@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@58@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@58@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef9|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
        (< (inv@56@07 r) V@39@07))
      (<= 0 (inv@56@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@58@07  $FVF<Int>) r) r))
  :pattern ((inv@56@07 r) (inv@57@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))))))
(declare-const i1@59@07 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 38 | 0 <= i1@59@07 | live]
; [else-branch: 38 | !(0 <= i1@59@07) | live]
(push) ; 4
; [then-branch: 38 | 0 <= i1@59@07]
(assert (<= 0 i1@59@07))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 38 | !(0 <= i1@59@07)]
(assert (not (<= 0 i1@59@07)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@59@07 V@39@07) (<= 0 i1@59@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@59@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               558
;  :arith-add-rows          209
;  :arith-assert-diseq      11
;  :arith-assert-lower      128
;  :arith-assert-upper      72
;  :arith-bound-prop        35
;  :arith-conflicts         12
;  :arith-eq-adapter        61
;  :arith-fixed-eqs         44
;  :arith-offset-eqs        28
;  :arith-pivots            144
;  :conflicts               33
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               24
;  :del-clause              387
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.83
;  :mk-bool-var             1408
;  :mk-clause               389
;  :num-allocs              182459
;  :num-checks              55
;  :propagations            187
;  :quant-instantiations    364
;  :rlimit-count            233582)
(assert (< i1@59@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 3
; Joined path conditions
(assert (< i1@59@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 2
(declare-fun inv@60@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@59@07 Int)) (!
  (< i1@59@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@59@07))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@59@07 Int) (i12@59@07 Int)) (!
  (implies
    (and
      (and (< i11@59@07 V@39@07) (<= 0 i11@59@07))
      (and (< i12@59@07 V@39@07) (<= 0 i12@59@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@59@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@59@07)))
    (= i11@59@07 i12@59@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               578
;  :arith-add-rows          242
;  :arith-assert-diseq      13
;  :arith-assert-lower      134
;  :arith-assert-upper      74
;  :arith-bound-prop        38
;  :arith-conflicts         12
;  :arith-eq-adapter        62
;  :arith-fixed-eqs         44
;  :arith-offset-eqs        30
;  :arith-pivots            153
;  :conflicts               35
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               25
;  :del-clause              404
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.83
;  :mk-bool-var             1432
;  :mk-clause               406
;  :num-allocs              182990
;  :num-checks              56
;  :propagations            203
;  :quant-instantiations    374
;  :rlimit-count            235109)
; Definitional axioms for inverse functions
(assert (forall ((i1@59@07 Int)) (!
  (implies
    (and (< i1@59@07 V@39@07) (<= 0 i1@59@07))
    (=
      (inv@60@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@59@07))
      i1@59@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@59@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@60@07 r))
      r))
  :pattern ((inv@60@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@59@07 Int)) (!
  (implies
    (and (< i1@59@07 V@39@07) (<= 0 i1@59@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@59@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@59@07))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@61@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
    (=
      ($FVF.lookup_int (as sm@61@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@61@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef10|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
        (< (inv@56@07 r) V@39@07))
      (<= 0 (inv@56@07 r)))
    (=
      ($FVF.lookup_int (as sm@61@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@61@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@61@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef12|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@61@07  $FVF<Int>) r) r))
  :pattern ((inv@60@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, p, V)
(push) ; 2
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(declare-const i1@62@07 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 39 | 0 <= i1@62@07 | live]
; [else-branch: 39 | !(0 <= i1@62@07) | live]
(push) ; 5
; [then-branch: 39 | 0 <= i1@62@07]
(assert (<= 0 i1@62@07))
; [eval] i1 < V
(pop) ; 5
(push) ; 5
; [else-branch: 39 | !(0 <= i1@62@07)]
(assert (not (<= 0 i1@62@07)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
; Joined path conditions
(assert (and (< i1@62@07 V@39@07) (<= 0 i1@62@07)))
(declare-const $k@63@07 $Perm)
(assert ($Perm.isReadVar $k@63@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 5
(assert (not (< i1@62@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               579
;  :arith-add-rows          242
;  :arith-assert-diseq      14
;  :arith-assert-lower      138
;  :arith-assert-upper      75
;  :arith-bound-prop        38
;  :arith-conflicts         12
;  :arith-eq-adapter        63
;  :arith-fixed-eqs         44
;  :arith-offset-eqs        30
;  :arith-pivots            153
;  :conflicts               35
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               25
;  :del-clause              404
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.85
;  :mk-bool-var             1446
;  :mk-clause               408
;  :num-allocs              184225
;  :num-checks              57
;  :propagations            204
;  :quant-instantiations    374
;  :rlimit-count            238372)
(assert (< i1@62@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 4
; Joined path conditions
(assert (< i1@62@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 3
(declare-fun inv@64@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@63@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@62@07 Int)) (!
  (< i1@62@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@62@07))
  :qid |int-aux|)))
(push) ; 3
(assert (not (forall ((i1@62@07 Int)) (!
  (implies
    (and (< i1@62@07 V@39@07) (<= 0 i1@62@07))
    (or (= $k@63@07 $Perm.No) (< $Perm.No $k@63@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               579
;  :arith-add-rows          242
;  :arith-assert-diseq      15
;  :arith-assert-lower      140
;  :arith-assert-upper      76
;  :arith-bound-prop        38
;  :arith-conflicts         12
;  :arith-eq-adapter        64
;  :arith-fixed-eqs         44
;  :arith-offset-eqs        30
;  :arith-pivots            153
;  :conflicts               36
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               25
;  :del-clause              406
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.85
;  :mk-bool-var             1453
;  :mk-clause               410
;  :num-allocs              184655
;  :num-checks              58
;  :propagations            205
;  :quant-instantiations    374
;  :rlimit-count            238918)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 3
(assert (not (forall ((i11@62@07 Int) (i12@62@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@62@07 V@39@07) (<= 0 i11@62@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@61@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@62@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@62@07)))
        (< $Perm.No $k@63@07))
      (and
        (and
          (and (< i12@62@07 V@39@07) (<= 0 i12@62@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@61@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@62@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@62@07)))
        (< $Perm.No $k@63@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@62@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@62@07)))
    (= i11@62@07 i12@62@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               588
;  :arith-add-rows          246
;  :arith-assert-diseq      16
;  :arith-assert-lower      144
;  :arith-assert-upper      76
;  :arith-bound-prop        38
;  :arith-conflicts         12
;  :arith-eq-adapter        65
;  :arith-fixed-eqs         44
;  :arith-offset-eqs        30
;  :arith-pivots            155
;  :conflicts               37
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   21
;  :datatype-splits         15
;  :decisions               25
;  :del-clause              417
;  :final-checks            17
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.85
;  :mk-bool-var             1484
;  :mk-clause               421
;  :num-allocs              185090
;  :num-checks              59
;  :propagations            207
;  :quant-instantiations    388
;  :rlimit-count            239913)
; Definitional axioms for inverse functions
(assert (forall ((i1@62@07 Int)) (!
  (implies
    (and (and (< i1@62@07 V@39@07) (<= 0 i1@62@07)) (< $Perm.No $k@63@07))
    (=
      (inv@64@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@62@07))
      i1@62@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@62@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
      (< $Perm.No $k@63@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@64@07 r))
      r))
  :pattern ((inv@64@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@61@07  $FVF<Int>) r) r))
  :pattern ((inv@64@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@65@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
        $Perm.Write
        $Perm.No)
      $k@63@07)
    $Perm.No))
(define-fun pTaken@66@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
            (< (inv@56@07 r) V@39@07))
          (<= 0 (inv@56@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@63@07 (pTaken@65@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@63@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
      (<
        (ite
          (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
          $k@63@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
          $k@63@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@60@07 r))
  :pattern ((inv@64@07 r))
  :qid |qp.srp13|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 3
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
    (= (- $k@63@07 (pTaken@65@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               655
;  :arith-add-rows          264
;  :arith-assert-diseq      22
;  :arith-assert-lower      154
;  :arith-assert-upper      86
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        79
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            169
;  :conflicts               45
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   24
;  :datatype-splits         18
;  :decisions               35
;  :del-clause              476
;  :final-checks            19
;  :max-generation          3
;  :max-memory              4.93
;  :memory                  4.89
;  :minimized-lits          1
;  :mk-bool-var             1570
;  :mk-clause               478
;  :num-allocs              187118
;  :num-checks              61
;  :propagations            237
;  :quant-instantiations    407
;  :rlimit-count            243599
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@67@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@67@07  $FVF<Int>)))
    (and
      (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
      (< $Perm.No $k@63@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@67@07  $FVF<Int>))))
  :qid |qp.fvfDomDef17|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
        (< $Perm.No $k@63@07))
      (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r))))
    (=
      ($FVF.lookup_int (as sm@67@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@67@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
        (< $Perm.No $k@63@07))
      (and
        (and
          (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
          (< (inv@56@07 r) V@39@07))
        (<= 0 (inv@56@07 r))))
    (=
      ($FVF.lookup_int (as sm@67@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@67@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@67@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef16|)))
(pop) ; 2
; Joined path conditions
(assert ($Perm.isReadVar $k@63@07 $Perm.Write))
(assert (forall ((i1@62@07 Int)) (!
  (implies
    (and (and (< i1@62@07 V@39@07) (<= 0 i1@62@07)) (< $Perm.No $k@63@07))
    (=
      (inv@64@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@62@07))
      i1@62@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@62@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
      (< $Perm.No $k@63@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@64@07 r))
      r))
  :pattern ((inv@64@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@67@07  $FVF<Int>)))
    (and
      (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
      (< $Perm.No $k@63@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@67@07  $FVF<Int>))))
  :qid |qp.fvfDomDef17|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
        (< $Perm.No $k@63@07))
      (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r))))
    (=
      ($FVF.lookup_int (as sm@67@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@67@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
        (< $Perm.No $k@63@07))
      (and
        (and
          (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
          (< (inv@56@07 r) V@39@07))
        (<= 0 (inv@56@07 r))))
    (=
      ($FVF.lookup_int (as sm@67@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@67@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef15|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@67@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef16|)))
(assert (and
  (forall ((i1@62@07 Int)) (!
    (< i1@62@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@62@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@61@07  $FVF<Int>) r) r))
    :pattern ((inv@64@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
        (<
          (ite
            (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
            $k@63@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@64@07 r) V@39@07) (<= 0 (inv@64@07 r)))
            $k@63@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@60@07 r))
    :pattern ((inv@64@07 r))
    :qid |qp.srp13|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@67@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@68@07 $Snap)
(assert (= $t@68@07 ($Snap.combine ($Snap.first $t@68@07) ($Snap.second $t@68@07))))
(assert (= ($Snap.first $t@68@07) $Snap.unit))
; [eval] exc == null
(assert (= exc@43@07 $Ref.null))
(assert (=
  ($Snap.second $t@68@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@68@07))
    ($Snap.second ($Snap.second $t@68@07)))))
(assert (= ($Snap.first ($Snap.second $t@68@07)) $Snap.unit))
; [eval] exc == null ==> Gf != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               707
;  :arith-add-rows          266
;  :arith-assert-diseq      24
;  :arith-assert-lower      158
;  :arith-assert-upper      88
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        81
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            169
;  :conflicts               45
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   34
;  :datatype-splits         23
;  :decisions               44
;  :del-clause              507
;  :final-checks            23
;  :max-generation          3
;  :max-memory              4.98
;  :memory                  4.96
;  :minimized-lits          1
;  :mk-bool-var             1622
;  :mk-clause               515
;  :num-allocs              190383
;  :num-checks              63
;  :propagations            253
;  :quant-instantiations    411
;  :rlimit-count            250058)
; [then-branch: 40 | exc@43@07 == Null | live]
; [else-branch: 40 | exc@43@07 != Null | dead]
(push) ; 4
; [then-branch: 40 | exc@43@07 == Null]
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@43@07 $Ref.null)
  (not (= Gf@38@07 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@68@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@68@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@68@07))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(Gf)) == V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               732
;  :arith-add-rows          266
;  :arith-assert-diseq      24
;  :arith-assert-lower      158
;  :arith-assert-upper      88
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        81
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            169
;  :conflicts               45
;  :datatype-accessor-ax    33
;  :datatype-constructor-ax 35
;  :datatype-occurs-check   37
;  :datatype-splits         24
;  :decisions               49
;  :del-clause              507
;  :final-checks            25
;  :max-generation          3
;  :max-memory              4.98
;  :memory                  4.96
;  :minimized-lits          1
;  :mk-bool-var             1625
;  :mk-clause               515
;  :num-allocs              191083
;  :num-checks              64
;  :propagations            253
;  :quant-instantiations    411
;  :rlimit-count            250828)
; [then-branch: 41 | exc@43@07 == Null | live]
; [else-branch: 41 | exc@43@07 != Null | dead]
(push) ; 4
; [then-branch: 41 | exc@43@07 == Null]
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@43@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit Gf@38@07)) V@39@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@68@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@68@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               759
;  :arith-add-rows          266
;  :arith-assert-diseq      24
;  :arith-assert-lower      158
;  :arith-assert-upper      88
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        81
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            169
;  :conflicts               45
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 41
;  :datatype-occurs-check   40
;  :datatype-splits         26
;  :decisions               55
;  :del-clause              507
;  :final-checks            27
;  :max-generation          3
;  :max-memory              4.98
;  :memory                  4.96
;  :minimized-lits          1
;  :mk-bool-var             1628
;  :mk-clause               515
;  :num-allocs              191784
;  :num-checks              65
;  :propagations            253
;  :quant-instantiations    411
;  :rlimit-count            251590)
; [then-branch: 42 | exc@43@07 == Null | live]
; [else-branch: 42 | exc@43@07 != Null | dead]
(push) ; 3
; [then-branch: 42 | exc@43@07 == Null]
(declare-const i1@69@07 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 43 | 0 <= i1@69@07 | live]
; [else-branch: 43 | !(0 <= i1@69@07) | live]
(push) ; 6
; [then-branch: 43 | 0 <= i1@69@07]
(assert (<= 0 i1@69@07))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 43 | !(0 <= i1@69@07)]
(assert (not (<= 0 i1@69@07)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@69@07 V@39@07) (<= 0 i1@69@07)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@69@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               759
;  :arith-add-rows          266
;  :arith-assert-diseq      24
;  :arith-assert-lower      160
;  :arith-assert-upper      88
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        81
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            169
;  :conflicts               45
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 41
;  :datatype-occurs-check   40
;  :datatype-splits         26
;  :decisions               55
;  :del-clause              507
;  :final-checks            27
;  :max-generation          3
;  :max-memory              4.98
;  :memory                  4.96
;  :minimized-lits          1
;  :mk-bool-var             1630
;  :mk-clause               515
;  :num-allocs              191887
;  :num-checks              66
;  :propagations            253
;  :quant-instantiations    411
;  :rlimit-count            251775)
(assert (< i1@69@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 5
; Joined path conditions
(assert (< i1@69@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(declare-const $k@70@07 $Perm)
(assert ($Perm.isReadVar $k@70@07 $Perm.Write))
(pop) ; 4
(declare-fun inv@71@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@70@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@69@07 Int)) (!
  (< i1@69@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@69@07))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@69@07 Int)) (!
  (implies
    (and (< i1@69@07 V@39@07) (<= 0 i1@69@07))
    (or (= $k@70@07 $Perm.No) (< $Perm.No $k@70@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               759
;  :arith-add-rows          266
;  :arith-assert-diseq      25
;  :arith-assert-lower      162
;  :arith-assert-upper      89
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        82
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            169
;  :conflicts               46
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 41
;  :datatype-occurs-check   40
;  :datatype-splits         26
;  :decisions               55
;  :del-clause              507
;  :final-checks            27
;  :max-generation          3
;  :max-memory              4.98
;  :memory                  4.96
;  :minimized-lits          1
;  :mk-bool-var             1637
;  :mk-clause               517
;  :num-allocs              192356
;  :num-checks              67
;  :propagations            254
;  :quant-instantiations    411
;  :rlimit-count            252346)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@69@07 Int) (i12@69@07 Int)) (!
  (implies
    (and
      (and (and (< i11@69@07 V@39@07) (<= 0 i11@69@07)) (< $Perm.No $k@70@07))
      (and (and (< i12@69@07 V@39@07) (<= 0 i12@69@07)) (< $Perm.No $k@70@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@69@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@69@07)))
    (= i11@69@07 i12@69@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               765
;  :arith-add-rows          270
;  :arith-assert-diseq      26
;  :arith-assert-lower      166
;  :arith-assert-upper      89
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        83
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            171
;  :conflicts               47
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 41
;  :datatype-occurs-check   40
;  :datatype-splits         26
;  :decisions               55
;  :del-clause              513
;  :final-checks            27
;  :max-generation          3
;  :max-memory              4.98
;  :memory                  4.96
;  :minimized-lits          1
;  :mk-bool-var             1654
;  :mk-clause               523
;  :num-allocs              192717
;  :num-checks              68
;  :propagations            254
;  :quant-instantiations    422
;  :rlimit-count            253068)
; Definitional axioms for inverse functions
(assert (forall ((i1@69@07 Int)) (!
  (implies
    (and (and (< i1@69@07 V@39@07) (<= 0 i1@69@07)) (< $Perm.No $k@70@07))
    (=
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@69@07))
      i1@69@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@69@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@71@07 r) V@39@07) (<= 0 (inv@71@07 r)))
      (< $Perm.No $k@70@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@71@07 r))
      r))
  :pattern ((inv@71@07 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@69@07 Int)) (!
  (<= $Perm.No $k@70@07)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@69@07))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@69@07 Int)) (!
  (<= $k@70@07 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@69@07))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@69@07 Int)) (!
  (implies
    (and (and (< i1@69@07 V@39@07) (<= 0 i1@69@07)) (< $Perm.No $k@70@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@69@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@69@07))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@72@07 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@71@07 r) V@39@07) (<= 0 (inv@71@07 r)))
      (< $Perm.No $k@70@07)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@68@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@68@07))))) r))
  :qid |qp.fvfValDef18|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@68@07))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef19|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@71@07 r) V@39@07) (<= 0 (inv@71@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) r) r))
  :pattern ((inv@71@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               795
;  :arith-add-rows          270
;  :arith-assert-diseq      26
;  :arith-assert-lower      166
;  :arith-assert-upper      90
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        83
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            171
;  :conflicts               47
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 47
;  :datatype-occurs-check   43
;  :datatype-splits         28
;  :decisions               61
;  :del-clause              513
;  :final-checks            29
;  :max-generation          3
;  :max-memory              4.98
;  :memory                  4.96
;  :minimized-lits          1
;  :mk-bool-var             1665
;  :mk-clause               523
;  :num-allocs              194417
;  :num-checks              69
;  :propagations            254
;  :quant-instantiations    422
;  :rlimit-count            255855)
; [then-branch: 44 | exc@43@07 == Null | live]
; [else-branch: 44 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 44 | exc@43@07 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@73@07 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 45 | 0 <= i1@73@07 | live]
; [else-branch: 45 | !(0 <= i1@73@07) | live]
(push) ; 8
; [then-branch: 45 | 0 <= i1@73@07]
(assert (<= 0 i1@73@07))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 45 | !(0 <= i1@73@07)]
(assert (not (<= 0 i1@73@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 46 | i1@73@07 < V@39@07 && 0 <= i1@73@07 | live]
; [else-branch: 46 | !(i1@73@07 < V@39@07 && 0 <= i1@73@07) | live]
(push) ; 8
; [then-branch: 46 | i1@73@07 < V@39@07 && 0 <= i1@73@07]
(assert (and (< i1@73@07 V@39@07) (<= 0 i1@73@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@73@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               795
;  :arith-add-rows          270
;  :arith-assert-diseq      26
;  :arith-assert-lower      168
;  :arith-assert-upper      90
;  :arith-bound-prop        40
;  :arith-conflicts         15
;  :arith-eq-adapter        83
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        34
;  :arith-pivots            171
;  :conflicts               47
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 47
;  :datatype-occurs-check   43
;  :datatype-splits         28
;  :decisions               61
;  :del-clause              513
;  :final-checks            29
;  :max-generation          3
;  :max-memory              4.98
;  :memory                  4.96
;  :minimized-lits          1
;  :mk-bool-var             1667
;  :mk-clause               523
;  :num-allocs              194520
;  :num-checks              70
;  :propagations            254
;  :quant-instantiations    422
;  :rlimit-count            256050)
(assert (< i1@73@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@73@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07))
      V@39@07)
    (<=
      0
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07))))
  (< $Perm.No $k@70@07)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               804
;  :arith-add-rows          278
;  :arith-assert-diseq      26
;  :arith-assert-lower      170
;  :arith-assert-upper      93
;  :arith-bound-prop        42
;  :arith-conflicts         16
;  :arith-eq-adapter        85
;  :arith-fixed-eqs         49
;  :arith-offset-eqs        34
;  :arith-pivots            174
;  :conflicts               48
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 47
;  :datatype-occurs-check   43
;  :datatype-splits         28
;  :decisions               61
;  :del-clause              513
;  :final-checks            29
;  :max-generation          3
;  :max-memory              4.99
;  :memory                  4.97
;  :minimized-lits          1
;  :mk-bool-var             1715
;  :mk-clause               543
;  :num-allocs              194971
;  :num-checks              71
;  :propagations            255
;  :quant-instantiations    445
;  :rlimit-count            257425)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 46 | !(i1@73@07 < V@39@07 && 0 <= i1@73@07)]
(assert (not (and (< i1@73@07 V@39@07) (<= 0 i1@73@07))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@73@07 V@39@07) (<= 0 i1@73@07))
  (and
    (< i1@73@07 V@39@07)
    (<= 0 i1@73@07)
    (< i1@73@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@73@07 Int)) (!
  (implies
    (and (< i1@73@07 V@39@07) (<= 0 i1@73@07))
    (and
      (< i1@73@07 V@39@07)
      (<= 0 i1@73@07)
      (< i1@73@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@43@07 $Ref.null)
  (forall ((i1@73@07 Int)) (!
    (implies
      (and (< i1@73@07 V@39@07) (<= 0 i1@73@07))
      (and
        (< i1@73@07 V@39@07)
        (<= 0 i1@73@07)
        (< i1@73@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@43@07 $Ref.null)
  (forall ((i1@73@07 Int)) (!
    (implies
      (and (< i1@73@07 V@39@07) (<= 0 i1@73@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@73@07))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               835
;  :arith-add-rows          281
;  :arith-assert-diseq      26
;  :arith-assert-lower      170
;  :arith-assert-upper      93
;  :arith-bound-prop        42
;  :arith-conflicts         16
;  :arith-eq-adapter        85
;  :arith-fixed-eqs         49
;  :arith-offset-eqs        34
;  :arith-pivots            177
;  :conflicts               48
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 53
;  :datatype-occurs-check   46
;  :datatype-splits         30
;  :decisions               67
;  :del-clause              533
;  :final-checks            31
;  :max-generation          3
;  :max-memory              4.99
;  :memory                  4.97
;  :minimized-lits          1
;  :mk-bool-var             1721
;  :mk-clause               543
;  :num-allocs              196064
;  :num-checks              72
;  :propagations            255
;  :quant-instantiations    445
;  :rlimit-count            259081)
; [then-branch: 47 | exc@43@07 == Null | live]
; [else-branch: 47 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 47 | exc@43@07 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@74@07 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 48 | 0 <= i1@74@07 | live]
; [else-branch: 48 | !(0 <= i1@74@07) | live]
(push) ; 8
; [then-branch: 48 | 0 <= i1@74@07]
(assert (<= 0 i1@74@07))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 48 | !(0 <= i1@74@07)]
(assert (not (<= 0 i1@74@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 49 | i1@74@07 < V@39@07 && 0 <= i1@74@07 | live]
; [else-branch: 49 | !(i1@74@07 < V@39@07 && 0 <= i1@74@07) | live]
(push) ; 8
; [then-branch: 49 | i1@74@07 < V@39@07 && 0 <= i1@74@07]
(assert (and (< i1@74@07 V@39@07) (<= 0 i1@74@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@74@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               835
;  :arith-add-rows          281
;  :arith-assert-diseq      26
;  :arith-assert-lower      172
;  :arith-assert-upper      93
;  :arith-bound-prop        42
;  :arith-conflicts         16
;  :arith-eq-adapter        85
;  :arith-fixed-eqs         49
;  :arith-offset-eqs        34
;  :arith-pivots            178
;  :conflicts               48
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 53
;  :datatype-occurs-check   46
;  :datatype-splits         30
;  :decisions               67
;  :del-clause              533
;  :final-checks            31
;  :max-generation          3
;  :max-memory              4.99
;  :memory                  4.98
;  :minimized-lits          1
;  :mk-bool-var             1723
;  :mk-clause               543
;  :num-allocs              196167
;  :num-checks              73
;  :propagations            255
;  :quant-instantiations    445
;  :rlimit-count            259280)
(assert (< i1@74@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@74@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
      V@39@07)
    (<=
      0
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))))
  (< $Perm.No $k@70@07)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               853
;  :arith-add-rows          292
;  :arith-assert-diseq      26
;  :arith-assert-lower      174
;  :arith-assert-upper      96
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        87
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        39
;  :arith-pivots            181
;  :conflicts               49
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 53
;  :datatype-occurs-check   46
;  :datatype-splits         30
;  :decisions               67
;  :del-clause              533
;  :final-checks            31
;  :max-generation          3
;  :max-memory              5.00
;  :memory                  4.99
;  :minimized-lits          1
;  :mk-bool-var             1774
;  :mk-clause               563
;  :num-allocs              196606
;  :num-checks              74
;  :propagations            259
;  :quant-instantiations    470
;  :rlimit-count            260702)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               853
;  :arith-add-rows          292
;  :arith-assert-diseq      26
;  :arith-assert-lower      174
;  :arith-assert-upper      96
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        87
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        39
;  :arith-pivots            181
;  :conflicts               50
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 53
;  :datatype-occurs-check   46
;  :datatype-splits         30
;  :decisions               67
;  :del-clause              533
;  :final-checks            31
;  :max-generation          3
;  :max-memory              5.00
;  :memory                  4.99
;  :minimized-lits          1
;  :mk-bool-var             1774
;  :mk-clause               563
;  :num-allocs              196695
;  :num-checks              75
;  :propagations            259
;  :quant-instantiations    470
;  :rlimit-count            260797)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 49 | !(i1@74@07 < V@39@07 && 0 <= i1@74@07)]
(assert (not (and (< i1@74@07 V@39@07) (<= 0 i1@74@07))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@74@07 V@39@07) (<= 0 i1@74@07))
  (and
    (< i1@74@07 V@39@07)
    (<= 0 i1@74@07)
    (< i1@74@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@74@07 Int)) (!
  (implies
    (and (< i1@74@07 V@39@07) (<= 0 i1@74@07))
    (and
      (< i1@74@07 V@39@07)
      (<= 0 i1@74@07)
      (< i1@74@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@43@07 $Ref.null)
  (forall ((i1@74@07 Int)) (!
    (implies
      (and (< i1@74@07 V@39@07) (<= 0 i1@74@07))
      (and
        (< i1@74@07 V@39@07)
        (<= 0 i1@74@07)
        (< i1@74@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@43@07 $Ref.null)
  (forall ((i1@74@07 Int)) (!
    (implies
      (and (< i1@74@07 V@39@07) (<= 0 i1@74@07))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07))))
        V@39@07))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@74@07)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               885
;  :arith-add-rows          295
;  :arith-assert-diseq      26
;  :arith-assert-lower      174
;  :arith-assert-upper      96
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        87
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        39
;  :arith-pivots            184
;  :conflicts               50
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               73
;  :del-clause              553
;  :final-checks            33
;  :max-generation          3
;  :max-memory              5.00
;  :memory                  4.99
;  :minimized-lits          1
;  :mk-bool-var             1780
;  :mk-clause               563
;  :num-allocs              197804
;  :num-checks              76
;  :propagations            259
;  :quant-instantiations    470
;  :rlimit-count            262553)
; [then-branch: 50 | exc@43@07 == Null | live]
; [else-branch: 50 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 50 | exc@43@07 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@75@07 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@76@07 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 51 | 0 <= i1@75@07 | live]
; [else-branch: 51 | !(0 <= i1@75@07) | live]
(push) ; 9
; [then-branch: 51 | 0 <= i1@75@07]
(assert (<= 0 i1@75@07))
; [eval] i1 < V
(push) ; 10
; [then-branch: 52 | i1@75@07 < V@39@07 | live]
; [else-branch: 52 | !(i1@75@07 < V@39@07) | live]
(push) ; 11
; [then-branch: 52 | i1@75@07 < V@39@07]
(assert (< i1@75@07 V@39@07))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 53 | 0 <= i2@76@07 | live]
; [else-branch: 53 | !(0 <= i2@76@07) | live]
(push) ; 13
; [then-branch: 53 | 0 <= i2@76@07]
(assert (<= 0 i2@76@07))
; [eval] i2 < V
(push) ; 14
; [then-branch: 54 | i2@76@07 < V@39@07 | live]
; [else-branch: 54 | !(i2@76@07 < V@39@07) | live]
(push) ; 15
; [then-branch: 54 | i2@76@07 < V@39@07]
(assert (< i2@76@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               885
;  :arith-add-rows          295
;  :arith-assert-diseq      26
;  :arith-assert-lower      178
;  :arith-assert-upper      96
;  :arith-bound-prop        45
;  :arith-conflicts         17
;  :arith-eq-adapter        87
;  :arith-fixed-eqs         51
;  :arith-offset-eqs        39
;  :arith-pivots            184
;  :conflicts               50
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               73
;  :del-clause              553
;  :final-checks            33
;  :max-generation          3
;  :max-memory              5.00
;  :memory                  4.99
;  :minimized-lits          1
;  :mk-bool-var             1784
;  :mk-clause               563
;  :num-allocs              198084
;  :num-checks              77
;  :propagations            259
;  :quant-instantiations    470
;  :rlimit-count            262892)
(assert (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 16
; Joined path conditions
(assert (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
      V@39@07)
    (<=
      0
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))))
  (< $Perm.No $k@70@07)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               895
;  :arith-add-rows          303
;  :arith-assert-diseq      26
;  :arith-assert-lower      180
;  :arith-assert-upper      99
;  :arith-bound-prop        47
;  :arith-conflicts         18
;  :arith-eq-adapter        89
;  :arith-fixed-eqs         53
;  :arith-offset-eqs        39
;  :arith-pivots            187
;  :conflicts               51
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               73
;  :del-clause              553
;  :final-checks            33
;  :max-generation          3
;  :max-memory              5.01
;  :memory                  5.00
;  :minimized-lits          1
;  :mk-bool-var             1835
;  :mk-clause               583
;  :num-allocs              198522
;  :num-checks              78
;  :propagations            260
;  :quant-instantiations    495
;  :rlimit-count            264292)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               895
;  :arith-add-rows          303
;  :arith-assert-diseq      26
;  :arith-assert-lower      180
;  :arith-assert-upper      99
;  :arith-bound-prop        47
;  :arith-conflicts         18
;  :arith-eq-adapter        89
;  :arith-fixed-eqs         53
;  :arith-offset-eqs        39
;  :arith-pivots            187
;  :conflicts               51
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               73
;  :del-clause              553
;  :final-checks            33
;  :max-generation          3
;  :max-memory              5.01
;  :memory                  5.00
;  :minimized-lits          1
;  :mk-bool-var             1835
;  :mk-clause               583
;  :num-allocs              198548
;  :num-checks              79
;  :propagations            260
;  :quant-instantiations    495
;  :rlimit-count            264322)
(assert (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 16
; Joined path conditions
(assert (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))
      V@39@07)
    (<=
      0
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))))
  (< $Perm.No $k@70@07)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               904
;  :arith-add-rows          313
;  :arith-assert-diseq      26
;  :arith-assert-lower      182
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            190
;  :conflicts               52
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 59
;  :datatype-occurs-check   49
;  :datatype-splits         32
;  :decisions               73
;  :del-clause              553
;  :final-checks            33
;  :max-generation          3
;  :max-memory              5.03
;  :memory                  5.02
;  :minimized-lits          1
;  :mk-bool-var             1893
;  :mk-clause               615
;  :num-allocs              199043
;  :num-checks              80
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            265835)
(pop) ; 15
(push) ; 15
; [else-branch: 54 | !(i2@76@07 < V@39@07)]
(assert (not (< i2@76@07 V@39@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@76@07 V@39@07)
  (and
    (< i2@76@07 V@39@07)
    (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
    (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 53 | !(0 <= i2@76@07)]
(assert (not (<= 0 i2@76@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@76@07)
  (and
    (<= 0 i2@76@07)
    (implies
      (< i2@76@07 V@39@07)
      (and
        (< i2@76@07 V@39@07)
        (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
        (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 52 | !(i1@75@07 < V@39@07)]
(assert (not (< i1@75@07 V@39@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@75@07 V@39@07)
  (and
    (< i1@75@07 V@39@07)
    (implies
      (<= 0 i2@76@07)
      (and
        (<= 0 i2@76@07)
        (implies
          (< i2@76@07 V@39@07)
          (and
            (< i2@76@07 V@39@07)
            (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
            (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 51 | !(0 <= i1@75@07)]
(assert (not (<= 0 i1@75@07)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@75@07)
  (and
    (<= 0 i1@75@07)
    (implies
      (< i1@75@07 V@39@07)
      (and
        (< i1@75@07 V@39@07)
        (implies
          (<= 0 i2@76@07)
          (and
            (<= 0 i2@76@07)
            (implies
              (< i2@76@07 V@39@07)
              (and
                (< i2@76@07 V@39@07)
                (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
                (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 55 | Lookup(option$array$,sm@72@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@75@07)) == Lookup(option$array$,sm@72@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@76@07)) && i2@76@07 < V@39@07 && 0 <= i2@76@07 && i1@75@07 < V@39@07 && 0 <= i1@75@07 | live]
; [else-branch: 55 | !(Lookup(option$array$,sm@72@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@75@07)) == Lookup(option$array$,sm@72@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@76@07)) && i2@76@07 < V@39@07 && 0 <= i2@76@07 && i1@75@07 < V@39@07 && 0 <= i1@75@07) | live]
(push) ; 9
; [then-branch: 55 | Lookup(option$array$,sm@72@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@75@07)) == Lookup(option$array$,sm@72@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@76@07)) && i2@76@07 < V@39@07 && 0 <= i2@76@07 && i1@75@07 < V@39@07 && 0 <= i1@75@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
          ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
        (< i2@76@07 V@39@07))
      (<= 0 i2@76@07))
    (< i1@75@07 V@39@07))
  (<= 0 i1@75@07)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 55 | !(Lookup(option$array$,sm@72@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@75@07)) == Lookup(option$array$,sm@72@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@76@07)) && i2@76@07 < V@39@07 && 0 <= i2@76@07 && i1@75@07 < V@39@07 && 0 <= i1@75@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
            ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
          (< i2@76@07 V@39@07))
        (<= 0 i2@76@07))
      (< i1@75@07 V@39@07))
    (<= 0 i1@75@07))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
            ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
          (< i2@76@07 V@39@07))
        (<= 0 i2@76@07))
      (< i1@75@07 V@39@07))
    (<= 0 i1@75@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
      ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
    (< i2@76@07 V@39@07)
    (<= 0 i2@76@07)
    (< i1@75@07 V@39@07)
    (<= 0 i1@75@07))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@76@07 Int)) (!
  (and
    (implies
      (<= 0 i1@75@07)
      (and
        (<= 0 i1@75@07)
        (implies
          (< i1@75@07 V@39@07)
          (and
            (< i1@75@07 V@39@07)
            (implies
              (<= 0 i2@76@07)
              (and
                (<= 0 i2@76@07)
                (implies
                  (< i2@76@07 V@39@07)
                  (and
                    (< i2@76@07 V@39@07)
                    (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
                    (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
                ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
              (< i2@76@07 V@39@07))
            (<= 0 i2@76@07))
          (< i1@75@07 V@39@07))
        (<= 0 i1@75@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
          ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
        (< i2@76@07 V@39@07)
        (<= 0 i2@76@07)
        (< i1@75@07 V@39@07)
        (<= 0 i1@75@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@75@07 Int)) (!
  (forall ((i2@76@07 Int)) (!
    (and
      (implies
        (<= 0 i1@75@07)
        (and
          (<= 0 i1@75@07)
          (implies
            (< i1@75@07 V@39@07)
            (and
              (< i1@75@07 V@39@07)
              (implies
                (<= 0 i2@76@07)
                (and
                  (<= 0 i2@76@07)
                  (implies
                    (< i2@76@07 V@39@07)
                    (and
                      (< i2@76@07 V@39@07)
                      (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
                      (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
                  ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
                (< i2@76@07 V@39@07))
              (<= 0 i2@76@07))
            (< i1@75@07 V@39@07))
          (<= 0 i1@75@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
            ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
          (< i2@76@07 V@39@07)
          (<= 0 i2@76@07)
          (< i1@75@07 V@39@07)
          (<= 0 i1@75@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@43@07 $Ref.null)
  (forall ((i1@75@07 Int)) (!
    (forall ((i2@76@07 Int)) (!
      (and
        (implies
          (<= 0 i1@75@07)
          (and
            (<= 0 i1@75@07)
            (implies
              (< i1@75@07 V@39@07)
              (and
                (< i1@75@07 V@39@07)
                (implies
                  (<= 0 i2@76@07)
                  (and
                    (<= 0 i2@76@07)
                    (implies
                      (< i2@76@07 V@39@07)
                      (and
                        (< i2@76@07 V@39@07)
                        (< i1@75@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
                        (< i2@76@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
                    ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
                  (< i2@76@07 V@39@07))
                (<= 0 i2@76@07))
              (< i1@75@07 V@39@07))
            (<= 0 i1@75@07))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
              ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
            (< i2@76@07 V@39@07)
            (<= 0 i2@76@07)
            (< i1@75@07 V@39@07)
            (<= 0 i1@75@07))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@43@07 $Ref.null)
  (forall ((i1@75@07 Int)) (!
    (forall ((i2@76@07 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
                  ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07)))
                (< i2@76@07 V@39@07))
              (<= 0 i2@76@07))
            (< i1@75@07 V@39@07))
          (<= 0 i1@75@07))
        (= i1@75@07 i2@76@07))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@76@07))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@75@07))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))
  $Snap.unit))
; [eval] exc == null ==> p != (None(): option[array])
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               937
;  :arith-add-rows          319
;  :arith-assert-diseq      26
;  :arith-assert-lower      182
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            196
;  :conflicts               52
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 65
;  :datatype-occurs-check   52
;  :datatype-splits         34
;  :decisions               79
;  :del-clause              629
;  :final-checks            35
;  :max-generation          3
;  :max-memory              5.04
;  :memory                  5.02
;  :minimized-lits          1
;  :mk-bool-var             1912
;  :mk-clause               639
;  :num-allocs              200714
;  :num-checks              81
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            269133)
; [then-branch: 56 | exc@43@07 == Null | live]
; [else-branch: 56 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 56 | exc@43@07 == Null]
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@43@07 $Ref.null)
  (not (= p@42@07 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(p)) == V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               971
;  :arith-add-rows          319
;  :arith-assert-diseq      26
;  :arith-assert-lower      182
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            196
;  :conflicts               52
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 71
;  :datatype-occurs-check   55
;  :datatype-splits         36
;  :decisions               85
;  :del-clause              629
;  :final-checks            37
;  :max-generation          3
;  :max-memory              5.04
;  :memory                  5.02
;  :minimized-lits          1
;  :mk-bool-var             1916
;  :mk-clause               639
;  :num-allocs              201448
;  :num-checks              82
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            270010)
; [then-branch: 57 | exc@43@07 == Null | live]
; [else-branch: 57 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 57 | exc@43@07 == Null]
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@43@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit p@42@07)) V@39@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1006
;  :arith-add-rows          319
;  :arith-assert-diseq      26
;  :arith-assert-lower      182
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            196
;  :conflicts               52
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   58
;  :datatype-splits         38
;  :decisions               91
;  :del-clause              629
;  :final-checks            39
;  :max-generation          3
;  :max-memory              5.04
;  :memory                  5.03
;  :minimized-lits          1
;  :mk-bool-var             1920
;  :mk-clause               639
;  :num-allocs              202193
;  :num-checks              83
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            270905)
; [then-branch: 58 | exc@43@07 == Null | live]
; [else-branch: 58 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 58 | exc@43@07 == Null]
; [eval] 0 <= s
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@43@07 $Ref.null) (<= 0 s@40@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1042
;  :arith-add-rows          319
;  :arith-assert-diseq      26
;  :arith-assert-lower      182
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            196
;  :conflicts               52
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 83
;  :datatype-occurs-check   61
;  :datatype-splits         40
;  :decisions               97
;  :del-clause              629
;  :final-checks            41
;  :max-generation          3
;  :max-memory              5.04
;  :memory                  5.03
;  :minimized-lits          1
;  :mk-bool-var             1924
;  :mk-clause               639
;  :num-allocs              202936
;  :num-checks              84
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            271815)
; [then-branch: 59 | exc@43@07 == Null | live]
; [else-branch: 59 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 59 | exc@43@07 == Null]
; [eval] s < V
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@43@07 $Ref.null) (< s@40@07 V@39@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1079
;  :arith-add-rows          319
;  :arith-assert-diseq      26
;  :arith-assert-lower      182
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            196
;  :conflicts               52
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 89
;  :datatype-occurs-check   64
;  :datatype-splits         42
;  :decisions               103
;  :del-clause              629
;  :final-checks            43
;  :max-generation          3
;  :max-memory              5.04
;  :memory                  5.03
;  :minimized-lits          1
;  :mk-bool-var             1928
;  :mk-clause               639
;  :num-allocs              203685
;  :num-checks              85
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            272743)
; [then-branch: 60 | exc@43@07 == Null | live]
; [else-branch: 60 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 60 | exc@43@07 == Null]
; [eval] 0 <= t
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@43@07 $Ref.null) (<= 0 t@41@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1117
;  :arith-add-rows          319
;  :arith-assert-diseq      26
;  :arith-assert-lower      182
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            196
;  :conflicts               52
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 95
;  :datatype-occurs-check   67
;  :datatype-splits         44
;  :decisions               109
;  :del-clause              629
;  :final-checks            45
;  :max-generation          3
;  :max-memory              5.05
;  :memory                  5.03
;  :minimized-lits          1
;  :mk-bool-var             1932
;  :mk-clause               639
;  :num-allocs              204437
;  :num-checks              86
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            273679)
; [then-branch: 61 | exc@43@07 == Null | live]
; [else-branch: 61 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 61 | exc@43@07 == Null]
; [eval] t < V
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies (= exc@43@07 $Ref.null) (< t@41@07 V@39@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))))
; [eval] exc == null
(push) ; 4
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1157
;  :arith-add-rows          319
;  :arith-assert-diseq      26
;  :arith-assert-lower      182
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            196
;  :conflicts               52
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   70
;  :datatype-splits         47
;  :decisions               116
;  :del-clause              629
;  :final-checks            47
;  :max-generation          3
;  :max-memory              5.05
;  :memory                  5.03
;  :minimized-lits          1
;  :mk-bool-var             1936
;  :mk-clause               639
;  :num-allocs              205185
;  :num-checks              87
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            274616)
; [then-branch: 62 | exc@43@07 == Null | live]
; [else-branch: 62 | exc@43@07 != Null | dead]
(push) ; 4
; [then-branch: 62 | exc@43@07 == Null]
(declare-const i1@77@07 Int)
(declare-const j1@78@07 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 63 | 0 <= i1@77@07 | live]
; [else-branch: 63 | !(0 <= i1@77@07) | live]
(push) ; 7
; [then-branch: 63 | 0 <= i1@77@07]
(assert (<= 0 i1@77@07))
; [eval] i1 < V
(push) ; 8
; [then-branch: 64 | i1@77@07 < V@39@07 | live]
; [else-branch: 64 | !(i1@77@07 < V@39@07) | live]
(push) ; 9
; [then-branch: 64 | i1@77@07 < V@39@07]
(assert (< i1@77@07 V@39@07))
; [eval] 0 <= j1
(push) ; 10
; [then-branch: 65 | 0 <= j1@78@07 | live]
; [else-branch: 65 | !(0 <= j1@78@07) | live]
(push) ; 11
; [then-branch: 65 | 0 <= j1@78@07]
(assert (<= 0 j1@78@07))
; [eval] j1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 65 | !(0 <= j1@78@07)]
(assert (not (<= 0 j1@78@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 64 | !(i1@77@07 < V@39@07)]
(assert (not (< i1@77@07 V@39@07)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 63 | !(0 <= i1@77@07)]
(assert (not (<= 0 i1@77@07)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@78@07 V@39@07) (<= 0 j1@78@07)) (< i1@77@07 V@39@07))
  (<= 0 i1@77@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@77@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1157
;  :arith-add-rows          319
;  :arith-assert-diseq      26
;  :arith-assert-lower      188
;  :arith-assert-upper      102
;  :arith-bound-prop        49
;  :arith-conflicts         19
;  :arith-eq-adapter        92
;  :arith-fixed-eqs         55
;  :arith-offset-eqs        39
;  :arith-pivots            198
;  :conflicts               52
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   70
;  :datatype-splits         47
;  :decisions               116
;  :del-clause              629
;  :final-checks            47
;  :max-generation          3
;  :max-memory              5.05
;  :memory                  5.03
;  :minimized-lits          1
;  :mk-bool-var             1942
;  :mk-clause               639
;  :num-allocs              205458
;  :num-checks              88
;  :propagations            267
;  :quant-instantiations    520
;  :rlimit-count            275096)
(assert (< i1@77@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 6
; Joined path conditions
(assert (< i1@77@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07)))
(push) ; 6
(assert (not (ite
  (and
    (<
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))
      V@39@07)
    (<=
      0
      (inv@71@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))))
  (< $Perm.No $k@70@07)
  false)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1175
;  :arith-add-rows          330
;  :arith-assert-diseq      26
;  :arith-assert-lower      190
;  :arith-assert-upper      105
;  :arith-bound-prop        52
;  :arith-conflicts         20
;  :arith-eq-adapter        94
;  :arith-fixed-eqs         57
;  :arith-offset-eqs        44
;  :arith-pivots            201
;  :conflicts               53
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   70
;  :datatype-splits         47
;  :decisions               116
;  :del-clause              629
;  :final-checks            47
;  :max-generation          3
;  :max-memory              5.05
;  :memory                  5.04
;  :minimized-lits          1
;  :mk-bool-var             2002
;  :mk-clause               659
;  :num-allocs              205948
;  :num-checks              89
;  :propagations            271
;  :quant-instantiations    548
;  :rlimit-count            276835)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1175
;  :arith-add-rows          330
;  :arith-assert-diseq      26
;  :arith-assert-lower      190
;  :arith-assert-upper      105
;  :arith-bound-prop        52
;  :arith-conflicts         20
;  :arith-eq-adapter        94
;  :arith-fixed-eqs         57
;  :arith-offset-eqs        44
;  :arith-pivots            201
;  :conflicts               54
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   70
;  :datatype-splits         47
;  :decisions               116
;  :del-clause              629
;  :final-checks            47
;  :max-generation          3
;  :max-memory              5.05
;  :memory                  5.04
;  :minimized-lits          1
;  :mk-bool-var             2002
;  :mk-clause               659
;  :num-allocs              206037
;  :num-checks              90
;  :propagations            271
;  :quant-instantiations    548
;  :rlimit-count            276930)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  j1@78@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1181
;  :arith-add-rows          333
;  :arith-assert-diseq      26
;  :arith-assert-lower      193
;  :arith-assert-upper      106
;  :arith-bound-prop        52
;  :arith-conflicts         21
;  :arith-eq-adapter        95
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        44
;  :arith-pivots            203
;  :conflicts               55
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   70
;  :datatype-splits         47
;  :decisions               116
;  :del-clause              633
;  :final-checks            47
;  :max-generation          3
;  :max-memory              5.05
;  :memory                  5.05
;  :minimized-lits          1
;  :mk-bool-var             2013
;  :mk-clause               663
;  :num-allocs              206232
;  :num-checks              91
;  :propagations            273
;  :quant-instantiations    555
;  :rlimit-count            277383)
(assert (<
  j1@78@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))))))
(pop) ; 6
; Joined path conditions
(assert (<
  j1@78@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))))))
(pop) ; 5
(declare-fun inv@79@07 ($Ref) Int)
(declare-fun inv@80@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@77@07 Int) (j1@78@07 Int)) (!
  (and
    (< i1@77@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@78@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))) j1@78@07))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@77@07 Int) (j11@78@07 Int) (i12@77@07 Int) (j12@78@07 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@78@07 V@39@07) (<= 0 j11@78@07)) (< i11@77@07 V@39@07))
        (<= 0 i11@77@07))
      (and
        (and (and (< j12@78@07 V@39@07) (<= 0 j12@78@07)) (< i12@77@07 V@39@07))
        (<= 0 i12@77@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@77@07))) j11@78@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@77@07))) j12@78@07)))
    (and (= i11@77@07 i12@77@07) (= j11@78@07 j12@78@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1228
;  :arith-add-rows          346
;  :arith-assert-diseq      26
;  :arith-assert-lower      205
;  :arith-assert-upper      110
;  :arith-bound-prop        55
;  :arith-conflicts         21
;  :arith-eq-adapter        103
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        47
;  :arith-pivots            213
;  :conflicts               56
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 102
;  :datatype-occurs-check   70
;  :datatype-splits         47
;  :decisions               116
;  :del-clause              724
;  :final-checks            47
;  :max-generation          3
;  :max-memory              5.14
;  :memory                  5.13
;  :minimized-lits          1
;  :mk-bool-var             2200
;  :mk-clause               734
;  :num-allocs              207668
;  :num-checks              92
;  :propagations            302
;  :quant-instantiations    637
;  :rlimit-count            282216
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@77@07 Int) (j1@78@07 Int)) (!
  (implies
    (and
      (and (and (< j1@78@07 V@39@07) (<= 0 j1@78@07)) (< i1@77@07 V@39@07))
      (<= 0 i1@77@07))
    (and
      (=
        (inv@79@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))) j1@78@07))
        i1@77@07)
      (=
        (inv@80@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))) j1@78@07))
        j1@78@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))) j1@78@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@07 r) V@39@07) (<= 0 (inv@80@07 r)))
        (< (inv@79@07 r) V@39@07))
      (<= 0 (inv@79@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@79@07 r)))) (inv@80@07 r))
      r))
  :pattern ((inv@79@07 r))
  :pattern ((inv@80@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@77@07 Int) (j1@78@07 Int)) (!
  (implies
    (and
      (and (and (< j1@78@07 V@39@07) (<= 0 j1@78@07)) (< i1@77@07 V@39@07))
      (<= 0 i1@77@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))) j1@78@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@77@07))) j1@78@07))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@81@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@07 r) V@39@07) (<= 0 (inv@80@07 r)))
        (< (inv@79@07 r) V@39@07))
      (<= 0 (inv@79@07 r)))
    (=
      ($FVF.lookup_int (as sm@81@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@81@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r))
  :qid |qp.fvfValDef20|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@81@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef21|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@07 r) V@39@07) (<= 0 (inv@80@07 r)))
        (< (inv@79@07 r) V@39@07))
      (<= 0 (inv@79@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@81@07  $FVF<Int>) r) r))
  :pattern ((inv@79@07 r) (inv@80@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1272
;  :arith-add-rows          346
;  :arith-assert-diseq      26
;  :arith-assert-lower      205
;  :arith-assert-upper      110
;  :arith-bound-prop        55
;  :arith-conflicts         21
;  :arith-eq-adapter        103
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        47
;  :arith-pivots            213
;  :conflicts               56
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 110
;  :datatype-occurs-check   75
;  :datatype-splits         51
;  :decisions               124
;  :del-clause              724
;  :final-checks            49
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2211
;  :mk-clause               734
;  :num-allocs              209313
;  :num-checks              93
;  :propagations            302
;  :quant-instantiations    637
;  :rlimit-count            285856)
; [then-branch: 66 | exc@43@07 == Null | live]
; [else-branch: 66 | exc@43@07 != Null | dead]
(push) ; 5
; [then-branch: 66 | exc@43@07 == Null]
(declare-const i1@82@07 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 67 | 0 <= i1@82@07 | live]
; [else-branch: 67 | !(0 <= i1@82@07) | live]
(push) ; 8
; [then-branch: 67 | 0 <= i1@82@07]
(assert (<= 0 i1@82@07))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 67 | !(0 <= i1@82@07)]
(assert (not (<= 0 i1@82@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@82@07 V@39@07) (<= 0 i1@82@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@82@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1272
;  :arith-add-rows          346
;  :arith-assert-diseq      26
;  :arith-assert-lower      207
;  :arith-assert-upper      110
;  :arith-bound-prop        55
;  :arith-conflicts         21
;  :arith-eq-adapter        103
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        47
;  :arith-pivots            214
;  :conflicts               56
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 110
;  :datatype-occurs-check   75
;  :datatype-splits         51
;  :decisions               124
;  :del-clause              724
;  :final-checks            49
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2213
;  :mk-clause               734
;  :num-allocs              209416
;  :num-checks              94
;  :propagations            302
;  :quant-instantiations    637
;  :rlimit-count            286045)
(assert (< i1@82@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 7
; Joined path conditions
(assert (< i1@82@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 6
(declare-fun inv@83@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@82@07 Int)) (!
  (< i1@82@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@82@07))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@82@07 Int) (i12@82@07 Int)) (!
  (implies
    (and
      (and (< i11@82@07 V@39@07) (<= 0 i11@82@07))
      (and (< i12@82@07 V@39@07) (<= 0 i12@82@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@82@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@82@07)))
    (= i11@82@07 i12@82@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1283
;  :arith-add-rows          352
;  :arith-assert-diseq      27
;  :arith-assert-lower      211
;  :arith-assert-upper      110
;  :arith-bound-prop        55
;  :arith-conflicts         21
;  :arith-eq-adapter        104
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        47
;  :arith-pivots            219
;  :conflicts               57
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 110
;  :datatype-occurs-check   75
;  :datatype-splits         51
;  :decisions               124
;  :del-clause              730
;  :final-checks            49
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.14
;  :minimized-lits          1
;  :mk-bool-var             2236
;  :mk-clause               740
;  :num-allocs              209958
;  :num-checks              95
;  :propagations            302
;  :quant-instantiations    654
;  :rlimit-count            287063)
; Definitional axioms for inverse functions
(assert (forall ((i1@82@07 Int)) (!
  (implies
    (and (< i1@82@07 V@39@07) (<= 0 i1@82@07))
    (=
      (inv@83@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@82@07))
      i1@82@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@82@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@83@07 r))
      r))
  :pattern ((inv@83@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@82@07 Int)) (!
  (implies
    (and (< i1@82@07 V@39@07) (<= 0 i1@82@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@82@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@82@07))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@84@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
    (=
      ($FVF.lookup_int (as sm@84@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@84@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@07 r) V@39@07) (<= 0 (inv@80@07 r)))
        (< (inv@79@07 r) V@39@07))
      (<= 0 (inv@79@07 r)))
    (=
      ($FVF.lookup_int (as sm@84@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@84@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r))
  :qid |qp.fvfValDef23|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@84@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef24|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@84@07  $FVF<Int>) r) r))
  :pattern ((inv@83@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> valid_graph_vertices(this, p, V)
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@43@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1322
;  :arith-add-rows          352
;  :arith-assert-diseq      27
;  :arith-assert-lower      211
;  :arith-assert-upper      110
;  :arith-bound-prop        55
;  :arith-conflicts         21
;  :arith-eq-adapter        104
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        47
;  :arith-pivots            219
;  :conflicts               57
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 117
;  :datatype-occurs-check   80
;  :datatype-splits         54
;  :decisions               131
;  :del-clause              730
;  :final-checks            51
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.14
;  :minimized-lits          1
;  :mk-bool-var             2247
;  :mk-clause               740
;  :num-allocs              211656
;  :num-checks              96
;  :propagations            302
;  :quant-instantiations    654
;  :rlimit-count            290698)
; [then-branch: 68 | exc@43@07 == Null | live]
; [else-branch: 68 | exc@43@07 != Null | dead]
(push) ; 7
; [then-branch: 68 | exc@43@07 == Null]
; [eval] valid_graph_vertices(this, p, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@85@07 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 69 | 0 <= i1@85@07 | live]
; [else-branch: 69 | !(0 <= i1@85@07) | live]
(push) ; 11
; [then-branch: 69 | 0 <= i1@85@07]
(assert (<= 0 i1@85@07))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 69 | !(0 <= i1@85@07)]
(assert (not (<= 0 i1@85@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@85@07 V@39@07) (<= 0 i1@85@07)))
(declare-const $k@86@07 $Perm)
(assert ($Perm.isReadVar $k@86@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@85@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1322
;  :arith-add-rows          352
;  :arith-assert-diseq      28
;  :arith-assert-lower      215
;  :arith-assert-upper      111
;  :arith-bound-prop        55
;  :arith-conflicts         21
;  :arith-eq-adapter        105
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        47
;  :arith-pivots            220
;  :conflicts               57
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 117
;  :datatype-occurs-check   80
;  :datatype-splits         54
;  :decisions               131
;  :del-clause              730
;  :final-checks            51
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2253
;  :mk-clause               742
;  :num-allocs              211828
;  :num-checks              97
;  :propagations            303
;  :quant-instantiations    654
;  :rlimit-count            291038)
(assert (< i1@85@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 10
; Joined path conditions
(assert (< i1@85@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 9
(declare-fun inv@87@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@86@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@85@07 Int)) (!
  (< i1@85@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@85@07 Int)) (!
  (implies
    (and (< i1@85@07 V@39@07) (<= 0 i1@85@07))
    (or (= $k@86@07 $Perm.No) (< $Perm.No $k@86@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1322
;  :arith-add-rows          352
;  :arith-assert-diseq      29
;  :arith-assert-lower      217
;  :arith-assert-upper      112
;  :arith-bound-prop        55
;  :arith-conflicts         21
;  :arith-eq-adapter        106
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        47
;  :arith-pivots            221
;  :conflicts               58
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 117
;  :datatype-occurs-check   80
;  :datatype-splits         54
;  :decisions               131
;  :del-clause              732
;  :final-checks            51
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2260
;  :mk-clause               744
;  :num-allocs              212260
;  :num-checks              98
;  :propagations            304
;  :quant-instantiations    654
;  :rlimit-count            291586)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@85@07 Int) (i12@85@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@85@07 V@39@07) (<= 0 i11@85@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@84@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@85@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@85@07)))
        (< $Perm.No $k@86@07))
      (and
        (and
          (and (< i12@85@07 V@39@07) (<= 0 i12@85@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@84@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@85@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@85@07)))
        (< $Perm.No $k@86@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@85@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@85@07)))
    (= i11@85@07 i12@85@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1336
;  :arith-add-rows          354
;  :arith-assert-diseq      30
;  :arith-assert-lower      221
;  :arith-assert-upper      112
;  :arith-bound-prop        55
;  :arith-conflicts         21
;  :arith-eq-adapter        107
;  :arith-fixed-eqs         60
;  :arith-offset-eqs        47
;  :arith-pivots            221
;  :conflicts               59
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 117
;  :datatype-occurs-check   80
;  :datatype-splits         54
;  :decisions               131
;  :del-clause              743
;  :final-checks            51
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.14
;  :minimized-lits          1
;  :mk-bool-var             2296
;  :mk-clause               755
;  :num-allocs              212734
;  :num-checks              99
;  :propagations            306
;  :quant-instantiations    678
;  :rlimit-count            292744)
; Definitional axioms for inverse functions
(assert (forall ((i1@85@07 Int)) (!
  (implies
    (and (and (< i1@85@07 V@39@07) (<= 0 i1@85@07)) (< $Perm.No $k@86@07))
    (=
      (inv@87@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
      i1@85@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
      (< $Perm.No $k@86@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@87@07 r))
      r))
  :pattern ((inv@87@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@84@07  $FVF<Int>) r) r))
  :pattern ((inv@87@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@88@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
        $Perm.Write
        $Perm.No)
      $k@86@07)
    $Perm.No))
(define-fun pTaken@89@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@80@07 r) V@39@07) (<= 0 (inv@80@07 r)))
            (< (inv@79@07 r) V@39@07))
          (<= 0 (inv@79@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@86@07 (pTaken@88@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@86@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
      (<
        (ite
          (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
          $k@86@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
          $k@86@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@83@07 r))
  :pattern ((inv@87@07 r))
  :qid |qp.srp25|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
    (= (- $k@86@07 (pTaken@88@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1439
;  :arith-add-rows          372
;  :arith-assert-diseq      34
;  :arith-assert-lower      235
;  :arith-assert-upper      120
;  :arith-bound-prop        61
;  :arith-conflicts         23
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        54
;  :arith-pivots            235
;  :conflicts               68
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 128
;  :datatype-occurs-check   85
;  :datatype-splits         57
;  :decisions               146
;  :del-clause              847
;  :final-checks            53
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2428
;  :mk-clause               857
;  :num-allocs              214994
;  :num-checks              101
;  :propagations            356
;  :quant-instantiations    711
;  :rlimit-count            297194
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@90@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@90@07  $FVF<Int>)))
    (and
      (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
      (< $Perm.No $k@86@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@90@07  $FVF<Int>))))
  :qid |qp.fvfDomDef29|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
        (< $Perm.No $k@86@07))
      (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r))))
    (=
      ($FVF.lookup_int (as sm@90@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
        (< $Perm.No $k@86@07))
      (and
        (and
          (and (< (inv@80@07 r) V@39@07) (<= 0 (inv@80@07 r)))
          (< (inv@79@07 r) V@39@07))
        (<= 0 (inv@79@07 r))))
    (=
      ($FVF.lookup_int (as sm@90@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef28|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@86@07 $Perm.Write))
(assert (forall ((i1@85@07 Int)) (!
  (implies
    (and (and (< i1@85@07 V@39@07) (<= 0 i1@85@07)) (< $Perm.No $k@86@07))
    (=
      (inv@87@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
      i1@85@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
      (< $Perm.No $k@86@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@87@07 r))
      r))
  :pattern ((inv@87@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@90@07  $FVF<Int>)))
    (and
      (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
      (< $Perm.No $k@86@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@90@07  $FVF<Int>))))
  :qid |qp.fvfDomDef29|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
        (< $Perm.No $k@86@07))
      (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r))))
    (=
      ($FVF.lookup_int (as sm@90@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
        (< $Perm.No $k@86@07))
      (and
        (and
          (and (< (inv@80@07 r) V@39@07) (<= 0 (inv@80@07 r)))
          (< (inv@79@07 r) V@39@07))
        (<= 0 (inv@79@07 r))))
    (=
      ($FVF.lookup_int (as sm@90@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef28|)))
(assert (and
  (forall ((i1@85@07 Int)) (!
    (< i1@85@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@84@07  $FVF<Int>) r) r))
    :pattern ((inv@87@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
        (<
          (ite
            (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
            $k@86@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
            $k@86@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@83@07 r))
    :pattern ((inv@87@07 r))
    :qid |qp.srp25|))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert ($Perm.isReadVar $k@86@07 $Perm.Write))
(assert (forall ((i1@85@07 Int)) (!
  (implies
    (and (and (< i1@85@07 V@39@07) (<= 0 i1@85@07)) (< $Perm.No $k@86@07))
    (=
      (inv@87@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
      i1@85@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
      (< $Perm.No $k@86@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@87@07 r))
      r))
  :pattern ((inv@87@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@90@07  $FVF<Int>)))
    (and
      (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
      (< $Perm.No $k@86@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@90@07  $FVF<Int>))))
  :qid |qp.fvfDomDef29|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
        (< $Perm.No $k@86@07))
      (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r))))
    (=
      ($FVF.lookup_int (as sm@90@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
        (< $Perm.No $k@86@07))
      (and
        (and
          (and (< (inv@80@07 r) V@39@07) (<= 0 (inv@80@07 r)))
          (< (inv@79@07 r) V@39@07))
        (<= 0 (inv@79@07 r))))
    (=
      ($FVF.lookup_int (as sm@90@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@68@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@90@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef28|)))
(assert (implies
  (= exc@43@07 $Ref.null)
  (and
    (forall ((i1@85@07 Int)) (!
      (< i1@85@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@85@07))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@84@07  $FVF<Int>) r) r))
      :pattern ((inv@87@07 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@83@07 r) V@39@07) (<= 0 (inv@83@07 r)))
          (<
            (ite
              (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
              $k@86@07
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@87@07 r) V@39@07) (<= 0 (inv@87@07 r)))
              $k@86@07
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@83@07 r))
      :pattern ((inv@87@07 r))
      :qid |qp.srp25|)))))
(assert (implies
  (= exc@43@07 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@90@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07)))
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; var return: Bool
(declare-const return@91@07 Bool)
; [exec]
; var visited: option[array]
(declare-const visited@92@07 option<array>)
; [exec]
; var queue: Seq[Int]
(declare-const queue@93@07 Seq<Int>)
; [exec]
; var u: Int
(declare-const u@94@07 Int)
; [exec]
; var k: Int
(declare-const k@95@07 Int)
; [exec]
; var v: Int
(declare-const v@96@07 Int)
; [exec]
; var res1: option[array]
(declare-const res1@97@07 option<array>)
; [exec]
; var res2: void
(declare-const res2@98@07 void)
; [exec]
; var flatten: Int
(declare-const flatten@99@07 Int)
; [exec]
; var excBeforeLoop: Ref
(declare-const excBeforeLoop@100@07 $Ref)
; [exec]
; var excBeforeLoop1: Ref
(declare-const excBeforeLoop1@101@07 $Ref)
; [exec]
; var evaluationDummy: void
(declare-const evaluationDummy@102@07 void)
; [exec]
; var evaluationDummy1: Seq[Int]
(declare-const evaluationDummy1@103@07 Seq<Int>)
; [exec]
; var evaluationDummy2: Int
(declare-const evaluationDummy2@104@07 Int)
; [exec]
; exc := null
; [exec]
; exc, res1 := make_array2(tid, V)
(declare-const exc@105@07 $Ref)
(declare-const res@106@07 option<array>)
(declare-const $t@107@07 $Snap)
(assert (= $t@107@07 ($Snap.combine ($Snap.first $t@107@07) ($Snap.second $t@107@07))))
(assert (= ($Snap.first $t@107@07) $Snap.unit))
; [eval] exc == null
(assert (= exc@105@07 $Ref.null))
(assert (=
  ($Snap.second $t@107@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@107@07))
    ($Snap.second ($Snap.second $t@107@07)))))
(assert (= ($Snap.first ($Snap.second $t@107@07)) $Snap.unit))
; [eval] exc == null ==> res != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@105@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1470
;  :arith-add-rows          372
;  :arith-assert-diseq      34
;  :arith-assert-lower      235
;  :arith-assert-upper      120
;  :arith-bound-prop        61
;  :arith-conflicts         23
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        54
;  :arith-pivots            235
;  :conflicts               68
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   88
;  :datatype-splits         58
;  :decisions               151
;  :del-clause              849
;  :final-checks            55
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2434
;  :mk-clause               857
;  :num-allocs              216827
;  :num-checks              102
;  :propagations            356
;  :quant-instantiations    711
;  :rlimit-count            299260)
; [then-branch: 70 | exc@105@07 == Null | live]
; [else-branch: 70 | exc@105@07 != Null | dead]
(push) ; 4
; [then-branch: 70 | exc@105@07 == Null]
; [eval] res != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@105@07 $Ref.null)
  (not (= res@106@07 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@107@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@107@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@107@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@107@07))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(res)) == dim0
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@105@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1495
;  :arith-add-rows          372
;  :arith-assert-diseq      34
;  :arith-assert-lower      235
;  :arith-assert-upper      120
;  :arith-bound-prop        61
;  :arith-conflicts         23
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        54
;  :arith-pivots            235
;  :conflicts               68
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 138
;  :datatype-occurs-check   91
;  :datatype-splits         59
;  :decisions               156
;  :del-clause              849
;  :final-checks            57
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2438
;  :mk-clause               857
;  :num-allocs              217542
;  :num-checks              103
;  :propagations            356
;  :quant-instantiations    711
;  :rlimit-count            300081)
; [then-branch: 71 | exc@105@07 == Null | live]
; [else-branch: 71 | exc@105@07 != Null | dead]
(push) ; 4
; [then-branch: 71 | exc@105@07 == Null]
; [eval] alen(opt_get1(res)) == dim0
; [eval] alen(opt_get1(res))
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@106@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1495
;  :arith-add-rows          372
;  :arith-assert-diseq      34
;  :arith-assert-lower      235
;  :arith-assert-upper      120
;  :arith-bound-prop        61
;  :arith-conflicts         23
;  :arith-eq-adapter        124
;  :arith-fixed-eqs         64
;  :arith-offset-eqs        54
;  :arith-pivots            235
;  :conflicts               68
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 138
;  :datatype-occurs-check   91
;  :datatype-splits         59
;  :decisions               156
;  :del-clause              849
;  :final-checks            57
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2438
;  :mk-clause               857
;  :num-allocs              217566
;  :num-checks              104
;  :propagations            356
;  :quant-instantiations    711
;  :rlimit-count            300102)
(assert (not (= res@106@07 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@106@07 (as None<option<array>>  option<array>))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@105@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@106@07)) V@39@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@107@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@107@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@107@07)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= exc@105@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1528
;  :arith-add-rows          372
;  :arith-assert-diseq      34
;  :arith-assert-lower      237
;  :arith-assert-upper      121
;  :arith-bound-prop        61
;  :arith-conflicts         23
;  :arith-eq-adapter        125
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        54
;  :arith-pivots            236
;  :conflicts               68
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 144
;  :datatype-occurs-check   94
;  :datatype-splits         61
;  :decisions               162
;  :del-clause              849
;  :final-checks            59
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2450
;  :mk-clause               857
;  :num-allocs              218342
;  :num-checks              105
;  :propagations            356
;  :quant-instantiations    716
;  :rlimit-count            301032)
; [then-branch: 72 | exc@105@07 == Null | live]
; [else-branch: 72 | exc@105@07 != Null | dead]
(push) ; 3
; [then-branch: 72 | exc@105@07 == Null]
(declare-const i0@108@07 Int)
(push) ; 4
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 5
; [then-branch: 73 | 0 <= i0@108@07 | live]
; [else-branch: 73 | !(0 <= i0@108@07) | live]
(push) ; 6
; [then-branch: 73 | 0 <= i0@108@07]
(assert (<= 0 i0@108@07))
; [eval] i0 < dim0
(pop) ; 6
(push) ; 6
; [else-branch: 73 | !(0 <= i0@108@07)]
(assert (not (<= 0 i0@108@07)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i0@108@07 V@39@07) (<= 0 i0@108@07)))
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@106@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1528
;  :arith-add-rows          372
;  :arith-assert-diseq      34
;  :arith-assert-lower      239
;  :arith-assert-upper      121
;  :arith-bound-prop        61
;  :arith-conflicts         23
;  :arith-eq-adapter        125
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        54
;  :arith-pivots            237
;  :conflicts               68
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 144
;  :datatype-occurs-check   94
;  :datatype-splits         61
;  :decisions               162
;  :del-clause              849
;  :final-checks            59
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2452
;  :mk-clause               857
;  :num-allocs              218441
;  :num-checks              106
;  :propagations            356
;  :quant-instantiations    716
;  :rlimit-count            301207)
(assert (not (= res@106@07 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@106@07 (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i0@108@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1528
;  :arith-add-rows          372
;  :arith-assert-diseq      34
;  :arith-assert-lower      239
;  :arith-assert-upper      121
;  :arith-bound-prop        61
;  :arith-conflicts         23
;  :arith-eq-adapter        125
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        54
;  :arith-pivots            237
;  :conflicts               68
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 144
;  :datatype-occurs-check   94
;  :datatype-splits         61
;  :decisions               162
;  :del-clause              849
;  :final-checks            59
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2452
;  :mk-clause               857
;  :num-allocs              218461
;  :num-checks              107
;  :propagations            356
;  :quant-instantiations    716
;  :rlimit-count            301238)
(assert (< i0@108@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 5
; Joined path conditions
(assert (< i0@108@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(declare-const sm@109@07 $FVF<Bool>)
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(pop) ; 4
(declare-fun inv@110@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@108@07 Int)) (!
  (and
    (not (= res@106@07 (as None<option<array>>  option<array>)))
    (< i0@108@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
  :pattern (($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@107@07))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@108@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@108@07)))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i01@108@07 Int) (i02@108@07 Int)) (!
  (implies
    (and
      (and (< i01@108@07 V@39@07) (<= 0 i01@108@07))
      (and (< i02@108@07 V@39@07) (<= 0 i02@108@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i01@108@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i02@108@07)))
    (= i01@108@07 i02@108@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1537
;  :arith-add-rows          380
;  :arith-assert-diseq      36
;  :arith-assert-lower      244
;  :arith-assert-upper      121
;  :arith-bound-prop        62
;  :arith-conflicts         24
;  :arith-eq-adapter        126
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        54
;  :arith-pivots            242
;  :conflicts               69
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 144
;  :datatype-occurs-check   94
;  :datatype-splits         61
;  :decisions               162
;  :del-clause              863
;  :final-checks            59
;  :max-generation          3
;  :max-memory              5.16
;  :memory                  5.14
;  :minimized-lits          1
;  :mk-bool-var             2475
;  :mk-clause               871
;  :num-allocs              219003
;  :num-checks              108
;  :propagations            361
;  :quant-instantiations    724
;  :rlimit-count            302372)
; Definitional axioms for inverse functions
(assert (forall ((i0@108@07 Int)) (!
  (implies
    (and (< i0@108@07 V@39@07) (<= 0 i0@108@07))
    (=
      (inv@110@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@108@07))
      i0@108@07))
  :pattern (($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@107@07))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@108@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@108@07)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@110@07 r) V@39@07) (<= 0 (inv@110@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@110@07 r))
      r))
  :pattern ((inv@110@07 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@108@07 Int)) (!
  (implies
    (and (< i0@108@07 V@39@07) (<= 0 i0@108@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@108@07)
        $Ref.null)))
  :pattern (($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@107@07))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@108@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@108@07)))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@111@07 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@110@07 r) V@39@07) (<= 0 (inv@110@07 r)))
    (=
      ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@107@07))))) r)))
  :pattern (($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@107@07))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@107@07))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@110@07 r) V@39@07) (<= 0 (inv@110@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) r) r))
  :pattern ((inv@110@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@107@07))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).bool } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).bool == false)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@105@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1558
;  :arith-add-rows          380
;  :arith-assert-diseq      36
;  :arith-assert-lower      244
;  :arith-assert-upper      121
;  :arith-bound-prop        62
;  :arith-conflicts         24
;  :arith-eq-adapter        126
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        54
;  :arith-pivots            242
;  :conflicts               69
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 149
;  :datatype-occurs-check   97
;  :datatype-splits         62
;  :decisions               167
;  :del-clause              863
;  :final-checks            61
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2483
;  :mk-clause               871
;  :num-allocs              220484
;  :num-checks              109
;  :propagations            361
;  :quant-instantiations    724
;  :rlimit-count            304907)
; [then-branch: 74 | exc@105@07 == Null | live]
; [else-branch: 74 | exc@105@07 != Null | dead]
(push) ; 5
; [then-branch: 74 | exc@105@07 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).bool } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).bool == false)
(declare-const i0@112@07 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).bool == false
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 75 | 0 <= i0@112@07 | live]
; [else-branch: 75 | !(0 <= i0@112@07) | live]
(push) ; 8
; [then-branch: 75 | 0 <= i0@112@07]
(assert (<= 0 i0@112@07))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 75 | !(0 <= i0@112@07)]
(assert (not (<= 0 i0@112@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 76 | i0@112@07 < V@39@07 && 0 <= i0@112@07 | live]
; [else-branch: 76 | !(i0@112@07 < V@39@07 && 0 <= i0@112@07) | live]
(push) ; 8
; [then-branch: 76 | i0@112@07 < V@39@07 && 0 <= i0@112@07]
(assert (and (< i0@112@07 V@39@07) (<= 0 i0@112@07)))
; [eval] aloc(opt_get1(res), i0).bool == false
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@106@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1558
;  :arith-add-rows          380
;  :arith-assert-diseq      36
;  :arith-assert-lower      246
;  :arith-assert-upper      121
;  :arith-bound-prop        62
;  :arith-conflicts         24
;  :arith-eq-adapter        126
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        54
;  :arith-pivots            243
;  :conflicts               69
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 149
;  :datatype-occurs-check   97
;  :datatype-splits         62
;  :decisions               167
;  :del-clause              863
;  :final-checks            61
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2485
;  :mk-clause               871
;  :num-allocs              220583
;  :num-checks              110
;  :propagations            361
;  :quant-instantiations    724
;  :rlimit-count            305092)
(assert (not (= res@106@07 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@106@07 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@112@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1558
;  :arith-add-rows          380
;  :arith-assert-diseq      36
;  :arith-assert-lower      246
;  :arith-assert-upper      121
;  :arith-bound-prop        62
;  :arith-conflicts         24
;  :arith-eq-adapter        126
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        54
;  :arith-pivots            243
;  :conflicts               69
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 149
;  :datatype-occurs-check   97
;  :datatype-splits         62
;  :decisions               167
;  :del-clause              863
;  :final-checks            61
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2485
;  :mk-clause               871
;  :num-allocs              220603
;  :num-checks              111
;  :propagations            361
;  :quant-instantiations    724
;  :rlimit-count            305123)
(assert (< i0@112@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 9
; Joined path conditions
(assert (< i0@112@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)))
(push) ; 9
(assert (not (and
  (<
    (inv@110@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07))
    V@39@07)
  (<=
    0
    (inv@110@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1568
;  :arith-add-rows          387
;  :arith-assert-diseq      36
;  :arith-assert-lower      247
;  :arith-assert-upper      123
;  :arith-bound-prop        64
;  :arith-conflicts         25
;  :arith-eq-adapter        127
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        57
;  :arith-pivots            245
;  :conflicts               70
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 149
;  :datatype-occurs-check   97
;  :datatype-splits         62
;  :decisions               167
;  :del-clause              863
;  :final-checks            61
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2504
;  :mk-clause               885
;  :num-allocs              220874
;  :num-checks              112
;  :propagations            366
;  :quant-instantiations    734
;  :rlimit-count            305783)
(pop) ; 8
(push) ; 8
; [else-branch: 76 | !(i0@112@07 < V@39@07 && 0 <= i0@112@07)]
(assert (not (and (< i0@112@07 V@39@07) (<= 0 i0@112@07))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@112@07 V@39@07) (<= 0 i0@112@07))
  (and
    (< i0@112@07 V@39@07)
    (<= 0 i0@112@07)
    (not (= res@106@07 (as None<option<array>>  option<array>)))
    (< i0@112@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@112@07 Int)) (!
  (implies
    (and (< i0@112@07 V@39@07) (<= 0 i0@112@07))
    (and
      (< i0@112@07 V@39@07)
      (<= 0 i0@112@07)
      (not (= res@106@07 (as None<option<array>>  option<array>)))
      (< i0@112@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
      ($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07))))
  :pattern (($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@105@07 $Ref.null)
  (forall ((i0@112@07 Int)) (!
    (implies
      (and (< i0@112@07 V@39@07) (<= 0 i0@112@07))
      (and
        (< i0@112@07 V@39@07)
        (<= 0 i0@112@07)
        (not (= res@106@07 (as None<option<array>>  option<array>)))
        (< i0@112@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07))))
    :pattern (($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@105@07 $Ref.null)
  (forall ((i0@112@07 Int)) (!
    (implies
      (and (< i0@112@07 V@39@07) (<= 0 i0@112@07))
      (=
        ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07))
        false))
    :pattern (($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) i0@112@07)))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 77 | exc@105@07 != Null | dead]
; [else-branch: 77 | exc@105@07 == Null | live]
(push) ; 4
; [else-branch: 77 | exc@105@07 == Null]
(pop) ; 4
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@105@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1608
;  :arith-add-rows          389
;  :arith-assert-diseq      36
;  :arith-assert-lower      247
;  :arith-assert-upper      123
;  :arith-bound-prop        64
;  :arith-conflicts         25
;  :arith-eq-adapter        127
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        57
;  :arith-pivots            247
;  :conflicts               70
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 159
;  :datatype-occurs-check   103
;  :datatype-splits         64
;  :decisions               177
;  :del-clause              877
;  :final-checks            65
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.16
;  :minimized-lits          1
;  :mk-bool-var             2508
;  :mk-clause               885
;  :num-allocs              222519
;  :num-checks              114
;  :propagations            366
;  :quant-instantiations    734
;  :rlimit-count            307732)
; [then-branch: 78 | exc@105@07 == Null | live]
; [else-branch: 78 | exc@105@07 != Null | dead]
(push) ; 4
; [then-branch: 78 | exc@105@07 == Null]
; [exec]
; visited := res1
; [exec]
; exc, res2 := initializeVisited(this, tid, visited, s, V)
; [eval] this != null
; [eval] visited != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 5
(assert (not (not (= res@106@07 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1608
;  :arith-add-rows          389
;  :arith-assert-diseq      36
;  :arith-assert-lower      247
;  :arith-assert-upper      123
;  :arith-bound-prop        64
;  :arith-conflicts         25
;  :arith-eq-adapter        127
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        57
;  :arith-pivots            247
;  :conflicts               70
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 159
;  :datatype-occurs-check   103
;  :datatype-splits         64
;  :decisions               177
;  :del-clause              877
;  :final-checks            65
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.16
;  :minimized-lits          1
;  :mk-bool-var             2508
;  :mk-clause               885
;  :num-allocs              222543
;  :num-checks              115
;  :propagations            366
;  :quant-instantiations    734
;  :rlimit-count            307748)
(assert (not (= res@106@07 (as None<option<array>>  option<array>))))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
(assert (not (= (alen<Int> (opt_get1 $Snap.unit res@106@07)) V@39@07)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1608
;  :arith-add-rows          389
;  :arith-assert-diseq      36
;  :arith-assert-lower      247
;  :arith-assert-upper      123
;  :arith-bound-prop        64
;  :arith-conflicts         25
;  :arith-eq-adapter        127
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        57
;  :arith-pivots            247
;  :conflicts               70
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 159
;  :datatype-occurs-check   103
;  :datatype-splits         64
;  :decisions               177
;  :del-clause              877
;  :final-checks            65
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.16
;  :minimized-lits          1
;  :mk-bool-var             2508
;  :mk-clause               885
;  :num-allocs              222559
;  :num-checks              116
;  :propagations            366
;  :quant-instantiations    734
;  :rlimit-count            307767)
(assert (= (alen<Int> (opt_get1 $Snap.unit res@106@07)) V@39@07))
; [eval] 0 <= s
; [eval] s < V
(declare-const k@113@07 Int)
(push) ; 5
; [eval] 0 <= k && k < V
; [eval] 0 <= k
(push) ; 6
; [then-branch: 79 | 0 <= k@113@07 | live]
; [else-branch: 79 | !(0 <= k@113@07) | live]
(push) ; 7
; [then-branch: 79 | 0 <= k@113@07]
(assert (<= 0 k@113@07))
; [eval] k < V
(pop) ; 7
(push) ; 7
; [else-branch: 79 | !(0 <= k@113@07)]
(assert (not (<= 0 k@113@07)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and (< k@113@07 V@39@07) (<= 0 k@113@07)))
; [eval] aloc(opt_get1(visited), k)
; [eval] opt_get1(visited)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< k@113@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1608
;  :arith-add-rows          389
;  :arith-assert-diseq      36
;  :arith-assert-lower      249
;  :arith-assert-upper      123
;  :arith-bound-prop        64
;  :arith-conflicts         25
;  :arith-eq-adapter        127
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        57
;  :arith-pivots            247
;  :conflicts               70
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 159
;  :datatype-occurs-check   103
;  :datatype-splits         64
;  :decisions               177
;  :del-clause              877
;  :final-checks            65
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.16
;  :minimized-lits          1
;  :mk-bool-var             2510
;  :mk-clause               885
;  :num-allocs              222654
;  :num-checks              117
;  :propagations            366
;  :quant-instantiations    734
;  :rlimit-count            307950)
(assert (< k@113@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 6
; Joined path conditions
(assert (< k@113@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 5
(declare-fun inv@114@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((k@113@07 Int)) (!
  (< k@113@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k@113@07))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((k1@113@07 Int) (k2@113@07 Int)) (!
  (implies
    (and
      (and
        (and (< k1@113@07 V@39@07) (<= 0 k1@113@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) k1@113@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) k1@113@07)))
      (and
        (and (< k2@113@07 V@39@07) (<= 0 k2@113@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) k2@113@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) k2@113@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k1@113@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k2@113@07)))
    (= k1@113@07 k2@113@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1626
;  :arith-add-rows          396
;  :arith-assert-diseq      37
;  :arith-assert-lower      253
;  :arith-assert-upper      123
;  :arith-bound-prop        66
;  :arith-conflicts         25
;  :arith-eq-adapter        129
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        57
;  :arith-pivots            251
;  :conflicts               71
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 159
;  :datatype-occurs-check   103
;  :datatype-splits         64
;  :decisions               177
;  :del-clause              898
;  :final-checks            65
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2550
;  :mk-clause               906
;  :num-allocs              223229
;  :num-checks              118
;  :propagations            374
;  :quant-instantiations    755
;  :rlimit-count            309281)
; Definitional axioms for inverse functions
(assert (forall ((k@113@07 Int)) (!
  (implies
    (and (< k@113@07 V@39@07) (<= 0 k@113@07))
    (=
      (inv@114@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k@113@07))
      k@113@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k@113@07))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@114@07 r) V@39@07) (<= 0 (inv@114@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@114@07 r))
      r))
  :pattern ((inv@114@07 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@114@07 r) V@39@07) (<= 0 (inv@114@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@111@07  $FVF<Bool>) r) r))
  :pattern ((inv@114@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@115@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@114@07 r) V@39@07) (<= 0 (inv@114@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@110@07 r) V@39@07) (<= 0 (inv@110@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@110@07 r) V@39@07) (<= 0 (inv@110@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@115@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1705
;  :arith-add-rows          409
;  :arith-assert-diseq      41
;  :arith-assert-lower      263
;  :arith-assert-upper      128
;  :arith-bound-prop        67
;  :arith-conflicts         26
;  :arith-eq-adapter        143
;  :arith-fixed-eqs         68
;  :arith-offset-eqs        57
;  :arith-pivots            260
;  :conflicts               80
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 168
;  :datatype-occurs-check   106
;  :datatype-splits         65
;  :decisions               191
;  :del-clause              962
;  :final-checks            67
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2632
;  :mk-clause               970
;  :num-allocs              224857
;  :num-checks              120
;  :propagations            404
;  :quant-instantiations    785
;  :rlimit-count            312139
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@114@07 r) V@39@07) (<= 0 (inv@114@07 r)))
    (= (- $Perm.Write (pTaken@115@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1727
;  :arith-add-rows          418
;  :arith-assert-diseq      43
;  :arith-assert-lower      267
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               81
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 168
;  :datatype-occurs-check   106
;  :datatype-splits         65
;  :decisions               191
;  :del-clause              984
;  :final-checks            67
;  :max-generation          3
;  :max-memory              5.17
;  :memory                  5.15
;  :minimized-lits          1
;  :mk-bool-var             2671
;  :mk-clause               992
;  :num-allocs              225233
;  :num-checks              121
;  :propagations            413
;  :quant-instantiations    800
;  :rlimit-count            313240)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@116@07 $Ref)
(declare-const res@117@07 void)
(declare-const $t@118@07 $Snap)
(assert (= $t@118@07 ($Snap.combine ($Snap.first $t@118@07) ($Snap.second $t@118@07))))
(assert (= ($Snap.first $t@118@07) $Snap.unit))
; [eval] exc == null
(assert (= exc@116@07 $Ref.null))
(assert (=
  ($Snap.second $t@118@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@118@07))
    ($Snap.second ($Snap.second $t@118@07)))))
(assert (= ($Snap.first ($Snap.second $t@118@07)) $Snap.unit))
; [eval] exc == null ==> visited != (None(): option[array])
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1764
;  :arith-add-rows          418
;  :arith-assert-diseq      43
;  :arith-assert-lower      267
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               81
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 174
;  :datatype-occurs-check   110
;  :datatype-splits         67
;  :decisions               197
;  :del-clause              984
;  :final-checks            69
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.16
;  :minimized-lits          1
;  :mk-bool-var             2678
;  :mk-clause               992
;  :num-allocs              226032
;  :num-checks              122
;  :propagations            413
;  :quant-instantiations    800
;  :rlimit-count            314170)
; [then-branch: 80 | exc@116@07 == Null | live]
; [else-branch: 80 | exc@116@07 != Null | dead]
(push) ; 6
; [then-branch: 80 | exc@116@07 == Null]
; [eval] visited != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@116@07 $Ref.null)
  (not (= res@106@07 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@118@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@118@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@118@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@118@07))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(visited)) == V
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1795
;  :arith-add-rows          418
;  :arith-assert-diseq      43
;  :arith-assert-lower      267
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               81
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 180
;  :datatype-occurs-check   114
;  :datatype-splits         69
;  :decisions               203
;  :del-clause              984
;  :final-checks            71
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2682
;  :mk-clause               992
;  :num-allocs              226770
;  :num-checks              123
;  :propagations            413
;  :quant-instantiations    800
;  :rlimit-count            314980)
; [then-branch: 81 | exc@116@07 == Null | live]
; [else-branch: 81 | exc@116@07 != Null | dead]
(push) ; 6
; [then-branch: 81 | exc@116@07 == Null]
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@116@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@106@07)) V@39@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@118@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@118@07))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1827
;  :arith-add-rows          418
;  :arith-assert-diseq      43
;  :arith-assert-lower      267
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               81
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 186
;  :datatype-occurs-check   118
;  :datatype-splits         71
;  :decisions               209
;  :del-clause              984
;  :final-checks            73
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2686
;  :mk-clause               992
;  :num-allocs              227513
;  :num-checks              124
;  :propagations            413
;  :quant-instantiations    800
;  :rlimit-count            315808)
; [then-branch: 82 | exc@116@07 == Null | live]
; [else-branch: 82 | exc@116@07 != Null | dead]
(push) ; 6
; [then-branch: 82 | exc@116@07 == Null]
; [eval] 0 <= s
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies (= exc@116@07 $Ref.null) (<= 0 s@40@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07)))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1860
;  :arith-add-rows          418
;  :arith-assert-diseq      43
;  :arith-assert-lower      267
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               81
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 192
;  :datatype-occurs-check   122
;  :datatype-splits         73
;  :decisions               215
;  :del-clause              984
;  :final-checks            75
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2690
;  :mk-clause               992
;  :num-allocs              228265
;  :num-checks              125
;  :propagations            413
;  :quant-instantiations    800
;  :rlimit-count            316651)
; [then-branch: 83 | exc@116@07 == Null | live]
; [else-branch: 83 | exc@116@07 != Null | dead]
(push) ; 6
; [then-branch: 83 | exc@116@07 == Null]
; [eval] s < V
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies (= exc@116@07 $Ref.null) (< s@40@07 V@39@07)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07)))))))))
; [eval] exc == null
(push) ; 5
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1895
;  :arith-add-rows          418
;  :arith-assert-diseq      43
;  :arith-assert-lower      267
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               81
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 199
;  :datatype-occurs-check   126
;  :datatype-splits         76
;  :decisions               222
;  :del-clause              984
;  :final-checks            77
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2694
;  :mk-clause               992
;  :num-allocs              229019
;  :num-checks              126
;  :propagations            413
;  :quant-instantiations    800
;  :rlimit-count            317495)
; [then-branch: 84 | exc@116@07 == Null | live]
; [else-branch: 84 | exc@116@07 != Null | dead]
(push) ; 5
; [then-branch: 84 | exc@116@07 == Null]
(declare-const k@119@07 Int)
(push) ; 6
; [eval] 0 <= k && k < V
; [eval] 0 <= k
(push) ; 7
; [then-branch: 85 | 0 <= k@119@07 | live]
; [else-branch: 85 | !(0 <= k@119@07) | live]
(push) ; 8
; [then-branch: 85 | 0 <= k@119@07]
(assert (<= 0 k@119@07))
; [eval] k < V
(pop) ; 8
(push) ; 8
; [else-branch: 85 | !(0 <= k@119@07)]
(assert (not (<= 0 k@119@07)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< k@119@07 V@39@07) (<= 0 k@119@07)))
; [eval] aloc(opt_get1(visited), k)
; [eval] opt_get1(visited)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< k@119@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1895
;  :arith-add-rows          418
;  :arith-assert-diseq      43
;  :arith-assert-lower      269
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               81
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 199
;  :datatype-occurs-check   126
;  :datatype-splits         76
;  :decisions               222
;  :del-clause              984
;  :final-checks            77
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2696
;  :mk-clause               992
;  :num-allocs              229122
;  :num-checks              127
;  :propagations            413
;  :quant-instantiations    800
;  :rlimit-count            317680)
(assert (< k@119@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 7
; Joined path conditions
(assert (< k@119@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 6
(declare-fun inv@120@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((k@119@07 Int)) (!
  (< k@119@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k@119@07))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((k1@119@07 Int) (k2@119@07 Int)) (!
  (implies
    (and
      (and (< k1@119@07 V@39@07) (<= 0 k1@119@07))
      (and (< k2@119@07 V@39@07) (<= 0 k2@119@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k1@119@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k2@119@07)))
    (= k1@119@07 k2@119@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1901
;  :arith-add-rows          420
;  :arith-assert-diseq      44
;  :arith-assert-lower      273
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        147
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               82
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 199
;  :datatype-occurs-check   126
;  :datatype-splits         76
;  :decisions               222
;  :del-clause              990
;  :final-checks            77
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.16
;  :minimized-lits          1
;  :mk-bool-var             2713
;  :mk-clause               998
;  :num-allocs              229610
;  :num-checks              128
;  :propagations            413
;  :quant-instantiations    810
;  :rlimit-count            318504)
; Definitional axioms for inverse functions
(assert (forall ((k@119@07 Int)) (!
  (implies
    (and (< k@119@07 V@39@07) (<= 0 k@119@07))
    (=
      (inv@120@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k@119@07))
      k@119@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k@119@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@07 r) V@39@07) (<= 0 (inv@120@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@120@07 r))
      r))
  :pattern ((inv@120@07 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((k@119@07 Int)) (!
  (implies
    (and (< k@119@07 V@39@07) (<= 0 k@119@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k@119@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) k@119@07))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@121@07 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@07 r) V@39@07) (<= 0 (inv@120@07 r)))
    (=
      ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07))))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@120@07 r) V@39@07) (<= 0 (inv@120@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) r) r))
  :pattern ((inv@120@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: { aloc(opt_get1(visited), unknown) } 0 <= unknown && unknown < V && unknown != s ==> aloc(opt_get1(visited), unknown).bool == false)
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1939
;  :arith-add-rows          420
;  :arith-assert-diseq      44
;  :arith-assert-lower      273
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        147
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               82
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 206
;  :datatype-occurs-check   130
;  :datatype-splits         79
;  :decisions               229
;  :del-clause              990
;  :final-checks            79
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2724
;  :mk-clause               998
;  :num-allocs              231224
;  :num-checks              129
;  :propagations            413
;  :quant-instantiations    810
;  :rlimit-count            321218)
; [then-branch: 86 | exc@116@07 == Null | live]
; [else-branch: 86 | exc@116@07 != Null | dead]
(push) ; 7
; [then-branch: 86 | exc@116@07 == Null]
; [eval] (forall unknown: Int :: { aloc(opt_get1(visited), unknown) } 0 <= unknown && unknown < V && unknown != s ==> aloc(opt_get1(visited), unknown).bool == false)
(declare-const unknown@122@07 Int)
(push) ; 8
; [eval] 0 <= unknown && unknown < V && unknown != s ==> aloc(opt_get1(visited), unknown).bool == false
; [eval] 0 <= unknown && unknown < V && unknown != s
; [eval] 0 <= unknown
(push) ; 9
; [then-branch: 87 | 0 <= unknown@122@07 | live]
; [else-branch: 87 | !(0 <= unknown@122@07) | live]
(push) ; 10
; [then-branch: 87 | 0 <= unknown@122@07]
(assert (<= 0 unknown@122@07))
; [eval] unknown < V
(push) ; 11
; [then-branch: 88 | unknown@122@07 < V@39@07 | live]
; [else-branch: 88 | !(unknown@122@07 < V@39@07) | live]
(push) ; 12
; [then-branch: 88 | unknown@122@07 < V@39@07]
(assert (< unknown@122@07 V@39@07))
; [eval] unknown != s
(pop) ; 12
(push) ; 12
; [else-branch: 88 | !(unknown@122@07 < V@39@07)]
(assert (not (< unknown@122@07 V@39@07)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 87 | !(0 <= unknown@122@07)]
(assert (not (<= 0 unknown@122@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 89 | unknown@122@07 != s@40@07 && unknown@122@07 < V@39@07 && 0 <= unknown@122@07 | live]
; [else-branch: 89 | !(unknown@122@07 != s@40@07 && unknown@122@07 < V@39@07 && 0 <= unknown@122@07) | live]
(push) ; 10
; [then-branch: 89 | unknown@122@07 != s@40@07 && unknown@122@07 < V@39@07 && 0 <= unknown@122@07]
(assert (and
  (and (not (= unknown@122@07 s@40@07)) (< unknown@122@07 V@39@07))
  (<= 0 unknown@122@07)))
; [eval] aloc(opt_get1(visited), unknown).bool == false
; [eval] aloc(opt_get1(visited), unknown)
; [eval] opt_get1(visited)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< unknown@122@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1940
;  :arith-add-rows          421
;  :arith-assert-diseq      47
;  :arith-assert-lower      276
;  :arith-assert-upper      133
;  :arith-bound-prop        69
;  :arith-conflicts         27
;  :arith-eq-adapter        148
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        58
;  :arith-pivots            266
;  :conflicts               82
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 206
;  :datatype-occurs-check   130
;  :datatype-splits         79
;  :decisions               229
;  :del-clause              990
;  :final-checks            79
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2731
;  :mk-clause               1002
;  :num-allocs              231416
;  :num-checks              130
;  :propagations            413
;  :quant-instantiations    810
;  :rlimit-count            321555)
(assert (< unknown@122@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 11
; Joined path conditions
(assert (< unknown@122@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07)))
(push) ; 11
(assert (not (and
  (<
    (inv@120@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07))
    V@39@07)
  (<=
    0
    (inv@120@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1954
;  :arith-add-rows          433
;  :arith-assert-diseq      47
;  :arith-assert-lower      278
;  :arith-assert-upper      136
;  :arith-bound-prop        72
;  :arith-conflicts         28
;  :arith-eq-adapter        150
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        61
;  :arith-pivots            269
;  :conflicts               83
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 206
;  :datatype-occurs-check   130
;  :datatype-splits         79
;  :decisions               229
;  :del-clause              990
;  :final-checks            79
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2759
;  :mk-clause               1015
;  :num-allocs              231700
;  :num-checks              131
;  :propagations            416
;  :quant-instantiations    823
;  :rlimit-count            322383)
(pop) ; 10
(push) ; 10
; [else-branch: 89 | !(unknown@122@07 != s@40@07 && unknown@122@07 < V@39@07 && 0 <= unknown@122@07)]
(assert (not
  (and
    (and (not (= unknown@122@07 s@40@07)) (< unknown@122@07 V@39@07))
    (<= 0 unknown@122@07))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and
    (and (not (= unknown@122@07 s@40@07)) (< unknown@122@07 V@39@07))
    (<= 0 unknown@122@07))
  (and
    (not (= unknown@122@07 s@40@07))
    (< unknown@122@07 V@39@07)
    (<= 0 unknown@122@07)
    (< unknown@122@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@122@07 Int)) (!
  (implies
    (and
      (and (not (= unknown@122@07 s@40@07)) (< unknown@122@07 V@39@07))
      (<= 0 unknown@122@07))
    (and
      (not (= unknown@122@07 s@40@07))
      (< unknown@122@07 V@39@07)
      (<= 0 unknown@122@07)
      (< unknown@122@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
      ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@116@07 $Ref.null)
  (forall ((unknown@122@07 Int)) (!
    (implies
      (and
        (and (not (= unknown@122@07 s@40@07)) (< unknown@122@07 V@39@07))
        (<= 0 unknown@122@07))
      (and
        (not (= unknown@122@07 s@40@07))
        (< unknown@122@07 V@39@07)
        (<= 0 unknown@122@07)
        (< unknown@122@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@116@07 $Ref.null)
  (forall ((unknown@122@07 Int)) (!
    (implies
      (and
        (and (not (= unknown@122@07 s@40@07)) (< unknown@122@07 V@39@07))
        (<= 0 unknown@122@07))
      (=
        ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07))
        false))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) unknown@122@07))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@118@07)))))))
  $Snap.unit))
; [eval] exc == null ==> aloc(opt_get1(visited), s).bool == true
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1985
;  :arith-add-rows          437
;  :arith-assert-diseq      47
;  :arith-assert-lower      278
;  :arith-assert-upper      136
;  :arith-bound-prop        72
;  :arith-conflicts         28
;  :arith-eq-adapter        150
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        61
;  :arith-pivots            272
;  :conflicts               83
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 212
;  :datatype-occurs-check   134
;  :datatype-splits         81
;  :decisions               235
;  :del-clause              1007
;  :final-checks            81
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2764
;  :mk-clause               1015
;  :num-allocs              232776
;  :num-checks              132
;  :propagations            416
;  :quant-instantiations    823
;  :rlimit-count            324004)
; [then-branch: 90 | exc@116@07 == Null | live]
; [else-branch: 90 | exc@116@07 != Null | dead]
(push) ; 7
; [then-branch: 90 | exc@116@07 == Null]
; [eval] aloc(opt_get1(visited), s).bool == true
; [eval] aloc(opt_get1(visited), s)
; [eval] opt_get1(visited)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< s@40@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1985
;  :arith-add-rows          437
;  :arith-assert-diseq      47
;  :arith-assert-lower      278
;  :arith-assert-upper      136
;  :arith-bound-prop        72
;  :arith-conflicts         28
;  :arith-eq-adapter        150
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        61
;  :arith-pivots            272
;  :conflicts               83
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 212
;  :datatype-occurs-check   134
;  :datatype-splits         81
;  :decisions               235
;  :del-clause              1007
;  :final-checks            81
;  :max-generation          3
;  :max-memory              5.18
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2764
;  :mk-clause               1015
;  :num-allocs              232804
;  :num-checks              133
;  :propagations            416
;  :quant-instantiations    823
;  :rlimit-count            324039)
(assert (< s@40@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 8
; Joined path conditions
(assert (< s@40@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) s@40@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) s@40@07)))
(push) ; 8
(assert (not (and
  (<
    (inv@120@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) s@40@07))
    V@39@07)
  (<=
    0
    (inv@120@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) s@40@07))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1995
;  :arith-add-rows          445
;  :arith-assert-diseq      47
;  :arith-assert-lower      280
;  :arith-assert-upper      139
;  :arith-bound-prop        74
;  :arith-conflicts         29
;  :arith-eq-adapter        152
;  :arith-fixed-eqs         73
;  :arith-offset-eqs        61
;  :arith-pivots            275
;  :conflicts               84
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 212
;  :datatype-occurs-check   134
;  :datatype-splits         81
;  :decisions               235
;  :del-clause              1007
;  :final-checks            81
;  :max-generation          3
;  :max-memory              5.19
;  :memory                  5.17
;  :minimized-lits          1
;  :mk-bool-var             2792
;  :mk-clause               1028
;  :num-allocs              233076
;  :num-checks              134
;  :propagations            416
;  :quant-instantiations    836
;  :rlimit-count            324822)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@116@07 $Ref.null)
  (and
    (< s@40@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) s@40@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) s@40@07)))))
(assert (implies
  (= exc@116@07 $Ref.null)
  (=
    ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) s@40@07))
    true)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 91 | exc@116@07 != Null | dead]
; [else-branch: 91 | exc@116@07 == Null | live]
(push) ; 6
; [else-branch: 91 | exc@116@07 == Null]
(pop) ; 6
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2117
;  :arith-add-rows          461
;  :arith-assert-diseq      47
;  :arith-assert-lower      285
;  :arith-assert-upper      144
;  :arith-bound-prop        79
;  :arith-conflicts         29
;  :arith-eq-adapter        157
;  :arith-fixed-eqs         78
;  :arith-offset-eqs        70
;  :arith-pivots            284
;  :conflicts               85
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1112
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.19
;  :minimized-lits          1
;  :mk-bool-var             2919
;  :mk-clause               1126
;  :num-allocs              235321
;  :num-checks              136
;  :propagations            439
;  :quant-instantiations    872
;  :rlimit-count            328217
;  :time                    0.00)
; [then-branch: 92 | exc@116@07 == Null | live]
; [else-branch: 92 | exc@116@07 != Null | dead]
(push) ; 6
; [then-branch: 92 | exc@116@07 == Null]
; [exec]
; evaluationDummy := res2
; [exec]
; queue := Seq(s)
; [eval] Seq(s)
(assert (= (Seq_length (Seq_singleton s@40@07)) 1))
(declare-const queue@123@07 Seq<Int>)
(assert (Seq_equal queue@123@07 (Seq_singleton s@40@07)))
; [exec]
; label loop
; [exec]
; excBeforeLoop := exc
(declare-const u@124@07 Int)
(declare-const evaluationDummy1@125@07 Seq<Int>)
(declare-const k@126@07 Int)
(declare-const excBeforeLoop1@127@07 $Ref)
(declare-const v@128@07 Int)
(declare-const queue@129@07 Seq<Int>)
(declare-const flatten@130@07 Int)
(declare-const evaluationDummy2@131@07 Int)
(push) ; 7
; Loop head block: Check well-definedness of invariant
(declare-const $t@132@07 $Snap)
(assert (= $t@132@07 ($Snap.combine ($Snap.first $t@132@07) ($Snap.second $t@132@07))))
(assert (= ($Snap.first $t@132@07) $Snap.unit))
; [eval] exc == excBeforeLoop
(assert (=
  ($Snap.second $t@132@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@132@07))
    ($Snap.second ($Snap.second $t@132@07)))))
(assert (= ($Snap.first ($Snap.second $t@132@07)) $Snap.unit))
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second $t@132@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@132@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@132@07))) $Snap.unit))
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@132@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))
(declare-const i1@133@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 93 | 0 <= i1@133@07 | live]
; [else-branch: 93 | !(0 <= i1@133@07) | live]
(push) ; 10
; [then-branch: 93 | 0 <= i1@133@07]
(assert (<= 0 i1@133@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 93 | !(0 <= i1@133@07)]
(assert (not (<= 0 i1@133@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@133@07 V@39@07) (<= 0 i1@133@07)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@133@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2146
;  :arith-add-rows          462
;  :arith-assert-diseq      48
;  :arith-assert-lower      291
;  :arith-assert-upper      146
;  :arith-bound-prop        79
;  :arith-conflicts         29
;  :arith-eq-adapter        160
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        70
;  :arith-pivots            285
;  :conflicts               85
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1112
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             2949
;  :mk-clause               1141
;  :num-allocs              235888
;  :num-checks              137
;  :propagations            445
;  :quant-instantiations    876
;  :rlimit-count            329279)
(assert (< i1@133@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@133@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(declare-const $k@134@07 $Perm)
(assert ($Perm.isReadVar $k@134@07 $Perm.Write))
(pop) ; 8
(declare-fun inv@135@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@134@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@133@07 Int)) (!
  (< i1@133@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  :qid |option$array$-aux|)))
(push) ; 8
(assert (not (forall ((i1@133@07 Int)) (!
  (implies
    (and (< i1@133@07 V@39@07) (<= 0 i1@133@07))
    (or (= $k@134@07 $Perm.No) (< $Perm.No $k@134@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2146
;  :arith-add-rows          462
;  :arith-assert-diseq      49
;  :arith-assert-lower      293
;  :arith-assert-upper      147
;  :arith-bound-prop        79
;  :arith-conflicts         29
;  :arith-eq-adapter        161
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        70
;  :arith-pivots            285
;  :conflicts               86
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1112
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.22
;  :memory                  5.21
;  :minimized-lits          1
;  :mk-bool-var             2956
;  :mk-clause               1143
;  :num-allocs              236357
;  :num-checks              138
;  :propagations            446
;  :quant-instantiations    876
;  :rlimit-count            329850)
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@133@07 Int) (i12@133@07 Int)) (!
  (implies
    (and
      (and (and (< i11@133@07 V@39@07) (<= 0 i11@133@07)) (< $Perm.No $k@134@07))
      (and (and (< i12@133@07 V@39@07) (<= 0 i12@133@07)) (< $Perm.No $k@134@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@133@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@133@07)))
    (= i11@133@07 i12@133@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2153
;  :arith-add-rows          464
;  :arith-assert-diseq      50
;  :arith-assert-lower      297
;  :arith-assert-upper      147
;  :arith-bound-prop        79
;  :arith-conflicts         29
;  :arith-eq-adapter        162
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        70
;  :arith-pivots            285
;  :conflicts               87
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1118
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.26
;  :memory                  5.25
;  :minimized-lits          1
;  :mk-bool-var             2973
;  :mk-clause               1149
;  :num-allocs              236727
;  :num-checks              139
;  :propagations            446
;  :quant-instantiations    887
;  :rlimit-count            330549)
; Definitional axioms for inverse functions
(assert (forall ((i1@133@07 Int)) (!
  (implies
    (and (and (< i1@133@07 V@39@07) (<= 0 i1@133@07)) (< $Perm.No $k@134@07))
    (=
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
      i1@133@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
      (< $Perm.No $k@134@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@135@07 r))
      r))
  :pattern ((inv@135@07 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@133@07 Int)) (!
  (<= $Perm.No $k@134@07)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@133@07 Int)) (!
  (<= $k@134@07 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@133@07 Int)) (!
  (implies
    (and (and (< i1@133@07 V@39@07) (<= 0 i1@133@07)) (< $Perm.No $k@134@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@136@07 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
      (< $Perm.No $k@134@07)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r) r))
  :pattern ((inv@135@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@137@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 94 | 0 <= i1@137@07 | live]
; [else-branch: 94 | !(0 <= i1@137@07) | live]
(push) ; 10
; [then-branch: 94 | 0 <= i1@137@07]
(assert (<= 0 i1@137@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 94 | !(0 <= i1@137@07)]
(assert (not (<= 0 i1@137@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 95 | i1@137@07 < V@39@07 && 0 <= i1@137@07 | live]
; [else-branch: 95 | !(i1@137@07 < V@39@07 && 0 <= i1@137@07) | live]
(push) ; 10
; [then-branch: 95 | i1@137@07 < V@39@07 && 0 <= i1@137@07]
(assert (and (< i1@137@07 V@39@07) (<= 0 i1@137@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@137@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2159
;  :arith-add-rows          464
;  :arith-assert-diseq      50
;  :arith-assert-lower      299
;  :arith-assert-upper      148
;  :arith-bound-prop        79
;  :arith-conflicts         29
;  :arith-eq-adapter        162
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        70
;  :arith-pivots            285
;  :conflicts               87
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1118
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.26
;  :memory                  5.25
;  :minimized-lits          1
;  :mk-bool-var             2984
;  :mk-clause               1149
;  :num-allocs              237915
;  :num-checks              140
;  :propagations            446
;  :quant-instantiations    887
;  :rlimit-count            332886)
(assert (< i1@137@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 11
; Joined path conditions
(assert (< i1@137@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2173
;  :arith-add-rows          472
;  :arith-assert-diseq      50
;  :arith-assert-lower      301
;  :arith-assert-upper      151
;  :arith-bound-prop        81
;  :arith-conflicts         30
;  :arith-eq-adapter        164
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        70
;  :arith-pivots            288
;  :conflicts               88
;  :datatype-accessor-ax    63
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1118
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.42
;  :memory                  5.36
;  :minimized-lits          1
;  :mk-bool-var             3034
;  :mk-clause               1169
;  :num-allocs              238361
;  :num-checks              141
;  :propagations            447
;  :quant-instantiations    910
;  :rlimit-count            334274)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 95 | !(i1@137@07 < V@39@07 && 0 <= i1@137@07)]
(assert (not (and (< i1@137@07 V@39@07) (<= 0 i1@137@07))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@137@07 V@39@07) (<= 0 i1@137@07))
  (and
    (< i1@137@07 V@39@07)
    (<= 0 i1@137@07)
    (< i1@137@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@137@07 Int)) (!
  (implies
    (and (< i1@137@07 V@39@07) (<= 0 i1@137@07))
    (and
      (< i1@137@07 V@39@07)
      (<= 0 i1@137@07)
      (< i1@137@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@137@07 Int)) (!
  (implies
    (and (< i1@137@07 V@39@07) (<= 0 i1@137@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@138@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 96 | 0 <= i1@138@07 | live]
; [else-branch: 96 | !(0 <= i1@138@07) | live]
(push) ; 10
; [then-branch: 96 | 0 <= i1@138@07]
(assert (<= 0 i1@138@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 96 | !(0 <= i1@138@07)]
(assert (not (<= 0 i1@138@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 97 | i1@138@07 < V@39@07 && 0 <= i1@138@07 | live]
; [else-branch: 97 | !(i1@138@07 < V@39@07 && 0 <= i1@138@07) | live]
(push) ; 10
; [then-branch: 97 | i1@138@07 < V@39@07 && 0 <= i1@138@07]
(assert (and (< i1@138@07 V@39@07) (<= 0 i1@138@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@138@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2179
;  :arith-add-rows          475
;  :arith-assert-diseq      50
;  :arith-assert-lower      303
;  :arith-assert-upper      151
;  :arith-bound-prop        81
;  :arith-conflicts         30
;  :arith-eq-adapter        164
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        70
;  :arith-pivots            291
;  :conflicts               88
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1138
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.42
;  :memory                  5.35
;  :minimized-lits          1
;  :mk-bool-var             3040
;  :mk-clause               1169
;  :num-allocs              238910
;  :num-checks              142
;  :propagations            447
;  :quant-instantiations    910
;  :rlimit-count            335436)
(assert (< i1@138@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 11
; Joined path conditions
(assert (< i1@138@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2193
;  :arith-add-rows          483
;  :arith-assert-diseq      50
;  :arith-assert-lower      305
;  :arith-assert-upper      154
;  :arith-bound-prop        83
;  :arith-conflicts         31
;  :arith-eq-adapter        166
;  :arith-fixed-eqs         83
;  :arith-offset-eqs        70
;  :arith-pivots            294
;  :conflicts               89
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1138
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.42
;  :memory                  5.37
;  :minimized-lits          1
;  :mk-bool-var             3092
;  :mk-clause               1189
;  :num-allocs              239340
;  :num-checks              143
;  :propagations            448
;  :quant-instantiations    935
;  :rlimit-count            336851)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2193
;  :arith-add-rows          483
;  :arith-assert-diseq      50
;  :arith-assert-lower      305
;  :arith-assert-upper      154
;  :arith-bound-prop        83
;  :arith-conflicts         31
;  :arith-eq-adapter        166
;  :arith-fixed-eqs         83
;  :arith-offset-eqs        70
;  :arith-pivots            294
;  :conflicts               90
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1138
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.42
;  :memory                  5.37
;  :minimized-lits          1
;  :mk-bool-var             3092
;  :mk-clause               1189
;  :num-allocs              239429
;  :num-checks              144
;  :propagations            448
;  :quant-instantiations    935
;  :rlimit-count            336946)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 97 | !(i1@138@07 < V@39@07 && 0 <= i1@138@07)]
(assert (not (and (< i1@138@07 V@39@07) (<= 0 i1@138@07))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@138@07 V@39@07) (<= 0 i1@138@07))
  (and
    (< i1@138@07 V@39@07)
    (<= 0 i1@138@07)
    (< i1@138@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@138@07 Int)) (!
  (implies
    (and (< i1@138@07 V@39@07) (<= 0 i1@138@07))
    (and
      (< i1@138@07 V@39@07)
      (<= 0 i1@138@07)
      (< i1@138@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@138@07 Int)) (!
  (implies
    (and (< i1@138@07 V@39@07) (<= 0 i1@138@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@139@07 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@140@07 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 98 | 0 <= i1@139@07 | live]
; [else-branch: 98 | !(0 <= i1@139@07) | live]
(push) ; 11
; [then-branch: 98 | 0 <= i1@139@07]
(assert (<= 0 i1@139@07))
; [eval] i1 < V
(push) ; 12
; [then-branch: 99 | i1@139@07 < V@39@07 | live]
; [else-branch: 99 | !(i1@139@07 < V@39@07) | live]
(push) ; 13
; [then-branch: 99 | i1@139@07 < V@39@07]
(assert (< i1@139@07 V@39@07))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 100 | 0 <= i2@140@07 | live]
; [else-branch: 100 | !(0 <= i2@140@07) | live]
(push) ; 15
; [then-branch: 100 | 0 <= i2@140@07]
(assert (<= 0 i2@140@07))
; [eval] i2 < V
(push) ; 16
; [then-branch: 101 | i2@140@07 < V@39@07 | live]
; [else-branch: 101 | !(i2@140@07 < V@39@07) | live]
(push) ; 17
; [then-branch: 101 | i2@140@07 < V@39@07]
(assert (< i2@140@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2199
;  :arith-add-rows          486
;  :arith-assert-diseq      50
;  :arith-assert-lower      309
;  :arith-assert-upper      154
;  :arith-bound-prop        83
;  :arith-conflicts         31
;  :arith-eq-adapter        166
;  :arith-fixed-eqs         83
;  :arith-offset-eqs        70
;  :arith-pivots            297
;  :conflicts               90
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1158
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.42
;  :memory                  5.37
;  :minimized-lits          1
;  :mk-bool-var             3100
;  :mk-clause               1189
;  :num-allocs              240172
;  :num-checks              145
;  :propagations            448
;  :quant-instantiations    935
;  :rlimit-count            338345)
(assert (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 18
; Joined path conditions
(assert (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2213
;  :arith-add-rows          494
;  :arith-assert-diseq      50
;  :arith-assert-lower      311
;  :arith-assert-upper      157
;  :arith-bound-prop        85
;  :arith-conflicts         32
;  :arith-eq-adapter        168
;  :arith-fixed-eqs         85
;  :arith-offset-eqs        70
;  :arith-pivots            300
;  :conflicts               91
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1158
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.42
;  :memory                  5.37
;  :minimized-lits          1
;  :mk-bool-var             3152
;  :mk-clause               1209
;  :num-allocs              240605
;  :num-checks              146
;  :propagations            449
;  :quant-instantiations    960
;  :rlimit-count            339760)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2213
;  :arith-add-rows          494
;  :arith-assert-diseq      50
;  :arith-assert-lower      311
;  :arith-assert-upper      157
;  :arith-bound-prop        85
;  :arith-conflicts         32
;  :arith-eq-adapter        168
;  :arith-fixed-eqs         85
;  :arith-offset-eqs        70
;  :arith-pivots            300
;  :conflicts               91
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1158
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.42
;  :memory                  5.37
;  :minimized-lits          1
;  :mk-bool-var             3152
;  :mk-clause               1209
;  :num-allocs              240631
;  :num-checks              147
;  :propagations            449
;  :quant-instantiations    960
;  :rlimit-count            339790)
(assert (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 18
; Joined path conditions
(assert (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2226
;  :arith-add-rows          504
;  :arith-assert-diseq      50
;  :arith-assert-lower      313
;  :arith-assert-upper      160
;  :arith-bound-prop        87
;  :arith-conflicts         33
;  :arith-eq-adapter        171
;  :arith-fixed-eqs         87
;  :arith-offset-eqs        70
;  :arith-pivots            303
;  :conflicts               92
;  :datatype-accessor-ax    65
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1158
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.47
;  :minimized-lits          1
;  :mk-bool-var             3211
;  :mk-clause               1241
;  :num-allocs              241160
;  :num-checks              148
;  :propagations            456
;  :quant-instantiations    985
;  :rlimit-count            341318)
(pop) ; 17
(push) ; 17
; [else-branch: 101 | !(i2@140@07 < V@39@07)]
(assert (not (< i2@140@07 V@39@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@140@07 V@39@07)
  (and
    (< i2@140@07 V@39@07)
    (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
    (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 100 | !(0 <= i2@140@07)]
(assert (not (<= 0 i2@140@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@140@07)
  (and
    (<= 0 i2@140@07)
    (implies
      (< i2@140@07 V@39@07)
      (and
        (< i2@140@07 V@39@07)
        (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
        (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 99 | !(i1@139@07 < V@39@07)]
(assert (not (< i1@139@07 V@39@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@139@07 V@39@07)
  (and
    (< i1@139@07 V@39@07)
    (implies
      (<= 0 i2@140@07)
      (and
        (<= 0 i2@140@07)
        (implies
          (< i2@140@07 V@39@07)
          (and
            (< i2@140@07 V@39@07)
            (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
            (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 98 | !(0 <= i1@139@07)]
(assert (not (<= 0 i1@139@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@139@07)
  (and
    (<= 0 i1@139@07)
    (implies
      (< i1@139@07 V@39@07)
      (and
        (< i1@139@07 V@39@07)
        (implies
          (<= 0 i2@140@07)
          (and
            (<= 0 i2@140@07)
            (implies
              (< i2@140@07 V@39@07)
              (and
                (< i2@140@07 V@39@07)
                (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 102 | Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@139@07)) == Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@140@07)) && i2@140@07 < V@39@07 && 0 <= i2@140@07 && i1@139@07 < V@39@07 && 0 <= i1@139@07 | live]
; [else-branch: 102 | !(Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@139@07)) == Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@140@07)) && i2@140@07 < V@39@07 && 0 <= i2@140@07 && i1@139@07 < V@39@07 && 0 <= i1@139@07) | live]
(push) ; 11
; [then-branch: 102 | Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@139@07)) == Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@140@07)) && i2@140@07 < V@39@07 && 0 <= i2@140@07 && i1@139@07 < V@39@07 && 0 <= i1@139@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
        (< i2@140@07 V@39@07))
      (<= 0 i2@140@07))
    (< i1@139@07 V@39@07))
  (<= 0 i1@139@07)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 102 | !(Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@139@07)) == Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@140@07)) && i2@140@07 < V@39@07 && 0 <= i2@140@07 && i1@139@07 < V@39@07 && 0 <= i1@139@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
          (< i2@140@07 V@39@07))
        (<= 0 i2@140@07))
      (< i1@139@07 V@39@07))
    (<= 0 i1@139@07))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
          (< i2@140@07 V@39@07))
        (<= 0 i2@140@07))
      (< i1@139@07 V@39@07))
    (<= 0 i1@139@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
      ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
    (< i2@140@07 V@39@07)
    (<= 0 i2@140@07)
    (< i1@139@07 V@39@07)
    (<= 0 i1@139@07))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@140@07 Int)) (!
  (and
    (implies
      (<= 0 i1@139@07)
      (and
        (<= 0 i1@139@07)
        (implies
          (< i1@139@07 V@39@07)
          (and
            (< i1@139@07 V@39@07)
            (implies
              (<= 0 i2@140@07)
              (and
                (<= 0 i2@140@07)
                (implies
                  (< i2@140@07 V@39@07)
                  (and
                    (< i2@140@07 V@39@07)
                    (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                    (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
              (< i2@140@07 V@39@07))
            (<= 0 i2@140@07))
          (< i1@139@07 V@39@07))
        (<= 0 i1@139@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
        (< i2@140@07 V@39@07)
        (<= 0 i2@140@07)
        (< i1@139@07 V@39@07)
        (<= 0 i1@139@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@139@07 Int)) (!
  (forall ((i2@140@07 Int)) (!
    (and
      (implies
        (<= 0 i1@139@07)
        (and
          (<= 0 i1@139@07)
          (implies
            (< i1@139@07 V@39@07)
            (and
              (< i1@139@07 V@39@07)
              (implies
                (<= 0 i2@140@07)
                (and
                  (<= 0 i2@140@07)
                  (implies
                    (< i2@140@07 V@39@07)
                    (and
                      (< i2@140@07 V@39@07)
                      (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                      (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                  ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
                (< i2@140@07 V@39@07))
              (<= 0 i2@140@07))
            (< i1@139@07 V@39@07))
          (<= 0 i1@139@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
          (< i2@140@07 V@39@07)
          (<= 0 i2@140@07)
          (< i1@139@07 V@39@07)
          (<= 0 i1@139@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@139@07 Int)) (!
  (forall ((i2@140@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
              (< i2@140@07 V@39@07))
            (<= 0 i2@140@07))
          (< i1@139@07 V@39@07))
        (<= 0 i1@139@07))
      (= i1@139@07 i2@140@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))
  $Snap.unit))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))
  $Snap.unit))
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))
  $Snap.unit))
; [eval] s < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))
  $Snap.unit))
; [eval] 0 <= t
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))
  $Snap.unit))
; [eval] t < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))
(declare-const i1@141@07 Int)
(declare-const j1@142@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 103 | 0 <= i1@141@07 | live]
; [else-branch: 103 | !(0 <= i1@141@07) | live]
(push) ; 10
; [then-branch: 103 | 0 <= i1@141@07]
(assert (<= 0 i1@141@07))
; [eval] i1 < V
(push) ; 11
; [then-branch: 104 | i1@141@07 < V@39@07 | live]
; [else-branch: 104 | !(i1@141@07 < V@39@07) | live]
(push) ; 12
; [then-branch: 104 | i1@141@07 < V@39@07]
(assert (< i1@141@07 V@39@07))
; [eval] 0 <= j1
(push) ; 13
; [then-branch: 105 | 0 <= j1@142@07 | live]
; [else-branch: 105 | !(0 <= j1@142@07) | live]
(push) ; 14
; [then-branch: 105 | 0 <= j1@142@07]
(assert (<= 0 j1@142@07))
; [eval] j1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 105 | !(0 <= j1@142@07)]
(assert (not (<= 0 j1@142@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 104 | !(i1@141@07 < V@39@07)]
(assert (not (< i1@141@07 V@39@07)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 103 | !(0 <= i1@141@07)]
(assert (not (<= 0 i1@141@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@142@07 V@39@07) (<= 0 j1@142@07)) (< i1@141@07 V@39@07))
  (<= 0 i1@141@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@141@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2267
;  :arith-add-rows          510
;  :arith-assert-diseq      50
;  :arith-assert-lower      319
;  :arith-assert-upper      160
;  :arith-bound-prop        87
;  :arith-conflicts         33
;  :arith-eq-adapter        171
;  :arith-fixed-eqs         87
;  :arith-offset-eqs        70
;  :arith-pivots            309
;  :conflicts               92
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1234
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.47
;  :minimized-lits          1
;  :mk-bool-var             3245
;  :mk-clause               1265
;  :num-allocs              242715
;  :num-checks              149
;  :propagations            456
;  :quant-instantiations    985
;  :rlimit-count            345141)
(assert (< i1@141@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@141@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2281
;  :arith-add-rows          518
;  :arith-assert-diseq      50
;  :arith-assert-lower      321
;  :arith-assert-upper      163
;  :arith-bound-prop        89
;  :arith-conflicts         34
;  :arith-eq-adapter        173
;  :arith-fixed-eqs         89
;  :arith-offset-eqs        70
;  :arith-pivots            312
;  :conflicts               93
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1234
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.47
;  :minimized-lits          1
;  :mk-bool-var             3306
;  :mk-clause               1285
;  :num-allocs              243209
;  :num-checks              150
;  :propagations            457
;  :quant-instantiations    1013
;  :rlimit-count            346873)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2281
;  :arith-add-rows          518
;  :arith-assert-diseq      50
;  :arith-assert-lower      321
;  :arith-assert-upper      163
;  :arith-bound-prop        89
;  :arith-conflicts         34
;  :arith-eq-adapter        173
;  :arith-fixed-eqs         89
;  :arith-offset-eqs        70
;  :arith-pivots            312
;  :conflicts               94
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1234
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.47
;  :minimized-lits          1
;  :mk-bool-var             3306
;  :mk-clause               1285
;  :num-allocs              243299
;  :num-checks              151
;  :propagations            457
;  :quant-instantiations    1013
;  :rlimit-count            346968)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  j1@142@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2287
;  :arith-add-rows          523
;  :arith-assert-diseq      50
;  :arith-assert-lower      324
;  :arith-assert-upper      164
;  :arith-bound-prop        89
;  :arith-conflicts         35
;  :arith-eq-adapter        174
;  :arith-fixed-eqs         90
;  :arith-offset-eqs        70
;  :arith-pivots            316
;  :conflicts               95
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1238
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.49
;  :memory                  5.47
;  :minimized-lits          1
;  :mk-bool-var             3317
;  :mk-clause               1289
;  :num-allocs              243495
;  :num-checks              152
;  :propagations            459
;  :quant-instantiations    1020
;  :rlimit-count            347460)
(assert (<
  j1@142@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))))))
(pop) ; 9
; Joined path conditions
(assert (<
  j1@142@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))))))
(pop) ; 8
(declare-fun inv@143@07 ($Ref) Int)
(declare-fun inv@144@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@141@07 Int) (j1@142@07 Int)) (!
  (and
    (< i1@141@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@142@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@141@07 Int) (j11@142@07 Int) (i12@141@07 Int) (j12@142@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@142@07 V@39@07) (<= 0 j11@142@07))
          (< i11@141@07 V@39@07))
        (<= 0 i11@141@07))
      (and
        (and
          (and (< j12@142@07 V@39@07) (<= 0 j12@142@07))
          (< i12@141@07 V@39@07))
        (<= 0 i12@141@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@141@07))) j11@142@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@141@07))) j12@142@07)))
    (and (= i11@141@07 i12@141@07) (= j11@142@07 j12@142@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2341
;  :arith-add-rows          535
;  :arith-assert-diseq      50
;  :arith-assert-lower      336
;  :arith-assert-upper      168
;  :arith-bound-prop        91
;  :arith-conflicts         35
;  :arith-eq-adapter        182
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        70
;  :arith-pivots            327
;  :conflicts               96
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1329
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.56
;  :memory                  5.54
;  :minimized-lits          1
;  :mk-bool-var             3508
;  :mk-clause               1360
;  :num-allocs              244941
;  :num-checks              153
;  :propagations            483
;  :quant-instantiations    1102
;  :rlimit-count            352325
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@141@07 Int) (j1@142@07 Int)) (!
  (implies
    (and
      (and (and (< j1@142@07 V@39@07) (<= 0 j1@142@07)) (< i1@141@07 V@39@07))
      (<= 0 i1@141@07))
    (and
      (=
        (inv@143@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
        i1@141@07)
      (=
        (inv@144@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
        j1@142@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@143@07 r)))) (inv@144@07 r))
      r))
  :pattern ((inv@143@07 r))
  :pattern ((inv@144@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@141@07 Int) (j1@142@07 Int)) (!
  (implies
    (and
      (and (and (< j1@142@07 V@39@07) (<= 0 j1@142@07)) (< i1@141@07 V@39@07))
      (<= 0 i1@141@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@145@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@145@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@145@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@145@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@145@07  $FVF<Int>) r) r))
  :pattern ((inv@143@07 r) (inv@144@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))
(declare-const i1@146@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 106 | 0 <= i1@146@07 | live]
; [else-branch: 106 | !(0 <= i1@146@07) | live]
(push) ; 10
; [then-branch: 106 | 0 <= i1@146@07]
(assert (<= 0 i1@146@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 106 | !(0 <= i1@146@07)]
(assert (not (<= 0 i1@146@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@146@07 V@39@07) (<= 0 i1@146@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@146@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2346
;  :arith-add-rows          535
;  :arith-assert-diseq      50
;  :arith-assert-lower      338
;  :arith-assert-upper      168
;  :arith-bound-prop        91
;  :arith-conflicts         35
;  :arith-eq-adapter        182
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        70
;  :arith-pivots            327
;  :conflicts               96
;  :datatype-accessor-ax    73
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1329
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.56
;  :memory                  5.54
;  :minimized-lits          1
;  :mk-bool-var             3517
;  :mk-clause               1360
;  :num-allocs              246046
;  :num-checks              154
;  :propagations            483
;  :quant-instantiations    1102
;  :rlimit-count            355442)
(assert (< i1@146@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@146@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 8
(declare-fun inv@147@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@146@07 Int)) (!
  (< i1@146@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@146@07 Int) (i12@146@07 Int)) (!
  (implies
    (and
      (and (< i11@146@07 V@39@07) (<= 0 i11@146@07))
      (and (< i12@146@07 V@39@07) (<= 0 i12@146@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@146@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@146@07)))
    (= i11@146@07 i12@146@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2358
;  :arith-add-rows          537
;  :arith-assert-diseq      51
;  :arith-assert-lower      342
;  :arith-assert-upper      168
;  :arith-bound-prop        91
;  :arith-conflicts         35
;  :arith-eq-adapter        183
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        70
;  :arith-pivots            327
;  :conflicts               97
;  :datatype-accessor-ax    73
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1335
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.56
;  :memory                  5.54
;  :minimized-lits          1
;  :mk-bool-var             3540
;  :mk-clause               1366
;  :num-allocs              246582
;  :num-checks              155
;  :propagations            483
;  :quant-instantiations    1119
;  :rlimit-count            356416)
; Definitional axioms for inverse functions
(assert (forall ((i1@146@07 Int)) (!
  (implies
    (and (< i1@146@07 V@39@07) (<= 0 i1@146@07))
    (=
      (inv@147@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07))
      i1@146@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@147@07 r))
      r))
  :pattern ((inv@147@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@146@07 Int)) (!
  (implies
    (and (< i1@146@07 V@39@07) (<= 0 i1@146@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@148@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@148@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@148@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef40|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@148@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef41|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r) r))
  :pattern ((inv@147@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, p, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@149@07 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 107 | 0 <= i1@149@07 | live]
; [else-branch: 107 | !(0 <= i1@149@07) | live]
(push) ; 11
; [then-branch: 107 | 0 <= i1@149@07]
(assert (<= 0 i1@149@07))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 107 | !(0 <= i1@149@07)]
(assert (not (<= 0 i1@149@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@149@07 V@39@07) (<= 0 i1@149@07)))
(declare-const $k@150@07 $Perm)
(assert ($Perm.isReadVar $k@150@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (< i1@149@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2364
;  :arith-add-rows          537
;  :arith-assert-diseq      52
;  :arith-assert-lower      346
;  :arith-assert-upper      169
;  :arith-bound-prop        91
;  :arith-conflicts         35
;  :arith-eq-adapter        184
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        70
;  :arith-pivots            327
;  :conflicts               97
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1335
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.56
;  :memory                  5.55
;  :minimized-lits          1
;  :mk-bool-var             3555
;  :mk-clause               1368
;  :num-allocs              247953
;  :num-checks              156
;  :propagations            484
;  :quant-instantiations    1119
;  :rlimit-count            360075)
(assert (< i1@149@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 10
; Joined path conditions
(assert (< i1@149@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 9
(declare-fun inv@151@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@150@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@149@07 Int)) (!
  (< i1@149@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@149@07 Int)) (!
  (implies
    (and (< i1@149@07 V@39@07) (<= 0 i1@149@07))
    (or (= $k@150@07 $Perm.No) (< $Perm.No $k@150@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2364
;  :arith-add-rows          537
;  :arith-assert-diseq      53
;  :arith-assert-lower      348
;  :arith-assert-upper      170
;  :arith-bound-prop        91
;  :arith-conflicts         35
;  :arith-eq-adapter        185
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        70
;  :arith-pivots            327
;  :conflicts               98
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1337
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.56
;  :memory                  5.55
;  :minimized-lits          1
;  :mk-bool-var             3562
;  :mk-clause               1370
;  :num-allocs              248386
;  :num-checks              157
;  :propagations            485
;  :quant-instantiations    1119
;  :rlimit-count            360620)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@149@07 Int) (i12@149@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@149@07 V@39@07) (<= 0 i11@149@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@148@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@149@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@149@07)))
        (< $Perm.No $k@150@07))
      (and
        (and
          (and (< i12@149@07 V@39@07) (<= 0 i12@149@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@148@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@149@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@149@07)))
        (< $Perm.No $k@150@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@149@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@149@07)))
    (= i11@149@07 i12@149@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2380
;  :arith-add-rows          539
;  :arith-assert-diseq      54
;  :arith-assert-lower      352
;  :arith-assert-upper      170
;  :arith-bound-prop        91
;  :arith-conflicts         35
;  :arith-eq-adapter        186
;  :arith-fixed-eqs         92
;  :arith-offset-eqs        70
;  :arith-pivots            327
;  :conflicts               99
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   148
;  :datatype-splits         89
;  :decisions               264
;  :del-clause              1348
;  :final-checks            87
;  :max-generation          4
;  :max-memory              5.56
;  :memory                  5.55
;  :minimized-lits          1
;  :mk-bool-var             3599
;  :mk-clause               1381
;  :num-allocs              248863
;  :num-checks              158
;  :propagations            487
;  :quant-instantiations    1143
;  :rlimit-count            361782)
; Definitional axioms for inverse functions
(assert (forall ((i1@149@07 Int)) (!
  (implies
    (and (and (< i1@149@07 V@39@07) (<= 0 i1@149@07)) (< $Perm.No $k@150@07))
    (=
      (inv@151@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
      i1@149@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
      (< $Perm.No $k@150@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@151@07 r))
      r))
  :pattern ((inv@151@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r) r))
  :pattern ((inv@151@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@152@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        $Perm.Write
        $Perm.No)
      $k@150@07)
    $Perm.No))
(define-fun pTaken@153@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
            (< (inv@143@07 r) V@39@07))
          (<= 0 (inv@143@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@150@07 (pTaken@152@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@150@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
      (<
        (ite
          (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
          $k@150@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
          $k@150@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@147@07 r))
  :pattern ((inv@151@07 r))
  :qid |qp.srp42|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
    (= (- $k@150@07 (pTaken@152@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2534
;  :arith-add-rows          558
;  :arith-assert-diseq      58
;  :arith-assert-lower      368
;  :arith-assert-upper      180
;  :arith-bound-prop        97
;  :arith-conflicts         37
;  :arith-eq-adapter        208
;  :arith-fixed-eqs         98
;  :arith-offset-eqs        81
;  :arith-pivots            340
;  :conflicts               111
;  :datatype-accessor-ax    75
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   160
;  :datatype-splits         97
;  :decisions               293
;  :del-clause              1525
;  :final-checks            90
;  :max-generation          4
;  :max-memory              5.60
;  :memory                  5.57
;  :minimized-lits          1
;  :mk-bool-var             3803
;  :mk-clause               1556
;  :num-allocs              251585
;  :num-checks              160
;  :propagations            552
;  :quant-instantiations    1196
;  :rlimit-count            367248
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@154@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@154@07  $FVF<Int>)))
    (and
      (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
      (< $Perm.No $k@150@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@154@07  $FVF<Int>))))
  :qid |qp.fvfDomDef46|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
        (< $Perm.No $k@150@07))
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r))))
    (=
      ($FVF.lookup_int (as sm@154@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef43|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
        (< $Perm.No $k@150@07))
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r))))
    (=
      ($FVF.lookup_int (as sm@154@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef45|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@150@07 $Perm.Write))
(assert (forall ((i1@149@07 Int)) (!
  (implies
    (and (and (< i1@149@07 V@39@07) (<= 0 i1@149@07)) (< $Perm.No $k@150@07))
    (=
      (inv@151@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
      i1@149@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
      (< $Perm.No $k@150@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@151@07 r))
      r))
  :pattern ((inv@151@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@154@07  $FVF<Int>)))
    (and
      (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
      (< $Perm.No $k@150@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@154@07  $FVF<Int>))))
  :qid |qp.fvfDomDef46|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
        (< $Perm.No $k@150@07))
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r))))
    (=
      ($FVF.lookup_int (as sm@154@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef43|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
        (< $Perm.No $k@150@07))
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r))))
    (=
      ($FVF.lookup_int (as sm@154@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef45|)))
(assert (and
  (forall ((i1@149@07 Int)) (!
    (< i1@149@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r) r))
    :pattern ((inv@151@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        (<
          (ite
            (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
            $k@150@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
            $k@150@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@147@07 r))
    :pattern ((inv@151@07 r))
    :qid |qp.srp42|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@154@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))
  $Snap.unit))
; [eval] s < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 8
; [eval] this != null
(pop) ; 8
; Joined path conditions
(assert (valid_graph_vertices1 $Snap.unit this@36@07 queue@129@07 V@39@07))
(declare-const i1@155@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 108 | 0 <= i1@155@07 | live]
; [else-branch: 108 | !(0 <= i1@155@07) | live]
(push) ; 10
; [then-branch: 108 | 0 <= i1@155@07]
(assert (<= 0 i1@155@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 108 | !(0 <= i1@155@07)]
(assert (not (<= 0 i1@155@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@155@07 V@39@07) (<= 0 i1@155@07)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@155@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2561
;  :arith-add-rows          560
;  :arith-assert-diseq      59
;  :arith-assert-lower      372
;  :arith-assert-upper      181
;  :arith-bound-prop        97
;  :arith-conflicts         37
;  :arith-eq-adapter        209
;  :arith-fixed-eqs         98
;  :arith-offset-eqs        81
;  :arith-pivots            340
;  :conflicts               111
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   160
;  :datatype-splits         97
;  :decisions               293
;  :del-clause              1525
;  :final-checks            90
;  :max-generation          4
;  :max-memory              5.60
;  :memory                  5.60
;  :minimized-lits          1
;  :mk-bool-var             3876
;  :mk-clause               1610
;  :num-allocs              254012
;  :num-checks              161
;  :propagations            569
;  :quant-instantiations    1204
;  :rlimit-count            373793)
(assert (< i1@155@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@155@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 8
(declare-fun inv@156@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@155@07 Int)) (!
  (< i1@155@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@155@07 Int) (i12@155@07 Int)) (!
  (implies
    (and
      (and (< i11@155@07 V@39@07) (<= 0 i11@155@07))
      (and (< i12@155@07 V@39@07) (<= 0 i12@155@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@155@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@155@07)))
    (= i11@155@07 i12@155@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2571
;  :arith-add-rows          562
;  :arith-assert-diseq      60
;  :arith-assert-lower      376
;  :arith-assert-upper      181
;  :arith-bound-prop        97
;  :arith-conflicts         37
;  :arith-eq-adapter        210
;  :arith-fixed-eqs         98
;  :arith-offset-eqs        81
;  :arith-pivots            340
;  :conflicts               112
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   160
;  :datatype-splits         97
;  :decisions               293
;  :del-clause              1531
;  :final-checks            90
;  :max-generation          4
;  :max-memory              5.60
;  :memory                  5.60
;  :minimized-lits          1
;  :mk-bool-var             3897
;  :mk-clause               1616
;  :num-allocs              254543
;  :num-checks              162
;  :propagations            569
;  :quant-instantiations    1220
;  :rlimit-count            374726)
; Definitional axioms for inverse functions
(assert (forall ((i1@155@07 Int)) (!
  (implies
    (and (< i1@155@07 V@39@07) (<= 0 i1@155@07))
    (=
      (inv@156@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07))
      i1@155@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@156@07 r) V@39@07) (<= 0 (inv@156@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@156@07 r))
      r))
  :pattern ((inv@156@07 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@155@07 Int)) (!
  (implies
    (and (< i1@155@07 V@39@07) (<= 0 i1@155@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@157@07 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@156@07 r) V@39@07) (<= 0 (inv@156@07 r)))
    (=
      ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))) r))
  :qid |qp.fvfValDef47|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@156@07 r) V@39@07) (<= 0 (inv@156@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r) r))
  :pattern ((inv@156@07 r))
  )))
; Loop head block: Check well-definedness of edge conditions
(push) ; 8
; [eval] !(|queue| == 0)
; [eval] |queue| == 0
; [eval] |queue|
(pop) ; 8
(push) ; 8
; [eval] !!(|queue| == 0)
; [eval] !(|queue| == 0)
; [eval] |queue| == 0
; [eval] |queue|
(pop) ; 8
(pop) ; 7
(push) ; 7
; Loop head block: Establish invariant
; [eval] exc == excBeforeLoop
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(declare-const i1@158@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 109 | 0 <= i1@158@07 | live]
; [else-branch: 109 | !(0 <= i1@158@07) | live]
(push) ; 10
; [then-branch: 109 | 0 <= i1@158@07]
(assert (<= 0 i1@158@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 109 | !(0 <= i1@158@07)]
(assert (not (<= 0 i1@158@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@158@07 V@39@07) (<= 0 i1@158@07)))
(declare-const $k@159@07 $Perm)
(assert ($Perm.isReadVar $k@159@07 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@158@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2577
;  :arith-add-rows          565
;  :arith-assert-diseq      61
;  :arith-assert-lower      381
;  :arith-assert-upper      183
;  :arith-bound-prop        98
;  :arith-conflicts         37
;  :arith-eq-adapter        212
;  :arith-fixed-eqs         99
;  :arith-offset-eqs        83
;  :arith-pivots            342
;  :conflicts               112
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   160
;  :datatype-splits         97
;  :decisions               293
;  :del-clause              1589
;  :final-checks            90
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.58
;  :minimized-lits          1
;  :mk-bool-var             3917
;  :mk-clause               1620
;  :num-allocs              255618
;  :num-checks              163
;  :propagations            570
;  :quant-instantiations    1222
;  :rlimit-count            377325)
(assert (< i1@158@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@158@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 8
(declare-fun inv@160@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@159@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@158@07 Int)) (!
  (< i1@158@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@158@07))
  :qid |option$array$-aux|)))
(push) ; 8
(assert (not (forall ((i1@158@07 Int)) (!
  (implies
    (and (< i1@158@07 V@39@07) (<= 0 i1@158@07))
    (or (= $k@159@07 $Perm.No) (< $Perm.No $k@159@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2577
;  :arith-add-rows          565
;  :arith-assert-diseq      62
;  :arith-assert-lower      383
;  :arith-assert-upper      184
;  :arith-bound-prop        98
;  :arith-conflicts         37
;  :arith-eq-adapter        213
;  :arith-fixed-eqs         99
;  :arith-offset-eqs        83
;  :arith-pivots            342
;  :conflicts               113
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   160
;  :datatype-splits         97
;  :decisions               293
;  :del-clause              1591
;  :final-checks            90
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.59
;  :minimized-lits          1
;  :mk-bool-var             3924
;  :mk-clause               1622
;  :num-allocs              256052
;  :num-checks              164
;  :propagations            571
;  :quant-instantiations    1222
;  :rlimit-count            377871)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@158@07 Int) (i12@158@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@158@07 V@39@07) (<= 0 i11@158@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@158@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@158@07)))
        (< $Perm.No $k@159@07))
      (and
        (and
          (and (< i12@158@07 V@39@07) (<= 0 i12@158@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@158@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@158@07)))
        (< $Perm.No $k@159@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@158@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@158@07)))
    (= i11@158@07 i12@158@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2586
;  :arith-add-rows          567
;  :arith-assert-diseq      63
;  :arith-assert-lower      387
;  :arith-assert-upper      184
;  :arith-bound-prop        98
;  :arith-conflicts         37
;  :arith-eq-adapter        214
;  :arith-fixed-eqs         99
;  :arith-offset-eqs        83
;  :arith-pivots            342
;  :conflicts               114
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   160
;  :datatype-splits         97
;  :decisions               293
;  :del-clause              1598
;  :final-checks            90
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.59
;  :minimized-lits          1
;  :mk-bool-var             3947
;  :mk-clause               1629
;  :num-allocs              256445
;  :num-checks              165
;  :propagations            571
;  :quant-instantiations    1235
;  :rlimit-count            378731)
; Definitional axioms for inverse functions
(assert (forall ((i1@158@07 Int)) (!
  (implies
    (and (and (< i1@158@07 V@39@07) (<= 0 i1@158@07)) (< $Perm.No $k@159@07))
    (=
      (inv@160@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@158@07))
      i1@158@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@158@07))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@160@07 r) V@39@07) (<= 0 (inv@160@07 r)))
      (< $Perm.No $k@159@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@160@07 r))
      r))
  :pattern ((inv@160@07 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@160@07 r) V@39@07) (<= 0 (inv@160@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) r) r))
  :pattern ((inv@160@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@161@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@160@07 r) V@39@07) (<= 0 (inv@160@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
        $k@47@07
        $Perm.No)
      $k@159@07)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@159@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
          $k@47@07
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
      (<
        (ite
          (and (< (inv@160@07 r) V@39@07) (<= 0 (inv@160@07 r)))
          $k@159@07
          $Perm.No)
        $k@47@07)
      (<
        (ite
          (and (< (inv@160@07 r) V@39@07) (<= 0 (inv@160@07 r)))
          $k@159@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@48@07 r))
  :pattern ((inv@160@07 r))
  :qid |qp.srp49|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@160@07 r) V@39@07) (<= 0 (inv@160@07 r)))
    (= (- $k@159@07 (pTaken@161@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2725
;  :arith-add-rows          617
;  :arith-assert-diseq      76
;  :arith-assert-lower      414
;  :arith-assert-upper      197
;  :arith-bound-prop        106
;  :arith-conflicts         40
;  :arith-eq-adapter        241
;  :arith-fixed-eqs         108
;  :arith-offset-eqs        91
;  :arith-pivots            360
;  :conflicts               127
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1762
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.59
;  :minimized-lits          3
;  :mk-bool-var             4150
;  :mk-clause               1791
;  :num-allocs              258934
;  :num-checks              167
;  :propagations            636
;  :quant-instantiations    1274
;  :rlimit-count            383936
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@162@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 110 | 0 <= i1@162@07 | live]
; [else-branch: 110 | !(0 <= i1@162@07) | live]
(push) ; 10
; [then-branch: 110 | 0 <= i1@162@07]
(assert (<= 0 i1@162@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 110 | !(0 <= i1@162@07)]
(assert (not (<= 0 i1@162@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 111 | i1@162@07 < V@39@07 && 0 <= i1@162@07 | live]
; [else-branch: 111 | !(i1@162@07 < V@39@07 && 0 <= i1@162@07) | live]
(push) ; 10
; [then-branch: 111 | i1@162@07 < V@39@07 && 0 <= i1@162@07]
(assert (and (< i1@162@07 V@39@07) (<= 0 i1@162@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@162@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2725
;  :arith-add-rows          617
;  :arith-assert-diseq      76
;  :arith-assert-lower      416
;  :arith-assert-upper      197
;  :arith-bound-prop        106
;  :arith-conflicts         40
;  :arith-eq-adapter        241
;  :arith-fixed-eqs         108
;  :arith-offset-eqs        91
;  :arith-pivots            360
;  :conflicts               127
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1762
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.59
;  :minimized-lits          3
;  :mk-bool-var             4152
;  :mk-clause               1791
;  :num-allocs              259043
;  :num-checks              168
;  :propagations            636
;  :quant-instantiations    1274
;  :rlimit-count            384126)
(assert (< i1@162@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 11
; Joined path conditions
(assert (< i1@162@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2737
;  :arith-add-rows          629
;  :arith-assert-diseq      76
;  :arith-assert-lower      419
;  :arith-assert-upper      201
;  :arith-bound-prop        109
;  :arith-conflicts         41
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         111
;  :arith-offset-eqs        91
;  :arith-pivots            364
;  :conflicts               128
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1762
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          3
;  :mk-bool-var             4200
;  :mk-clause               1815
;  :num-allocs              259470
;  :num-checks              169
;  :propagations            636
;  :quant-instantiations    1292
;  :rlimit-count            385452)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 111 | !(i1@162@07 < V@39@07 && 0 <= i1@162@07)]
(assert (not (and (< i1@162@07 V@39@07) (<= 0 i1@162@07))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@162@07 V@39@07) (<= 0 i1@162@07))
  (and
    (< i1@162@07 V@39@07)
    (<= 0 i1@162@07)
    (< i1@162@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@162@07 Int)) (!
  (implies
    (and (< i1@162@07 V@39@07) (<= 0 i1@162@07))
    (and
      (< i1@162@07 V@39@07)
      (<= 0 i1@162@07)
      (< i1@162@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@162@07 Int)) (!
  (implies
    (and (< i1@162@07 V@39@07) (<= 0 i1@162@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2742
;  :arith-add-rows          636
;  :arith-assert-diseq      76
;  :arith-assert-lower      422
;  :arith-assert-upper      202
;  :arith-bound-prop        110
;  :arith-conflicts         41
;  :arith-eq-adapter        245
;  :arith-fixed-eqs         112
;  :arith-offset-eqs        91
;  :arith-pivots            370
;  :conflicts               129
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1816
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.59
;  :minimized-lits          3
;  :mk-bool-var             4239
;  :mk-clause               1845
;  :num-allocs              260102
;  :num-checks              170
;  :propagations            638
;  :quant-instantiations    1312
;  :rlimit-count            386985)
(assert (forall ((i1@162@07 Int)) (!
  (implies
    (and (< i1@162@07 V@39@07) (<= 0 i1@162@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@162@07))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@163@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 112 | 0 <= i1@163@07 | live]
; [else-branch: 112 | !(0 <= i1@163@07) | live]
(push) ; 10
; [then-branch: 112 | 0 <= i1@163@07]
(assert (<= 0 i1@163@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 112 | !(0 <= i1@163@07)]
(assert (not (<= 0 i1@163@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 113 | i1@163@07 < V@39@07 && 0 <= i1@163@07 | live]
; [else-branch: 113 | !(i1@163@07 < V@39@07 && 0 <= i1@163@07) | live]
(push) ; 10
; [then-branch: 113 | i1@163@07 < V@39@07 && 0 <= i1@163@07]
(assert (and (< i1@163@07 V@39@07) (<= 0 i1@163@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (< i1@163@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2742
;  :arith-add-rows          636
;  :arith-assert-diseq      76
;  :arith-assert-lower      424
;  :arith-assert-upper      202
;  :arith-bound-prop        110
;  :arith-conflicts         41
;  :arith-eq-adapter        245
;  :arith-fixed-eqs         112
;  :arith-offset-eqs        91
;  :arith-pivots            370
;  :conflicts               129
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1816
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.59
;  :minimized-lits          3
;  :mk-bool-var             4242
;  :mk-clause               1845
;  :num-allocs              260407
;  :num-checks              171
;  :propagations            638
;  :quant-instantiations    1312
;  :rlimit-count            387484)
(assert (< i1@163@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 11
; Joined path conditions
(assert (< i1@163@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2755
;  :arith-add-rows          648
;  :arith-assert-diseq      76
;  :arith-assert-lower      427
;  :arith-assert-upper      206
;  :arith-bound-prop        113
;  :arith-conflicts         42
;  :arith-eq-adapter        248
;  :arith-fixed-eqs         115
;  :arith-offset-eqs        91
;  :arith-pivots            374
;  :conflicts               130
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1816
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          3
;  :mk-bool-var             4291
;  :mk-clause               1869
;  :num-allocs              260840
;  :num-checks              172
;  :propagations            638
;  :quant-instantiations    1331
;  :rlimit-count            388842)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2755
;  :arith-add-rows          648
;  :arith-assert-diseq      76
;  :arith-assert-lower      427
;  :arith-assert-upper      206
;  :arith-bound-prop        113
;  :arith-conflicts         42
;  :arith-eq-adapter        248
;  :arith-fixed-eqs         115
;  :arith-offset-eqs        91
;  :arith-pivots            374
;  :conflicts               131
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1816
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          3
;  :mk-bool-var             4291
;  :mk-clause               1869
;  :num-allocs              260930
;  :num-checks              173
;  :propagations            638
;  :quant-instantiations    1331
;  :rlimit-count            388937)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 113 | !(i1@163@07 < V@39@07 && 0 <= i1@163@07)]
(assert (not (and (< i1@163@07 V@39@07) (<= 0 i1@163@07))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@163@07 V@39@07) (<= 0 i1@163@07))
  (and
    (< i1@163@07 V@39@07)
    (<= 0 i1@163@07)
    (< i1@163@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@163@07 Int)) (!
  (implies
    (and (< i1@163@07 V@39@07) (<= 0 i1@163@07))
    (and
      (< i1@163@07 V@39@07)
      (<= 0 i1@163@07)
      (< i1@163@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@163@07 Int)) (!
  (implies
    (and (< i1@163@07 V@39@07) (<= 0 i1@163@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2755
;  :arith-add-rows          653
;  :arith-assert-diseq      76
;  :arith-assert-lower      429
;  :arith-assert-upper      206
;  :arith-bound-prop        113
;  :arith-conflicts         42
;  :arith-eq-adapter        249
;  :arith-fixed-eqs         115
;  :arith-offset-eqs        91
;  :arith-pivots            378
;  :conflicts               132
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1850
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.59
;  :minimized-lits          3
;  :mk-bool-var             4313
;  :mk-clause               1879
;  :num-allocs              261451
;  :num-checks              174
;  :propagations            638
;  :quant-instantiations    1346
;  :rlimit-count            390116)
(assert (forall ((i1@163@07 Int)) (!
  (implies
    (and (< i1@163@07 V@39@07) (<= 0 i1@163@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@163@07)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@164@07 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@165@07 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 114 | 0 <= i1@164@07 | live]
; [else-branch: 114 | !(0 <= i1@164@07) | live]
(push) ; 11
; [then-branch: 114 | 0 <= i1@164@07]
(assert (<= 0 i1@164@07))
; [eval] i1 < V
(push) ; 12
; [then-branch: 115 | i1@164@07 < V@39@07 | live]
; [else-branch: 115 | !(i1@164@07 < V@39@07) | live]
(push) ; 13
; [then-branch: 115 | i1@164@07 < V@39@07]
(assert (< i1@164@07 V@39@07))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 116 | 0 <= i2@165@07 | live]
; [else-branch: 116 | !(0 <= i2@165@07) | live]
(push) ; 15
; [then-branch: 116 | 0 <= i2@165@07]
(assert (<= 0 i2@165@07))
; [eval] i2 < V
(push) ; 16
; [then-branch: 117 | i2@165@07 < V@39@07 | live]
; [else-branch: 117 | !(i2@165@07 < V@39@07) | live]
(push) ; 17
; [then-branch: 117 | i2@165@07 < V@39@07]
(assert (< i2@165@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2755
;  :arith-add-rows          653
;  :arith-assert-diseq      76
;  :arith-assert-lower      433
;  :arith-assert-upper      206
;  :arith-bound-prop        113
;  :arith-conflicts         42
;  :arith-eq-adapter        249
;  :arith-fixed-eqs         115
;  :arith-offset-eqs        91
;  :arith-pivots            378
;  :conflicts               132
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1850
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.59
;  :minimized-lits          3
;  :mk-bool-var             4318
;  :mk-clause               1879
;  :num-allocs              261930
;  :num-checks              175
;  :propagations            638
;  :quant-instantiations    1346
;  :rlimit-count            390759)
(assert (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 18
; Joined path conditions
(assert (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2768
;  :arith-add-rows          665
;  :arith-assert-diseq      76
;  :arith-assert-lower      436
;  :arith-assert-upper      210
;  :arith-bound-prop        116
;  :arith-conflicts         43
;  :arith-eq-adapter        252
;  :arith-fixed-eqs         118
;  :arith-offset-eqs        91
;  :arith-pivots            382
;  :conflicts               133
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1850
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          3
;  :mk-bool-var             4367
;  :mk-clause               1903
;  :num-allocs              262367
;  :num-checks              176
;  :propagations            638
;  :quant-instantiations    1365
;  :rlimit-count            392123)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2768
;  :arith-add-rows          665
;  :arith-assert-diseq      76
;  :arith-assert-lower      436
;  :arith-assert-upper      210
;  :arith-bound-prop        116
;  :arith-conflicts         43
;  :arith-eq-adapter        252
;  :arith-fixed-eqs         118
;  :arith-offset-eqs        91
;  :arith-pivots            382
;  :conflicts               133
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1850
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.61
;  :memory                  5.60
;  :minimized-lits          3
;  :mk-bool-var             4367
;  :mk-clause               1903
;  :num-allocs              262393
;  :num-checks              177
;  :propagations            638
;  :quant-instantiations    1365
;  :rlimit-count            392153)
(assert (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 18
; Joined path conditions
(assert (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2782
;  :arith-add-rows          679
;  :arith-assert-diseq      76
;  :arith-assert-lower      439
;  :arith-assert-upper      214
;  :arith-bound-prop        119
;  :arith-conflicts         44
;  :arith-eq-adapter        256
;  :arith-fixed-eqs         121
;  :arith-offset-eqs        91
;  :arith-pivots            386
;  :conflicts               134
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1850
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.63
;  :memory                  5.62
;  :minimized-lits          3
;  :mk-bool-var             4434
;  :mk-clause               1933
;  :num-allocs              262878
;  :num-checks              178
;  :propagations            638
;  :quant-instantiations    1387
;  :rlimit-count            393746)
(pop) ; 17
(push) ; 17
; [else-branch: 117 | !(i2@165@07 < V@39@07)]
(assert (not (< i2@165@07 V@39@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@165@07 V@39@07)
  (and
    (< i2@165@07 V@39@07)
    (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
    (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 116 | !(0 <= i2@165@07)]
(assert (not (<= 0 i2@165@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@165@07)
  (and
    (<= 0 i2@165@07)
    (implies
      (< i2@165@07 V@39@07)
      (and
        (< i2@165@07 V@39@07)
        (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
        (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 115 | !(i1@164@07 < V@39@07)]
(assert (not (< i1@164@07 V@39@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@164@07 V@39@07)
  (and
    (< i1@164@07 V@39@07)
    (implies
      (<= 0 i2@165@07)
      (and
        (<= 0 i2@165@07)
        (implies
          (< i2@165@07 V@39@07)
          (and
            (< i2@165@07 V@39@07)
            (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
            (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 114 | !(0 <= i1@164@07)]
(assert (not (<= 0 i1@164@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@164@07)
  (and
    (<= 0 i1@164@07)
    (implies
      (< i1@164@07 V@39@07)
      (and
        (< i1@164@07 V@39@07)
        (implies
          (<= 0 i2@165@07)
          (and
            (<= 0 i2@165@07)
            (implies
              (< i2@165@07 V@39@07)
              (and
                (< i2@165@07 V@39@07)
                (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
                (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 118 | Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@164@07)) == Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@165@07)) && i2@165@07 < V@39@07 && 0 <= i2@165@07 && i1@164@07 < V@39@07 && 0 <= i1@164@07 | live]
; [else-branch: 118 | !(Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@164@07)) == Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@165@07)) && i2@165@07 < V@39@07 && 0 <= i2@165@07 && i1@164@07 < V@39@07 && 0 <= i1@164@07) | live]
(push) ; 11
; [then-branch: 118 | Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@164@07)) == Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@165@07)) && i2@165@07 < V@39@07 && 0 <= i2@165@07 && i1@164@07 < V@39@07 && 0 <= i1@164@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
        (< i2@165@07 V@39@07))
      (<= 0 i2@165@07))
    (< i1@164@07 V@39@07))
  (<= 0 i1@164@07)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 118 | !(Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@164@07)) == Lookup(option$array$,sm@49@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@165@07)) && i2@165@07 < V@39@07 && 0 <= i2@165@07 && i1@164@07 < V@39@07 && 0 <= i1@164@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
          (< i2@165@07 V@39@07))
        (<= 0 i2@165@07))
      (< i1@164@07 V@39@07))
    (<= 0 i1@164@07))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
          (< i2@165@07 V@39@07))
        (<= 0 i2@165@07))
      (< i1@164@07 V@39@07))
    (<= 0 i1@164@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
      ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
    (< i2@165@07 V@39@07)
    (<= 0 i2@165@07)
    (< i1@164@07 V@39@07)
    (<= 0 i1@164@07))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@165@07 Int)) (!
  (and
    (implies
      (<= 0 i1@164@07)
      (and
        (<= 0 i1@164@07)
        (implies
          (< i1@164@07 V@39@07)
          (and
            (< i1@164@07 V@39@07)
            (implies
              (<= 0 i2@165@07)
              (and
                (<= 0 i2@165@07)
                (implies
                  (< i2@165@07 V@39@07)
                  (and
                    (< i2@165@07 V@39@07)
                    (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
                    (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
              (< i2@165@07 V@39@07))
            (<= 0 i2@165@07))
          (< i1@164@07 V@39@07))
        (<= 0 i1@164@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
          ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
        (< i2@165@07 V@39@07)
        (<= 0 i2@165@07)
        (< i1@164@07 V@39@07)
        (<= 0 i1@164@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@164@07 Int)) (!
  (forall ((i2@165@07 Int)) (!
    (and
      (implies
        (<= 0 i1@164@07)
        (and
          (<= 0 i1@164@07)
          (implies
            (< i1@164@07 V@39@07)
            (and
              (< i1@164@07 V@39@07)
              (implies
                (<= 0 i2@165@07)
                (and
                  (<= 0 i2@165@07)
                  (implies
                    (< i2@165@07 V@39@07)
                    (and
                      (< i2@165@07 V@39@07)
                      (< i1@164@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
                      (< i2@165@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
                  ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
                (< i2@165@07 V@39@07))
              (<= 0 i2@165@07))
            (< i1@164@07 V@39@07))
          (<= 0 i1@164@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
            ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
          (< i2@165@07 V@39@07)
          (<= 0 i2@165@07)
          (< i1@164@07 V@39@07)
          (<= 0 i1@164@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 8
(assert (not (forall ((i1@164@07 Int)) (!
  (forall ((i2@165@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
              (< i2@165@07 V@39@07))
            (<= 0 i2@165@07))
          (< i1@164@07 V@39@07))
        (<= 0 i1@164@07))
      (= i1@164@07 i2@165@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2802
;  :arith-add-rows          695
;  :arith-assert-diseq      77
;  :arith-assert-lower      445
;  :arith-assert-upper      216
;  :arith-bound-prop        121
;  :arith-conflicts         44
;  :arith-eq-adapter        263
;  :arith-fixed-eqs         123
;  :arith-offset-eqs        91
;  :arith-pivots            398
;  :conflicts               135
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1996
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          3
;  :mk-bool-var             4569
;  :mk-clause               2025
;  :num-allocs              264401
;  :num-checks              179
;  :propagations            644
;  :quant-instantiations    1437
;  :rlimit-count            398616
;  :time                    0.00)
(assert (forall ((i1@164@07 Int)) (!
  (forall ((i2@165@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
                ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07)))
              (< i2@165@07 V@39@07))
            (<= 0 i2@165@07))
          (< i1@164@07 V@39@07))
        (<= 0 i1@164@07))
      (= i1@164@07 i2@165@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@165@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@164@07))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@166@07 Int)
(declare-const j1@167@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 119 | 0 <= i1@166@07 | live]
; [else-branch: 119 | !(0 <= i1@166@07) | live]
(push) ; 10
; [then-branch: 119 | 0 <= i1@166@07]
(assert (<= 0 i1@166@07))
; [eval] i1 < V
(push) ; 11
; [then-branch: 120 | i1@166@07 < V@39@07 | live]
; [else-branch: 120 | !(i1@166@07 < V@39@07) | live]
(push) ; 12
; [then-branch: 120 | i1@166@07 < V@39@07]
(assert (< i1@166@07 V@39@07))
; [eval] 0 <= j1
(push) ; 13
; [then-branch: 121 | 0 <= j1@167@07 | live]
; [else-branch: 121 | !(0 <= j1@167@07) | live]
(push) ; 14
; [then-branch: 121 | 0 <= j1@167@07]
(assert (<= 0 j1@167@07))
; [eval] j1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 121 | !(0 <= j1@167@07)]
(assert (not (<= 0 j1@167@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 120 | !(i1@166@07 < V@39@07)]
(assert (not (< i1@166@07 V@39@07)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 119 | !(0 <= i1@166@07)]
(assert (not (<= 0 i1@166@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@167@07 V@39@07) (<= 0 j1@167@07)) (< i1@166@07 V@39@07))
  (<= 0 i1@166@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@166@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2802
;  :arith-add-rows          695
;  :arith-assert-diseq      77
;  :arith-assert-lower      451
;  :arith-assert-upper      216
;  :arith-bound-prop        121
;  :arith-conflicts         44
;  :arith-eq-adapter        263
;  :arith-fixed-eqs         123
;  :arith-offset-eqs        91
;  :arith-pivots            398
;  :conflicts               135
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1996
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          3
;  :mk-bool-var             4576
;  :mk-clause               2025
;  :num-allocs              265002
;  :num-checks              180
;  :propagations            644
;  :quant-instantiations    1437
;  :rlimit-count            399613)
(assert (< i1@166@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@166@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))
      V@39@07)
    (<=
      0
      (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))))
  (< $Perm.No $k@47@07)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2815
;  :arith-add-rows          707
;  :arith-assert-diseq      77
;  :arith-assert-lower      454
;  :arith-assert-upper      220
;  :arith-bound-prop        124
;  :arith-conflicts         45
;  :arith-eq-adapter        266
;  :arith-fixed-eqs         126
;  :arith-offset-eqs        91
;  :arith-pivots            402
;  :conflicts               136
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1996
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          3
;  :mk-bool-var             4627
;  :mk-clause               2049
;  :num-allocs              265504
;  :num-checks              181
;  :propagations            644
;  :quant-instantiations    1459
;  :rlimit-count            401281)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2815
;  :arith-add-rows          707
;  :arith-assert-diseq      77
;  :arith-assert-lower      454
;  :arith-assert-upper      220
;  :arith-bound-prop        124
;  :arith-conflicts         45
;  :arith-eq-adapter        266
;  :arith-fixed-eqs         126
;  :arith-offset-eqs        91
;  :arith-pivots            402
;  :conflicts               137
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              1996
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          3
;  :mk-bool-var             4627
;  :mk-clause               2049
;  :num-allocs              265594
;  :num-checks              182
;  :propagations            644
;  :quant-instantiations    1459
;  :rlimit-count            401376)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  j1@167@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2821
;  :arith-add-rows          712
;  :arith-assert-diseq      77
;  :arith-assert-lower      457
;  :arith-assert-upper      221
;  :arith-bound-prop        124
;  :arith-conflicts         46
;  :arith-eq-adapter        267
;  :arith-fixed-eqs         127
;  :arith-offset-eqs        91
;  :arith-pivots            406
;  :conflicts               138
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              2000
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.66
;  :memory                  5.63
;  :minimized-lits          3
;  :mk-bool-var             4638
;  :mk-clause               2053
;  :num-allocs              265799
;  :num-checks              183
;  :propagations            646
;  :quant-instantiations    1468
;  :rlimit-count            401922)
(assert (<
  j1@167@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))))))
(pop) ; 9
; Joined path conditions
(assert (<
  j1@167@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))))))
(pop) ; 8
(declare-fun inv@168@07 ($Ref) Int)
(declare-fun inv@169@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@166@07 Int) (j1@167@07 Int)) (!
  (and
    (< i1@166@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@167@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))) j1@167@07))
  :qid |int-aux|)))
(declare-const sm@170@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
    (=
      ($FVF.lookup_int (as sm@170@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@170@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
        (< (inv@56@07 r) V@39@07))
      (<= 0 (inv@56@07 r)))
    (=
      ($FVF.lookup_int (as sm@170@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@170@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@170@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef52|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@166@07 Int) (j11@167@07 Int) (i12@166@07 Int) (j12@167@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@167@07 V@39@07) (<= 0 j11@167@07))
            (< i11@166@07 V@39@07))
          (<= 0 i11@166@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@170@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@166@07))) j11@167@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@166@07))) j11@167@07)))
      (and
        (and
          (and
            (and (< j12@167@07 V@39@07) (<= 0 j12@167@07))
            (< i12@166@07 V@39@07))
          (<= 0 i12@166@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@170@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@166@07))) j12@167@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@166@07))) j12@167@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@166@07))) j11@167@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@166@07))) j12@167@07)))
    (and (= i11@166@07 i12@166@07) (= j11@167@07 j12@167@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2864
;  :arith-add-rows          720
;  :arith-assert-diseq      77
;  :arith-assert-lower      465
;  :arith-assert-upper      223
;  :arith-bound-prop        124
;  :arith-conflicts         46
;  :arith-eq-adapter        277
;  :arith-fixed-eqs         127
;  :arith-offset-eqs        91
;  :arith-pivots            412
;  :conflicts               139
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   167
;  :datatype-splits         101
;  :decisions               319
;  :del-clause              2102
;  :final-checks            93
;  :max-generation          4
;  :max-memory              5.67
;  :memory                  5.65
;  :minimized-lits          3
;  :mk-bool-var             4787
;  :mk-clause               2131
;  :num-allocs              267619
;  :num-checks              184
;  :propagations            664
;  :quant-instantiations    1532
;  :rlimit-count            407515
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@166@07 Int) (j1@167@07 Int)) (!
  (implies
    (and
      (and (and (< j1@167@07 V@39@07) (<= 0 j1@167@07)) (< i1@166@07 V@39@07))
      (<= 0 i1@166@07))
    (and
      (=
        (inv@168@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))) j1@167@07))
        i1@166@07)
      (=
        (inv@169@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))) j1@167@07))
        j1@167@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@166@07))) j1@167@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@169@07 r) V@39@07) (<= 0 (inv@169@07 r)))
        (< (inv@168@07 r) V@39@07))
      (<= 0 (inv@168@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@49@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@168@07 r)))) (inv@169@07 r))
      r))
  :pattern ((inv@168@07 r))
  :pattern ((inv@169@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@169@07 r) V@39@07) (<= 0 (inv@169@07 r)))
        (< (inv@168@07 r) V@39@07))
      (<= 0 (inv@168@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@170@07  $FVF<Int>) r) r))
  :pattern ((inv@168@07 r) (inv@169@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@171@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@169@07 r) V@39@07) (<= 0 (inv@169@07 r)))
        (< (inv@168@07 r) V@39@07))
      (<= 0 (inv@168@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@172@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@169@07 r) V@39@07) (<= 0 (inv@169@07 r)))
        (< (inv@168@07 r) V@39@07))
      (<= 0 (inv@168@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
            (< (inv@56@07 r) V@39@07))
          (<= 0 (inv@56@07 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@171@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@171@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3027
;  :arith-add-rows          728
;  :arith-assert-diseq      83
;  :arith-assert-lower      489
;  :arith-assert-upper      235
;  :arith-bound-prop        128
;  :arith-conflicts         46
;  :arith-eq-adapter        293
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        95
;  :arith-pivots            422
;  :conflicts               141
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 273
;  :datatype-occurs-check   181
;  :datatype-splits         109
;  :decisions               359
;  :del-clause              2273
;  :final-checks            99
;  :max-generation          4
;  :max-memory              5.71
;  :memory                  5.67
;  :minimized-lits          3
;  :mk-bool-var             5003
;  :mk-clause               2302
;  :num-allocs              271138
;  :num-checks              186
;  :propagations            720
;  :quant-instantiations    1598
;  :rlimit-count            413437
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@169@07 r) V@39@07) (<= 0 (inv@169@07 r)))
        (< (inv@168@07 r) V@39@07))
      (<= 0 (inv@168@07 r)))
    (= (- $Perm.Write (pTaken@171@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3228
;  :arith-add-rows          783
;  :arith-assert-diseq      88
;  :arith-assert-lower      517
;  :arith-assert-upper      255
;  :arith-bound-prop        143
;  :arith-conflicts         48
;  :arith-eq-adapter        308
;  :arith-fixed-eqs         148
;  :arith-offset-eqs        116
;  :arith-pivots            455
;  :conflicts               144
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 281
;  :datatype-occurs-check   188
;  :datatype-splits         113
;  :decisions               384
;  :del-clause              2437
;  :final-checks            103
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.75
;  :memory                  5.70
;  :minimized-lits          3
;  :mk-bool-var             5233
;  :mk-clause               2466
;  :num-allocs              273604
;  :num-checks              187
;  :propagations            769
;  :quant-instantiations    1672
;  :rlimit-count            419738
;  :time                    0.00)
; Chunk depleted?
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
            (< (inv@56@07 r) V@39@07))
          (<= 0 (inv@56@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@172@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 8
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3579
;  :arith-add-rows          921
;  :arith-assert-diseq      108
;  :arith-assert-lower      634
;  :arith-assert-upper      303
;  :arith-bound-prop        164
;  :arith-conflicts         52
;  :arith-eq-adapter        371
;  :arith-fixed-eqs         190
;  :arith-offset-eqs        138
;  :arith-pivots            529
;  :conflicts               154
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 289
;  :datatype-occurs-check   195
;  :datatype-splits         117
;  :decisions               426
;  :del-clause              2824
;  :final-checks            107
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.80
;  :memory                  5.75
;  :minimized-lits          3
;  :mk-bool-var             5801
;  :mk-clause               2853
;  :num-allocs              277314
;  :num-checks              188
;  :propagations            954
;  :quant-instantiations    1832
;  :rlimit-count            430546
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@169@07 r) V@39@07) (<= 0 (inv@169@07 r)))
        (< (inv@168@07 r) V@39@07))
      (<= 0 (inv@168@07 r)))
    (= (- (- $Perm.Write (pTaken@171@07 r)) (pTaken@172@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3798
;  :arith-add-rows          1017
;  :arith-assert-diseq      125
;  :arith-assert-lower      678
;  :arith-assert-upper      349
;  :arith-bound-prop        183
;  :arith-conflicts         58
;  :arith-eq-adapter        420
;  :arith-fixed-eqs         209
;  :arith-offset-eqs        160
;  :arith-pivots            564
;  :conflicts               169
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 293
;  :datatype-occurs-check   195
;  :datatype-splits         117
;  :decisions               440
;  :del-clause              3063
;  :final-checks            107
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.80
;  :memory                  5.74
;  :minimized-lits          6
;  :mk-bool-var             6129
;  :mk-clause               3092
;  :num-allocs              278894
;  :num-checks              189
;  :propagations            1027
;  :quant-instantiations    1903
;  :rlimit-count            436746
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@173@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 122 | 0 <= i1@173@07 | live]
; [else-branch: 122 | !(0 <= i1@173@07) | live]
(push) ; 10
; [then-branch: 122 | 0 <= i1@173@07]
(assert (<= 0 i1@173@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 122 | !(0 <= i1@173@07)]
(assert (not (<= 0 i1@173@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@173@07 V@39@07) (<= 0 i1@173@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@173@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3798
;  :arith-add-rows          1017
;  :arith-assert-diseq      125
;  :arith-assert-lower      680
;  :arith-assert-upper      349
;  :arith-bound-prop        183
;  :arith-conflicts         58
;  :arith-eq-adapter        420
;  :arith-fixed-eqs         209
;  :arith-offset-eqs        160
;  :arith-pivots            564
;  :conflicts               169
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 293
;  :datatype-occurs-check   195
;  :datatype-splits         117
;  :decisions               440
;  :del-clause              3063
;  :final-checks            107
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.80
;  :memory                  5.74
;  :minimized-lits          6
;  :mk-bool-var             6131
;  :mk-clause               3092
;  :num-allocs              279003
;  :num-checks              190
;  :propagations            1027
;  :quant-instantiations    1903
;  :rlimit-count            436926)
(assert (< i1@173@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@173@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 8
(declare-fun inv@174@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@173@07 Int)) (!
  (< i1@173@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@173@07))
  :qid |int-aux|)))
(declare-const sm@175@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
              (< (inv@56@07 r) V@39@07))
            (<= 0 (inv@56@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@172@07 r)))
    (=
      ($FVF.lookup_int (as sm@175@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@175@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@171@07 r)))
    (=
      ($FVF.lookup_int (as sm@175@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@175@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@175@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef55|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@173@07 Int) (i12@173@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@173@07 V@39@07) (<= 0 i11@173@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@175@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@173@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@173@07)))
      (and
        (and (< i12@173@07 V@39@07) (<= 0 i12@173@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@175@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@173@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@173@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@173@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@173@07)))
    (= i11@173@07 i12@173@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3811
;  :arith-add-rows          1019
;  :arith-assert-diseq      126
;  :arith-assert-lower      684
;  :arith-assert-upper      349
;  :arith-bound-prop        183
;  :arith-conflicts         58
;  :arith-eq-adapter        421
;  :arith-fixed-eqs         209
;  :arith-offset-eqs        160
;  :arith-pivots            564
;  :conflicts               170
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 293
;  :datatype-occurs-check   195
;  :datatype-splits         117
;  :decisions               440
;  :del-clause              3099
;  :final-checks            107
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.80
;  :memory                  5.75
;  :minimized-lits          6
;  :mk-bool-var             6192
;  :mk-clause               3128
;  :num-allocs              280298
;  :num-checks              191
;  :propagations            1029
;  :quant-instantiations    1923
;  :rlimit-count            441112)
; Definitional axioms for inverse functions
(assert (forall ((i1@173@07 Int)) (!
  (implies
    (and (< i1@173@07 V@39@07) (<= 0 i1@173@07))
    (=
      (inv@174@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@173@07))
      i1@173@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@173@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@174@07 r) V@39@07) (<= 0 (inv@174@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@174@07 r))
      r))
  :pattern ((inv@174@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@174@07 r) V@39@07) (<= 0 (inv@174@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@175@07  $FVF<Int>) r) r))
  :pattern ((inv@174@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@176@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@174@07 r) V@39@07) (<= 0 (inv@174@07 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
              (< (inv@56@07 r) V@39@07))
            (<= 0 (inv@56@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@172@07 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@177@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@174@07 r) V@39@07) (<= 0 (inv@174@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@171@07 r))
      (- $Perm.Write (pTaken@176@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
              (< (inv@56@07 r) V@39@07))
            (<= 0 (inv@56@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@172@07 r))
      (pTaken@176@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4315
;  :arith-add-rows          1246
;  :arith-assert-diseq      136
;  :arith-assert-lower      829
;  :arith-assert-upper      447
;  :arith-bound-prop        206
;  :arith-conflicts         63
;  :arith-eq-adapter        532
;  :arith-fixed-eqs         283
;  :arith-offset-eqs        170
;  :arith-pivots            653
;  :conflicts               190
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 305
;  :datatype-occurs-check   202
;  :datatype-splits         121
;  :decisions               484
;  :del-clause              3757
;  :final-checks            110
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.80
;  :memory                  5.78
;  :minimized-lits          8
;  :mk-bool-var             7313
;  :mk-clause               3786
;  :num-allocs              286336
;  :num-checks              193
;  :propagations            1286
;  :quant-instantiations    2199
;  :rlimit-count            454670
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@174@07 r) V@39@07) (<= 0 (inv@174@07 r)))
    (= (- $Perm.Write (pTaken@176@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 8
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4667
;  :arith-add-rows          1320
;  :arith-assert-diseq      146
;  :arith-assert-lower      913
;  :arith-assert-upper      496
;  :arith-bound-prop        225
;  :arith-conflicts         68
;  :arith-eq-adapter        585
;  :arith-fixed-eqs         312
;  :arith-offset-eqs        212
;  :arith-pivots            693
;  :conflicts               196
;  :datatype-accessor-ax    88
;  :datatype-constructor-ax 313
;  :datatype-occurs-check   209
;  :datatype-splits         125
;  :decisions               508
;  :del-clause              4058
;  :final-checks            113
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.87
;  :memory                  5.82
;  :minimized-lits          8
;  :mk-bool-var             7765
;  :mk-clause               4087
;  :num-allocs              289640
;  :num-checks              194
;  :propagations            1438
;  :quant-instantiations    2331
;  :rlimit-count            464323
;  :time                    0.00)
; Chunk depleted?
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@171@07 r))
      (pTaken@177@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5437
;  :arith-add-rows          1679
;  :arith-assert-diseq      173
;  :arith-assert-lower      1134
;  :arith-assert-upper      652
;  :arith-bound-prop        277
;  :arith-conflicts         79
;  :arith-eq-adapter        755
;  :arith-fixed-eqs         444
;  :arith-offset-eqs        251
;  :arith-pivots            827
;  :conflicts               224
;  :datatype-accessor-ax    88
;  :datatype-constructor-ax 317
;  :datatype-occurs-check   209
;  :datatype-splits         125
;  :decisions               543
;  :del-clause              5013
;  :final-checks            113
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.49
;  :memory                  6.16
;  :minimized-lits          9
;  :mk-bool-var             9362
;  :mk-clause               5042
;  :num-allocs              296302
;  :num-checks              195
;  :propagations            1837
;  :quant-instantiations    2724
;  :rlimit-count            481615
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@174@07 r) V@39@07) (<= 0 (inv@174@07 r)))
    (= (- (- $Perm.Write (pTaken@176@07 r)) (pTaken@177@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6016
;  :arith-add-rows          1985
;  :arith-assert-diseq      204
;  :arith-assert-lower      1293
;  :arith-assert-upper      756
;  :arith-bound-prop        312
;  :arith-conflicts         90
;  :arith-eq-adapter        883
;  :arith-fixed-eqs         516
;  :arith-offset-eqs        278
;  :arith-pivots            924
;  :conflicts               249
;  :datatype-accessor-ax    88
;  :datatype-constructor-ax 321
;  :datatype-occurs-check   209
;  :datatype-splits         125
;  :decisions               575
;  :del-clause              5732
;  :final-checks            113
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.49
;  :memory                  6.28
;  :minimized-lits          18
;  :mk-bool-var             10364
;  :mk-clause               5761
;  :num-allocs              300794
;  :num-checks              196
;  :propagations            2107
;  :quant-instantiations    2968
;  :rlimit-count            497610
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 8
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(declare-const i1@178@07 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 123 | 0 <= i1@178@07 | live]
; [else-branch: 123 | !(0 <= i1@178@07) | live]
(push) ; 11
; [then-branch: 123 | 0 <= i1@178@07]
(assert (<= 0 i1@178@07))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 123 | !(0 <= i1@178@07)]
(assert (not (<= 0 i1@178@07)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and (< i1@178@07 V@39@07) (<= 0 i1@178@07)))
(declare-const $k@179@07 $Perm)
(assert ($Perm.isReadVar $k@179@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@178@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6016
;  :arith-add-rows          1985
;  :arith-assert-diseq      205
;  :arith-assert-lower      1297
;  :arith-assert-upper      757
;  :arith-bound-prop        312
;  :arith-conflicts         90
;  :arith-eq-adapter        884
;  :arith-fixed-eqs         516
;  :arith-offset-eqs        278
;  :arith-pivots            924
;  :conflicts               249
;  :datatype-accessor-ax    88
;  :datatype-constructor-ax 321
;  :datatype-occurs-check   209
;  :datatype-splits         125
;  :decisions               575
;  :del-clause              5732
;  :final-checks            113
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.49
;  :memory                  6.28
;  :minimized-lits          18
;  :mk-bool-var             10370
;  :mk-clause               5763
;  :num-allocs              300970
;  :num-checks              197
;  :propagations            2108
;  :quant-instantiations    2968
;  :rlimit-count            497942)
(assert (< i1@178@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 10
; Joined path conditions
(assert (< i1@178@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 9
(declare-fun inv@180@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@179@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@178@07 Int)) (!
  (< i1@178@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@178@07))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@178@07 Int)) (!
  (implies
    (and (< i1@178@07 V@39@07) (<= 0 i1@178@07))
    (or (= $k@179@07 $Perm.No) (< $Perm.No $k@179@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6016
;  :arith-add-rows          1985
;  :arith-assert-diseq      206
;  :arith-assert-lower      1299
;  :arith-assert-upper      758
;  :arith-bound-prop        312
;  :arith-conflicts         90
;  :arith-eq-adapter        885
;  :arith-fixed-eqs         516
;  :arith-offset-eqs        278
;  :arith-pivots            924
;  :conflicts               250
;  :datatype-accessor-ax    88
;  :datatype-constructor-ax 321
;  :datatype-occurs-check   209
;  :datatype-splits         125
;  :decisions               575
;  :del-clause              5734
;  :final-checks            113
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.49
;  :memory                  6.28
;  :minimized-lits          18
;  :mk-bool-var             10377
;  :mk-clause               5765
;  :num-allocs              301401
;  :num-checks              198
;  :propagations            2109
;  :quant-instantiations    2968
;  :rlimit-count            498487)
(declare-const sm@181@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
        (< (inv@56@07 r) V@39@07))
      (<= 0 (inv@56@07 r)))
    (=
      ($FVF.lookup_int (as sm@181@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@181@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
    (=
      ($FVF.lookup_int (as sm@181@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@181@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@181@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef58|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@178@07 Int) (i12@178@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@178@07 V@39@07) (<= 0 i11@178@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@181@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@178@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@178@07)))
        (< $Perm.No $k@179@07))
      (and
        (and
          (and (< i12@178@07 V@39@07) (<= 0 i12@178@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@181@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@178@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@178@07)))
        (< $Perm.No $k@179@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@178@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@178@07)))
    (= i11@178@07 i12@178@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6031
;  :arith-add-rows          1987
;  :arith-assert-diseq      207
;  :arith-assert-lower      1303
;  :arith-assert-upper      758
;  :arith-bound-prop        312
;  :arith-conflicts         90
;  :arith-eq-adapter        886
;  :arith-fixed-eqs         516
;  :arith-offset-eqs        278
;  :arith-pivots            924
;  :conflicts               251
;  :datatype-accessor-ax    88
;  :datatype-constructor-ax 321
;  :datatype-occurs-check   209
;  :datatype-splits         125
;  :decisions               575
;  :del-clause              5745
;  :final-checks            113
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              6.49
;  :memory                  6.30
;  :minimized-lits          18
;  :mk-bool-var             10416
;  :mk-clause               5776
;  :num-allocs              302371
;  :num-checks              199
;  :propagations            2111
;  :quant-instantiations    2992
;  :rlimit-count            501341
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@178@07 Int)) (!
  (implies
    (and (and (< i1@178@07 V@39@07) (<= 0 i1@178@07)) (< $Perm.No $k@179@07))
    (=
      (inv@180@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@178@07))
      i1@178@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@178@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
      (< $Perm.No $k@179@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@180@07 r))
      r))
  :pattern ((inv@180@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@181@07  $FVF<Int>) r) r))
  :pattern ((inv@180@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@182@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
            (< (inv@56@07 r) V@39@07))
          (<= 0 (inv@56@07 r)))
        $Perm.Write
        $Perm.No)
      $k@179@07)
    $Perm.No))
(define-fun pTaken@183@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@179@07 (pTaken@182@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@179@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
              (< (inv@56@07 r) V@39@07))
            (<= 0 (inv@56@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
          (< (inv@56@07 r) V@39@07))
        (<= 0 (inv@56@07 r)))
      (<
        (ite
          (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
          $k@179@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
          $k@179@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@57@07 r))
  :pattern ((inv@56@07 r))
  :pattern ((inv@180@07 r))
  :qid |qp.srp59|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
    (= (- $k@179@07 (pTaken@182@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6322
;  :arith-add-rows          2020
;  :arith-assert-diseq      214
;  :arith-assert-lower      1346
;  :arith-assert-upper      784
;  :arith-bound-prop        325
;  :arith-conflicts         93
;  :arith-eq-adapter        917
;  :arith-fixed-eqs         531
;  :arith-offset-eqs        296
;  :arith-pivots            948
;  :conflicts               258
;  :datatype-accessor-ax    90
;  :datatype-constructor-ax 337
;  :datatype-occurs-check   223
;  :datatype-splits         133
;  :decisions               617
;  :del-clause              6023
;  :final-checks            119
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              6.49
;  :memory                  6.31
;  :minimized-lits          18
;  :mk-bool-var             10772
;  :mk-clause               6052
;  :num-allocs              306768
;  :num-checks              201
;  :propagations            2213
;  :quant-instantiations    3100
;  :rlimit-count            510791
;  :time                    0.00)
; Constrain original permissions $k@179@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
      (<
        (ite
          (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
          $k@179@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
          $k@179@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@60@07 r))
  :pattern ((inv@180@07 r))
  :qid |qp.srp60|)))
; Intermediate check if already taken enough permissions
(push) ; 9
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
    (= (- (- $k@179@07 (pTaken@182@07 r)) (pTaken@183@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6508
;  :arith-add-rows          2109
;  :arith-assert-diseq      229
;  :arith-assert-lower      1381
;  :arith-assert-upper      816
;  :arith-bound-prop        338
;  :arith-conflicts         99
;  :arith-eq-adapter        963
;  :arith-fixed-eqs         543
;  :arith-offset-eqs        307
;  :arith-pivots            971
;  :conflicts               274
;  :datatype-accessor-ax    90
;  :datatype-constructor-ax 341
;  :datatype-occurs-check   223
;  :datatype-splits         133
;  :decisions               632
;  :del-clause              6274
;  :final-checks            119
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              6.49
;  :memory                  6.29
;  :minimized-lits          24
;  :mk-bool-var             11079
;  :mk-clause               6303
;  :num-allocs              308464
;  :num-checks              202
;  :propagations            2295
;  :quant-instantiations    3154
;  :rlimit-count            516073
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@184@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@184@07  $FVF<Int>)))
    (and
      (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
      (< $Perm.No $k@179@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@184@07  $FVF<Int>))))
  :qid |qp.fvfDomDef64|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
        (< $Perm.No $k@179@07))
      (and
        (and
          (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
          (< (inv@56@07 r) V@39@07))
        (<= 0 (inv@56@07 r))))
    (=
      ($FVF.lookup_int (as sm@184@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@184@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef61|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
        (< $Perm.No $k@179@07))
      (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r))))
    (=
      ($FVF.lookup_int (as sm@184@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@184@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef62|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@184@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef63|)))
(pop) ; 8
; Joined path conditions
(assert ($Perm.isReadVar $k@179@07 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
        (< (inv@56@07 r) V@39@07))
      (<= 0 (inv@56@07 r)))
    (=
      ($FVF.lookup_int (as sm@181@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@181@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef56|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
    (=
      ($FVF.lookup_int (as sm@181@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@181@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@181@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef58|)))
(assert (forall ((i1@178@07 Int)) (!
  (implies
    (and (and (< i1@178@07 V@39@07) (<= 0 i1@178@07)) (< $Perm.No $k@179@07))
    (=
      (inv@180@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@178@07))
      i1@178@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@178@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
      (< $Perm.No $k@179@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@180@07 r))
      r))
  :pattern ((inv@180@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@184@07  $FVF<Int>)))
    (and
      (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
      (< $Perm.No $k@179@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@184@07  $FVF<Int>))))
  :qid |qp.fvfDomDef64|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
        (< $Perm.No $k@179@07))
      (and
        (and
          (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
          (< (inv@56@07 r) V@39@07))
        (<= 0 (inv@56@07 r))))
    (=
      ($FVF.lookup_int (as sm@184@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@184@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r))
  :qid |qp.fvfValDef61|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
        (< $Perm.No $k@179@07))
      (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r))))
    (=
      ($FVF.lookup_int (as sm@184@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@184@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r))
  :qid |qp.fvfValDef62|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@45@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@184@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef63|)))
(assert (and
  (forall ((i1@178@07 Int)) (!
    (< i1@178@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@178@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@181@07  $FVF<Int>) r) r))
    :pattern ((inv@180@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
                (< (inv@56@07 r) V@39@07))
              (<= 0 (inv@56@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@57@07 r) V@39@07) (<= 0 (inv@57@07 r)))
            (< (inv@56@07 r) V@39@07))
          (<= 0 (inv@56@07 r)))
        (<
          (ite
            (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
            $k@179@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
            $k@179@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@57@07 r))
    :pattern ((inv@56@07 r))
    :pattern ((inv@180@07 r))
    :qid |qp.srp59|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@60@07 r) V@39@07) (<= 0 (inv@60@07 r)))
        (<
          (ite
            (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
            $k@179@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@180@07 r) V@39@07) (<= 0 (inv@180@07 r)))
            $k@179@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@60@07 r))
    :pattern ((inv@180@07 r))
    :qid |qp.srp60|))))
(set-option :timeout 0)
(push) ; 8
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@184@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 8
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6992
;  :arith-add-rows          2290
;  :arith-assert-diseq      230
;  :arith-assert-lower      1461
;  :arith-assert-upper      874
;  :arith-bound-prop        381
;  :arith-conflicts         104
;  :arith-eq-adapter        1034
;  :arith-fixed-eqs         600
;  :arith-offset-eqs        338
;  :arith-pivots            1065
;  :conflicts               289
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 346
;  :datatype-occurs-check   223
;  :datatype-splits         133
;  :decisions               662
;  :del-clause              7383
;  :final-checks            119
;  :interface-eqs           2
;  :max-generation          6
;  :max-memory              6.61
;  :memory                  6.55
;  :minimized-lits          26
;  :mk-bool-var             12596
;  :mk-clause               7414
;  :num-allocs              316485
;  :num-checks              203
;  :propagations            2503
;  :quant-instantiations    3539
;  :rlimit-count            536914
;  :time                    0.01)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@184@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
; [eval] 0 <= s
; [eval] s < V
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 8
; [eval] this != null
(pop) ; 8
; Joined path conditions
(push) ; 8
(assert (not (valid_graph_vertices1 $Snap.unit this@36@07 queue@123@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 8
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7483
;  :arith-add-rows          2482
;  :arith-assert-diseq      239
;  :arith-assert-lower      1553
;  :arith-assert-upper      1010
;  :arith-bound-prop        395
;  :arith-conflicts         113
;  :arith-eq-adapter        1134
;  :arith-fixed-eqs         649
;  :arith-offset-eqs        380
;  :arith-pivots            1129
;  :conflicts               311
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 360
;  :datatype-occurs-check   238
;  :datatype-splits         143
;  :decisions               813
;  :del-clause              8700
;  :final-checks            130
;  :interface-eqs           8
;  :max-generation          7
;  :max-memory              6.61
;  :memory                  6.57
;  :minimized-lits          28
;  :mk-bool-var             14212
;  :mk-clause               8764
;  :num-allocs              321877
;  :num-checks              204
;  :propagations            2793
;  :quant-instantiations    3894
;  :rlimit-count            552298
;  :time                    0.01)
(assert (valid_graph_vertices1 $Snap.unit this@36@07 queue@123@07 V@39@07))
(declare-const i1@185@07 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 124 | 0 <= i1@185@07 | live]
; [else-branch: 124 | !(0 <= i1@185@07) | live]
(push) ; 10
; [then-branch: 124 | 0 <= i1@185@07]
(assert (<= 0 i1@185@07))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 124 | !(0 <= i1@185@07)]
(assert (not (<= 0 i1@185@07)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@185@07 V@39@07) (<= 0 i1@185@07)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@185@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7484
;  :arith-add-rows          2482
;  :arith-assert-diseq      239
;  :arith-assert-lower      1555
;  :arith-assert-upper      1010
;  :arith-bound-prop        395
;  :arith-conflicts         113
;  :arith-eq-adapter        1134
;  :arith-fixed-eqs         649
;  :arith-offset-eqs        380
;  :arith-pivots            1129
;  :conflicts               311
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 360
;  :datatype-occurs-check   238
;  :datatype-splits         143
;  :decisions               813
;  :del-clause              8700
;  :final-checks            130
;  :interface-eqs           8
;  :max-generation          7
;  :max-memory              6.61
;  :memory                  6.57
;  :minimized-lits          28
;  :mk-bool-var             14233
;  :mk-clause               8789
;  :num-allocs              322122
;  :num-checks              205
;  :propagations            2799
;  :quant-instantiations    3897
;  :rlimit-count            552666)
(assert (< i1@185@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 9
; Joined path conditions
(assert (< i1@185@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 8
(declare-fun inv@186@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@185@07 Int)) (!
  (< i1@185@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@185@07))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@185@07 Int) (i12@185@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@185@07 V@39@07) (<= 0 i11@185@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@185@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@185@07)))
      (and
        (and (< i12@185@07 V@39@07) (<= 0 i12@185@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@185@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@185@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@185@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@185@07)))
    (= i11@185@07 i12@185@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7495
;  :arith-add-rows          2484
;  :arith-assert-diseq      240
;  :arith-assert-lower      1559
;  :arith-assert-upper      1010
;  :arith-bound-prop        395
;  :arith-conflicts         113
;  :arith-eq-adapter        1135
;  :arith-fixed-eqs         649
;  :arith-offset-eqs        380
;  :arith-pivots            1129
;  :conflicts               312
;  :datatype-accessor-ax    102
;  :datatype-constructor-ax 360
;  :datatype-occurs-check   238
;  :datatype-splits         143
;  :decisions               813
;  :del-clause              8711
;  :final-checks            130
;  :interface-eqs           8
;  :max-generation          7
;  :max-memory              6.61
;  :memory                  6.57
;  :minimized-lits          28
;  :mk-bool-var             14262
;  :mk-clause               8800
;  :num-allocs              322673
;  :num-checks              206
;  :propagations            2799
;  :quant-instantiations    3915
;  :rlimit-count            553762)
; Definitional axioms for inverse functions
(assert (forall ((i1@185@07 Int)) (!
  (implies
    (and (< i1@185@07 V@39@07) (<= 0 i1@185@07))
    (=
      (inv@186@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@185@07))
      i1@185@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@185@07))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@186@07 r) V@39@07) (<= 0 (inv@186@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@186@07 r))
      r))
  :pattern ((inv@186@07 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@186@07 r) V@39@07) (<= 0 (inv@186@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@121@07  $FVF<Bool>) r) r))
  :pattern ((inv@186@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@187@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@186@07 r) V@39@07) (<= 0 (inv@186@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@120@07 r) V@39@07) (<= 0 (inv@120@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@120@07 r) V@39@07) (<= 0 (inv@120@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@187@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7946
;  :arith-add-rows          2697
;  :arith-assert-diseq      250
;  :arith-assert-lower      1639
;  :arith-assert-upper      1078
;  :arith-bound-prop        425
;  :arith-conflicts         121
;  :arith-eq-adapter        1209
;  :arith-fixed-eqs         693
;  :arith-offset-eqs        406
;  :arith-pivots            1206
;  :conflicts               334
;  :datatype-accessor-ax    103
;  :datatype-constructor-ax 372
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               878
;  :del-clause              9607
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          7
;  :max-memory              6.64
;  :memory                  6.59
;  :minimized-lits          30
;  :mk-bool-var             15396
;  :mk-clause               9714
;  :num-allocs              328665
;  :num-checks              208
;  :propagations            2971
;  :quant-instantiations    4253
;  :rlimit-count            569563
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 8
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@186@07 r) V@39@07) (<= 0 (inv@186@07 r)))
    (= (- $Perm.Write (pTaken@187@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7966
;  :arith-add-rows          2707
;  :arith-assert-diseq      252
;  :arith-assert-lower      1644
;  :arith-assert-upper      1084
;  :arith-bound-prop        426
;  :arith-conflicts         122
;  :arith-eq-adapter        1214
;  :arith-fixed-eqs         695
;  :arith-offset-eqs        406
;  :arith-pivots            1210
;  :conflicts               335
;  :datatype-accessor-ax    103
;  :datatype-constructor-ax 372
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               878
;  :del-clause              9638
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          7
;  :max-memory              6.64
;  :memory                  6.60
;  :minimized-lits          30
;  :mk-bool-var             15446
;  :mk-clause               9745
;  :num-allocs              329085
;  :num-checks              209
;  :propagations            2976
;  :quant-instantiations    4270
;  :rlimit-count            570735)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; Loop head block: Execute statements of loop head block (in invariant state)
(push) ; 8
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@156@07 r) V@39@07) (<= 0 (inv@156@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@156@07 r))
      r))
  :pattern ((inv@156@07 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@156@07 r) V@39@07) (<= 0 (inv@156@07 r)))
    (=
      ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))) r))
  :qid |qp.fvfValDef47|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef48|)))
(assert (forall ((i1@155@07 Int)) (!
  (implies
    (and (< i1@155@07 V@39@07) (<= 0 i1@155@07))
    (=
      (inv@156@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07))
      i1@155@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07))
  )))
(assert (forall ((i1@155@07 Int)) (!
  (implies
    (and (< i1@155@07 V@39@07) (<= 0 i1@155@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07))
  :qid |bool-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@156@07 r) V@39@07) (<= 0 (inv@156@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r) r))
  :pattern ((inv@156@07 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@147@07 r))
      r))
  :pattern ((inv@147@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@148@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@148@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef40|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@148@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef41|)))
(assert ($Perm.isReadVar $k@150@07 $Perm.Write))
(assert (forall ((i1@149@07 Int)) (!
  (implies
    (and (and (< i1@149@07 V@39@07) (<= 0 i1@149@07)) (< $Perm.No $k@150@07))
    (=
      (inv@151@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
      i1@149@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
      (< $Perm.No $k@150@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@151@07 r))
      r))
  :pattern ((inv@151@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@154@07  $FVF<Int>)))
    (and
      (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
      (< $Perm.No $k@150@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@154@07  $FVF<Int>))))
  :qid |qp.fvfDomDef46|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
        (< $Perm.No $k@150@07))
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r))))
    (=
      ($FVF.lookup_int (as sm@154@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef43|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
        (< $Perm.No $k@150@07))
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r))))
    (=
      ($FVF.lookup_int (as sm@154@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@154@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef45|)))
(assert (forall ((i1@146@07 Int)) (!
  (implies
    (and (< i1@146@07 V@39@07) (<= 0 i1@146@07))
    (=
      (inv@147@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07))
      i1@146@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07))
  )))
(assert (forall ((i1@146@07 Int)) (!
  (implies
    (and (< i1@146@07 V@39@07) (<= 0 i1@146@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r) r))
  :pattern ((inv@147@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))
  $Snap.unit))
(assert (forall ((i1@149@07 Int)) (!
  (< i1@149@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@149@07))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@148@07  $FVF<Int>) r) r))
  :pattern ((inv@151@07 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
      (<
        (ite
          (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
          $k@150@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@151@07 r) V@39@07) (<= 0 (inv@151@07 r)))
          $k@150@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@147@07 r))
  :pattern ((inv@151@07 r))
  :qid |qp.srp42|)))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@154@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))))
  $Snap.unit))
(assert (valid_graph_vertices1 $Snap.unit this@36@07 queue@129@07 V@39@07))
(assert (forall ((i1@155@07 Int)) (!
  (< i1@155@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@155@07))
  :qid |bool-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@143@07 r)))) (inv@144@07 r))
      r))
  :pattern ((inv@143@07 r))
  :pattern ((inv@144@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@145@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@145@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@145@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((i1@141@07 Int) (j1@142@07 Int)) (!
  (implies
    (and
      (and (and (< j1@142@07 V@39@07) (<= 0 j1@142@07)) (< i1@141@07 V@39@07))
      (<= 0 i1@141@07))
    (and
      (=
        (inv@143@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
        i1@141@07)
      (=
        (inv@144@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
        j1@142@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
  )))
(assert (forall ((i1@141@07 Int) (j1@142@07 Int)) (!
  (implies
    (and
      (and (and (< j1@142@07 V@39@07) (<= 0 j1@142@07)) (< i1@141@07 V@39@07))
      (<= 0 i1@141@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@145@07  $FVF<Int>) r) r))
  :pattern ((inv@143@07 r) (inv@144@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))))
(assert (forall ((i1@146@07 Int)) (!
  (< i1@146@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@146@07))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
      (< $Perm.No $k@134@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@135@07 r))
      r))
  :pattern ((inv@135@07 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
      (< $Perm.No $k@134@07)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef36|)))
(assert (forall ((i1@133@07 Int)) (!
  (implies
    (and (and (< i1@133@07 V@39@07) (<= 0 i1@133@07)) (< $Perm.No $k@134@07))
    (=
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
      i1@133@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  )))
(assert (forall ((i1@133@07 Int)) (!
  (<= $Perm.No $k@134@07)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@133@07 Int)) (!
  (<= $k@134@07 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@133@07 Int)) (!
  (implies
    (and (and (< i1@133@07 V@39@07) (<= 0 i1@133@07)) (< $Perm.No $k@134@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r) r))
  :pattern ((inv@135@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))
  $Snap.unit))
(assert (forall ((i1@137@07 Int)) (!
  (implies
    (and (< i1@137@07 V@39@07) (<= 0 i1@137@07))
    (and
      (< i1@137@07 V@39@07)
      (<= 0 i1@137@07)
      (< i1@137@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@137@07 Int)) (!
  (implies
    (and (< i1@137@07 V@39@07) (<= 0 i1@137@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@137@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))
  $Snap.unit))
(assert (forall ((i1@138@07 Int)) (!
  (implies
    (and (< i1@138@07 V@39@07) (<= 0 i1@138@07))
    (and
      (< i1@138@07 V@39@07)
      (<= 0 i1@138@07)
      (< i1@138@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@138@07 Int)) (!
  (implies
    (and (< i1@138@07 V@39@07) (<= 0 i1@138@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@138@07)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))
  $Snap.unit))
(assert (forall ((i1@139@07 Int)) (!
  (forall ((i2@140@07 Int)) (!
    (and
      (implies
        (<= 0 i1@139@07)
        (and
          (<= 0 i1@139@07)
          (implies
            (< i1@139@07 V@39@07)
            (and
              (< i1@139@07 V@39@07)
              (implies
                (<= 0 i2@140@07)
                (and
                  (<= 0 i2@140@07)
                  (implies
                    (< i2@140@07 V@39@07)
                    (and
                      (< i2@140@07 V@39@07)
                      (< i1@139@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                      (< i2@140@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                  ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
                (< i2@140@07 V@39@07))
              (<= 0 i2@140@07))
            (< i1@139@07 V@39@07))
          (<= 0 i1@139@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
          (< i2@140@07 V@39@07)
          (<= 0 i2@140@07)
          (< i1@139@07 V@39@07)
          (<= 0 i1@139@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@139@07 Int)) (!
  (forall ((i2@140@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07)))
              (< i2@140@07 V@39@07))
            (<= 0 i2@140@07))
          (< i1@139@07 V@39@07))
        (<= 0 i1@139@07))
      (= i1@139@07 i2@140@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@140@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@139@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))))
(assert (forall ((i1@141@07 Int) (j1@142@07 Int)) (!
  (and
    (< i1@141@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@142@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@141@07))) j1@142@07))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@134@07 $Perm.Write))
(assert (= $t@132@07 ($Snap.combine ($Snap.first $t@132@07) ($Snap.second $t@132@07))))
(assert (= ($Snap.first $t@132@07) $Snap.unit))
(assert (=
  ($Snap.second $t@132@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@132@07))
    ($Snap.second ($Snap.second $t@132@07)))))
(assert (= ($Snap.first ($Snap.second $t@132@07)) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second $t@132@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@132@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@132@07))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@132@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))
(assert (forall ((i1@133@07 Int)) (!
  (< i1@133@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@133@07))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 10)
(check-sat)
; unknown
; Loop head block: Follow loop-internal edges
; [eval] !(|queue| == 0)
; [eval] |queue| == 0
; [eval] |queue|
(push) ; 9
(assert (not (= (Seq_length queue@129@07) 0)))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10949
;  :arith-add-rows          3777
;  :arith-assert-diseq      346
;  :arith-assert-lower      2417
;  :arith-assert-upper      1647
;  :arith-bound-prop        620
;  :arith-conflicts         137
;  :arith-eq-adapter        1660
;  :arith-fixed-eqs         1025
;  :arith-offset-eqs        688
;  :arith-pivots            1557
;  :conflicts               358
;  :datatype-accessor-ax    125
;  :datatype-constructor-ax 384
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1295
;  :del-clause              16414
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.47
;  :minimized-lits          35
;  :mk-bool-var             22585
;  :mk-clause               16900
;  :num-allocs              361291
;  :num-checks              212
;  :propagations            4658
;  :quant-instantiations    6335
;  :rlimit-count            676995
;  :time                    0.01)
(push) ; 9
(assert (not (not (= (Seq_length queue@129@07) 0))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11640
;  :arith-add-rows          4071
;  :arith-assert-diseq      357
;  :arith-assert-lower      2614
;  :arith-assert-upper      1766
;  :arith-bound-prop        645
;  :arith-conflicts         142
;  :arith-eq-adapter        1774
;  :arith-fixed-eqs         1134
;  :arith-offset-eqs        703
;  :arith-pivots            1633
;  :conflicts               364
;  :datatype-accessor-ax    125
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17730
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.47
;  :minimized-lits          35
;  :mk-bool-var             24071
;  :mk-clause               18216
;  :num-allocs              366012
;  :num-checks              213
;  :propagations            5106
;  :quant-instantiations    6816
;  :rlimit-count            697082
;  :time                    0.01)
; [then-branch: 125 | |queue@129@07| != 0 | live]
; [else-branch: 125 | |queue@129@07| == 0 | live]
(push) ; 9
; [then-branch: 125 | |queue@129@07| != 0]
(assert (not (= (Seq_length queue@129@07) 0)))
; [exec]
; u := queue[0]
; [eval] queue[0]
(set-option :timeout 0)
(push) ; 10
(assert (not (< 0 (Seq_length queue@129@07))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11640
;  :arith-add-rows          4071
;  :arith-assert-diseq      358
;  :arith-assert-lower      2616
;  :arith-assert-upper      1766
;  :arith-bound-prop        645
;  :arith-conflicts         142
;  :arith-eq-adapter        1775
;  :arith-fixed-eqs         1134
;  :arith-offset-eqs        703
;  :arith-pivots            1633
;  :conflicts               365
;  :datatype-accessor-ax    125
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17730
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.47
;  :minimized-lits          35
;  :mk-bool-var             24074
;  :mk-clause               18220
;  :num-allocs              366154
;  :num-checks              214
;  :propagations            5107
;  :quant-instantiations    6817
;  :rlimit-count            697227)
(declare-const u@188@07 Int)
(assert (= u@188@07 (Seq_index queue@129@07 0)))
; [exec]
; evaluationDummy1 := queue[..0] ++ queue[0 + 1..]
; [eval] queue[..0] ++ queue[0 + 1..]
; [eval] queue[..0]
; [eval] queue[0 + 1..]
; [eval] 0 + 1
(declare-const evaluationDummy1@189@07 Seq<Int>)
(assert (Seq_equal
  evaluationDummy1@189@07
  (Seq_append (Seq_take queue@129@07 0) (Seq_drop queue@129@07 1))))
; [exec]
; k := 0
; [exec]
; label loop1
; [exec]
; excBeforeLoop1 := exc
; [exec]
; v := 0
(declare-const k@190@07 Int)
(declare-const queue@191@07 Seq<Int>)
(declare-const flatten@192@07 Int)
(declare-const v@193@07 Int)
(declare-const evaluationDummy2@194@07 Int)
(push) ; 10
; Loop head block: Check well-definedness of invariant
(declare-const $t@195@07 $Snap)
(assert (= $t@195@07 ($Snap.combine ($Snap.first $t@195@07) ($Snap.second $t@195@07))))
(assert (= ($Snap.first $t@195@07) $Snap.unit))
; [eval] exc == excBeforeLoop1
(assert (=
  ($Snap.second $t@195@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@195@07))
    ($Snap.second ($Snap.second $t@195@07)))))
(assert (= ($Snap.first ($Snap.second $t@195@07)) $Snap.unit))
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second $t@195@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@195@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@195@07))) $Snap.unit))
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@195@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))
(declare-const i1@196@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 126 | 0 <= i1@196@07 | live]
; [else-branch: 126 | !(0 <= i1@196@07) | live]
(push) ; 13
; [then-branch: 126 | 0 <= i1@196@07]
(assert (<= 0 i1@196@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 126 | !(0 <= i1@196@07)]
(assert (not (<= 0 i1@196@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@196@07 V@39@07) (<= 0 i1@196@07)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@196@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11681
;  :arith-add-rows          4075
;  :arith-assert-diseq      359
;  :arith-assert-lower      2626
;  :arith-assert-upper      1769
;  :arith-bound-prop        646
;  :arith-conflicts         142
;  :arith-eq-adapter        1780
;  :arith-fixed-eqs         1136
;  :arith-offset-eqs        703
;  :arith-pivots            1636
;  :conflicts               365
;  :datatype-accessor-ax    129
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17730
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.49
;  :minimized-lits          35
;  :mk-bool-var             24121
;  :mk-clause               18251
;  :num-allocs              366840
;  :num-checks              215
;  :propagations            5116
;  :quant-instantiations    6827
;  :rlimit-count            698735)
(assert (< i1@196@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@196@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(declare-const $k@197@07 $Perm)
(assert ($Perm.isReadVar $k@197@07 $Perm.Write))
(pop) ; 11
(declare-fun inv@198@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@197@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@196@07 Int)) (!
  (< i1@196@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@196@07 Int)) (!
  (implies
    (and (< i1@196@07 V@39@07) (<= 0 i1@196@07))
    (or (= $k@197@07 $Perm.No) (< $Perm.No $k@197@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11681
;  :arith-add-rows          4075
;  :arith-assert-diseq      360
;  :arith-assert-lower      2628
;  :arith-assert-upper      1770
;  :arith-bound-prop        646
;  :arith-conflicts         142
;  :arith-eq-adapter        1781
;  :arith-fixed-eqs         1136
;  :arith-offset-eqs        703
;  :arith-pivots            1636
;  :conflicts               366
;  :datatype-accessor-ax    129
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17730
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.49
;  :minimized-lits          35
;  :mk-bool-var             24128
;  :mk-clause               18253
;  :num-allocs              367309
;  :num-checks              216
;  :propagations            5117
;  :quant-instantiations    6827
;  :rlimit-count            699305)
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@196@07 Int) (i12@196@07 Int)) (!
  (implies
    (and
      (and (and (< i11@196@07 V@39@07) (<= 0 i11@196@07)) (< $Perm.No $k@197@07))
      (and (and (< i12@196@07 V@39@07) (<= 0 i12@196@07)) (< $Perm.No $k@197@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@196@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@196@07)))
    (= i11@196@07 i12@196@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11692
;  :arith-add-rows          4077
;  :arith-assert-diseq      361
;  :arith-assert-lower      2632
;  :arith-assert-upper      1770
;  :arith-bound-prop        646
;  :arith-conflicts         142
;  :arith-eq-adapter        1782
;  :arith-fixed-eqs         1136
;  :arith-offset-eqs        703
;  :arith-pivots            1636
;  :conflicts               367
;  :datatype-accessor-ax    129
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17736
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.49
;  :minimized-lits          35
;  :mk-bool-var             24149
;  :mk-clause               18259
;  :num-allocs              367706
;  :num-checks              217
;  :propagations            5117
;  :quant-instantiations    6846
;  :rlimit-count            700176)
; Definitional axioms for inverse functions
(assert (forall ((i1@196@07 Int)) (!
  (implies
    (and (and (< i1@196@07 V@39@07) (<= 0 i1@196@07)) (< $Perm.No $k@197@07))
    (=
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
      i1@196@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
      (< $Perm.No $k@197@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@198@07 r))
      r))
  :pattern ((inv@198@07 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@196@07 Int)) (!
  (<= $Perm.No $k@197@07)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@196@07 Int)) (!
  (<= $k@197@07 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@196@07 Int)) (!
  (implies
    (and (and (< i1@196@07 V@39@07) (<= 0 i1@196@07)) (< $Perm.No $k@197@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@199@07 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
      (< $Perm.No $k@197@07)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r))
  :qid |qp.fvfValDef65|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r) r))
  :pattern ((inv@198@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@200@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 127 | 0 <= i1@200@07 | live]
; [else-branch: 127 | !(0 <= i1@200@07) | live]
(push) ; 13
; [then-branch: 127 | 0 <= i1@200@07]
(assert (<= 0 i1@200@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 127 | !(0 <= i1@200@07)]
(assert (not (<= 0 i1@200@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 128 | i1@200@07 < V@39@07 && 0 <= i1@200@07 | live]
; [else-branch: 128 | !(i1@200@07 < V@39@07 && 0 <= i1@200@07) | live]
(push) ; 13
; [then-branch: 128 | i1@200@07 < V@39@07 && 0 <= i1@200@07]
(assert (and (< i1@200@07 V@39@07) (<= 0 i1@200@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@200@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11698
;  :arith-add-rows          4077
;  :arith-assert-diseq      361
;  :arith-assert-lower      2634
;  :arith-assert-upper      1771
;  :arith-bound-prop        646
;  :arith-conflicts         142
;  :arith-eq-adapter        1782
;  :arith-fixed-eqs         1136
;  :arith-offset-eqs        703
;  :arith-pivots            1636
;  :conflicts               367
;  :datatype-accessor-ax    130
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17736
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.50
;  :minimized-lits          35
;  :mk-bool-var             24160
;  :mk-clause               18259
;  :num-allocs              368894
;  :num-checks              218
;  :propagations            5117
;  :quant-instantiations    6846
;  :rlimit-count            702511)
(assert (< i1@200@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@200@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11724
;  :arith-add-rows          4091
;  :arith-assert-diseq      361
;  :arith-assert-lower      2638
;  :arith-assert-upper      1776
;  :arith-bound-prop        650
;  :arith-conflicts         143
;  :arith-eq-adapter        1786
;  :arith-fixed-eqs         1140
;  :arith-offset-eqs        703
;  :arith-pivots            1641
;  :conflicts               368
;  :datatype-accessor-ax    130
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17736
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.51
;  :minimized-lits          35
;  :mk-bool-var             24268
;  :mk-clause               18317
;  :num-allocs              369646
;  :num-checks              219
;  :propagations            5119
;  :quant-instantiations    6893
;  :rlimit-count            705315)
; [eval] (None(): option[array])
(pop) ; 13
(push) ; 13
; [else-branch: 128 | !(i1@200@07 < V@39@07 && 0 <= i1@200@07)]
(assert (not (and (< i1@200@07 V@39@07) (<= 0 i1@200@07))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@200@07 V@39@07) (<= 0 i1@200@07))
  (and
    (< i1@200@07 V@39@07)
    (<= 0 i1@200@07)
    (< i1@200@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@200@07 Int)) (!
  (implies
    (and (< i1@200@07 V@39@07) (<= 0 i1@200@07))
    (and
      (< i1@200@07 V@39@07)
      (<= 0 i1@200@07)
      (< i1@200@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@200@07 Int)) (!
  (implies
    (and (< i1@200@07 V@39@07) (<= 0 i1@200@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@201@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 129 | 0 <= i1@201@07 | live]
; [else-branch: 129 | !(0 <= i1@201@07) | live]
(push) ; 13
; [then-branch: 129 | 0 <= i1@201@07]
(assert (<= 0 i1@201@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 129 | !(0 <= i1@201@07)]
(assert (not (<= 0 i1@201@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 130 | i1@201@07 < V@39@07 && 0 <= i1@201@07 | live]
; [else-branch: 130 | !(i1@201@07 < V@39@07 && 0 <= i1@201@07) | live]
(push) ; 13
; [then-branch: 130 | i1@201@07 < V@39@07 && 0 <= i1@201@07]
(assert (and (< i1@201@07 V@39@07) (<= 0 i1@201@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@201@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11730
;  :arith-add-rows          4096
;  :arith-assert-diseq      361
;  :arith-assert-lower      2640
;  :arith-assert-upper      1776
;  :arith-bound-prop        650
;  :arith-conflicts         143
;  :arith-eq-adapter        1786
;  :arith-fixed-eqs         1140
;  :arith-offset-eqs        703
;  :arith-pivots            1646
;  :conflicts               368
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17794
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.50
;  :minimized-lits          35
;  :mk-bool-var             24274
;  :mk-clause               18317
;  :num-allocs              370194
;  :num-checks              220
;  :propagations            5119
;  :quant-instantiations    6893
;  :rlimit-count            706517)
(assert (< i1@201@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@201@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11757
;  :arith-add-rows          4110
;  :arith-assert-diseq      361
;  :arith-assert-lower      2644
;  :arith-assert-upper      1781
;  :arith-bound-prop        654
;  :arith-conflicts         144
;  :arith-eq-adapter        1790
;  :arith-fixed-eqs         1144
;  :arith-offset-eqs        703
;  :arith-pivots            1651
;  :conflicts               369
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17794
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.52
;  :minimized-lits          35
;  :mk-bool-var             24385
;  :mk-clause               18375
;  :num-allocs              370935
;  :num-checks              221
;  :propagations            5121
;  :quant-instantiations    6942
;  :rlimit-count            709284)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11757
;  :arith-add-rows          4110
;  :arith-assert-diseq      361
;  :arith-assert-lower      2644
;  :arith-assert-upper      1781
;  :arith-bound-prop        654
;  :arith-conflicts         144
;  :arith-eq-adapter        1790
;  :arith-fixed-eqs         1144
;  :arith-offset-eqs        703
;  :arith-pivots            1651
;  :conflicts               370
;  :datatype-accessor-ax    131
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17794
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.52
;  :minimized-lits          35
;  :mk-bool-var             24385
;  :mk-clause               18375
;  :num-allocs              371025
;  :num-checks              222
;  :propagations            5121
;  :quant-instantiations    6942
;  :rlimit-count            709379)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
    (as None<option<array>>  option<array>))))
(pop) ; 13
(push) ; 13
; [else-branch: 130 | !(i1@201@07 < V@39@07 && 0 <= i1@201@07)]
(assert (not (and (< i1@201@07 V@39@07) (<= 0 i1@201@07))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@201@07 V@39@07) (<= 0 i1@201@07))
  (and
    (< i1@201@07 V@39@07)
    (<= 0 i1@201@07)
    (< i1@201@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@201@07 Int)) (!
  (implies
    (and (< i1@201@07 V@39@07) (<= 0 i1@201@07))
    (and
      (< i1@201@07 V@39@07)
      (<= 0 i1@201@07)
      (< i1@201@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@201@07 Int)) (!
  (implies
    (and (< i1@201@07 V@39@07) (<= 0 i1@201@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@202@07 Int)
(push) ; 11
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@203@07 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 131 | 0 <= i1@202@07 | live]
; [else-branch: 131 | !(0 <= i1@202@07) | live]
(push) ; 14
; [then-branch: 131 | 0 <= i1@202@07]
(assert (<= 0 i1@202@07))
; [eval] i1 < V
(push) ; 15
; [then-branch: 132 | i1@202@07 < V@39@07 | live]
; [else-branch: 132 | !(i1@202@07 < V@39@07) | live]
(push) ; 16
; [then-branch: 132 | i1@202@07 < V@39@07]
(assert (< i1@202@07 V@39@07))
; [eval] 0 <= i2
(push) ; 17
; [then-branch: 133 | 0 <= i2@203@07 | live]
; [else-branch: 133 | !(0 <= i2@203@07) | live]
(push) ; 18
; [then-branch: 133 | 0 <= i2@203@07]
(assert (<= 0 i2@203@07))
; [eval] i2 < V
(push) ; 19
; [then-branch: 134 | i2@203@07 < V@39@07 | live]
; [else-branch: 134 | !(i2@203@07 < V@39@07) | live]
(push) ; 20
; [then-branch: 134 | i2@203@07 < V@39@07]
(assert (< i2@203@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11763
;  :arith-add-rows          4115
;  :arith-assert-diseq      361
;  :arith-assert-lower      2648
;  :arith-assert-upper      1781
;  :arith-bound-prop        654
;  :arith-conflicts         144
;  :arith-eq-adapter        1790
;  :arith-fixed-eqs         1144
;  :arith-offset-eqs        703
;  :arith-pivots            1656
;  :conflicts               370
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17852
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.53
;  :minimized-lits          35
;  :mk-bool-var             24393
;  :mk-clause               18375
;  :num-allocs              371768
;  :num-checks              223
;  :propagations            5121
;  :quant-instantiations    6942
;  :rlimit-count            710820)
(assert (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 21
; Joined path conditions
(assert (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11789
;  :arith-add-rows          4129
;  :arith-assert-diseq      361
;  :arith-assert-lower      2652
;  :arith-assert-upper      1786
;  :arith-bound-prop        658
;  :arith-conflicts         145
;  :arith-eq-adapter        1794
;  :arith-fixed-eqs         1148
;  :arith-offset-eqs        703
;  :arith-pivots            1661
;  :conflicts               371
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17852
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.53
;  :minimized-lits          35
;  :mk-bool-var             24503
;  :mk-clause               18433
;  :num-allocs              372504
;  :num-checks              224
;  :propagations            5123
;  :quant-instantiations    6991
;  :rlimit-count            713585)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11789
;  :arith-add-rows          4129
;  :arith-assert-diseq      361
;  :arith-assert-lower      2652
;  :arith-assert-upper      1786
;  :arith-bound-prop        658
;  :arith-conflicts         145
;  :arith-eq-adapter        1794
;  :arith-fixed-eqs         1148
;  :arith-offset-eqs        703
;  :arith-pivots            1661
;  :conflicts               371
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17852
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.53
;  :minimized-lits          35
;  :mk-bool-var             24503
;  :mk-clause               18433
;  :num-allocs              372530
;  :num-checks              225
;  :propagations            5123
;  :quant-instantiations    6991
;  :rlimit-count            713615)
(assert (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 21
; Joined path conditions
(assert (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11813
;  :arith-add-rows          4145
;  :arith-assert-diseq      361
;  :arith-assert-lower      2656
;  :arith-assert-upper      1791
;  :arith-bound-prop        662
;  :arith-conflicts         146
;  :arith-eq-adapter        1799
;  :arith-fixed-eqs         1152
;  :arith-offset-eqs        703
;  :arith-pivots            1666
;  :conflicts               372
;  :datatype-accessor-ax    132
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              17852
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.54
;  :minimized-lits          35
;  :mk-bool-var             24615
;  :mk-clause               18505
;  :num-allocs              373285
;  :num-checks              226
;  :propagations            5137
;  :quant-instantiations    7043
;  :rlimit-count            716711)
(pop) ; 20
(push) ; 20
; [else-branch: 134 | !(i2@203@07 < V@39@07)]
(assert (not (< i2@203@07 V@39@07)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (< i2@203@07 V@39@07)
  (and
    (< i2@203@07 V@39@07)
    (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
    (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 133 | !(0 <= i2@203@07)]
(assert (not (<= 0 i2@203@07)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (<= 0 i2@203@07)
  (and
    (<= 0 i2@203@07)
    (implies
      (< i2@203@07 V@39@07)
      (and
        (< i2@203@07 V@39@07)
        (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
        (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 132 | !(i1@202@07 < V@39@07)]
(assert (not (< i1@202@07 V@39@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i1@202@07 V@39@07)
  (and
    (< i1@202@07 V@39@07)
    (implies
      (<= 0 i2@203@07)
      (and
        (<= 0 i2@203@07)
        (implies
          (< i2@203@07 V@39@07)
          (and
            (< i2@203@07 V@39@07)
            (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
            (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 131 | !(0 <= i1@202@07)]
(assert (not (<= 0 i1@202@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i1@202@07)
  (and
    (<= 0 i1@202@07)
    (implies
      (< i1@202@07 V@39@07)
      (and
        (< i1@202@07 V@39@07)
        (implies
          (<= 0 i2@203@07)
          (and
            (<= 0 i2@203@07)
            (implies
              (< i2@203@07 V@39@07)
              (and
                (< i2@203@07 V@39@07)
                (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))))))))))
; Joined path conditions
(push) ; 13
; [then-branch: 135 | Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@202@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@203@07)) && i2@203@07 < V@39@07 && 0 <= i2@203@07 && i1@202@07 < V@39@07 && 0 <= i1@202@07 | live]
; [else-branch: 135 | !(Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@202@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@203@07)) && i2@203@07 < V@39@07 && 0 <= i2@203@07 && i1@202@07 < V@39@07 && 0 <= i1@202@07) | live]
(push) ; 14
; [then-branch: 135 | Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@202@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@203@07)) && i2@203@07 < V@39@07 && 0 <= i2@203@07 && i1@202@07 < V@39@07 && 0 <= i1@202@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
        (< i2@203@07 V@39@07))
      (<= 0 i2@203@07))
    (< i1@202@07 V@39@07))
  (<= 0 i1@202@07)))
; [eval] i1 == i2
(pop) ; 14
(push) ; 14
; [else-branch: 135 | !(Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@202@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@203@07)) && i2@203@07 < V@39@07 && 0 <= i2@203@07 && i1@202@07 < V@39@07 && 0 <= i1@202@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
          (< i2@203@07 V@39@07))
        (<= 0 i2@203@07))
      (< i1@202@07 V@39@07))
    (<= 0 i1@202@07))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
          (< i2@203@07 V@39@07))
        (<= 0 i2@203@07))
      (< i1@202@07 V@39@07))
    (<= 0 i1@202@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
      ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
    (< i2@203@07 V@39@07)
    (<= 0 i2@203@07)
    (< i1@202@07 V@39@07)
    (<= 0 i1@202@07))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@203@07 Int)) (!
  (and
    (implies
      (<= 0 i1@202@07)
      (and
        (<= 0 i1@202@07)
        (implies
          (< i1@202@07 V@39@07)
          (and
            (< i1@202@07 V@39@07)
            (implies
              (<= 0 i2@203@07)
              (and
                (<= 0 i2@203@07)
                (implies
                  (< i2@203@07 V@39@07)
                  (and
                    (< i2@203@07 V@39@07)
                    (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                    (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
              (< i2@203@07 V@39@07))
            (<= 0 i2@203@07))
          (< i1@202@07 V@39@07))
        (<= 0 i1@202@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
        (< i2@203@07 V@39@07)
        (<= 0 i2@203@07)
        (< i1@202@07 V@39@07)
        (<= 0 i1@202@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@202@07 Int)) (!
  (forall ((i2@203@07 Int)) (!
    (and
      (implies
        (<= 0 i1@202@07)
        (and
          (<= 0 i1@202@07)
          (implies
            (< i1@202@07 V@39@07)
            (and
              (< i1@202@07 V@39@07)
              (implies
                (<= 0 i2@203@07)
                (and
                  (<= 0 i2@203@07)
                  (implies
                    (< i2@203@07 V@39@07)
                    (and
                      (< i2@203@07 V@39@07)
                      (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                      (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                  ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
                (< i2@203@07 V@39@07))
              (<= 0 i2@203@07))
            (< i1@202@07 V@39@07))
          (<= 0 i1@202@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
          (< i2@203@07 V@39@07)
          (<= 0 i2@203@07)
          (< i1@202@07 V@39@07)
          (<= 0 i1@202@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@202@07 Int)) (!
  (forall ((i2@203@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
              (< i2@203@07 V@39@07))
            (<= 0 i2@203@07))
          (< i1@202@07 V@39@07))
        (<= 0 i1@202@07))
      (= i1@202@07 i2@203@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))
  $Snap.unit))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))
  $Snap.unit))
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))
  $Snap.unit))
; [eval] s < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))
  $Snap.unit))
; [eval] 0 <= t
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))
  $Snap.unit))
; [eval] t < V
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))
(declare-const i1@204@07 Int)
(declare-const j1@205@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 136 | 0 <= i1@204@07 | live]
; [else-branch: 136 | !(0 <= i1@204@07) | live]
(push) ; 13
; [then-branch: 136 | 0 <= i1@204@07]
(assert (<= 0 i1@204@07))
; [eval] i1 < V
(push) ; 14
; [then-branch: 137 | i1@204@07 < V@39@07 | live]
; [else-branch: 137 | !(i1@204@07 < V@39@07) | live]
(push) ; 15
; [then-branch: 137 | i1@204@07 < V@39@07]
(assert (< i1@204@07 V@39@07))
; [eval] 0 <= j1
(push) ; 16
; [then-branch: 138 | 0 <= j1@205@07 | live]
; [else-branch: 138 | !(0 <= j1@205@07) | live]
(push) ; 17
; [then-branch: 138 | 0 <= j1@205@07]
(assert (<= 0 j1@205@07))
; [eval] j1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 138 | !(0 <= j1@205@07)]
(assert (not (<= 0 j1@205@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 137 | !(i1@204@07 < V@39@07)]
(assert (not (< i1@204@07 V@39@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 136 | !(0 <= i1@204@07)]
(assert (not (<= 0 i1@204@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@205@07 V@39@07) (<= 0 j1@205@07)) (< i1@204@07 V@39@07))
  (<= 0 i1@204@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@204@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11854
;  :arith-add-rows          4155
;  :arith-assert-diseq      361
;  :arith-assert-lower      2662
;  :arith-assert-upper      1791
;  :arith-bound-prop        662
;  :arith-conflicts         146
;  :arith-eq-adapter        1799
;  :arith-fixed-eqs         1152
;  :arith-offset-eqs        703
;  :arith-pivots            1676
;  :conflicts               372
;  :datatype-accessor-ax    139
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18006
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.54
;  :minimized-lits          35
;  :mk-bool-var             24649
;  :mk-clause               18529
;  :num-allocs              374829
;  :num-checks              227
;  :propagations            5137
;  :quant-instantiations    7043
;  :rlimit-count            720621)
(assert (< i1@204@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@204@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11880
;  :arith-add-rows          4169
;  :arith-assert-diseq      361
;  :arith-assert-lower      2666
;  :arith-assert-upper      1796
;  :arith-bound-prop        666
;  :arith-conflicts         147
;  :arith-eq-adapter        1803
;  :arith-fixed-eqs         1156
;  :arith-offset-eqs        703
;  :arith-pivots            1681
;  :conflicts               373
;  :datatype-accessor-ax    139
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18006
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.65
;  :minimized-lits          35
;  :mk-bool-var             24768
;  :mk-clause               18587
;  :num-allocs              375645
;  :num-checks              228
;  :propagations            5139
;  :quant-instantiations    7095
;  :rlimit-count            723703)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11880
;  :arith-add-rows          4169
;  :arith-assert-diseq      361
;  :arith-assert-lower      2666
;  :arith-assert-upper      1796
;  :arith-bound-prop        666
;  :arith-conflicts         147
;  :arith-eq-adapter        1803
;  :arith-fixed-eqs         1156
;  :arith-offset-eqs        703
;  :arith-pivots            1681
;  :conflicts               374
;  :datatype-accessor-ax    139
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18006
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.64
;  :minimized-lits          35
;  :mk-bool-var             24768
;  :mk-clause               18587
;  :num-allocs              375736
;  :num-checks              229
;  :propagations            5139
;  :quant-instantiations    7095
;  :rlimit-count            723798)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))
    (as None<option<array>>  option<array>))))
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (<
  j1@205@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11886
;  :arith-add-rows          4174
;  :arith-assert-diseq      361
;  :arith-assert-lower      2668
;  :arith-assert-upper      1798
;  :arith-bound-prop        666
;  :arith-conflicts         148
;  :arith-eq-adapter        1804
;  :arith-fixed-eqs         1157
;  :arith-offset-eqs        703
;  :arith-pivots            1685
;  :conflicts               375
;  :datatype-accessor-ax    139
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18010
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.64
;  :minimized-lits          35
;  :mk-bool-var             24779
;  :mk-clause               18591
;  :num-allocs              375923
;  :num-checks              230
;  :propagations            5141
;  :quant-instantiations    7102
;  :rlimit-count            724297)
(assert (<
  j1@205@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))))))
(pop) ; 12
; Joined path conditions
(assert (<
  j1@205@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))))))
(pop) ; 11
(declare-fun inv@206@07 ($Ref) Int)
(declare-fun inv@207@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@204@07 Int) (j1@205@07 Int)) (!
  (and
    (< i1@204@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@205@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@204@07 Int) (j11@205@07 Int) (i12@204@07 Int) (j12@205@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@205@07 V@39@07) (<= 0 j11@205@07))
          (< i11@204@07 V@39@07))
        (<= 0 i11@204@07))
      (and
        (and
          (and (< j12@205@07 V@39@07) (<= 0 j12@205@07))
          (< i12@204@07 V@39@07))
        (<= 0 i12@204@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@204@07))) j11@205@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@204@07))) j12@205@07)))
    (and (= i11@204@07 i12@204@07) (= j11@205@07 j12@205@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11950
;  :arith-add-rows          4188
;  :arith-assert-diseq      361
;  :arith-assert-lower      2681
;  :arith-assert-upper      1801
;  :arith-bound-prop        668
;  :arith-conflicts         148
;  :arith-eq-adapter        1816
;  :arith-fixed-eqs         1159
;  :arith-offset-eqs        703
;  :arith-pivots            1698
;  :conflicts               376
;  :datatype-accessor-ax    139
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18187
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.65
;  :minimized-lits          35
;  :mk-bool-var             25059
;  :mk-clause               18710
;  :num-allocs              377779
;  :num-checks              231
;  :propagations            5169
;  :quant-instantiations    7228
;  :rlimit-count            731574
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@204@07 Int) (j1@205@07 Int)) (!
  (implies
    (and
      (and (and (< j1@205@07 V@39@07) (<= 0 j1@205@07)) (< i1@204@07 V@39@07))
      (<= 0 i1@204@07))
    (and
      (=
        (inv@206@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
        i1@204@07)
      (=
        (inv@207@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
        j1@205@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@206@07 r)))) (inv@207@07 r))
      r))
  :pattern ((inv@206@07 r))
  :pattern ((inv@207@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@204@07 Int) (j1@205@07 Int)) (!
  (implies
    (and
      (and (and (< j1@205@07 V@39@07) (<= 0 j1@205@07)) (< i1@204@07 V@39@07))
      (<= 0 i1@204@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@208@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@208@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@208@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@208@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@208@07  $FVF<Int>) r) r))
  :pattern ((inv@206@07 r) (inv@207@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))
(declare-const i1@209@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 139 | 0 <= i1@209@07 | live]
; [else-branch: 139 | !(0 <= i1@209@07) | live]
(push) ; 13
; [then-branch: 139 | 0 <= i1@209@07]
(assert (<= 0 i1@209@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 139 | !(0 <= i1@209@07)]
(assert (not (<= 0 i1@209@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@209@07 V@39@07) (<= 0 i1@209@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@209@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11955
;  :arith-add-rows          4188
;  :arith-assert-diseq      361
;  :arith-assert-lower      2683
;  :arith-assert-upper      1801
;  :arith-bound-prop        668
;  :arith-conflicts         148
;  :arith-eq-adapter        1816
;  :arith-fixed-eqs         1159
;  :arith-offset-eqs        703
;  :arith-pivots            1698
;  :conflicts               376
;  :datatype-accessor-ax    140
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18187
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.65
;  :minimized-lits          35
;  :mk-bool-var             25068
;  :mk-clause               18710
;  :num-allocs              378883
;  :num-checks              232
;  :propagations            5169
;  :quant-instantiations    7228
;  :rlimit-count            734693)
(assert (< i1@209@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@209@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 11
(declare-fun inv@210@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@209@07 Int)) (!
  (< i1@209@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@209@07 Int) (i12@209@07 Int)) (!
  (implies
    (and
      (and (< i11@209@07 V@39@07) (<= 0 i11@209@07))
      (and (< i12@209@07 V@39@07) (<= 0 i12@209@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@209@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@209@07)))
    (= i11@209@07 i12@209@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11979
;  :arith-add-rows          4190
;  :arith-assert-diseq      362
;  :arith-assert-lower      2687
;  :arith-assert-upper      1801
;  :arith-bound-prop        668
;  :arith-conflicts         148
;  :arith-eq-adapter        1817
;  :arith-fixed-eqs         1159
;  :arith-offset-eqs        703
;  :arith-pivots            1698
;  :conflicts               377
;  :datatype-accessor-ax    140
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18193
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.65
;  :minimized-lits          35
;  :mk-bool-var             25103
;  :mk-clause               18716
;  :num-allocs              379500
;  :num-checks              233
;  :propagations            5169
;  :quant-instantiations    7265
;  :rlimit-count            736082)
; Definitional axioms for inverse functions
(assert (forall ((i1@209@07 Int)) (!
  (implies
    (and (< i1@209@07 V@39@07) (<= 0 i1@209@07))
    (=
      (inv@210@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07))
      i1@209@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@210@07 r))
      r))
  :pattern ((inv@210@07 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@209@07 Int)) (!
  (implies
    (and (< i1@209@07 V@39@07) (<= 0 i1@209@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@211@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@211@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef69|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@211@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@211@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r) r))
  :pattern ((inv@210@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices(this, p, V)
(push) ; 11
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(declare-const i1@212@07 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 140 | 0 <= i1@212@07 | live]
; [else-branch: 140 | !(0 <= i1@212@07) | live]
(push) ; 14
; [then-branch: 140 | 0 <= i1@212@07]
(assert (<= 0 i1@212@07))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 140 | !(0 <= i1@212@07)]
(assert (not (<= 0 i1@212@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@212@07 V@39@07) (<= 0 i1@212@07)))
(declare-const $k@213@07 $Perm)
(assert ($Perm.isReadVar $k@213@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i1@212@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11985
;  :arith-add-rows          4190
;  :arith-assert-diseq      363
;  :arith-assert-lower      2691
;  :arith-assert-upper      1802
;  :arith-bound-prop        668
;  :arith-conflicts         148
;  :arith-eq-adapter        1818
;  :arith-fixed-eqs         1159
;  :arith-offset-eqs        703
;  :arith-pivots            1698
;  :conflicts               377
;  :datatype-accessor-ax    141
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18193
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.65
;  :minimized-lits          35
;  :mk-bool-var             25118
;  :mk-clause               18718
;  :num-allocs              380871
;  :num-checks              234
;  :propagations            5170
;  :quant-instantiations    7265
;  :rlimit-count            739742)
(assert (< i1@212@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 13
; Joined path conditions
(assert (< i1@212@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 12
(declare-fun inv@214@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@213@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@212@07 Int)) (!
  (< i1@212@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
  :qid |int-aux|)))
(push) ; 12
(assert (not (forall ((i1@212@07 Int)) (!
  (implies
    (and (< i1@212@07 V@39@07) (<= 0 i1@212@07))
    (or (= $k@213@07 $Perm.No) (< $Perm.No $k@213@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11985
;  :arith-add-rows          4190
;  :arith-assert-diseq      364
;  :arith-assert-lower      2693
;  :arith-assert-upper      1803
;  :arith-bound-prop        668
;  :arith-conflicts         148
;  :arith-eq-adapter        1819
;  :arith-fixed-eqs         1159
;  :arith-offset-eqs        703
;  :arith-pivots            1698
;  :conflicts               378
;  :datatype-accessor-ax    141
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18195
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.65
;  :minimized-lits          35
;  :mk-bool-var             25125
;  :mk-clause               18720
;  :num-allocs              381299
;  :num-checks              235
;  :propagations            5171
;  :quant-instantiations    7265
;  :rlimit-count            740280)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@212@07 Int) (i12@212@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@212@07 V@39@07) (<= 0 i11@212@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@211@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@212@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@212@07)))
        (< $Perm.No $k@213@07))
      (and
        (and
          (and (< i12@212@07 V@39@07) (<= 0 i12@212@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@211@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@212@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@212@07)))
        (< $Perm.No $k@213@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@212@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@212@07)))
    (= i11@212@07 i12@212@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12012
;  :arith-add-rows          4192
;  :arith-assert-diseq      365
;  :arith-assert-lower      2697
;  :arith-assert-upper      1803
;  :arith-bound-prop        668
;  :arith-conflicts         148
;  :arith-eq-adapter        1820
;  :arith-fixed-eqs         1159
;  :arith-offset-eqs        703
;  :arith-pivots            1698
;  :conflicts               379
;  :datatype-accessor-ax    141
;  :datatype-constructor-ax 388
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1364
;  :del-clause              18206
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.79
;  :memory                  7.65
;  :minimized-lits          35
;  :mk-bool-var             25173
;  :mk-clause               18731
;  :num-allocs              381855
;  :num-checks              236
;  :propagations            5173
;  :quant-instantiations    7309
;  :rlimit-count            741813)
; Definitional axioms for inverse functions
(assert (forall ((i1@212@07 Int)) (!
  (implies
    (and (and (< i1@212@07 V@39@07) (<= 0 i1@212@07)) (< $Perm.No $k@213@07))
    (=
      (inv@214@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
      i1@212@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
      (< $Perm.No $k@213@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@214@07 r))
      r))
  :pattern ((inv@214@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r) r))
  :pattern ((inv@214@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@215@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      $k@213@07)
    $Perm.No))
(define-fun pTaken@216@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@213@07 (pTaken@215@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@213@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
      (<
        (ite
          (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
          $k@213@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
          $k@213@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@210@07 r))
  :pattern ((inv@214@07 r))
  :qid |qp.srp72|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
    (= (- $k@213@07 (pTaken@215@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13134
;  :arith-add-rows          4859
;  :arith-assert-diseq      386
;  :arith-assert-lower      2948
;  :arith-assert-upper      1968
;  :arith-bound-prop        752
;  :arith-conflicts         153
;  :arith-eq-adapter        2016
;  :arith-fixed-eqs         1319
;  :arith-offset-eqs        750
;  :arith-pivots            1845
;  :conflicts               402
;  :datatype-accessor-ax    141
;  :datatype-constructor-ax 396
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1450
;  :del-clause              20220
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.97
;  :memory                  7.91
;  :minimized-lits          35
;  :mk-bool-var             27624
;  :mk-clause               20781
;  :num-allocs              391852
;  :num-checks              238
;  :propagations            5710
;  :quant-instantiations    8024
;  :rlimit-count            782020
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@217@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@217@07  $FVF<Int>)))
    (and
      (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
      (< $Perm.No $k@213@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@217@07  $FVF<Int>))))
  :qid |qp.fvfDomDef76|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
        (< $Perm.No $k@213@07))
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r))))
    (=
      ($FVF.lookup_int (as sm@217@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
        (< $Perm.No $k@213@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@217@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef75|)))
(pop) ; 11
; Joined path conditions
(assert ($Perm.isReadVar $k@213@07 $Perm.Write))
(assert (forall ((i1@212@07 Int)) (!
  (implies
    (and (and (< i1@212@07 V@39@07) (<= 0 i1@212@07)) (< $Perm.No $k@213@07))
    (=
      (inv@214@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
      i1@212@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
      (< $Perm.No $k@213@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@214@07 r))
      r))
  :pattern ((inv@214@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@217@07  $FVF<Int>)))
    (and
      (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
      (< $Perm.No $k@213@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@217@07  $FVF<Int>))))
  :qid |qp.fvfDomDef76|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
        (< $Perm.No $k@213@07))
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r))))
    (=
      ($FVF.lookup_int (as sm@217@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
        (< $Perm.No $k@213@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@217@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef75|)))
(assert (and
  (forall ((i1@212@07 Int)) (!
    (< i1@212@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r) r))
    :pattern ((inv@214@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        (<
          (ite
            (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
            $k@213@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
            $k@213@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@210@07 r))
    :pattern ((inv@214@07 r))
    :qid |qp.srp72|))))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@217@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))
  $Snap.unit))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))
  $Snap.unit))
; [eval] 0 <= u
(assert (<= 0 u@188@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))
  $Snap.unit))
; [eval] u < V
(assert (< u@188@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))
  $Snap.unit))
; [eval] 0 <= v
(assert (<= 0 v@193@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))
  $Snap.unit))
; [eval] v <= V
(assert (<= v@193@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))
  $Snap.unit))
; [eval] 0 <= k
(assert (<= 0 k@190@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))
  $Snap.unit))
; [eval] k < V
(assert (< k@190@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))
  $Snap.unit))
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 11
; [eval] this != null
(pop) ; 11
; Joined path conditions
(assert (valid_graph_vertices1 $Snap.unit this@36@07 queue@191@07 V@39@07))
(declare-const i1@218@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 141 | 0 <= i1@218@07 | live]
; [else-branch: 141 | !(0 <= i1@218@07) | live]
(push) ; 13
; [then-branch: 141 | 0 <= i1@218@07]
(assert (<= 0 i1@218@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 141 | !(0 <= i1@218@07)]
(assert (not (<= 0 i1@218@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@218@07 V@39@07) (<= 0 i1@218@07)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@218@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13194
;  :arith-add-rows          4891
;  :arith-assert-diseq      387
;  :arith-assert-lower      2958
;  :arith-assert-upper      1971
;  :arith-bound-prop        752
;  :arith-conflicts         153
;  :arith-eq-adapter        2018
;  :arith-fixed-eqs         1320
;  :arith-offset-eqs        750
;  :arith-pivots            1856
;  :conflicts               402
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 396
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1450
;  :del-clause              20258
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.98
;  :memory                  7.96
;  :minimized-lits          35
;  :mk-bool-var             27735
;  :mk-clause               20850
;  :num-allocs              394658
;  :num-checks              239
;  :propagations            5727
;  :quant-instantiations    8036
;  :rlimit-count            790460)
(assert (< i1@218@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@218@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 11
(declare-fun inv@219@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@218@07 Int)) (!
  (< i1@218@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@218@07 Int) (i12@218@07 Int)) (!
  (implies
    (and
      (and (< i11@218@07 V@39@07) (<= 0 i11@218@07))
      (and (< i12@218@07 V@39@07) (<= 0 i12@218@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@218@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@218@07)))
    (= i11@218@07 i12@218@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13208
;  :arith-add-rows          4893
;  :arith-assert-diseq      388
;  :arith-assert-lower      2962
;  :arith-assert-upper      1971
;  :arith-bound-prop        752
;  :arith-conflicts         153
;  :arith-eq-adapter        2019
;  :arith-fixed-eqs         1320
;  :arith-offset-eqs        750
;  :arith-pivots            1856
;  :conflicts               403
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 396
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1450
;  :del-clause              20264
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.98
;  :memory                  7.96
;  :minimized-lits          35
;  :mk-bool-var             27760
;  :mk-clause               20856
;  :num-allocs              395221
;  :num-checks              240
;  :propagations            5727
;  :quant-instantiations    8060
;  :rlimit-count            791541
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@218@07 Int)) (!
  (implies
    (and (< i1@218@07 V@39@07) (<= 0 i1@218@07))
    (=
      (inv@219@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07))
      i1@218@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@219@07 r))
      r))
  :pattern ((inv@219@07 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@218@07 Int)) (!
  (implies
    (and (< i1@218@07 V@39@07) (<= 0 i1@218@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@220@07 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
    (=
      ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef77|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef78|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r) r))
  :pattern ((inv@219@07 r))
  )))
; Loop head block: Check well-definedness of edge conditions
(push) ; 11
; [eval] v < V
(pop) ; 11
(push) ; 11
; [eval] !(v < V)
; [eval] v < V
(pop) ; 11
(pop) ; 10
(push) ; 10
; Loop head block: Establish invariant
; [eval] exc == excBeforeLoop1
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(declare-const i1@221@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 142 | 0 <= i1@221@07 | live]
; [else-branch: 142 | !(0 <= i1@221@07) | live]
(push) ; 13
; [then-branch: 142 | 0 <= i1@221@07]
(assert (<= 0 i1@221@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 142 | !(0 <= i1@221@07)]
(assert (not (<= 0 i1@221@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@221@07 V@39@07) (<= 0 i1@221@07)))
(declare-const $k@222@07 $Perm)
(assert ($Perm.isReadVar $k@222@07 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@221@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13212
;  :arith-add-rows          4897
;  :arith-assert-diseq      389
;  :arith-assert-lower      2967
;  :arith-assert-upper      1973
;  :arith-bound-prop        752
;  :arith-conflicts         153
;  :arith-eq-adapter        2021
;  :arith-fixed-eqs         1321
;  :arith-offset-eqs        750
;  :arith-pivots            1859
;  :conflicts               403
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 396
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1450
;  :del-clause              20336
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.98
;  :memory                  7.94
;  :minimized-lits          35
;  :mk-bool-var             27780
;  :mk-clause               20859
;  :num-allocs              396332
;  :num-checks              241
;  :propagations            5728
;  :quant-instantiations    8062
;  :rlimit-count            794344)
(assert (< i1@221@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@221@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 11
(declare-fun inv@223@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@222@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@221@07 Int)) (!
  (< i1@221@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@221@07))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@221@07 Int)) (!
  (implies
    (and (< i1@221@07 V@39@07) (<= 0 i1@221@07))
    (or (= $k@222@07 $Perm.No) (< $Perm.No $k@222@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13212
;  :arith-add-rows          4897
;  :arith-assert-diseq      390
;  :arith-assert-lower      2969
;  :arith-assert-upper      1974
;  :arith-bound-prop        752
;  :arith-conflicts         153
;  :arith-eq-adapter        2022
;  :arith-fixed-eqs         1321
;  :arith-offset-eqs        750
;  :arith-pivots            1859
;  :conflicts               404
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 396
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1450
;  :del-clause              20338
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.98
;  :memory                  7.94
;  :minimized-lits          35
;  :mk-bool-var             27787
;  :mk-clause               20861
;  :num-allocs              396765
;  :num-checks              242
;  :propagations            5729
;  :quant-instantiations    8062
;  :rlimit-count            794889)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@221@07 Int) (i12@221@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@221@07 V@39@07) (<= 0 i11@221@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@221@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@221@07)))
        (< $Perm.No $k@222@07))
      (and
        (and
          (and (< i12@221@07 V@39@07) (<= 0 i12@221@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@221@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@221@07)))
        (< $Perm.No $k@222@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@221@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@221@07)))
    (= i11@221@07 i12@221@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13226
;  :arith-add-rows          4899
;  :arith-assert-diseq      391
;  :arith-assert-lower      2973
;  :arith-assert-upper      1974
;  :arith-bound-prop        752
;  :arith-conflicts         153
;  :arith-eq-adapter        2023
;  :arith-fixed-eqs         1321
;  :arith-offset-eqs        750
;  :arith-pivots            1859
;  :conflicts               405
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 396
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1450
;  :del-clause              20345
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              7.98
;  :memory                  7.93
;  :minimized-lits          35
;  :mk-bool-var             27815
;  :mk-clause               20868
;  :num-allocs              397190
;  :num-checks              243
;  :propagations            5729
;  :quant-instantiations    8083
;  :rlimit-count            795903)
; Definitional axioms for inverse functions
(assert (forall ((i1@221@07 Int)) (!
  (implies
    (and (and (< i1@221@07 V@39@07) (<= 0 i1@221@07)) (< $Perm.No $k@222@07))
    (=
      (inv@223@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@221@07))
      i1@221@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@221@07))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@223@07 r) V@39@07) (<= 0 (inv@223@07 r)))
      (< $Perm.No $k@222@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@223@07 r))
      r))
  :pattern ((inv@223@07 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@223@07 r) V@39@07) (<= 0 (inv@223@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) r) r))
  :pattern ((inv@223@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@224@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@223@07 r) V@39@07) (<= 0 (inv@223@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
        $k@134@07
        $Perm.No)
      $k@222@07)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@222@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
          $k@134@07
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
      (<
        (ite
          (and (< (inv@223@07 r) V@39@07) (<= 0 (inv@223@07 r)))
          $k@222@07
          $Perm.No)
        $k@134@07)
      (<
        (ite
          (and (< (inv@223@07 r) V@39@07) (<= 0 (inv@223@07 r)))
          $k@222@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@135@07 r))
  :pattern ((inv@223@07 r))
  :qid |qp.srp79|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@223@07 r) V@39@07) (<= 0 (inv@223@07 r)))
    (= (- $k@222@07 (pTaken@224@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14368
;  :arith-add-rows          5513
;  :arith-assert-diseq      415
;  :arith-assert-lower      3283
;  :arith-assert-upper      2163
;  :arith-bound-prop        824
;  :arith-conflicts         161
;  :arith-eq-adapter        2220
;  :arith-fixed-eqs         1502
;  :arith-offset-eqs        813
;  :arith-pivots            1977
;  :conflicts               430
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22397
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.96
;  :minimized-lits          37
;  :mk-bool-var             30247
;  :mk-clause               22962
;  :num-allocs              405855
;  :num-checks              245
;  :propagations            6368
;  :quant-instantiations    8804
;  :rlimit-count            830136
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@225@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 143 | 0 <= i1@225@07 | live]
; [else-branch: 143 | !(0 <= i1@225@07) | live]
(push) ; 13
; [then-branch: 143 | 0 <= i1@225@07]
(assert (<= 0 i1@225@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 143 | !(0 <= i1@225@07)]
(assert (not (<= 0 i1@225@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 144 | i1@225@07 < V@39@07 && 0 <= i1@225@07 | live]
; [else-branch: 144 | !(i1@225@07 < V@39@07 && 0 <= i1@225@07) | live]
(push) ; 13
; [then-branch: 144 | i1@225@07 < V@39@07 && 0 <= i1@225@07]
(assert (and (< i1@225@07 V@39@07) (<= 0 i1@225@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@225@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14368
;  :arith-add-rows          5513
;  :arith-assert-diseq      415
;  :arith-assert-lower      3285
;  :arith-assert-upper      2163
;  :arith-bound-prop        824
;  :arith-conflicts         161
;  :arith-eq-adapter        2220
;  :arith-fixed-eqs         1502
;  :arith-offset-eqs        813
;  :arith-pivots            1977
;  :conflicts               430
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22397
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.96
;  :minimized-lits          37
;  :mk-bool-var             30249
;  :mk-clause               22962
;  :num-allocs              405964
;  :num-checks              246
;  :propagations            6368
;  :quant-instantiations    8804
;  :rlimit-count            830324)
(assert (< i1@225@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@225@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14392
;  :arith-add-rows          5531
;  :arith-assert-diseq      415
;  :arith-assert-lower      3290
;  :arith-assert-upper      2169
;  :arith-bound-prop        829
;  :arith-conflicts         162
;  :arith-eq-adapter        2225
;  :arith-fixed-eqs         1507
;  :arith-offset-eqs        813
;  :arith-pivots            1983
;  :conflicts               431
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22397
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.97
;  :minimized-lits          37
;  :mk-bool-var             30346
;  :mk-clause               23016
;  :num-allocs              406679
;  :num-checks              247
;  :propagations            6369
;  :quant-instantiations    8844
;  :rlimit-count            832846)
; [eval] (None(): option[array])
(pop) ; 13
(push) ; 13
; [else-branch: 144 | !(i1@225@07 < V@39@07 && 0 <= i1@225@07)]
(assert (not (and (< i1@225@07 V@39@07) (<= 0 i1@225@07))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@225@07 V@39@07) (<= 0 i1@225@07))
  (and
    (< i1@225@07 V@39@07)
    (<= 0 i1@225@07)
    (< i1@225@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07)))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@225@07 Int)) (!
  (implies
    (and (< i1@225@07 V@39@07) (<= 0 i1@225@07))
    (and
      (< i1@225@07 V@39@07)
      (<= 0 i1@225@07)
      (< i1@225@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@225@07 Int)) (!
  (implies
    (and (< i1@225@07 V@39@07) (<= 0 i1@225@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14400
;  :arith-add-rows          5538
;  :arith-assert-diseq      415
;  :arith-assert-lower      3292
;  :arith-assert-upper      2169
;  :arith-bound-prop        829
;  :arith-conflicts         162
;  :arith-eq-adapter        2226
;  :arith-fixed-eqs         1507
;  :arith-offset-eqs        813
;  :arith-pivots            1989
;  :conflicts               432
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22499
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.96
;  :minimized-lits          37
;  :mk-bool-var             30409
;  :mk-clause               23064
;  :num-allocs              407505
;  :num-checks              248
;  :propagations            6369
;  :quant-instantiations    8879
;  :rlimit-count            835167
;  :time                    0.00)
(assert (forall ((i1@225@07 Int)) (!
  (implies
    (and (< i1@225@07 V@39@07) (<= 0 i1@225@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@225@07))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@226@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 145 | 0 <= i1@226@07 | live]
; [else-branch: 145 | !(0 <= i1@226@07) | live]
(push) ; 13
; [then-branch: 145 | 0 <= i1@226@07]
(assert (<= 0 i1@226@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 145 | !(0 <= i1@226@07)]
(assert (not (<= 0 i1@226@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(push) ; 12
; [then-branch: 146 | i1@226@07 < V@39@07 && 0 <= i1@226@07 | live]
; [else-branch: 146 | !(i1@226@07 < V@39@07 && 0 <= i1@226@07) | live]
(push) ; 13
; [then-branch: 146 | i1@226@07 < V@39@07 && 0 <= i1@226@07]
(assert (and (< i1@226@07 V@39@07) (<= 0 i1@226@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@226@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14400
;  :arith-add-rows          5538
;  :arith-assert-diseq      415
;  :arith-assert-lower      3294
;  :arith-assert-upper      2169
;  :arith-bound-prop        829
;  :arith-conflicts         162
;  :arith-eq-adapter        2226
;  :arith-fixed-eqs         1507
;  :arith-offset-eqs        813
;  :arith-pivots            1989
;  :conflicts               432
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22499
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.96
;  :minimized-lits          37
;  :mk-bool-var             30412
;  :mk-clause               23064
;  :num-allocs              407807
;  :num-checks              249
;  :propagations            6369
;  :quant-instantiations    8879
;  :rlimit-count            835666)
(assert (< i1@226@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@226@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07)))
(push) ; 14
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14425
;  :arith-add-rows          5556
;  :arith-assert-diseq      415
;  :arith-assert-lower      3299
;  :arith-assert-upper      2175
;  :arith-bound-prop        834
;  :arith-conflicts         163
;  :arith-eq-adapter        2231
;  :arith-fixed-eqs         1512
;  :arith-offset-eqs        813
;  :arith-pivots            1995
;  :conflicts               433
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22499
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.96
;  :minimized-lits          37
;  :mk-bool-var             30510
;  :mk-clause               23118
;  :num-allocs              408529
;  :num-checks              250
;  :propagations            6370
;  :quant-instantiations    8920
;  :rlimit-count            838282)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14425
;  :arith-add-rows          5556
;  :arith-assert-diseq      415
;  :arith-assert-lower      3299
;  :arith-assert-upper      2175
;  :arith-bound-prop        834
;  :arith-conflicts         163
;  :arith-eq-adapter        2231
;  :arith-fixed-eqs         1512
;  :arith-offset-eqs        813
;  :arith-pivots            1995
;  :conflicts               434
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22499
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.96
;  :minimized-lits          37
;  :mk-bool-var             30510
;  :mk-clause               23118
;  :num-allocs              408619
;  :num-checks              251
;  :propagations            6370
;  :quant-instantiations    8920
;  :rlimit-count            838377)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))
    (as None<option<array>>  option<array>))))
(pop) ; 13
(push) ; 13
; [else-branch: 146 | !(i1@226@07 < V@39@07 && 0 <= i1@226@07)]
(assert (not (and (< i1@226@07 V@39@07) (<= 0 i1@226@07))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and (< i1@226@07 V@39@07) (<= 0 i1@226@07))
  (and
    (< i1@226@07 V@39@07)
    (<= 0 i1@226@07)
    (< i1@226@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@226@07 Int)) (!
  (implies
    (and (< i1@226@07 V@39@07) (<= 0 i1@226@07))
    (and
      (< i1@226@07 V@39@07)
      (<= 0 i1@226@07)
      (< i1@226@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@226@07 Int)) (!
  (implies
    (and (< i1@226@07 V@39@07) (<= 0 i1@226@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14425
;  :arith-add-rows          5563
;  :arith-assert-diseq      415
;  :arith-assert-lower      3301
;  :arith-assert-upper      2175
;  :arith-bound-prop        834
;  :arith-conflicts         163
;  :arith-eq-adapter        2232
;  :arith-fixed-eqs         1512
;  :arith-offset-eqs        813
;  :arith-pivots            2001
;  :conflicts               435
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22563
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.95
;  :minimized-lits          37
;  :mk-bool-var             30535
;  :mk-clause               23128
;  :num-allocs              409149
;  :num-checks              252
;  :propagations            6370
;  :quant-instantiations    8939
;  :rlimit-count            839661)
(assert (forall ((i1@226@07 Int)) (!
  (implies
    (and (< i1@226@07 V@39@07) (<= 0 i1@226@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@226@07)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@227@07 Int)
(push) ; 11
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@228@07 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 147 | 0 <= i1@227@07 | live]
; [else-branch: 147 | !(0 <= i1@227@07) | live]
(push) ; 14
; [then-branch: 147 | 0 <= i1@227@07]
(assert (<= 0 i1@227@07))
; [eval] i1 < V
(push) ; 15
; [then-branch: 148 | i1@227@07 < V@39@07 | live]
; [else-branch: 148 | !(i1@227@07 < V@39@07) | live]
(push) ; 16
; [then-branch: 148 | i1@227@07 < V@39@07]
(assert (< i1@227@07 V@39@07))
; [eval] 0 <= i2
(push) ; 17
; [then-branch: 149 | 0 <= i2@228@07 | live]
; [else-branch: 149 | !(0 <= i2@228@07) | live]
(push) ; 18
; [then-branch: 149 | 0 <= i2@228@07]
(assert (<= 0 i2@228@07))
; [eval] i2 < V
(push) ; 19
; [then-branch: 150 | i2@228@07 < V@39@07 | live]
; [else-branch: 150 | !(i2@228@07 < V@39@07) | live]
(push) ; 20
; [then-branch: 150 | i2@228@07 < V@39@07]
(assert (< i2@228@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14425
;  :arith-add-rows          5563
;  :arith-assert-diseq      415
;  :arith-assert-lower      3305
;  :arith-assert-upper      2175
;  :arith-bound-prop        834
;  :arith-conflicts         163
;  :arith-eq-adapter        2232
;  :arith-fixed-eqs         1512
;  :arith-offset-eqs        813
;  :arith-pivots            2001
;  :conflicts               435
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22563
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.95
;  :minimized-lits          37
;  :mk-bool-var             30540
;  :mk-clause               23128
;  :num-allocs              409627
;  :num-checks              253
;  :propagations            6370
;  :quant-instantiations    8939
;  :rlimit-count            840304)
(assert (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 21
; Joined path conditions
(assert (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14450
;  :arith-add-rows          5581
;  :arith-assert-diseq      415
;  :arith-assert-lower      3310
;  :arith-assert-upper      2181
;  :arith-bound-prop        839
;  :arith-conflicts         164
;  :arith-eq-adapter        2237
;  :arith-fixed-eqs         1517
;  :arith-offset-eqs        813
;  :arith-pivots            2007
;  :conflicts               436
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22563
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.96
;  :minimized-lits          37
;  :mk-bool-var             30638
;  :mk-clause               23182
;  :num-allocs              410350
;  :num-checks              254
;  :propagations            6371
;  :quant-instantiations    8980
;  :rlimit-count            842926)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 21
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 21
; Joined path conditions
(push) ; 21
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 22
(assert (not (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14450
;  :arith-add-rows          5581
;  :arith-assert-diseq      415
;  :arith-assert-lower      3310
;  :arith-assert-upper      2181
;  :arith-bound-prop        839
;  :arith-conflicts         164
;  :arith-eq-adapter        2237
;  :arith-fixed-eqs         1517
;  :arith-offset-eqs        813
;  :arith-pivots            2007
;  :conflicts               436
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22563
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.96
;  :minimized-lits          37
;  :mk-bool-var             30638
;  :mk-clause               23182
;  :num-allocs              410376
;  :num-checks              255
;  :propagations            6371
;  :quant-instantiations    8980
;  :rlimit-count            842956)
(assert (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 21
; Joined path conditions
(assert (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
(push) ; 21
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14475
;  :arith-add-rows          5601
;  :arith-assert-diseq      415
;  :arith-assert-lower      3315
;  :arith-assert-upper      2187
;  :arith-bound-prop        844
;  :arith-conflicts         165
;  :arith-eq-adapter        2243
;  :arith-fixed-eqs         1522
;  :arith-offset-eqs        813
;  :arith-pivots            2013
;  :conflicts               437
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22563
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.01
;  :memory                  7.97
;  :minimized-lits          37
;  :mk-bool-var             30758
;  :mk-clause               23252
;  :num-allocs              411157
;  :num-checks              256
;  :propagations            6378
;  :quant-instantiations    9029
;  :rlimit-count            846117)
(pop) ; 20
(push) ; 20
; [else-branch: 150 | !(i2@228@07 < V@39@07)]
(assert (not (< i2@228@07 V@39@07)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (< i2@228@07 V@39@07)
  (and
    (< i2@228@07 V@39@07)
    (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
    (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 149 | !(0 <= i2@228@07)]
(assert (not (<= 0 i2@228@07)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (<= 0 i2@228@07)
  (and
    (<= 0 i2@228@07)
    (implies
      (< i2@228@07 V@39@07)
      (and
        (< i2@228@07 V@39@07)
        (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
        (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 148 | !(i1@227@07 < V@39@07)]
(assert (not (< i1@227@07 V@39@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i1@227@07 V@39@07)
  (and
    (< i1@227@07 V@39@07)
    (implies
      (<= 0 i2@228@07)
      (and
        (<= 0 i2@228@07)
        (implies
          (< i2@228@07 V@39@07)
          (and
            (< i2@228@07 V@39@07)
            (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
            (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 147 | !(0 <= i1@227@07)]
(assert (not (<= 0 i1@227@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i1@227@07)
  (and
    (<= 0 i1@227@07)
    (implies
      (< i1@227@07 V@39@07)
      (and
        (< i1@227@07 V@39@07)
        (implies
          (<= 0 i2@228@07)
          (and
            (<= 0 i2@228@07)
            (implies
              (< i2@228@07 V@39@07)
              (and
                (< i2@228@07 V@39@07)
                (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
                (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))))))))))
; Joined path conditions
(push) ; 13
; [then-branch: 151 | Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@227@07)) == Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@228@07)) && i2@228@07 < V@39@07 && 0 <= i2@228@07 && i1@227@07 < V@39@07 && 0 <= i1@227@07 | live]
; [else-branch: 151 | !(Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@227@07)) == Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@228@07)) && i2@228@07 < V@39@07 && 0 <= i2@228@07 && i1@227@07 < V@39@07 && 0 <= i1@227@07) | live]
(push) ; 14
; [then-branch: 151 | Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@227@07)) == Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@228@07)) && i2@228@07 < V@39@07 && 0 <= i2@228@07 && i1@227@07 < V@39@07 && 0 <= i1@227@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
        (< i2@228@07 V@39@07))
      (<= 0 i2@228@07))
    (< i1@227@07 V@39@07))
  (<= 0 i1@227@07)))
; [eval] i1 == i2
(pop) ; 14
(push) ; 14
; [else-branch: 151 | !(Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@227@07)) == Lookup(option$array$,sm@136@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@228@07)) && i2@228@07 < V@39@07 && 0 <= i2@228@07 && i1@227@07 < V@39@07 && 0 <= i1@227@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
          (< i2@228@07 V@39@07))
        (<= 0 i2@228@07))
      (< i1@227@07 V@39@07))
    (<= 0 i1@227@07))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
          (< i2@228@07 V@39@07))
        (<= 0 i2@228@07))
      (< i1@227@07 V@39@07))
    (<= 0 i1@227@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
      ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
    (< i2@228@07 V@39@07)
    (<= 0 i2@228@07)
    (< i1@227@07 V@39@07)
    (<= 0 i1@227@07))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@228@07 Int)) (!
  (and
    (implies
      (<= 0 i1@227@07)
      (and
        (<= 0 i1@227@07)
        (implies
          (< i1@227@07 V@39@07)
          (and
            (< i1@227@07 V@39@07)
            (implies
              (<= 0 i2@228@07)
              (and
                (<= 0 i2@228@07)
                (implies
                  (< i2@228@07 V@39@07)
                  (and
                    (< i2@228@07 V@39@07)
                    (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
                    (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
              (< i2@228@07 V@39@07))
            (<= 0 i2@228@07))
          (< i1@227@07 V@39@07))
        (<= 0 i1@227@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
          ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
        (< i2@228@07 V@39@07)
        (<= 0 i2@228@07)
        (< i1@227@07 V@39@07)
        (<= 0 i1@227@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@227@07 Int)) (!
  (forall ((i2@228@07 Int)) (!
    (and
      (implies
        (<= 0 i1@227@07)
        (and
          (<= 0 i1@227@07)
          (implies
            (< i1@227@07 V@39@07)
            (and
              (< i1@227@07 V@39@07)
              (implies
                (<= 0 i2@228@07)
                (and
                  (<= 0 i2@228@07)
                  (implies
                    (< i2@228@07 V@39@07)
                    (and
                      (< i2@228@07 V@39@07)
                      (< i1@227@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
                      (< i2@228@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
                  ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
                (< i2@228@07 V@39@07))
              (<= 0 i2@228@07))
            (< i1@227@07 V@39@07))
          (<= 0 i1@227@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
            ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
          (< i2@228@07 V@39@07)
          (<= 0 i2@228@07)
          (< i1@227@07 V@39@07)
          (<= 0 i1@227@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 11
(assert (not (forall ((i1@227@07 Int)) (!
  (forall ((i2@228@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
              (< i2@228@07 V@39@07))
            (<= 0 i2@228@07))
          (< i1@227@07 V@39@07))
        (<= 0 i1@227@07))
      (= i1@227@07 i2@228@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14509
;  :arith-add-rows          5618
;  :arith-assert-diseq      417
;  :arith-assert-lower      3321
;  :arith-assert-upper      2189
;  :arith-bound-prop        846
;  :arith-conflicts         165
;  :arith-eq-adapter        2254
;  :arith-fixed-eqs         1524
;  :arith-offset-eqs        813
;  :arith-pivots            2027
;  :conflicts               438
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22823
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.03
;  :minimized-lits          37
;  :mk-bool-var             30984
;  :mk-clause               23388
;  :num-allocs              413168
;  :num-checks              257
;  :propagations            6386
;  :quant-instantiations    9122
;  :rlimit-count            853375
;  :time                    0.00)
(assert (forall ((i1@227@07 Int)) (!
  (forall ((i2@228@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
                ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07)))
              (< i2@228@07 V@39@07))
            (<= 0 i2@228@07))
          (< i1@227@07 V@39@07))
        (<= 0 i1@227@07))
      (= i1@227@07 i2@228@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@228@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@227@07))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@229@07 Int)
(declare-const j1@230@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 152 | 0 <= i1@229@07 | live]
; [else-branch: 152 | !(0 <= i1@229@07) | live]
(push) ; 13
; [then-branch: 152 | 0 <= i1@229@07]
(assert (<= 0 i1@229@07))
; [eval] i1 < V
(push) ; 14
; [then-branch: 153 | i1@229@07 < V@39@07 | live]
; [else-branch: 153 | !(i1@229@07 < V@39@07) | live]
(push) ; 15
; [then-branch: 153 | i1@229@07 < V@39@07]
(assert (< i1@229@07 V@39@07))
; [eval] 0 <= j1
(push) ; 16
; [then-branch: 154 | 0 <= j1@230@07 | live]
; [else-branch: 154 | !(0 <= j1@230@07) | live]
(push) ; 17
; [then-branch: 154 | 0 <= j1@230@07]
(assert (<= 0 j1@230@07))
; [eval] j1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 154 | !(0 <= j1@230@07)]
(assert (not (<= 0 j1@230@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 153 | !(i1@229@07 < V@39@07)]
(assert (not (< i1@229@07 V@39@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 152 | !(0 <= i1@229@07)]
(assert (not (<= 0 i1@229@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@230@07 V@39@07) (<= 0 j1@230@07)) (< i1@229@07 V@39@07))
  (<= 0 i1@229@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@229@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14509
;  :arith-add-rows          5618
;  :arith-assert-diseq      417
;  :arith-assert-lower      3327
;  :arith-assert-upper      2189
;  :arith-bound-prop        846
;  :arith-conflicts         165
;  :arith-eq-adapter        2254
;  :arith-fixed-eqs         1524
;  :arith-offset-eqs        813
;  :arith-pivots            2027
;  :conflicts               438
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22823
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.03
;  :minimized-lits          37
;  :mk-bool-var             30991
;  :mk-clause               23388
;  :num-allocs              413774
;  :num-checks              258
;  :propagations            6386
;  :quant-instantiations    9122
;  :rlimit-count            854376)
(assert (< i1@229@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@229@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))
      V@39@07)
    (<=
      0
      (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))))
  (< $Perm.No $k@134@07)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14533
;  :arith-add-rows          5636
;  :arith-assert-diseq      417
;  :arith-assert-lower      3332
;  :arith-assert-upper      2195
;  :arith-bound-prop        851
;  :arith-conflicts         166
;  :arith-eq-adapter        2259
;  :arith-fixed-eqs         1529
;  :arith-offset-eqs        813
;  :arith-pivots            2033
;  :conflicts               439
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22823
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.04
;  :minimized-lits          37
;  :mk-bool-var             31090
;  :mk-clause               23442
;  :num-allocs              414567
;  :num-checks              259
;  :propagations            6387
;  :quant-instantiations    9166
;  :rlimit-count            857300)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14533
;  :arith-add-rows          5636
;  :arith-assert-diseq      417
;  :arith-assert-lower      3332
;  :arith-assert-upper      2195
;  :arith-bound-prop        851
;  :arith-conflicts         166
;  :arith-eq-adapter        2259
;  :arith-fixed-eqs         1529
;  :arith-offset-eqs        813
;  :arith-pivots            2033
;  :conflicts               440
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22823
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.04
;  :minimized-lits          37
;  :mk-bool-var             31090
;  :mk-clause               23442
;  :num-allocs              414657
;  :num-checks              260
;  :propagations            6387
;  :quant-instantiations    9166
;  :rlimit-count            857395)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))
    (as None<option<array>>  option<array>))))
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (<
  j1@230@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14539
;  :arith-add-rows          5641
;  :arith-assert-diseq      417
;  :arith-assert-lower      3334
;  :arith-assert-upper      2197
;  :arith-bound-prop        851
;  :arith-conflicts         167
;  :arith-eq-adapter        2260
;  :arith-fixed-eqs         1530
;  :arith-offset-eqs        813
;  :arith-pivots            2037
;  :conflicts               441
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22827
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.04
;  :minimized-lits          37
;  :mk-bool-var             31101
;  :mk-clause               23446
;  :num-allocs              414855
;  :num-checks              261
;  :propagations            6389
;  :quant-instantiations    9175
;  :rlimit-count            857937)
(assert (<
  j1@230@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))))))
(pop) ; 12
; Joined path conditions
(assert (<
  j1@230@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))))))
(pop) ; 11
(declare-fun inv@231@07 ($Ref) Int)
(declare-fun inv@232@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@229@07 Int) (j1@230@07 Int)) (!
  (and
    (< i1@229@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@230@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))) j1@230@07))
  :qid |int-aux|)))
(declare-const sm@233@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@233@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@233@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@233@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@233@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@233@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef82|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@229@07 Int) (j11@230@07 Int) (i12@229@07 Int) (j12@230@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@230@07 V@39@07) (<= 0 j11@230@07))
            (< i11@229@07 V@39@07))
          (<= 0 i11@229@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@233@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@229@07))) j11@230@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@229@07))) j11@230@07)))
      (and
        (and
          (and
            (and (< j12@230@07 V@39@07) (<= 0 j12@230@07))
            (< i12@229@07 V@39@07))
          (<= 0 i12@229@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@233@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@229@07))) j12@230@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@229@07))) j12@230@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@229@07))) j11@230@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@229@07))) j12@230@07)))
    (and (= i11@229@07 i12@229@07) (= j11@230@07 j12@230@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               14586
;  :arith-add-rows          5650
;  :arith-assert-diseq      417
;  :arith-assert-lower      3344
;  :arith-assert-upper      2197
;  :arith-bound-prop        851
;  :arith-conflicts         167
;  :arith-eq-adapter        2270
;  :arith-fixed-eqs         1530
;  :arith-offset-eqs        813
;  :arith-pivots            2045
;  :conflicts               442
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 404
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1554
;  :del-clause              22978
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.03
;  :minimized-lits          37
;  :mk-bool-var             31273
;  :mk-clause               23543
;  :num-allocs              416809
;  :num-checks              262
;  :propagations            6405
;  :quant-instantiations    9257
;  :rlimit-count            864401
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@229@07 Int) (j1@230@07 Int)) (!
  (implies
    (and
      (and (and (< j1@230@07 V@39@07) (<= 0 j1@230@07)) (< i1@229@07 V@39@07))
      (<= 0 i1@229@07))
    (and
      (=
        (inv@231@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))) j1@230@07))
        i1@229@07)
      (=
        (inv@232@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))) j1@230@07))
        j1@230@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@229@07))) j1@230@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@232@07 r) V@39@07) (<= 0 (inv@232@07 r)))
        (< (inv@231@07 r) V@39@07))
      (<= 0 (inv@231@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@231@07 r)))) (inv@232@07 r))
      r))
  :pattern ((inv@231@07 r))
  :pattern ((inv@232@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@232@07 r) V@39@07) (<= 0 (inv@232@07 r)))
        (< (inv@231@07 r) V@39@07))
      (<= 0 (inv@231@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@233@07  $FVF<Int>) r) r))
  :pattern ((inv@231@07 r) (inv@232@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@234@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@232@07 r) V@39@07) (<= 0 (inv@232@07 r)))
        (< (inv@231@07 r) V@39@07))
      (<= 0 (inv@231@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
            (< (inv@143@07 r) V@39@07))
          (<= 0 (inv@143@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@235@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@232@07 r) V@39@07) (<= 0 (inv@232@07 r)))
        (< (inv@231@07 r) V@39@07))
      (<= 0 (inv@231@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@234@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
            (< (inv@143@07 r) V@39@07))
          (<= 0 (inv@143@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@234@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15622
;  :arith-add-rows          5980
;  :arith-assert-diseq      458
;  :arith-assert-lower      3584
;  :arith-assert-upper      2373
;  :arith-bound-prop        893
;  :arith-conflicts         173
;  :arith-eq-adapter        2464
;  :arith-fixed-eqs         1647
;  :arith-offset-eqs        874
;  :arith-pivots            2139
;  :conflicts               468
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 412
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1741
;  :del-clause              25446
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.06
;  :minimized-lits          37
;  :mk-bool-var             34067
;  :mk-clause               26080
;  :num-allocs              425900
;  :num-checks              264
;  :propagations            7098
;  :quant-instantiations    9912
;  :rlimit-count            897116
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@232@07 r) V@39@07) (<= 0 (inv@232@07 r)))
        (< (inv@231@07 r) V@39@07))
      (<= 0 (inv@231@07 r)))
    (= (- $Perm.Write (pTaken@234@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16028
;  :arith-add-rows          6033
;  :arith-assert-diseq      466
;  :arith-assert-lower      3678
;  :arith-assert-upper      2432
;  :arith-bound-prop        904
;  :arith-conflicts         175
;  :arith-eq-adapter        2528
;  :arith-fixed-eqs         1701
;  :arith-offset-eqs        879
;  :arith-pivots            2165
;  :conflicts               485
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 416
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1757
;  :del-clause              25879
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.06
;  :minimized-lits          37
;  :mk-bool-var             34644
;  :mk-clause               26513
;  :num-allocs              428421
;  :num-checks              265
;  :propagations            7296
;  :quant-instantiations    10141
;  :rlimit-count            908470
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@236@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 155 | 0 <= i1@236@07 | live]
; [else-branch: 155 | !(0 <= i1@236@07) | live]
(push) ; 13
; [then-branch: 155 | 0 <= i1@236@07]
(assert (<= 0 i1@236@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 155 | !(0 <= i1@236@07)]
(assert (not (<= 0 i1@236@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@236@07 V@39@07) (<= 0 i1@236@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@236@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16028
;  :arith-add-rows          6033
;  :arith-assert-diseq      466
;  :arith-assert-lower      3680
;  :arith-assert-upper      2432
;  :arith-bound-prop        904
;  :arith-conflicts         175
;  :arith-eq-adapter        2528
;  :arith-fixed-eqs         1701
;  :arith-offset-eqs        879
;  :arith-pivots            2165
;  :conflicts               485
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 416
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1757
;  :del-clause              25879
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.06
;  :minimized-lits          37
;  :mk-bool-var             34646
;  :mk-clause               26513
;  :num-allocs              428531
;  :num-checks              266
;  :propagations            7296
;  :quant-instantiations    10141
;  :rlimit-count            908650)
(assert (< i1@236@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@236@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 11
(declare-fun inv@237@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@236@07 Int)) (!
  (< i1@236@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@236@07))
  :qid |int-aux|)))
(declare-const sm@238@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@238@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@238@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef84|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@236@07 Int) (i12@236@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@236@07 V@39@07) (<= 0 i11@236@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@238@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@236@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@236@07)))
      (and
        (and (< i12@236@07 V@39@07) (<= 0 i12@236@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@238@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@236@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@236@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@236@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@236@07)))
    (= i11@236@07 i12@236@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16053
;  :arith-add-rows          6035
;  :arith-assert-diseq      467
;  :arith-assert-lower      3684
;  :arith-assert-upper      2432
;  :arith-bound-prop        904
;  :arith-conflicts         175
;  :arith-eq-adapter        2529
;  :arith-fixed-eqs         1701
;  :arith-offset-eqs        879
;  :arith-pivots            2165
;  :conflicts               486
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 416
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1757
;  :del-clause              25886
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.11
;  :memory                  8.06
;  :minimized-lits          37
;  :mk-bool-var             34688
;  :mk-clause               26520
;  :num-allocs              429460
;  :num-checks              267
;  :propagations            7296
;  :quant-instantiations    10180
;  :rlimit-count            911097)
; Definitional axioms for inverse functions
(assert (forall ((i1@236@07 Int)) (!
  (implies
    (and (< i1@236@07 V@39@07) (<= 0 i1@236@07))
    (=
      (inv@237@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@236@07))
      i1@236@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@236@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@237@07 r) V@39@07) (<= 0 (inv@237@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@237@07 r))
      r))
  :pattern ((inv@237@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@237@07 r) V@39@07) (<= 0 (inv@237@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@238@07  $FVF<Int>) r) r))
  :pattern ((inv@237@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@239@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@237@07 r) V@39@07) (<= 0 (inv@237@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@239@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17176
;  :arith-add-rows          6448
;  :arith-assert-diseq      505
;  :arith-assert-lower      3990
;  :arith-assert-upper      2604
;  :arith-bound-prop        967
;  :arith-conflicts         184
;  :arith-eq-adapter        2729
;  :arith-fixed-eqs         1840
;  :arith-offset-eqs        961
;  :arith-pivots            2271
;  :conflicts               516
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 424
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1879
;  :del-clause              27902
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.14
;  :memory                  8.10
;  :minimized-lits          38
;  :mk-bool-var             36957
;  :mk-clause               28670
;  :num-allocs              437307
;  :num-checks              269
;  :propagations            7991
;  :quant-instantiations    10806
;  :rlimit-count            942034
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@237@07 r) V@39@07) (<= 0 (inv@237@07 r)))
    (= (- $Perm.Write (pTaken@239@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17213
;  :arith-add-rows          6460
;  :arith-assert-diseq      507
;  :arith-assert-lower      3999
;  :arith-assert-upper      2614
;  :arith-bound-prop        968
;  :arith-conflicts         185
;  :arith-eq-adapter        2737
;  :arith-fixed-eqs         1846
;  :arith-offset-eqs        961
;  :arith-pivots            2275
;  :conflicts               517
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 424
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1879
;  :del-clause              28009
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.14
;  :memory                  8.10
;  :minimized-lits          38
;  :mk-bool-var             37096
;  :mk-clause               28777
;  :num-allocs              438038
;  :num-checks              270
;  :propagations            7996
;  :quant-instantiations    10857
;  :rlimit-count            944470
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 11
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(declare-const i1@240@07 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 156 | 0 <= i1@240@07 | live]
; [else-branch: 156 | !(0 <= i1@240@07) | live]
(push) ; 14
; [then-branch: 156 | 0 <= i1@240@07]
(assert (<= 0 i1@240@07))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 156 | !(0 <= i1@240@07)]
(assert (not (<= 0 i1@240@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@240@07 V@39@07) (<= 0 i1@240@07)))
(declare-const $k@241@07 $Perm)
(assert ($Perm.isReadVar $k@241@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@240@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17213
;  :arith-add-rows          6460
;  :arith-assert-diseq      508
;  :arith-assert-lower      4003
;  :arith-assert-upper      2615
;  :arith-bound-prop        968
;  :arith-conflicts         185
;  :arith-eq-adapter        2738
;  :arith-fixed-eqs         1846
;  :arith-offset-eqs        961
;  :arith-pivots            2275
;  :conflicts               517
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 424
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1879
;  :del-clause              28009
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.14
;  :memory                  8.10
;  :minimized-lits          38
;  :mk-bool-var             37102
;  :mk-clause               28779
;  :num-allocs              438215
;  :num-checks              271
;  :propagations            7997
;  :quant-instantiations    10857
;  :rlimit-count            944799)
(assert (< i1@240@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 13
; Joined path conditions
(assert (< i1@240@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 12
(declare-fun inv@242@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@241@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@240@07 Int)) (!
  (< i1@240@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@240@07))
  :qid |int-aux|)))
(push) ; 12
(assert (not (forall ((i1@240@07 Int)) (!
  (implies
    (and (< i1@240@07 V@39@07) (<= 0 i1@240@07))
    (or (= $k@241@07 $Perm.No) (< $Perm.No $k@241@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17213
;  :arith-add-rows          6460
;  :arith-assert-diseq      509
;  :arith-assert-lower      4005
;  :arith-assert-upper      2616
;  :arith-bound-prop        968
;  :arith-conflicts         185
;  :arith-eq-adapter        2739
;  :arith-fixed-eqs         1846
;  :arith-offset-eqs        961
;  :arith-pivots            2275
;  :conflicts               518
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 424
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1879
;  :del-clause              28011
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.14
;  :memory                  8.10
;  :minimized-lits          38
;  :mk-bool-var             37109
;  :mk-clause               28781
;  :num-allocs              438646
;  :num-checks              272
;  :propagations            7998
;  :quant-instantiations    10857
;  :rlimit-count            945344)
(declare-const sm@243@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@243@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@243@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@243@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@243@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef86|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@243@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef87|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@240@07 Int) (i12@240@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@240@07 V@39@07) (<= 0 i11@240@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@243@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@240@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@240@07)))
        (< $Perm.No $k@241@07))
      (and
        (and
          (and (< i12@240@07 V@39@07) (<= 0 i12@240@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@243@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@240@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@240@07)))
        (< $Perm.No $k@241@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@240@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@240@07)))
    (= i11@240@07 i12@240@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17241
;  :arith-add-rows          6462
;  :arith-assert-diseq      510
;  :arith-assert-lower      4009
;  :arith-assert-upper      2616
;  :arith-bound-prop        968
;  :arith-conflicts         185
;  :arith-eq-adapter        2740
;  :arith-fixed-eqs         1846
;  :arith-offset-eqs        961
;  :arith-pivots            2275
;  :conflicts               519
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 424
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               1879
;  :del-clause              28022
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.14
;  :memory                  8.10
;  :minimized-lits          38
;  :mk-bool-var             37161
;  :mk-clause               28792
;  :num-allocs              439700
;  :num-checks              273
;  :propagations            8000
;  :quant-instantiations    10901
;  :rlimit-count            948569)
; Definitional axioms for inverse functions
(assert (forall ((i1@240@07 Int)) (!
  (implies
    (and (and (< i1@240@07 V@39@07) (<= 0 i1@240@07)) (< $Perm.No $k@241@07))
    (=
      (inv@242@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@240@07))
      i1@240@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@240@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
      (< $Perm.No $k@241@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@242@07 r))
      r))
  :pattern ((inv@242@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@243@07  $FVF<Int>) r) r))
  :pattern ((inv@242@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@244@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        $Perm.Write
        $Perm.No)
      $k@241@07)
    $Perm.No))
(define-fun pTaken@245@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
            (< (inv@143@07 r) V@39@07))
          (<= 0 (inv@143@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@241@07 (pTaken@244@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@241@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
      (<
        (ite
          (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
          $k@241@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
          $k@241@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@147@07 r))
  :pattern ((inv@242@07 r))
  :qid |qp.srp88|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
    (= (- $k@241@07 (pTaken@244@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18451
;  :arith-add-rows          6663
;  :arith-assert-diseq      546
;  :arith-assert-lower      4359
;  :arith-assert-upper      2791
;  :arith-bound-prop        1013
;  :arith-conflicts         188
;  :arith-eq-adapter        2951
;  :arith-fixed-eqs         2010
;  :arith-offset-eqs        1026
;  :arith-pivots            2378
;  :conflicts               542
;  :datatype-accessor-ax    152
;  :datatype-constructor-ax 432
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2002
;  :del-clause              29868
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          8
;  :max-memory              8.31
;  :memory                  8.25
;  :minimized-lits          38
;  :mk-bool-var             39087
;  :mk-clause               30691
;  :num-allocs              447464
;  :num-checks              275
;  :propagations            8816
;  :quant-instantiations    11573
;  :rlimit-count            980671
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@246@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@246@07  $FVF<Int>)))
    (and
      (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
      (< $Perm.No $k@241@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@246@07  $FVF<Int>))))
  :qid |qp.fvfDomDef92|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
        (< $Perm.No $k@241@07))
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r))))
    (=
      ($FVF.lookup_int (as sm@246@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@246@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
        (< $Perm.No $k@241@07))
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r))))
    (=
      ($FVF.lookup_int (as sm@246@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@246@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef90|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@246@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef91|)))
(pop) ; 11
; Joined path conditions
(assert ($Perm.isReadVar $k@241@07 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@243@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@243@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@243@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@243@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef86|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@243@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef87|)))
(assert (forall ((i1@240@07 Int)) (!
  (implies
    (and (and (< i1@240@07 V@39@07) (<= 0 i1@240@07)) (< $Perm.No $k@241@07))
    (=
      (inv@242@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@240@07))
      i1@240@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@240@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
      (< $Perm.No $k@241@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@242@07 r))
      r))
  :pattern ((inv@242@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@246@07  $FVF<Int>)))
    (and
      (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
      (< $Perm.No $k@241@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@246@07  $FVF<Int>))))
  :qid |qp.fvfDomDef92|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
        (< $Perm.No $k@241@07))
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r))))
    (=
      ($FVF.lookup_int (as sm@246@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@246@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
        (< $Perm.No $k@241@07))
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r))))
    (=
      ($FVF.lookup_int (as sm@246@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@246@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef90|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@246@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef91|)))
(assert (and
  (forall ((i1@240@07 Int)) (!
    (< i1@240@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@240@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@243@07  $FVF<Int>) r) r))
    :pattern ((inv@242@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        (<
          (ite
            (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
            $k@241@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@242@07 r) V@39@07) (<= 0 (inv@242@07 r)))
            $k@241@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@147@07 r))
    :pattern ((inv@242@07 r))
    :qid |qp.srp88|))))
(set-option :timeout 0)
(push) ; 11
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@246@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 11
; 0.11s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24953
;  :arith-add-rows          8907
;  :arith-assert-diseq      679
;  :arith-assert-lower      5992
;  :arith-assert-upper      3957
;  :arith-bound-prop        1271
;  :arith-conflicts         199
;  :arith-eq-adapter        4055
;  :arith-fixed-eqs         3198
;  :arith-offset-eqs        1447
;  :arith-pivots            3201
;  :conflicts               576
;  :datatype-accessor-ax    155
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2425
;  :del-clause              44079
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.89
;  :minimized-lits          50
;  :mk-bool-var             56222
;  :mk-clause               44849
;  :num-allocs              510629
;  :num-checks              276
;  :propagations            12727
;  :quant-instantiations    16761
;  :rlimit-count            1130492
;  :time                    0.11)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@246@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
; [eval] 0 <= u
(push) ; 11
(assert (not (<= 0 u@188@07)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24964
;  :arith-add-rows          8909
;  :arith-assert-diseq      679
;  :arith-assert-lower      5993
;  :arith-assert-upper      3959
;  :arith-bound-prop        1271
;  :arith-conflicts         200
;  :arith-eq-adapter        4056
;  :arith-fixed-eqs         3199
;  :arith-offset-eqs        1447
;  :arith-pivots            3201
;  :conflicts               577
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2425
;  :del-clause              44080
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.89
;  :minimized-lits          50
;  :mk-bool-var             56279
;  :mk-clause               44899
;  :num-allocs              511004
;  :num-checks              277
;  :propagations            12738
;  :quant-instantiations    16770
;  :rlimit-count            1131094)
(assert (<= 0 u@188@07))
; [eval] u < V
(push) ; 11
(assert (not (< u@188@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24965
;  :arith-add-rows          8913
;  :arith-assert-diseq      679
;  :arith-assert-lower      5996
;  :arith-assert-upper      3960
;  :arith-bound-prop        1271
;  :arith-conflicts         201
;  :arith-eq-adapter        4057
;  :arith-fixed-eqs         3200
;  :arith-offset-eqs        1447
;  :arith-pivots            3204
;  :conflicts               578
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2425
;  :del-clause              44080
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.89
;  :minimized-lits          50
;  :mk-bool-var             56283
;  :mk-clause               44899
;  :num-allocs              511171
;  :num-checks              278
;  :propagations            12738
;  :quant-instantiations    16770
;  :rlimit-count            1131290)
(assert (< u@188@07 V@39@07))
; [eval] 0 <= v
; [eval] v <= V
(push) ; 11
(assert (not (<= 0 V@39@07)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24965
;  :arith-add-rows          8913
;  :arith-assert-diseq      679
;  :arith-assert-lower      5996
;  :arith-assert-upper      3962
;  :arith-bound-prop        1271
;  :arith-conflicts         202
;  :arith-eq-adapter        4057
;  :arith-fixed-eqs         3200
;  :arith-offset-eqs        1447
;  :arith-pivots            3204
;  :conflicts               579
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2425
;  :del-clause              44080
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.89
;  :minimized-lits          50
;  :mk-bool-var             56285
;  :mk-clause               44899
;  :num-allocs              511323
;  :num-checks              279
;  :propagations            12738
;  :quant-instantiations    16770
;  :rlimit-count            1131568)
(assert (<= 0 V@39@07))
; [eval] 0 <= k
; [eval] k < V
(push) ; 11
(assert (not (< 0 V@39@07)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24965
;  :arith-add-rows          8924
;  :arith-assert-diseq      679
;  :arith-assert-lower      5997
;  :arith-assert-upper      3963
;  :arith-bound-prop        1271
;  :arith-conflicts         203
;  :arith-eq-adapter        4057
;  :arith-fixed-eqs         3201
;  :arith-offset-eqs        1447
;  :arith-pivots            3205
;  :conflicts               580
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2425
;  :del-clause              44080
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.89
;  :minimized-lits          50
;  :mk-bool-var             56287
;  :mk-clause               44899
;  :num-allocs              511461
;  :num-checks              280
;  :propagations            12738
;  :quant-instantiations    16770
;  :rlimit-count            1131974)
(assert (< 0 V@39@07))
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 11
; [eval] this != null
(pop) ; 11
; Joined path conditions
(declare-const i1@247@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 157 | 0 <= i1@247@07 | live]
; [else-branch: 157 | !(0 <= i1@247@07) | live]
(push) ; 13
; [then-branch: 157 | 0 <= i1@247@07]
(assert (<= 0 i1@247@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 157 | !(0 <= i1@247@07)]
(assert (not (<= 0 i1@247@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@247@07 V@39@07) (<= 0 i1@247@07)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@247@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24965
;  :arith-add-rows          8924
;  :arith-assert-diseq      679
;  :arith-assert-lower      6000
;  :arith-assert-upper      3963
;  :arith-bound-prop        1271
;  :arith-conflicts         203
;  :arith-eq-adapter        4057
;  :arith-fixed-eqs         3201
;  :arith-offset-eqs        1447
;  :arith-pivots            3205
;  :conflicts               580
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2425
;  :del-clause              44080
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.89
;  :minimized-lits          50
;  :mk-bool-var             56290
;  :mk-clause               44899
;  :num-allocs              511629
;  :num-checks              281
;  :propagations            12738
;  :quant-instantiations    16770
;  :rlimit-count            1132214)
(assert (< i1@247@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@247@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 11
(declare-fun inv@248@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@247@07 Int)) (!
  (< i1@247@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@247@07))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@247@07 Int) (i12@247@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@247@07 V@39@07) (<= 0 i11@247@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@247@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@247@07)))
      (and
        (and (< i12@247@07 V@39@07) (<= 0 i12@247@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@247@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@247@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@247@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@247@07)))
    (= i11@247@07 i12@247@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24980
;  :arith-add-rows          8926
;  :arith-assert-diseq      680
;  :arith-assert-lower      6004
;  :arith-assert-upper      3963
;  :arith-bound-prop        1271
;  :arith-conflicts         203
;  :arith-eq-adapter        4058
;  :arith-fixed-eqs         3201
;  :arith-offset-eqs        1447
;  :arith-pivots            3205
;  :conflicts               581
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2425
;  :del-clause              44091
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.87
;  :minimized-lits          50
;  :mk-bool-var             56323
;  :mk-clause               44910
;  :num-allocs              512207
;  :num-checks              282
;  :propagations            12738
;  :quant-instantiations    16796
;  :rlimit-count            1133458)
; Definitional axioms for inverse functions
(assert (forall ((i1@247@07 Int)) (!
  (implies
    (and (< i1@247@07 V@39@07) (<= 0 i1@247@07))
    (=
      (inv@248@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@247@07))
      i1@247@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@247@07))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@248@07 r) V@39@07) (<= 0 (inv@248@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@248@07 r))
      r))
  :pattern ((inv@248@07 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@248@07 r) V@39@07) (<= 0 (inv@248@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) r) r))
  :pattern ((inv@248@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@249@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@248@07 r) V@39@07) (<= 0 (inv@248@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@156@07 r) V@39@07) (<= 0 (inv@156@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@156@07 r) V@39@07) (<= 0 (inv@156@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@249@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26084
;  :arith-add-rows          9117
;  :arith-assert-diseq      706
;  :arith-assert-lower      6264
;  :arith-assert-upper      4123
;  :arith-bound-prop        1294
;  :arith-conflicts         205
;  :arith-eq-adapter        4244
;  :arith-fixed-eqs         3365
;  :arith-offset-eqs        1492
;  :arith-pivots            3269
;  :conflicts               603
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 444
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2490
;  :del-clause              45559
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.83
;  :minimized-lits          51
;  :mk-bool-var             57994
;  :mk-clause               46379
;  :num-allocs              518591
;  :num-checks              284
;  :propagations            13436
;  :quant-instantiations    17437
;  :rlimit-count            1159685
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@248@07 r) V@39@07) (<= 0 (inv@248@07 r)))
    (= (- $Perm.Write (pTaken@249@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26110
;  :arith-add-rows          9129
;  :arith-assert-diseq      708
;  :arith-assert-lower      6271
;  :arith-assert-upper      4131
;  :arith-bound-prop        1295
;  :arith-conflicts         206
;  :arith-eq-adapter        4251
;  :arith-fixed-eqs         3369
;  :arith-offset-eqs        1492
;  :arith-pivots            3273
;  :conflicts               604
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 444
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2490
;  :del-clause              45594
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.04
;  :memory                  9.83
;  :minimized-lits          51
;  :mk-bool-var             58058
;  :mk-clause               46414
;  :num-allocs              519067
;  :num-checks              285
;  :propagations            13441
;  :quant-instantiations    17460
;  :rlimit-count            1161047
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; Loop head block: Execute statements of loop head block (in invariant state)
(push) ; 11
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@219@07 r))
      r))
  :pattern ((inv@219@07 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
    (=
      ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef77|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef78|)))
(assert (forall ((i1@218@07 Int)) (!
  (implies
    (and (< i1@218@07 V@39@07) (<= 0 i1@218@07))
    (=
      (inv@219@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07))
      i1@218@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07))
  )))
(assert (forall ((i1@218@07 Int)) (!
  (implies
    (and (< i1@218@07 V@39@07) (<= 0 i1@218@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07))
  :qid |bool-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r) r))
  :pattern ((inv@219@07 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@210@07 r))
      r))
  :pattern ((inv@210@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@211@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef69|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@211@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@211@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef71|)))
(assert ($Perm.isReadVar $k@213@07 $Perm.Write))
(assert (forall ((i1@212@07 Int)) (!
  (implies
    (and (and (< i1@212@07 V@39@07) (<= 0 i1@212@07)) (< $Perm.No $k@213@07))
    (=
      (inv@214@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
      i1@212@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
      (< $Perm.No $k@213@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@214@07 r))
      r))
  :pattern ((inv@214@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@217@07  $FVF<Int>)))
    (and
      (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
      (< $Perm.No $k@213@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@217@07  $FVF<Int>))))
  :qid |qp.fvfDomDef76|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
        (< $Perm.No $k@213@07))
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r))))
    (=
      ($FVF.lookup_int (as sm@217@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
        (< $Perm.No $k@213@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@217@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@217@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef75|)))
(assert (forall ((i1@209@07 Int)) (!
  (implies
    (and (< i1@209@07 V@39@07) (<= 0 i1@209@07))
    (=
      (inv@210@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07))
      i1@209@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07))
  )))
(assert (forall ((i1@209@07 Int)) (!
  (implies
    (and (< i1@209@07 V@39@07) (<= 0 i1@209@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r) r))
  :pattern ((inv@210@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))
  $Snap.unit))
(assert (forall ((i1@212@07 Int)) (!
  (< i1@212@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@212@07))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@211@07  $FVF<Int>) r) r))
  :pattern ((inv@214@07 r))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
      (<
        (ite
          (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
          $k@213@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@214@07 r) V@39@07) (<= 0 (inv@214@07 r)))
          $k@213@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@210@07 r))
  :pattern ((inv@214@07 r))
  :qid |qp.srp72|)))
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@217@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))
  $Snap.unit))
(assert (<= 0 v@193@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))
  $Snap.unit))
(assert (<= v@193@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))
  $Snap.unit))
(assert (<= 0 k@190@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))
  $Snap.unit))
(assert (< k@190@07 V@39@07))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))
  $Snap.unit))
(assert (valid_graph_vertices1 $Snap.unit this@36@07 queue@191@07 V@39@07))
(assert (forall ((i1@218@07 Int)) (!
  (< i1@218@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@218@07))
  :qid |bool-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@206@07 r)))) (inv@207@07 r))
      r))
  :pattern ((inv@206@07 r))
  :pattern ((inv@207@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@208@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@208@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@208@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef68|)))
(assert (forall ((i1@204@07 Int) (j1@205@07 Int)) (!
  (implies
    (and
      (and (and (< j1@205@07 V@39@07) (<= 0 j1@205@07)) (< i1@204@07 V@39@07))
      (<= 0 i1@204@07))
    (and
      (=
        (inv@206@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
        i1@204@07)
      (=
        (inv@207@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
        j1@205@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
  )))
(assert (forall ((i1@204@07 Int) (j1@205@07 Int)) (!
  (implies
    (and
      (and (and (< j1@205@07 V@39@07) (<= 0 j1@205@07)) (< i1@204@07 V@39@07))
      (<= 0 i1@204@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
  :qid |int-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@208@07  $FVF<Int>) r) r))
  :pattern ((inv@206@07 r) (inv@207@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))
(assert (forall ((i1@209@07 Int)) (!
  (< i1@209@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@209@07))
  :qid |int-aux|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
      (< $Perm.No $k@197@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@198@07 r))
      r))
  :pattern ((inv@198@07 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
      (< $Perm.No $k@197@07)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r))
  :qid |qp.fvfValDef65|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef66|)))
(assert (forall ((i1@196@07 Int)) (!
  (implies
    (and (and (< i1@196@07 V@39@07) (<= 0 i1@196@07)) (< $Perm.No $k@197@07))
    (=
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
      i1@196@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  )))
(assert (forall ((i1@196@07 Int)) (!
  (<= $Perm.No $k@197@07)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  :qid |option$array$-permAtLeastZero|)))
(assert (forall ((i1@196@07 Int)) (!
  (<= $k@197@07 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  :qid |option$array$-permAtMostOne|)))
(assert (forall ((i1@196@07 Int)) (!
  (implies
    (and (and (< i1@196@07 V@39@07) (<= 0 i1@196@07)) (< $Perm.No $k@197@07))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  :qid |option$array$-permImpliesNonNull|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r) r))
  :pattern ((inv@198@07 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))
  $Snap.unit))
(assert (forall ((i1@200@07 Int)) (!
  (implies
    (and (< i1@200@07 V@39@07) (<= 0 i1@200@07))
    (and
      (< i1@200@07 V@39@07)
      (<= 0 i1@200@07)
      (< i1@200@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@200@07 Int)) (!
  (implies
    (and (< i1@200@07 V@39@07) (<= 0 i1@200@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@200@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))
  $Snap.unit))
(assert (forall ((i1@201@07 Int)) (!
  (implies
    (and (< i1@201@07 V@39@07) (<= 0 i1@201@07))
    (and
      (< i1@201@07 V@39@07)
      (<= 0 i1@201@07)
      (< i1@201@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@201@07 Int)) (!
  (implies
    (and (< i1@201@07 V@39@07) (<= 0 i1@201@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@201@07)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))
  $Snap.unit))
(assert (forall ((i1@202@07 Int)) (!
  (forall ((i2@203@07 Int)) (!
    (and
      (implies
        (<= 0 i1@202@07)
        (and
          (<= 0 i1@202@07)
          (implies
            (< i1@202@07 V@39@07)
            (and
              (< i1@202@07 V@39@07)
              (implies
                (<= 0 i2@203@07)
                (and
                  (<= 0 i2@203@07)
                  (implies
                    (< i2@203@07 V@39@07)
                    (and
                      (< i2@203@07 V@39@07)
                      (< i1@202@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                      (< i2@203@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                  ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
                (< i2@203@07 V@39@07))
              (<= 0 i2@203@07))
            (< i1@202@07 V@39@07))
          (<= 0 i1@202@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
          (< i2@203@07 V@39@07)
          (<= 0 i2@203@07)
          (< i1@202@07 V@39@07)
          (<= 0 i1@202@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@202@07 Int)) (!
  (forall ((i2@203@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07)))
              (< i2@203@07 V@39@07))
            (<= 0 i2@203@07))
          (< i1@202@07 V@39@07))
        (<= 0 i1@202@07))
      (= i1@202@07 i2@203@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@203@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@202@07))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))
  $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))))
(assert (forall ((i1@204@07 Int) (j1@205@07 Int)) (!
  (and
    (< i1@204@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@205@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@204@07))) j1@205@07))
  :qid |int-aux|)))
(assert ($Perm.isReadVar $k@197@07 $Perm.Write))
(assert (= $t@195@07 ($Snap.combine ($Snap.first $t@195@07) ($Snap.second $t@195@07))))
(assert (= ($Snap.first $t@195@07) $Snap.unit))
(assert (=
  ($Snap.second $t@195@07)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@195@07))
    ($Snap.second ($Snap.second $t@195@07)))))
(assert (= ($Snap.first ($Snap.second $t@195@07)) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second $t@195@07))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@195@07)))
    ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@195@07))) $Snap.unit))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@195@07)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))
(assert (forall ((i1@196@07 Int)) (!
  (< i1@196@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@196@07))
  :qid |option$array$-aux|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(set-option :timeout 10)
(check-sat)
; unknown
; Loop head block: Follow loop-internal edges
; [eval] v < V
(push) ; 12
(assert (not (not (< v@193@07 V@39@07))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29225
;  :arith-add-rows          9570
;  :arith-assert-diseq      789
;  :arith-assert-lower      7062
;  :arith-assert-upper      4559
;  :arith-bound-prop        1361
;  :arith-conflicts         209
;  :arith-eq-adapter        4682
;  :arith-fixed-eqs         3793
;  :arith-offset-eqs        1693
;  :arith-pivots            3425
;  :conflicts               609
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 456
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2843
;  :del-clause              53726
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.21
;  :memory                  9.91
;  :minimized-lits          53
;  :mk-bool-var             65426
;  :mk-clause               54722
;  :num-allocs              546132
;  :num-checks              288
;  :propagations            15895
;  :quant-instantiations    19736
;  :rlimit-count            1268541
;  :time                    0.01)
(push) ; 12
(assert (not (< v@193@07 V@39@07)))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29895
;  :arith-add-rows          9696
;  :arith-assert-diseq      804
;  :arith-assert-lower      7226
;  :arith-assert-upper      4654
;  :arith-bound-prop        1367
;  :arith-conflicts         210
;  :arith-eq-adapter        4800
;  :arith-fixed-eqs         3887
;  :arith-offset-eqs        1725
;  :arith-pivots            3450
;  :conflicts               611
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2863
;  :del-clause              54559
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.21
;  :memory                  9.83
;  :minimized-lits          53
;  :mk-bool-var             66513
;  :mk-clause               55555
;  :num-allocs              550110
;  :num-checks              289
;  :propagations            16252
;  :quant-instantiations    20217
;  :rlimit-count            1287367
;  :time                    0.01)
; [then-branch: 158 | v@193@07 < V@39@07 | live]
; [else-branch: 158 | !(v@193@07 < V@39@07) | live]
(push) ; 12
; [then-branch: 158 | v@193@07 < V@39@07]
(assert (< v@193@07 V@39@07))
; [exec]
; k := v
; [eval] !aloc(opt_get1(visited), v).bool && 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int
; [eval] !aloc(opt_get1(visited), v).bool
; [eval] aloc(opt_get1(visited), v)
; [eval] opt_get1(visited)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< v@193@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29895
;  :arith-add-rows          9696
;  :arith-assert-diseq      804
;  :arith-assert-lower      7227
;  :arith-assert-upper      4654
;  :arith-bound-prop        1367
;  :arith-conflicts         210
;  :arith-eq-adapter        4800
;  :arith-fixed-eqs         3887
;  :arith-offset-eqs        1725
;  :arith-pivots            3450
;  :conflicts               611
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2863
;  :del-clause              54559
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.21
;  :memory                  9.83
;  :minimized-lits          53
;  :mk-bool-var             66514
;  :mk-clause               55555
;  :num-allocs              550206
;  :num-checks              290
;  :propagations            16252
;  :quant-instantiations    20217
;  :rlimit-count            1287477)
(assert (< v@193@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 13
; Joined path conditions
(assert (< v@193@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
(push) ; 13
(assert (not (and
  (<
    (inv@219@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))
    V@39@07)
  (<=
    0
    (inv@219@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29943
;  :arith-add-rows          9726
;  :arith-assert-diseq      804
;  :arith-assert-lower      7233
;  :arith-assert-upper      4661
;  :arith-bound-prop        1374
;  :arith-conflicts         211
;  :arith-eq-adapter        4807
;  :arith-fixed-eqs         3893
;  :arith-offset-eqs        1738
;  :arith-pivots            3457
;  :conflicts               612
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2863
;  :del-clause              54559
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.21
;  :memory                  9.85
;  :minimized-lits          53
;  :mk-bool-var             66619
;  :mk-clause               55633
;  :num-allocs              550730
;  :num-checks              291
;  :propagations            16255
;  :quant-instantiations    20250
;  :rlimit-count            1289397)
(push) ; 13
; [then-branch: 159 | !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07))) | live]
; [else-branch: 159 | Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07)) | live]
(push) ; 14
; [then-branch: 159 | !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07)))]
(assert (not
  ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))))
; [eval] 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k)
; [eval] opt_get1(aloc(opt_get1(Gf), u).option$array$)
; [eval] aloc(opt_get1(Gf), u)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< u@188@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29944
;  :arith-add-rows          9726
;  :arith-assert-diseq      804
;  :arith-assert-lower      7233
;  :arith-assert-upper      4661
;  :arith-bound-prop        1374
;  :arith-conflicts         211
;  :arith-eq-adapter        4807
;  :arith-fixed-eqs         3893
;  :arith-offset-eqs        1738
;  :arith-pivots            3457
;  :conflicts               612
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2863
;  :del-clause              54559
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.21
;  :memory                  9.85
;  :minimized-lits          53
;  :mk-bool-var             66619
;  :mk-clause               55633
;  :num-allocs              550822
;  :num-checks              292
;  :propagations            16255
;  :quant-instantiations    20250
;  :rlimit-count            1289528)
(assert (< u@188@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 15
; Joined path conditions
(assert (< u@188@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29979
;  :arith-add-rows          9751
;  :arith-assert-diseq      804
;  :arith-assert-lower      7238
;  :arith-assert-upper      4667
;  :arith-bound-prop        1379
;  :arith-conflicts         212
;  :arith-eq-adapter        4812
;  :arith-fixed-eqs         3898
;  :arith-offset-eqs        1738
;  :arith-pivots            3463
;  :conflicts               613
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2863
;  :del-clause              54559
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.21
;  :memory                  9.86
;  :minimized-lits          53
;  :mk-bool-var             66757
;  :mk-clause               55710
;  :num-allocs              551796
;  :num-checks              293
;  :propagations            16258
;  :quant-instantiations    20313
;  :rlimit-count            1293442)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29980
;  :arith-add-rows          9751
;  :arith-assert-diseq      804
;  :arith-assert-lower      7238
;  :arith-assert-upper      4667
;  :arith-bound-prop        1379
;  :arith-conflicts         212
;  :arith-eq-adapter        4812
;  :arith-fixed-eqs         3898
;  :arith-offset-eqs        1738
;  :arith-pivots            3463
;  :conflicts               614
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2863
;  :del-clause              54559
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.21
;  :memory                  9.86
;  :minimized-lits          53
;  :mk-bool-var             66758
;  :mk-clause               55710
;  :num-allocs              551891
;  :num-checks              294
;  :propagations            16258
;  :quant-instantiations    20313
;  :rlimit-count            1293539)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  v@193@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29990
;  :arith-add-rows          9799
;  :arith-assert-diseq      804
;  :arith-assert-lower      7241
;  :arith-assert-upper      4668
;  :arith-bound-prop        1380
;  :arith-conflicts         213
;  :arith-eq-adapter        4813
;  :arith-fixed-eqs         3899
;  :arith-offset-eqs        1738
;  :arith-pivots            3467
;  :conflicts               615
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2863
;  :del-clause              54561
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.21
;  :memory                  9.86
;  :minimized-lits          53
;  :mk-bool-var             66770
;  :mk-clause               55712
;  :num-allocs              552097
;  :num-checks              295
;  :propagations            16260
;  :quant-instantiations    20320
;  :rlimit-count            1294800)
(assert (<
  v@193@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))))))
(pop) ; 15
; Joined path conditions
(assert (<
  v@193@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))))))
(declare-const sm@250@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@250@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@250@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@250@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@250@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@250@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef95|)))
(declare-const pm@251@07 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@251@07  $FPM) r)
    (+
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@251@07  $FPM) r))
  :qid |qp.resPrmSumDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@250@07  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@251@07  $FPM) r))
  :qid |qp.resTrgDef97|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@250@07  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
(push) ; 15
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@251@07  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32567
;  :arith-add-rows          10268
;  :arith-assert-diseq      856
;  :arith-assert-lower      7811
;  :arith-assert-upper      5001
;  :arith-bound-prop        1473
;  :arith-conflicts         220
;  :arith-eq-adapter        5193
;  :arith-fixed-eqs         4228
;  :arith-offset-eqs        1903
;  :arith-pivots            3654
;  :conflicts               630
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 472
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               2985
;  :del-clause              58134
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.47
;  :memory                  10.34
;  :minimized-lits          53
;  :mk-bool-var             71254
;  :mk-clause               59395
;  :num-allocs              568605
;  :num-checks              296
;  :propagations            17573
;  :quant-instantiations    21961
;  :rlimit-count            1353069
;  :time                    0.04)
(pop) ; 14
(push) ; 14
; [else-branch: 159 | Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07))]
(assert ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@250@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@250@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@250@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@250@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@250@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef95|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@251@07  $FPM) r)
    (+
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@251@07  $FPM) r))
  :qid |qp.resPrmSumDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@250@07  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@251@07  $FPM) r))
  :qid |qp.resTrgDef97|)))
(assert (implies
  (not
    ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
  (and
    (not
      ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
    (< u@188@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
        (as None<option<array>>  option<array>)))
    (<
      v@193@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@250@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))))
; Joined path conditions
(set-option :timeout 10)
(push) ; 13
(assert (not (not
  (and
    (<
      0
      ($FVF.lookup_int (as sm@250@07  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
    (not
      ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33361
;  :arith-add-rows          10518
;  :arith-assert-diseq      871
;  :arith-assert-lower      7986
;  :arith-assert-upper      5110
;  :arith-bound-prop        1493
;  :arith-conflicts         222
;  :arith-eq-adapter        5323
;  :arith-fixed-eqs         4333
;  :arith-offset-eqs        1933
;  :arith-pivots            3704
;  :conflicts               633
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 476
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               3013
;  :del-clause              59307
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.47
;  :memory                  10.32
;  :minimized-lits          53
;  :mk-bool-var             72538
;  :mk-clause               60388
;  :num-allocs              574038
;  :num-checks              297
;  :propagations            17957
;  :quant-instantiations    22450
;  :rlimit-count            1379646
;  :time                    0.01)
(push) ; 13
(assert (not (and
  (<
    0
    ($FVF.lookup_int (as sm@250@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
  (not
    ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               34169
;  :arith-add-rows          10673
;  :arith-assert-diseq      886
;  :arith-assert-lower      8166
;  :arith-assert-upper      5220
;  :arith-bound-prop        1514
;  :arith-conflicts         224
;  :arith-eq-adapter        5454
;  :arith-fixed-eqs         4438
;  :arith-offset-eqs        1963
;  :arith-pivots            3738
;  :conflicts               636
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 480
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               3043
;  :del-clause              60347
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.47
;  :memory                  10.30
;  :minimized-lits          53
;  :mk-bool-var             73917
;  :mk-clause               61428
;  :num-allocs              578985
;  :num-checks              298
;  :propagations            18353
;  :quant-instantiations    23013
;  :rlimit-count            1402397
;  :time                    0.01)
; [then-branch: 160 | 0 < Lookup(int,sm@250@07,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), u@188@07))), v@193@07)) && !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07))) | live]
; [else-branch: 160 | !(0 < Lookup(int,sm@250@07,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), u@188@07))), v@193@07)) && !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07)))) | live]
(push) ; 13
; [then-branch: 160 | 0 < Lookup(int,sm@250@07,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), u@188@07))), v@193@07)) && !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07)))]
(assert (and
  (<
    0
    ($FVF.lookup_int (as sm@250@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
  (not
    ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))))
; [exec]
; queue := queue ++ Seq(k)
; [eval] queue ++ Seq(k)
; [eval] Seq(k)
(assert (= (Seq_length (Seq_singleton v@193@07)) 1))
(declare-const queue@252@07 Seq<Int>)
(assert (Seq_equal queue@252@07 (Seq_append queue@191@07 (Seq_singleton v@193@07))))
; [exec]
; aloc(opt_get1(p), v).int := u
; [eval] aloc(opt_get1(p), v)
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< v@193@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               34265
;  :arith-add-rows          10698
;  :arith-assert-diseq      886
;  :arith-assert-lower      8183
;  :arith-assert-upper      5235
;  :arith-bound-prop        1521
;  :arith-conflicts         224
;  :arith-eq-adapter        5470
;  :arith-fixed-eqs         4450
;  :arith-offset-eqs        1964
;  :arith-pivots            3749
;  :conflicts               636
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 480
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               3043
;  :del-clause              60347
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          9
;  :max-memory              10.47
;  :memory                  10.32
;  :minimized-lits          53
;  :mk-bool-var             74262
;  :mk-clause               61643
;  :num-allocs              580293
;  :num-checks              299
;  :propagations            18378
;  :quant-instantiations    23127
;  :rlimit-count            1405442)
(assert (< v@193@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 14
; Joined path conditions
(assert (< v@193@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(declare-const sm@253@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@253@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@253@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef98|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@253@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@253@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef99|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@253@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef100|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@253@07  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)))
; Precomputing data for removing quantified permissions
(define-fun pTaken@254@07 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
    ($Perm.min
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@255@07 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@254@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@254@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               54991
;  :arith-add-rows          15058
;  :arith-assert-diseq      1020
;  :arith-assert-lower      12734
;  :arith-assert-upper      9002
;  :arith-bound-prop        2119
;  :arith-conflicts         243
;  :arith-eq-adapter        8882
;  :arith-fixed-eqs         7523
;  :arith-offset-eqs        2643
;  :arith-pivots            5190
;  :conflicts               679
;  :datatype-accessor-ax    188
;  :datatype-constructor-ax 492
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               4960
;  :del-clause              108806
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              18.59
;  :memory                  18.04
;  :minimized-lits          57
;  :mk-bool-var             128812
;  :mk-clause               110548
;  :num-allocs              773060
;  :num-checks              301
;  :propagations            27489
;  :quant-instantiations    47341
;  :rlimit-count            1829895
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
    (= (- $Perm.Write (pTaken@254@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               56920
;  :arith-add-rows          15561
;  :arith-assert-diseq      1041
;  :arith-assert-lower      13080
;  :arith-assert-upper      9227
;  :arith-bound-prop        2187
;  :arith-conflicts         248
;  :arith-eq-adapter        9135
;  :arith-fixed-eqs         7719
;  :arith-offset-eqs        2687
;  :arith-pivots            5307
;  :conflicts               701
;  :datatype-accessor-ax    189
;  :datatype-constructor-ax 497
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               5197
;  :del-clause              114083
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              18.59
;  :memory                  18.03
;  :minimized-lits          57
;  :mk-bool-var             133568
;  :mk-clause               115825
;  :num-allocs              786978
;  :num-checks              302
;  :propagations            28487
;  :quant-instantiations    48955
;  :rlimit-count            1895469
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@256@07 $FVF<Int>)
; Definitional axioms for singleton-FVF's value
(assert (=
  ($FVF.lookup_int (as sm@256@07  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
  u@188@07))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@256@07  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)))
; [exec]
; aloc(opt_get1(visited), v).bool := true
; [eval] aloc(opt_get1(visited), v)
; [eval] opt_get1(visited)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 14
; Joined path conditions
; Definitional axioms for snapshot map values
; Precomputing data for removing quantified permissions
(define-fun pTaken@257@07 ((r $Ref)) $Perm
  (ite
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))
    ($Perm.min
      (ite
        (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@257@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               85003
;  :arith-add-rows          21792
;  :arith-assert-diseq      1245
;  :arith-assert-lower      19558
;  :arith-assert-upper      14634
;  :arith-bound-prop        2930
;  :arith-conflicts         263
;  :arith-eq-adapter        13708
;  :arith-fixed-eqs         12329
;  :arith-offset-eqs        3697
;  :arith-pivots            6960
;  :conflicts               738
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 509
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               7776
;  :del-clause              176412
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.89
;  :minimized-lits          62
;  :mk-bool-var             203810
;  :mk-clause               177975
;  :num-allocs              1009262
;  :num-checks              304
;  :propagations            41203
;  :quant-instantiations    80446
;  :rlimit-count            2391196
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))
    (= (- $Perm.Write (pTaken@257@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               86616
;  :arith-add-rows          22269
;  :arith-assert-diseq      1262
;  :arith-assert-lower      19878
;  :arith-assert-upper      14847
;  :arith-bound-prop        2991
;  :arith-conflicts         267
;  :arith-eq-adapter        13941
;  :arith-fixed-eqs         12518
;  :arith-offset-eqs        3740
;  :arith-pivots            7070
;  :conflicts               758
;  :datatype-accessor-ax    194
;  :datatype-constructor-ax 513
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               7941
;  :del-clause              180545
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.81
;  :minimized-lits          62
;  :mk-bool-var             207751
;  :mk-clause               182108
;  :num-allocs              1021468
;  :num-checks              305
;  :propagations            41983
;  :quant-instantiations    81884
;  :rlimit-count            2447428
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@258@07 $FVF<Bool>)
; Definitional axioms for singleton-FVF's value
(assert (=
  ($FVF.lookup_bool (as sm@258@07  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))
  true))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@258@07  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
; [exec]
; flatten := v
; [exec]
; v := v + 1
; [eval] v + 1
(declare-const v@259@07 Int)
(assert (= v@259@07 (+ v@193@07 1)))
; [exec]
; evaluationDummy2 := flatten
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop1
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@260@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 161 | 0 <= i1@260@07 | live]
; [else-branch: 161 | !(0 <= i1@260@07) | live]
(push) ; 16
; [then-branch: 161 | 0 <= i1@260@07]
(assert (<= 0 i1@260@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 161 | !(0 <= i1@260@07)]
(assert (not (<= 0 i1@260@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@260@07 V@39@07) (<= 0 i1@260@07)))
(declare-const $k@261@07 $Perm)
(assert ($Perm.isReadVar $k@261@07 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@260@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               86617
;  :arith-add-rows          22270
;  :arith-assert-diseq      1263
;  :arith-assert-lower      19883
;  :arith-assert-upper      14849
;  :arith-bound-prop        2991
;  :arith-conflicts         267
;  :arith-eq-adapter        13943
;  :arith-fixed-eqs         12518
;  :arith-offset-eqs        3740
;  :arith-pivots            7071
;  :conflicts               758
;  :datatype-accessor-ax    194
;  :datatype-constructor-ax 513
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               7941
;  :del-clause              180545
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.81
;  :minimized-lits          62
;  :mk-bool-var             207762
;  :mk-clause               182113
;  :num-allocs              1021750
;  :num-checks              306
;  :propagations            41986
;  :quant-instantiations    81884
;  :rlimit-count            2447946)
(assert (< i1@260@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@260@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 14
(declare-fun inv@262@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@261@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@260@07 Int)) (!
  (< i1@260@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@260@07))
  :qid |option$array$-aux|)))
(push) ; 14
(assert (not (forall ((i1@260@07 Int)) (!
  (implies
    (and (< i1@260@07 V@39@07) (<= 0 i1@260@07))
    (or (= $k@261@07 $Perm.No) (< $Perm.No $k@261@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               86617
;  :arith-add-rows          22270
;  :arith-assert-diseq      1264
;  :arith-assert-lower      19885
;  :arith-assert-upper      14850
;  :arith-bound-prop        2991
;  :arith-conflicts         267
;  :arith-eq-adapter        13944
;  :arith-fixed-eqs         12518
;  :arith-offset-eqs        3740
;  :arith-pivots            7071
;  :conflicts               759
;  :datatype-accessor-ax    194
;  :datatype-constructor-ax 513
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               7941
;  :del-clause              180547
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.81
;  :minimized-lits          62
;  :mk-bool-var             207769
;  :mk-clause               182115
;  :num-allocs              1022184
;  :num-checks              307
;  :propagations            41987
;  :quant-instantiations    81885
;  :rlimit-count            2448502)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@260@07 Int) (i12@260@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@260@07 V@39@07) (<= 0 i11@260@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@260@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@260@07)))
        (< $Perm.No $k@261@07))
      (and
        (and
          (and (< i12@260@07 V@39@07) (<= 0 i12@260@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@260@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@260@07)))
        (< $Perm.No $k@261@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@260@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@260@07)))
    (= i11@260@07 i12@260@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               86634
;  :arith-add-rows          22272
;  :arith-assert-diseq      1265
;  :arith-assert-lower      19889
;  :arith-assert-upper      14850
;  :arith-bound-prop        2991
;  :arith-conflicts         267
;  :arith-eq-adapter        13945
;  :arith-fixed-eqs         12518
;  :arith-offset-eqs        3740
;  :arith-pivots            7071
;  :conflicts               760
;  :datatype-accessor-ax    194
;  :datatype-constructor-ax 513
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               7941
;  :del-clause              180554
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.72
;  :minimized-lits          62
;  :mk-bool-var             207800
;  :mk-clause               182122
;  :num-allocs              1022637
;  :num-checks              308
;  :propagations            41987
;  :quant-instantiations    81914
;  :rlimit-count            2449635
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@260@07 Int)) (!
  (implies
    (and (and (< i1@260@07 V@39@07) (<= 0 i1@260@07)) (< $Perm.No $k@261@07))
    (=
      (inv@262@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@260@07))
      i1@260@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@260@07))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@262@07 r) V@39@07) (<= 0 (inv@262@07 r)))
      (< $Perm.No $k@261@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@262@07 r))
      r))
  :pattern ((inv@262@07 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@262@07 r) V@39@07) (<= 0 (inv@262@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r) r))
  :pattern ((inv@262@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@263@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@262@07 r) V@39@07) (<= 0 (inv@262@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
        $k@197@07
        $Perm.No)
      $k@261@07)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@261@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
          $k@197@07
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
      (<
        (ite
          (and (< (inv@262@07 r) V@39@07) (<= 0 (inv@262@07 r)))
          $k@261@07
          $Perm.No)
        $k@197@07)
      (<
        (ite
          (and (< (inv@262@07 r) V@39@07) (<= 0 (inv@262@07 r)))
          $k@261@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@198@07 r))
  :pattern ((inv@262@07 r))
  :qid |qp.srp101|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@262@07 r) V@39@07) (<= 0 (inv@262@07 r)))
    (= (- $k@261@07 (pTaken@263@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               88921
;  :arith-add-rows          22700
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20345
;  :arith-assert-upper      15147
;  :arith-bound-prop        3064
;  :arith-conflicts         274
;  :arith-eq-adapter        14281
;  :arith-fixed-eqs         12773
;  :arith-offset-eqs        3787
;  :arith-pivots            7225
;  :conflicts               787
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187097
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.69
;  :minimized-lits          63
;  :mk-bool-var             214326
;  :mk-clause               188681
;  :num-allocs              1043151
;  :num-checks              310
;  :propagations            43318
;  :quant-instantiations    83928
;  :rlimit-count            2532530
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@264@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 162 | 0 <= i1@264@07 | live]
; [else-branch: 162 | !(0 <= i1@264@07) | live]
(push) ; 16
; [then-branch: 162 | 0 <= i1@264@07]
(assert (<= 0 i1@264@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 162 | !(0 <= i1@264@07)]
(assert (not (<= 0 i1@264@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 163 | i1@264@07 < V@39@07 && 0 <= i1@264@07 | live]
; [else-branch: 163 | !(i1@264@07 < V@39@07 && 0 <= i1@264@07) | live]
(push) ; 16
; [then-branch: 163 | i1@264@07 < V@39@07 && 0 <= i1@264@07]
(assert (and (< i1@264@07 V@39@07) (<= 0 i1@264@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@264@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               88921
;  :arith-add-rows          22700
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20347
;  :arith-assert-upper      15147
;  :arith-bound-prop        3064
;  :arith-conflicts         274
;  :arith-eq-adapter        14281
;  :arith-fixed-eqs         12773
;  :arith-offset-eqs        3787
;  :arith-pivots            7225
;  :conflicts               787
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187097
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.69
;  :minimized-lits          63
;  :mk-bool-var             214328
;  :mk-clause               188681
;  :num-allocs              1043260
;  :num-checks              311
;  :propagations            43318
;  :quant-instantiations    83928
;  :rlimit-count            2532718)
(assert (< i1@264@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 17
; Joined path conditions
(assert (< i1@264@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               88957
;  :arith-add-rows          22726
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20354
;  :arith-assert-upper      15155
;  :arith-bound-prop        3071
;  :arith-conflicts         275
;  :arith-eq-adapter        14289
;  :arith-fixed-eqs         12780
;  :arith-offset-eqs        3787
;  :arith-pivots            7233
;  :conflicts               788
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187097
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.70
;  :minimized-lits          63
;  :mk-bool-var             214501
;  :mk-clause               188791
;  :num-allocs              1044332
;  :num-checks              312
;  :propagations            43332
;  :quant-instantiations    84003
;  :rlimit-count            2537419)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 163 | !(i1@264@07 < V@39@07 && 0 <= i1@264@07)]
(assert (not (and (< i1@264@07 V@39@07) (<= 0 i1@264@07))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@264@07 V@39@07) (<= 0 i1@264@07))
  (and
    (< i1@264@07 V@39@07)
    (<= 0 i1@264@07)
    (< i1@264@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@264@07 Int)) (!
  (implies
    (and (< i1@264@07 V@39@07) (<= 0 i1@264@07))
    (and
      (< i1@264@07 V@39@07)
      (<= 0 i1@264@07)
      (< i1@264@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@264@07 Int)) (!
  (implies
    (and (< i1@264@07 V@39@07) (<= 0 i1@264@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               88966
;  :arith-add-rows          22738
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20357
;  :arith-assert-upper      15156
;  :arith-bound-prop        3072
;  :arith-conflicts         275
;  :arith-eq-adapter        14291
;  :arith-fixed-eqs         12781
;  :arith-offset-eqs        3787
;  :arith-pivots            7243
;  :conflicts               789
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187325
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.67
;  :minimized-lits          63
;  :mk-bool-var             214611
;  :mk-clause               188909
;  :num-allocs              1045421
;  :num-checks              313
;  :propagations            43334
;  :quant-instantiations    84062
;  :rlimit-count            2541119
;  :time                    0.00)
(assert (forall ((i1@264@07 Int)) (!
  (implies
    (and (< i1@264@07 V@39@07) (<= 0 i1@264@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@264@07))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@265@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 164 | 0 <= i1@265@07 | live]
; [else-branch: 164 | !(0 <= i1@265@07) | live]
(push) ; 16
; [then-branch: 164 | 0 <= i1@265@07]
(assert (<= 0 i1@265@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 164 | !(0 <= i1@265@07)]
(assert (not (<= 0 i1@265@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 165 | i1@265@07 < V@39@07 && 0 <= i1@265@07 | live]
; [else-branch: 165 | !(i1@265@07 < V@39@07 && 0 <= i1@265@07) | live]
(push) ; 16
; [then-branch: 165 | i1@265@07 < V@39@07 && 0 <= i1@265@07]
(assert (and (< i1@265@07 V@39@07) (<= 0 i1@265@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@265@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               88966
;  :arith-add-rows          22738
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20359
;  :arith-assert-upper      15156
;  :arith-bound-prop        3072
;  :arith-conflicts         275
;  :arith-eq-adapter        14291
;  :arith-fixed-eqs         12781
;  :arith-offset-eqs        3787
;  :arith-pivots            7243
;  :conflicts               789
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187325
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.67
;  :minimized-lits          63
;  :mk-bool-var             214614
;  :mk-clause               188909
;  :num-allocs              1045723
;  :num-checks              314
;  :propagations            43334
;  :quant-instantiations    84062
;  :rlimit-count            2541619)
(assert (< i1@265@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 17
; Joined path conditions
(assert (< i1@265@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89001
;  :arith-add-rows          22764
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20366
;  :arith-assert-upper      15164
;  :arith-bound-prop        3079
;  :arith-conflicts         276
;  :arith-eq-adapter        14299
;  :arith-fixed-eqs         12788
;  :arith-offset-eqs        3787
;  :arith-pivots            7251
;  :conflicts               790
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187325
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.67
;  :minimized-lits          63
;  :mk-bool-var             214786
;  :mk-clause               189019
;  :num-allocs              1046805
;  :num-checks              315
;  :propagations            43348
;  :quant-instantiations    84138
;  :rlimit-count            2546348)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89001
;  :arith-add-rows          22764
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20366
;  :arith-assert-upper      15164
;  :arith-bound-prop        3079
;  :arith-conflicts         276
;  :arith-eq-adapter        14299
;  :arith-fixed-eqs         12788
;  :arith-offset-eqs        3787
;  :arith-pivots            7251
;  :conflicts               791
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187325
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.67
;  :minimized-lits          63
;  :mk-bool-var             214786
;  :mk-clause               189019
;  :num-allocs              1046896
;  :num-checks              316
;  :propagations            43348
;  :quant-instantiations    84138
;  :rlimit-count            2546443)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 165 | !(i1@265@07 < V@39@07 && 0 <= i1@265@07)]
(assert (not (and (< i1@265@07 V@39@07) (<= 0 i1@265@07))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@265@07 V@39@07) (<= 0 i1@265@07))
  (and
    (< i1@265@07 V@39@07)
    (<= 0 i1@265@07)
    (< i1@265@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@265@07 Int)) (!
  (implies
    (and (< i1@265@07 V@39@07) (<= 0 i1@265@07))
    (and
      (< i1@265@07 V@39@07)
      (<= 0 i1@265@07)
      (< i1@265@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@265@07 Int)) (!
  (implies
    (and (< i1@265@07 V@39@07) (<= 0 i1@265@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89001
;  :arith-add-rows          22773
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20368
;  :arith-assert-upper      15164
;  :arith-bound-prop        3079
;  :arith-conflicts         276
;  :arith-eq-adapter        14300
;  :arith-fixed-eqs         12788
;  :arith-offset-eqs        3787
;  :arith-pivots            7259
;  :conflicts               792
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187445
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.65
;  :minimized-lits          63
;  :mk-bool-var             214813
;  :mk-clause               189029
;  :num-allocs              1047447
;  :num-checks              317
;  :propagations            43348
;  :quant-instantiations    84162
;  :rlimit-count            2547868)
(assert (forall ((i1@265@07 Int)) (!
  (implies
    (and (< i1@265@07 V@39@07) (<= 0 i1@265@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@265@07)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@266@07 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@267@07 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 166 | 0 <= i1@266@07 | live]
; [else-branch: 166 | !(0 <= i1@266@07) | live]
(push) ; 17
; [then-branch: 166 | 0 <= i1@266@07]
(assert (<= 0 i1@266@07))
; [eval] i1 < V
(push) ; 18
; [then-branch: 167 | i1@266@07 < V@39@07 | live]
; [else-branch: 167 | !(i1@266@07 < V@39@07) | live]
(push) ; 19
; [then-branch: 167 | i1@266@07 < V@39@07]
(assert (< i1@266@07 V@39@07))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 168 | 0 <= i2@267@07 | live]
; [else-branch: 168 | !(0 <= i2@267@07) | live]
(push) ; 21
; [then-branch: 168 | 0 <= i2@267@07]
(assert (<= 0 i2@267@07))
; [eval] i2 < V
(push) ; 22
; [then-branch: 169 | i2@267@07 < V@39@07 | live]
; [else-branch: 169 | !(i2@267@07 < V@39@07) | live]
(push) ; 23
; [then-branch: 169 | i2@267@07 < V@39@07]
(assert (< i2@267@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89001
;  :arith-add-rows          22773
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20372
;  :arith-assert-upper      15164
;  :arith-bound-prop        3079
;  :arith-conflicts         276
;  :arith-eq-adapter        14300
;  :arith-fixed-eqs         12788
;  :arith-offset-eqs        3787
;  :arith-pivots            7259
;  :conflicts               792
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187445
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.65
;  :minimized-lits          63
;  :mk-bool-var             214818
;  :mk-clause               189029
;  :num-allocs              1047928
;  :num-checks              318
;  :propagations            43348
;  :quant-instantiations    84162
;  :rlimit-count            2548512)
(assert (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 24
; Joined path conditions
(assert (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89036
;  :arith-add-rows          22799
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20379
;  :arith-assert-upper      15172
;  :arith-bound-prop        3086
;  :arith-conflicts         277
;  :arith-eq-adapter        14308
;  :arith-fixed-eqs         12795
;  :arith-offset-eqs        3787
;  :arith-pivots            7267
;  :conflicts               793
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187445
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.66
;  :minimized-lits          63
;  :mk-bool-var             214990
;  :mk-clause               189139
;  :num-allocs              1049008
;  :num-checks              319
;  :propagations            43362
;  :quant-instantiations    84238
;  :rlimit-count            2553241)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89036
;  :arith-add-rows          22799
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20379
;  :arith-assert-upper      15172
;  :arith-bound-prop        3086
;  :arith-conflicts         277
;  :arith-eq-adapter        14308
;  :arith-fixed-eqs         12795
;  :arith-offset-eqs        3787
;  :arith-pivots            7267
;  :conflicts               793
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187445
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.66
;  :minimized-lits          63
;  :mk-bool-var             214990
;  :mk-clause               189139
;  :num-allocs              1049034
;  :num-checks              320
;  :propagations            43362
;  :quant-instantiations    84238
;  :rlimit-count            2553271)
(assert (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 24
; Joined path conditions
(assert (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89075
;  :arith-add-rows          22827
;  :arith-assert-diseq      1305
;  :arith-assert-lower      20386
;  :arith-assert-upper      15180
;  :arith-bound-prop        3093
;  :arith-conflicts         278
;  :arith-eq-adapter        14317
;  :arith-fixed-eqs         12802
;  :arith-offset-eqs        3787
;  :arith-pivots            7275
;  :conflicts               794
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187445
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.68
;  :minimized-lits          63
;  :mk-bool-var             215211
;  :mk-clause               189291
;  :num-allocs              1050243
;  :num-checks              321
;  :propagations            43388
;  :quant-instantiations    84334
;  :rlimit-count            2559099)
(pop) ; 23
(push) ; 23
; [else-branch: 169 | !(i2@267@07 < V@39@07)]
(assert (not (< i2@267@07 V@39@07)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@267@07 V@39@07)
  (and
    (< i2@267@07 V@39@07)
    (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
    (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 168 | !(0 <= i2@267@07)]
(assert (not (<= 0 i2@267@07)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@267@07)
  (and
    (<= 0 i2@267@07)
    (implies
      (< i2@267@07 V@39@07)
      (and
        (< i2@267@07 V@39@07)
        (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
        (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 167 | !(i1@266@07 < V@39@07)]
(assert (not (< i1@266@07 V@39@07)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@266@07 V@39@07)
  (and
    (< i1@266@07 V@39@07)
    (implies
      (<= 0 i2@267@07)
      (and
        (<= 0 i2@267@07)
        (implies
          (< i2@267@07 V@39@07)
          (and
            (< i2@267@07 V@39@07)
            (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
            (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 166 | !(0 <= i1@266@07)]
(assert (not (<= 0 i1@266@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@266@07)
  (and
    (<= 0 i1@266@07)
    (implies
      (< i1@266@07 V@39@07)
      (and
        (< i1@266@07 V@39@07)
        (implies
          (<= 0 i2@267@07)
          (and
            (<= 0 i2@267@07)
            (implies
              (< i2@267@07 V@39@07)
              (and
                (< i2@267@07 V@39@07)
                (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
                (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 170 | Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@266@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@267@07)) && i2@267@07 < V@39@07 && 0 <= i2@267@07 && i1@266@07 < V@39@07 && 0 <= i1@266@07 | live]
; [else-branch: 170 | !(Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@266@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@267@07)) && i2@267@07 < V@39@07 && 0 <= i2@267@07 && i1@266@07 < V@39@07 && 0 <= i1@266@07) | live]
(push) ; 17
; [then-branch: 170 | Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@266@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@267@07)) && i2@267@07 < V@39@07 && 0 <= i2@267@07 && i1@266@07 < V@39@07 && 0 <= i1@266@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
        (< i2@267@07 V@39@07))
      (<= 0 i2@267@07))
    (< i1@266@07 V@39@07))
  (<= 0 i1@266@07)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 170 | !(Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@266@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@267@07)) && i2@267@07 < V@39@07 && 0 <= i2@267@07 && i1@266@07 < V@39@07 && 0 <= i1@266@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
          (< i2@267@07 V@39@07))
        (<= 0 i2@267@07))
      (< i1@266@07 V@39@07))
    (<= 0 i1@266@07))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
          (< i2@267@07 V@39@07))
        (<= 0 i2@267@07))
      (< i1@266@07 V@39@07))
    (<= 0 i1@266@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
      ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
    (< i2@267@07 V@39@07)
    (<= 0 i2@267@07)
    (< i1@266@07 V@39@07)
    (<= 0 i1@266@07))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@267@07 Int)) (!
  (and
    (implies
      (<= 0 i1@266@07)
      (and
        (<= 0 i1@266@07)
        (implies
          (< i1@266@07 V@39@07)
          (and
            (< i1@266@07 V@39@07)
            (implies
              (<= 0 i2@267@07)
              (and
                (<= 0 i2@267@07)
                (implies
                  (< i2@267@07 V@39@07)
                  (and
                    (< i2@267@07 V@39@07)
                    (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
                    (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
              (< i2@267@07 V@39@07))
            (<= 0 i2@267@07))
          (< i1@266@07 V@39@07))
        (<= 0 i1@266@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
        (< i2@267@07 V@39@07)
        (<= 0 i2@267@07)
        (< i1@266@07 V@39@07)
        (<= 0 i1@266@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@266@07 Int)) (!
  (forall ((i2@267@07 Int)) (!
    (and
      (implies
        (<= 0 i1@266@07)
        (and
          (<= 0 i1@266@07)
          (implies
            (< i1@266@07 V@39@07)
            (and
              (< i1@266@07 V@39@07)
              (implies
                (<= 0 i2@267@07)
                (and
                  (<= 0 i2@267@07)
                  (implies
                    (< i2@267@07 V@39@07)
                    (and
                      (< i2@267@07 V@39@07)
                      (< i1@266@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
                      (< i2@267@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
                  ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
                (< i2@267@07 V@39@07))
              (<= 0 i2@267@07))
            (< i1@266@07 V@39@07))
          (<= 0 i1@266@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
          (< i2@267@07 V@39@07)
          (<= 0 i2@267@07)
          (< i1@266@07 V@39@07)
          (<= 0 i1@266@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@266@07 Int)) (!
  (forall ((i2@267@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
              (< i2@267@07 V@39@07))
            (<= 0 i2@267@07))
          (< i1@266@07 V@39@07))
        (<= 0 i1@266@07))
      (= i1@266@07 i2@267@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89120
;  :arith-add-rows          22853
;  :arith-assert-diseq      1307
;  :arith-assert-lower      20392
;  :arith-assert-upper      15182
;  :arith-bound-prop        3095
;  :arith-conflicts         278
;  :arith-eq-adapter        14334
;  :arith-fixed-eqs         12804
;  :arith-offset-eqs        3787
;  :arith-pivots            7295
;  :conflicts               795
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187999
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.67
;  :minimized-lits          63
;  :mk-bool-var             215624
;  :mk-clause               189583
;  :num-allocs              1053039
;  :num-checks              322
;  :propagations            43434
;  :quant-instantiations    84515
;  :rlimit-count            2571456
;  :time                    0.00)
(assert (forall ((i1@266@07 Int)) (!
  (forall ((i2@267@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07)))
              (< i2@267@07 V@39@07))
            (<= 0 i2@267@07))
          (< i1@266@07 V@39@07))
        (<= 0 i1@266@07))
      (= i1@266@07 i2@267@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@267@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@266@07))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@268@07 Int)
(declare-const j1@269@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 171 | 0 <= i1@268@07 | live]
; [else-branch: 171 | !(0 <= i1@268@07) | live]
(push) ; 16
; [then-branch: 171 | 0 <= i1@268@07]
(assert (<= 0 i1@268@07))
; [eval] i1 < V
(push) ; 17
; [then-branch: 172 | i1@268@07 < V@39@07 | live]
; [else-branch: 172 | !(i1@268@07 < V@39@07) | live]
(push) ; 18
; [then-branch: 172 | i1@268@07 < V@39@07]
(assert (< i1@268@07 V@39@07))
; [eval] 0 <= j1
(push) ; 19
; [then-branch: 173 | 0 <= j1@269@07 | live]
; [else-branch: 173 | !(0 <= j1@269@07) | live]
(push) ; 20
; [then-branch: 173 | 0 <= j1@269@07]
(assert (<= 0 j1@269@07))
; [eval] j1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 173 | !(0 <= j1@269@07)]
(assert (not (<= 0 j1@269@07)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 172 | !(i1@268@07 < V@39@07)]
(assert (not (< i1@268@07 V@39@07)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 171 | !(0 <= i1@268@07)]
(assert (not (<= 0 i1@268@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@269@07 V@39@07) (<= 0 j1@269@07)) (< i1@268@07 V@39@07))
  (<= 0 i1@268@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@268@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89120
;  :arith-add-rows          22853
;  :arith-assert-diseq      1307
;  :arith-assert-lower      20398
;  :arith-assert-upper      15182
;  :arith-bound-prop        3095
;  :arith-conflicts         278
;  :arith-eq-adapter        14334
;  :arith-fixed-eqs         12804
;  :arith-offset-eqs        3787
;  :arith-pivots            7295
;  :conflicts               795
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187999
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.67
;  :minimized-lits          63
;  :mk-bool-var             215632
;  :mk-clause               189583
;  :num-allocs              1053682
;  :num-checks              323
;  :propagations            43434
;  :quant-instantiations    84516
;  :rlimit-count            2572546)
(assert (< i1@268@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@268@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89156
;  :arith-add-rows          22879
;  :arith-assert-diseq      1307
;  :arith-assert-lower      20405
;  :arith-assert-upper      15190
;  :arith-bound-prop        3102
;  :arith-conflicts         279
;  :arith-eq-adapter        14342
;  :arith-fixed-eqs         12811
;  :arith-offset-eqs        3787
;  :arith-pivots            7303
;  :conflicts               796
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187999
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.69
;  :minimized-lits          63
;  :mk-bool-var             215807
;  :mk-clause               189695
;  :num-allocs              1054854
;  :num-checks              324
;  :propagations            43448
;  :quant-instantiations    84599
;  :rlimit-count            2577787)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89156
;  :arith-add-rows          22879
;  :arith-assert-diseq      1307
;  :arith-assert-lower      20405
;  :arith-assert-upper      15190
;  :arith-bound-prop        3102
;  :arith-conflicts         279
;  :arith-eq-adapter        14342
;  :arith-fixed-eqs         12811
;  :arith-offset-eqs        3787
;  :arith-pivots            7303
;  :conflicts               797
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              187999
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.69
;  :minimized-lits          63
;  :mk-bool-var             215807
;  :mk-clause               189695
;  :num-allocs              1054943
;  :num-checks              325
;  :propagations            43448
;  :quant-instantiations    84599
;  :rlimit-count            2577882)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j1@269@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89162
;  :arith-add-rows          22884
;  :arith-assert-diseq      1307
;  :arith-assert-lower      20408
;  :arith-assert-upper      15191
;  :arith-bound-prop        3102
;  :arith-conflicts         280
;  :arith-eq-adapter        14343
;  :arith-fixed-eqs         12812
;  :arith-offset-eqs        3787
;  :arith-pivots            7307
;  :conflicts               798
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              188003
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.69
;  :minimized-lits          63
;  :mk-bool-var             215818
;  :mk-clause               189699
;  :num-allocs              1055147
;  :num-checks              326
;  :propagations            43450
;  :quant-instantiations    84608
;  :rlimit-count            2578428)
(assert (<
  j1@269@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j1@269@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))))))
(pop) ; 14
(declare-fun inv@270@07 ($Ref) Int)
(declare-fun inv@271@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@268@07 Int) (j1@269@07 Int)) (!
  (and
    (< i1@268@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@269@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))) j1@269@07))
  :qid |int-aux|)))
(declare-const sm@272@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
    (=
      ($FVF.lookup_int (as sm@272@07  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@272@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@256@07  $FVF<Int>) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@272@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r)))
    (=
      ($FVF.lookup_int (as sm@272@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@272@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef105|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@268@07 Int) (j11@269@07 Int) (i12@268@07 Int) (j12@269@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@269@07 V@39@07) (<= 0 j11@269@07))
            (< i11@268@07 V@39@07))
          (<= 0 i11@268@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@272@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@268@07))) j11@269@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@268@07))) j11@269@07)))
      (and
        (and
          (and
            (and (< j12@269@07 V@39@07) (<= 0 j12@269@07))
            (< i12@268@07 V@39@07))
          (<= 0 i12@268@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@272@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@268@07))) j12@269@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@268@07))) j12@269@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@268@07))) j11@269@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@268@07))) j12@269@07)))
    (and (= i11@268@07 i12@268@07) (= j11@269@07 j12@269@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               89219
;  :arith-add-rows          22895
;  :arith-assert-diseq      1307
;  :arith-assert-lower      20418
;  :arith-assert-upper      15191
;  :arith-bound-prop        3102
;  :arith-conflicts         280
;  :arith-eq-adapter        14354
;  :arith-fixed-eqs         12812
;  :arith-offset-eqs        3787
;  :arith-pivots            7315
;  :conflicts               799
;  :datatype-accessor-ax    196
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               8246
;  :del-clause              188284
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.55
;  :memory                  18.67
;  :minimized-lits          63
;  :mk-bool-var             216083
;  :mk-clause               189887
;  :num-allocs              1057717
;  :num-checks              327
;  :propagations            43472
;  :quant-instantiations    84730
;  :rlimit-count            2587376
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@268@07 Int) (j1@269@07 Int)) (!
  (implies
    (and
      (and (and (< j1@269@07 V@39@07) (<= 0 j1@269@07)) (< i1@268@07 V@39@07))
      (<= 0 i1@268@07))
    (and
      (=
        (inv@270@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))) j1@269@07))
        i1@268@07)
      (=
        (inv@271@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))) j1@269@07))
        j1@269@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@268@07))) j1@269@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@07 r) V@39@07) (<= 0 (inv@271@07 r)))
        (< (inv@270@07 r) V@39@07))
      (<= 0 (inv@270@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@270@07 r)))) (inv@271@07 r))
      r))
  :pattern ((inv@270@07 r))
  :pattern ((inv@271@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@07 r) V@39@07) (<= 0 (inv@271@07 r)))
        (< (inv@270@07 r) V@39@07))
      (<= 0 (inv@270@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@272@07  $FVF<Int>) r) r))
  :pattern ((inv@270@07 r) (inv@271@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@273@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@271@07 r) V@39@07) (<= 0 (inv@271@07 r)))
        (< (inv@270@07 r) V@39@07))
      (<= 0 (inv@270@07 r)))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@274@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@271@07 r) V@39@07) (<= 0 (inv@271@07 r)))
        (< (inv@270@07 r) V@39@07))
      (<= 0 (inv@270@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@273@07 r)))
    $Perm.No))
(define-fun pTaken@275@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@271@07 r) V@39@07) (<= 0 (inv@271@07 r)))
        (< (inv@270@07 r) V@39@07))
      (<= 0 (inv@270@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r))
      (- (- $Perm.Write (pTaken@273@07 r)) (pTaken@274@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (=
  (-
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
      $Perm.Write
      $Perm.No)
    (pTaken@273@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)))
  $Perm.No)))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               113870
;  :arith-add-rows          28526
;  :arith-assert-diseq      1577
;  :arith-assert-lower      26308
;  :arith-assert-upper      20173
;  :arith-bound-prop        3767
;  :arith-conflicts         293
;  :arith-eq-adapter        18545
;  :arith-fixed-eqs         16972
;  :arith-offset-eqs        4314
;  :arith-pivots            8790
;  :conflicts               834
;  :datatype-accessor-ax    200
;  :datatype-constructor-ax 532
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               10647
;  :del-clause              245042
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              19.79
;  :memory                  19.17
;  :minimized-lits          67
;  :mk-bool-var             280073
;  :mk-clause               246643
;  :num-allocs              1259402
;  :num-checks              329
;  :propagations            54768
;  :quant-instantiations    113111
;  :rlimit-count            3030840
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@07 r) V@39@07) (<= 0 (inv@271@07 r)))
        (< (inv@270@07 r) V@39@07))
      (<= 0 (inv@270@07 r)))
    (= (- $Perm.Write (pTaken@273@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136985
;  :arith-add-rows          34152
;  :arith-assert-diseq      1853
;  :arith-assert-lower      31967
;  :arith-assert-upper      25003
;  :arith-bound-prop        4447
;  :arith-conflicts         306
;  :arith-eq-adapter        22571
;  :arith-fixed-eqs         20888
;  :arith-offset-eqs        4785
;  :arith-pivots            10237
;  :conflicts               870
;  :datatype-accessor-ax    203
;  :datatype-constructor-ax 539
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               13007
;  :del-clause              299856
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              20.19
;  :memory                  18.79
;  :minimized-lits          72
;  :mk-bool-var             342046
;  :mk-clause               301457
;  :num-allocs              1454257
;  :num-checks              330
;  :propagations            65326
;  :quant-instantiations    140907
;  :rlimit-count            3457354
;  :time                    0.51)
; Chunk depleted?
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@274@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               164820
;  :arith-add-rows          41742
;  :arith-assert-diseq      1993
;  :arith-assert-lower      38131
;  :arith-assert-upper      30285
;  :arith-bound-prop        5467
;  :arith-conflicts         313
;  :arith-eq-adapter        27417
;  :arith-fixed-eqs         26095
;  :arith-offset-eqs        5382
;  :arith-pivots            13112
;  :conflicts               897
;  :datatype-accessor-ax    218
;  :datatype-constructor-ax 574
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               14670
;  :del-clause              358451
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              22.11
;  :memory                  21.09
;  :minimized-lits          72
;  :mk-bool-var             409285
;  :mk-clause               360052
;  :num-allocs              1674031
;  :num-checks              331
;  :propagations            78360
;  :quant-instantiations    168272
;  :rlimit-count            3997976
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@271@07 r) V@39@07) (<= 0 (inv@271@07 r)))
        (< (inv@270@07 r) V@39@07))
      (<= 0 (inv@270@07 r)))
    (= (- (- $Perm.Write (pTaken@273@07 r)) (pTaken@274@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               166727
;  :arith-add-rows          42119
;  :arith-assert-diseq      2043
;  :arith-assert-lower      38502
;  :arith-assert-upper      30522
;  :arith-bound-prop        5578
;  :arith-conflicts         320
;  :arith-eq-adapter        27733
;  :arith-fixed-eqs         26296
;  :arith-offset-eqs        5490
;  :arith-pivots            13257
;  :conflicts               920
;  :datatype-accessor-ax    219
;  :datatype-constructor-ax 578
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               14826
;  :del-clause              362254
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              22.11
;  :memory                  21.29
;  :minimized-lits          73
;  :mk-bool-var             413129
;  :mk-clause               363855
;  :num-allocs              1688461
;  :num-checks              332
;  :propagations            79224
;  :quant-instantiations    169436
;  :rlimit-count            4060004
;  :time                    0.03)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@276@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 174 | 0 <= i1@276@07 | live]
; [else-branch: 174 | !(0 <= i1@276@07) | live]
(push) ; 16
; [then-branch: 174 | 0 <= i1@276@07]
(assert (<= 0 i1@276@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 174 | !(0 <= i1@276@07)]
(assert (not (<= 0 i1@276@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@276@07 V@39@07) (<= 0 i1@276@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@276@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               166727
;  :arith-add-rows          42119
;  :arith-assert-diseq      2043
;  :arith-assert-lower      38504
;  :arith-assert-upper      30522
;  :arith-bound-prop        5578
;  :arith-conflicts         320
;  :arith-eq-adapter        27733
;  :arith-fixed-eqs         26296
;  :arith-offset-eqs        5490
;  :arith-pivots            13257
;  :conflicts               920
;  :datatype-accessor-ax    219
;  :datatype-constructor-ax 578
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               14826
;  :del-clause              362254
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              22.11
;  :memory                  21.29
;  :minimized-lits          73
;  :mk-bool-var             413131
;  :mk-clause               363855
;  :num-allocs              1688570
;  :num-checks              333
;  :propagations            79224
;  :quant-instantiations    169436
;  :rlimit-count            4060182)
(assert (< i1@276@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@276@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 14
(declare-fun inv@277@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@276@07 Int)) (!
  (< i1@276@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@276@07))
  :qid |int-aux|)))
(declare-const sm@278@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r)))
    (=
      ($FVF.lookup_int (as sm@278@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@278@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
              (< (inv@206@07 r) V@39@07))
            (<= 0 (inv@206@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@274@07 r)))
    (=
      ($FVF.lookup_int (as sm@278@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@278@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
          $Perm.Write
          $Perm.No)
        (pTaken@273@07 r)))
    (=
      ($FVF.lookup_int (as sm@278@07  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@278@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@256@07  $FVF<Int>) r))
  :qid |qp.fvfValDef108|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@278@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef109|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@276@07 Int) (i12@276@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@276@07 V@39@07) (<= 0 i11@276@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@278@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@276@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@276@07)))
      (and
        (and (< i12@276@07 V@39@07) (<= 0 i12@276@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@278@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@276@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@276@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@276@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@276@07)))
    (= i11@276@07 i12@276@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               166775
;  :arith-add-rows          42125
;  :arith-assert-diseq      2044
;  :arith-assert-lower      38510
;  :arith-assert-upper      30524
;  :arith-bound-prop        5578
;  :arith-conflicts         320
;  :arith-eq-adapter        27736
;  :arith-fixed-eqs         26298
;  :arith-offset-eqs        5494
;  :arith-pivots            13259
;  :conflicts               921
;  :datatype-accessor-ax    219
;  :datatype-constructor-ax 578
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               14826
;  :del-clause              362298
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              22.11
;  :memory                  21.21
;  :minimized-lits          73
;  :mk-bool-var             413285
;  :mk-clause               363940
;  :num-allocs              1690501
;  :num-checks              334
;  :propagations            79227
;  :quant-instantiations    169504
;  :rlimit-count            4066290
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@276@07 Int)) (!
  (implies
    (and (< i1@276@07 V@39@07) (<= 0 i1@276@07))
    (=
      (inv@277@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@276@07))
      i1@276@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@276@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@277@07 r) V@39@07) (<= 0 (inv@277@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@277@07 r))
      r))
  :pattern ((inv@277@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@277@07 r) V@39@07) (<= 0 (inv@277@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@278@07  $FVF<Int>) r) r))
  :pattern ((inv@277@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@279@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@277@07 r) V@39@07) (<= 0 (inv@277@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@280@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@277@07 r) V@39@07) (<= 0 (inv@277@07 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
              (< (inv@206@07 r) V@39@07))
            (<= 0 (inv@206@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@274@07 r))
      (- $Perm.Write (pTaken@279@07 r)))
    $Perm.No))
(define-fun pTaken@281@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@277@07 r) V@39@07) (<= 0 (inv@277@07 r)))
    ($Perm.min
      (-
        (ite
          (=
            r
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
          $Perm.Write
          $Perm.No)
        (pTaken@273@07 r))
      (- (- $Perm.Write (pTaken@279@07 r)) (pTaken@280@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r))
      (pTaken@279@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               169820
;  :arith-add-rows          42625
;  :arith-assert-diseq      2101
;  :arith-assert-lower      39028
;  :arith-assert-upper      30873
;  :arith-bound-prop        5687
;  :arith-conflicts         326
;  :arith-eq-adapter        28190
;  :arith-fixed-eqs         26599
;  :arith-offset-eqs        5624
;  :arith-pivots            13438
;  :conflicts               951
;  :datatype-accessor-ax    221
;  :datatype-constructor-ax 586
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               15128
;  :del-clause              368559
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          10
;  :max-memory              22.11
;  :memory                  21.17
;  :minimized-lits          76
;  :mk-bool-var             419492
;  :mk-clause               370227
;  :num-allocs              1709748
;  :num-checks              336
;  :propagations            80667
;  :quant-instantiations    171324
;  :rlimit-count            4144812
;  :time                    0.03)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@277@07 r) V@39@07) (<= 0 (inv@277@07 r)))
    (= (- $Perm.Write (pTaken@279@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               205434
;  :arith-add-rows          54657
;  :arith-assert-diseq      2673
;  :arith-assert-lower      48702
;  :arith-assert-upper      39124
;  :arith-bound-prop        6627
;  :arith-conflicts         346
;  :arith-eq-adapter        34504
;  :arith-fixed-eqs         33491
;  :arith-offset-eqs        7684
;  :arith-pivots            15437
;  :conflicts               1001
;  :datatype-accessor-ax    224
;  :datatype-constructor-ax 593
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               18258
;  :del-clause              437000
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  22.61
;  :minimized-lits          80
;  :mk-bool-var             499145
;  :mk-clause               438668
;  :num-allocs              1961919
;  :num-checks              337
;  :propagations            98085
;  :quant-instantiations    203049
;  :rlimit-count            4774866
;  :time                    0.50)
; Chunk depleted?
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
              (< (inv@206@07 r) V@39@07))
            (<= 0 (inv@206@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@274@07 r))
      (pTaken@280@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.10s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               216381
;  :arith-add-rows          57223
;  :arith-assert-diseq      2831
;  :arith-assert-lower      50488
;  :arith-assert-upper      40278
;  :arith-bound-prop        6911
;  :arith-conflicts         362
;  :arith-eq-adapter        35993
;  :arith-fixed-eqs         34724
;  :arith-offset-eqs        8337
;  :arith-pivots            15985
;  :conflicts               1043
;  :datatype-accessor-ax    233
;  :datatype-constructor-ax 629
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               18628
;  :del-clause              450015
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  22.70
;  :minimized-lits          83
;  :mk-bool-var             515860
;  :mk-clause               451683
;  :num-allocs              2018972
;  :num-checks              338
;  :propagations            102241
;  :quant-instantiations    207922
;  :rlimit-count            4938023
;  :time                    0.10)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@277@07 r) V@39@07) (<= 0 (inv@277@07 r)))
    (= (- (- $Perm.Write (pTaken@279@07 r)) (pTaken@280@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               250762
;  :arith-add-rows          68867
;  :arith-assert-diseq      3341
;  :arith-assert-lower      59338
;  :arith-assert-upper      48159
;  :arith-bound-prop        7855
;  :arith-conflicts         392
;  :arith-eq-adapter        42469
;  :arith-fixed-eqs         41100
;  :arith-offset-eqs        9383
;  :arith-pivots            17974
;  :conflicts               1111
;  :datatype-accessor-ax    236
;  :datatype-constructor-ax 636
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               21869
;  :del-clause              524691
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  23.39
;  :minimized-lits          95
;  :mk-bool-var             600624
;  :mk-clause               526359
;  :num-allocs              2287647
;  :num-checks              339
;  :propagations            119105
;  :quant-instantiations    242325
;  :rlimit-count            5620569
;  :time                    0.50)
; Chunk depleted?
(push) ; 14
(assert (not (=
  (-
    (-
      (ite
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
        $Perm.Write
        $Perm.No)
      (pTaken@273@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)))
    (pTaken@281@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 14
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               253736
;  :arith-add-rows          70320
;  :arith-assert-diseq      3413
;  :arith-assert-lower      60012
;  :arith-assert-upper      48681
;  :arith-bound-prop        7998
;  :arith-conflicts         409
;  :arith-eq-adapter        43002
;  :arith-fixed-eqs         41501
;  :arith-offset-eqs        9546
;  :arith-pivots            18364
;  :conflicts               1147
;  :datatype-accessor-ax    237
;  :datatype-constructor-ax 640
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               22087
;  :del-clause              529570
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  23.29
;  :minimized-lits          102
;  :mk-bool-var             607154
;  :mk-clause               531238
;  :num-allocs              2312368
;  :num-checks              340
;  :propagations            120468
;  :quant-instantiations    243958
;  :rlimit-count            5708835
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@277@07 r) V@39@07) (<= 0 (inv@277@07 r)))
    (=
      (-
        (- (- $Perm.Write (pTaken@279@07 r)) (pTaken@280@07 r))
        (pTaken@281@07 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257926
;  :arith-add-rows          72118
;  :arith-assert-diseq      3552
;  :arith-assert-lower      60869
;  :arith-assert-upper      49331
;  :arith-bound-prop        8223
;  :arith-conflicts         427
;  :arith-eq-adapter        43742
;  :arith-fixed-eqs         42026
;  :arith-offset-eqs        9847
;  :arith-pivots            18798
;  :conflicts               1193
;  :datatype-accessor-ax    238
;  :datatype-constructor-ax 644
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               22307
;  :del-clause              535813
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  23.22
;  :minimized-lits          116
;  :mk-bool-var             614844
;  :mk-clause               537481
;  :num-allocs              2340668
;  :num-checks              341
;  :propagations            122443
;  :quant-instantiations    245952
;  :rlimit-count            5815056
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 14
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(declare-const i1@282@07 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 175 | 0 <= i1@282@07 | live]
; [else-branch: 175 | !(0 <= i1@282@07) | live]
(push) ; 17
; [then-branch: 175 | 0 <= i1@282@07]
(assert (<= 0 i1@282@07))
; [eval] i1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 175 | !(0 <= i1@282@07)]
(assert (not (<= 0 i1@282@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (and (< i1@282@07 V@39@07) (<= 0 i1@282@07)))
(declare-const $k@283@07 $Perm)
(assert ($Perm.isReadVar $k@283@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@282@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257926
;  :arith-add-rows          72118
;  :arith-assert-diseq      3553
;  :arith-assert-lower      60873
;  :arith-assert-upper      49332
;  :arith-bound-prop        8223
;  :arith-conflicts         427
;  :arith-eq-adapter        43743
;  :arith-fixed-eqs         42026
;  :arith-offset-eqs        9847
;  :arith-pivots            18798
;  :conflicts               1193
;  :datatype-accessor-ax    238
;  :datatype-constructor-ax 644
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               22307
;  :del-clause              535813
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  23.22
;  :minimized-lits          116
;  :mk-bool-var             614850
;  :mk-clause               537483
;  :num-allocs              2340844
;  :num-checks              342
;  :propagations            122444
;  :quant-instantiations    245952
;  :rlimit-count            5815387)
(assert (< i1@282@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 16
; Joined path conditions
(assert (< i1@282@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 15
(declare-fun inv@284@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@283@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@282@07 Int)) (!
  (< i1@282@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@282@07))
  :qid |int-aux|)))
(push) ; 15
(assert (not (forall ((i1@282@07 Int)) (!
  (implies
    (and (< i1@282@07 V@39@07) (<= 0 i1@282@07))
    (or (= $k@283@07 $Perm.No) (< $Perm.No $k@283@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257926
;  :arith-add-rows          72118
;  :arith-assert-diseq      3554
;  :arith-assert-lower      60875
;  :arith-assert-upper      49333
;  :arith-bound-prop        8223
;  :arith-conflicts         427
;  :arith-eq-adapter        43744
;  :arith-fixed-eqs         42026
;  :arith-offset-eqs        9847
;  :arith-pivots            18798
;  :conflicts               1194
;  :datatype-accessor-ax    238
;  :datatype-constructor-ax 644
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               22307
;  :del-clause              535815
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  23.22
;  :minimized-lits          116
;  :mk-bool-var             614857
;  :mk-clause               537485
;  :num-allocs              2341284
;  :num-checks              343
;  :propagations            122445
;  :quant-instantiations    245953
;  :rlimit-count            5815946)
(declare-const sm@285@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r)))
    (=
      ($FVF.lookup_int (as sm@285@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@285@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@285@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@285@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
    (=
      ($FVF.lookup_int (as sm@285@07  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@285@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@256@07  $FVF<Int>) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@285@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef113|)))
; Check receiver injectivity
(push) ; 15
(assert (not (forall ((i11@282@07 Int) (i12@282@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@282@07 V@39@07) (<= 0 i11@282@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@285@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@282@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@282@07)))
        (< $Perm.No $k@283@07))
      (and
        (and
          (and (< i12@282@07 V@39@07) (<= 0 i12@282@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@285@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@282@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@282@07)))
        (< $Perm.No $k@283@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@282@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@282@07)))
    (= i11@282@07 i12@282@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               257971
;  :arith-add-rows          72120
;  :arith-assert-diseq      3555
;  :arith-assert-lower      60879
;  :arith-assert-upper      49333
;  :arith-bound-prop        8223
;  :arith-conflicts         427
;  :arith-eq-adapter        43745
;  :arith-fixed-eqs         42026
;  :arith-offset-eqs        9847
;  :arith-pivots            18798
;  :conflicts               1195
;  :datatype-accessor-ax    238
;  :datatype-constructor-ax 644
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               22307
;  :del-clause              535837
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  23.23
;  :minimized-lits          116
;  :mk-bool-var             614939
;  :mk-clause               537511
;  :num-allocs              2342704
;  :num-checks              344
;  :propagations            122448
;  :quant-instantiations    246024
;  :rlimit-count            5820422
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@282@07 Int)) (!
  (implies
    (and (and (< i1@282@07 V@39@07) (<= 0 i1@282@07)) (< $Perm.No $k@283@07))
    (=
      (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@282@07))
      i1@282@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@282@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
      (< $Perm.No $k@283@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@284@07 r))
      r))
  :pattern ((inv@284@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@285@07  $FVF<Int>) r) r))
  :pattern ((inv@284@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@286@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r))
      $k@283@07)
    $Perm.No))
(define-fun pTaken@287@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@283@07 (pTaken@286@07 r)))
    $Perm.No))
(define-fun pTaken@288@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
        $Perm.Write
        $Perm.No)
      (- (- $k@283@07 (pTaken@286@07 r)) (pTaken@287@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@283@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@254@07 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
        $k@283@07
        $Perm.No)
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r))))
  :pattern ((inv@210@07 r))
  :pattern ((inv@284@07 r))
  :qid |qp.srp114|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
    (= (- $k@283@07 (pTaken@286@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 15
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               297773
;  :arith-add-rows          81938
;  :arith-assert-diseq      4160
;  :arith-assert-lower      71219
;  :arith-assert-upper      58125
;  :arith-bound-prop        9222
;  :arith-conflicts         453
;  :arith-eq-adapter        51120
;  :arith-fixed-eqs         49369
;  :arith-offset-eqs        11672
;  :arith-pivots            20840
;  :conflicts               1250
;  :datatype-accessor-ax    242
;  :datatype-constructor-ax 655
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               25626
;  :del-clause              613820
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  22.94
;  :minimized-lits          122
;  :mk-bool-var             704080
;  :mk-clause               615514
;  :num-allocs              2621781
;  :num-checks              346
;  :propagations            141392
;  :quant-instantiations    280703
;  :rlimit-count            6458255
;  :time                    0.50)
; Constrain original permissions $k@283@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
              (< (inv@206@07 r) V@39@07))
            (<= 0 (inv@206@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r)))
      (<
        (ite
          (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
          $k@283@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
          $k@283@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@207@07 r))
  :pattern ((inv@206@07 r))
  :pattern ((inv@284@07 r))
  :qid |qp.srp115|)))
; Intermediate check if already taken enough permissions
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
    (= (- (- $k@283@07 (pTaken@286@07 r)) (pTaken@287@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 15
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               336548
;  :arith-add-rows          89811
;  :arith-assert-diseq      4639
;  :arith-assert-lower      81019
;  :arith-assert-upper      66434
;  :arith-bound-prop        10210
;  :arith-conflicts         475
;  :arith-eq-adapter        58327
;  :arith-fixed-eqs         56540
;  :arith-offset-eqs        13156
;  :arith-pivots            22945
;  :conflicts               1299
;  :datatype-accessor-ax    248
;  :datatype-constructor-ax 674
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               29249
;  :del-clause              701768
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  23.02
;  :minimized-lits          127
;  :mk-bool-var             800243
;  :mk-clause               703475
;  :num-allocs              2915283
;  :num-checks              347
;  :propagations            159698
;  :quant-instantiations    317298
;  :rlimit-count            7104807
;  :time                    0.50)
; Constrain original permissions $k@283@07
(assert (implies
  (not
    (=
      (ite
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
        $Perm.Write
        $Perm.No)
      $Perm.No))
  (ite
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
    (<
      (ite
        (and
          (<
            (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
            V@39@07)
          (<=
            0
            (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))))
        $k@283@07
        $Perm.No)
      $Perm.Write)
    (<
      (ite
        (and
          (<
            (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
            V@39@07)
          (<=
            0
            (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))))
        $k@283@07
        $Perm.No)
      $Perm.No))))
; Intermediate check if already taken enough permissions
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
    (=
      (- (- (- $k@283@07 (pTaken@286@07 r)) (pTaken@287@07 r)) (pTaken@288@07 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               342471
;  :arith-add-rows          90518
;  :arith-assert-diseq      4779
;  :arith-assert-lower      82099
;  :arith-assert-upper      67119
;  :arith-bound-prop        10327
;  :arith-conflicts         483
;  :arith-eq-adapter        59212
;  :arith-fixed-eqs         57093
;  :arith-offset-eqs        13399
;  :arith-pivots            23176
;  :conflicts               1333
;  :datatype-accessor-ax    253
;  :datatype-constructor-ax 694
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               29682
;  :del-clause              710808
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              25.09
;  :memory                  23.07
;  :minimized-lits          132
;  :mk-bool-var             809481
;  :mk-clause               712520
;  :num-allocs              2943963
;  :num-checks              348
;  :propagations            162318
;  :quant-instantiations    320098
;  :rlimit-count            7196263
;  :time                    0.06)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@289@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@289@07  $FVF<Int>)))
    (and
      (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
      (< $Perm.No $k@283@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@289@07  $FVF<Int>))))
  :qid |qp.fvfDomDef121|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
        (< $Perm.No $k@283@07))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@254@07 r))))
    (=
      ($FVF.lookup_int (as sm@289@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@289@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
        (< $Perm.No $k@283@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@289@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@289@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
        (< $Perm.No $k@283@07))
      (=
        r
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)))
    (=
      ($FVF.lookup_int (as sm@289@07  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@289@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@256@07  $FVF<Int>) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@289@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef120|)))
(pop) ; 14
; Joined path conditions
(assert ($Perm.isReadVar $k@283@07 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@254@07 r)))
    (=
      ($FVF.lookup_int (as sm@285@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@285@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@285@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@285@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
    (=
      ($FVF.lookup_int (as sm@285@07  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@285@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@256@07  $FVF<Int>) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@285@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef113|)))
(assert (forall ((i1@282@07 Int)) (!
  (implies
    (and (and (< i1@282@07 V@39@07) (<= 0 i1@282@07)) (< $Perm.No $k@283@07))
    (=
      (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@282@07))
      i1@282@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@282@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
      (< $Perm.No $k@283@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@284@07 r))
      r))
  :pattern ((inv@284@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@289@07  $FVF<Int>)))
    (and
      (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
      (< $Perm.No $k@283@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@289@07  $FVF<Int>))))
  :qid |qp.fvfDomDef121|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
        (< $Perm.No $k@283@07))
      (<
        $Perm.No
        (-
          (ite
            (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@254@07 r))))
    (=
      ($FVF.lookup_int (as sm@289@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@289@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
        (< $Perm.No $k@283@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@289@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@289@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
        (< $Perm.No $k@283@07))
      (=
        r
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)))
    (=
      ($FVF.lookup_int (as sm@289@07  $FVF<Int>) r)
      ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r)))
  :pattern (($FVF.lookup_int (as sm@289@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int (as sm@256@07  $FVF<Int>) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int (as sm@256@07  $FVF<Int>) r) r))
  :pattern (($FVF.lookup_int (as sm@289@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef120|)))
(assert (and
  (forall ((i1@282@07 Int)) (!
    (< i1@282@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@282@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@285@07  $FVF<Int>) r) r))
    :pattern ((inv@284@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (-
            (ite
              (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@254@07 r))
          $Perm.No))
      (<
        (ite
          (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
          $k@283@07
          $Perm.No)
        (-
          (ite
            (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@254@07 r))))
    :pattern ((inv@210@07 r))
    :pattern ((inv@284@07 r))
    :qid |qp.srp114|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
                (< (inv@206@07 r) V@39@07))
              (<= 0 (inv@206@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        (<
          (ite
            (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
            $k@283@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@284@07 r) V@39@07) (<= 0 (inv@284@07 r)))
            $k@283@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@207@07 r))
    :pattern ((inv@206@07 r))
    :pattern ((inv@284@07 r))
    :qid |qp.srp115|))
  (implies
    (not
      (=
        (ite
          (=
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)
            (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
      (<
        (ite
          (and
            (<
              (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
              V@39@07)
            (<=
              0
              (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))))
          $k@283@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (<
              (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))
              V@39@07)
            (<=
              0
              (inv@284@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) v@193@07))))
          $k@283@07
          $Perm.No)
        $Perm.No)))))
(set-option :timeout 0)
(push) ; 14
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@289@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 14
; 2.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               557421
;  :arith-add-rows          132643
;  :arith-assert-diseq      9821
;  :arith-assert-lower      144576
;  :arith-assert-upper      120922
;  :arith-bound-prop        12764
;  :arith-conflicts         574
;  :arith-eq-adapter        94493
;  :arith-fixed-eqs         103482
;  :arith-offset-eqs        22691
;  :arith-pivots            29962
;  :conflicts               1508
;  :datatype-accessor-ax    288
;  :datatype-constructor-ax 760
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               48907
;  :del-clause              1105858
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              30.58
;  :memory                  29.17
;  :minimized-lits          156
;  :mk-bool-var             1253801
;  :mk-clause               1107572
;  :num-allocs              4308516
;  :num-checks              349
;  :propagations            279878
;  :quant-instantiations    498051
;  :restarts                1
;  :rlimit-count            10117224
;  :time                    2.50)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@289@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
; [eval] 0 <= u
; [eval] u < V
; [eval] 0 <= v
(push) ; 14
(assert (not (<= 0 v@259@07)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               557445
;  :arith-add-rows          132714
;  :arith-assert-diseq      9821
;  :arith-assert-lower      144579
;  :arith-assert-upper      120924
;  :arith-bound-prop        12764
;  :arith-conflicts         575
;  :arith-eq-adapter        94494
;  :arith-fixed-eqs         103483
;  :arith-offset-eqs        22691
;  :arith-pivots            29964
;  :conflicts               1509
;  :datatype-accessor-ax    291
;  :datatype-constructor-ax 760
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               48907
;  :del-clause              1105858
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              30.58
;  :memory                  29.18
;  :minimized-lits          156
;  :mk-bool-var             1253946
;  :mk-clause               1107688
;  :num-allocs              4309093
;  :num-checks              350
;  :propagations            279889
;  :quant-instantiations    498081
;  :restarts                1
;  :rlimit-count            10119575
;  :time                    0.00)
(assert (<= 0 v@259@07))
; [eval] v <= V
(push) ; 14
(assert (not (<= v@259@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               557445
;  :arith-add-rows          132850
;  :arith-assert-diseq      9821
;  :arith-assert-lower      144580
;  :arith-assert-upper      120925
;  :arith-bound-prop        12764
;  :arith-conflicts         576
;  :arith-eq-adapter        94494
;  :arith-fixed-eqs         103483
;  :arith-offset-eqs        22691
;  :arith-pivots            29966
;  :conflicts               1510
;  :datatype-accessor-ax    291
;  :datatype-constructor-ax 760
;  :datatype-occurs-check   247
;  :datatype-splits         147
;  :decisions               48907
;  :del-clause              1105858
;  :final-checks            137
;  :interface-eqs           12
;  :max-generation          11
;  :max-memory              30.58
;  :memory                  29.18
;  :minimized-lits          156
;  :mk-bool-var             1253948
;  :mk-clause               1107688
;  :num-allocs              4309253
;  :num-checks              351
;  :propagations            279889
;  :quant-instantiations    498081
;  :restarts                1
;  :rlimit-count            10121835)
(assert (<= v@259@07 V@39@07))
; [eval] 0 <= k
; [eval] k < V
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 14
; [eval] this != null
(pop) ; 14
; Joined path conditions
(push) ; 14
(assert (not (valid_graph_vertices1 $Snap.unit this@36@07 queue@252@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 14
; 5.57s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1142415
;  :arith-add-rows          202035
;  :arith-assert-diseq      42998
;  :arith-assert-lower      325597
;  :arith-assert-upper      274045
;  :arith-bound-prop        17277
;  :arith-conflicts         832
;  :arith-eq-adapter        178727
;  :arith-fixed-eqs         199783
;  :arith-offset-eqs        54659
;  :arith-pivots            43723
;  :conflicts               2087
;  :datatype-accessor-ax    618
;  :datatype-constructor-ax 1679
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               119786
;  :del-clause              1758040
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.27
;  :minimized-lits          226
;  :mk-bool-var             2033022
;  :mk-clause               1759870
;  :num-allocs              6874173
;  :num-checks              352
;  :propagations            642310
;  :quant-instantiations    828646
;  :restarts                4
;  :rlimit-count            17749899
;  :time                    5.57)
(assert (valid_graph_vertices1 $Snap.unit this@36@07 queue@252@07 V@39@07))
(declare-const i1@290@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 176 | 0 <= i1@290@07 | live]
; [else-branch: 176 | !(0 <= i1@290@07) | live]
(push) ; 16
; [then-branch: 176 | 0 <= i1@290@07]
(assert (<= 0 i1@290@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 176 | !(0 <= i1@290@07)]
(assert (not (<= 0 i1@290@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@290@07 V@39@07) (<= 0 i1@290@07)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@290@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1142416
;  :arith-add-rows          202037
;  :arith-assert-diseq      42998
;  :arith-assert-lower      325599
;  :arith-assert-upper      274045
;  :arith-bound-prop        17277
;  :arith-conflicts         832
;  :arith-eq-adapter        178727
;  :arith-fixed-eqs         199783
;  :arith-offset-eqs        54659
;  :arith-pivots            43723
;  :conflicts               2087
;  :datatype-accessor-ax    618
;  :datatype-constructor-ax 1679
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               119786
;  :del-clause              1758040
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.27
;  :minimized-lits          226
;  :mk-bool-var             2033043
;  :mk-clause               1759895
;  :num-allocs              6874412
;  :num-checks              353
;  :propagations            642316
;  :quant-instantiations    828649
;  :restarts                4
;  :rlimit-count            17750265)
(assert (< i1@290@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@290@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 14
(declare-fun inv@291@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@290@07 Int)) (!
  (< i1@290@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@290@07))
  :qid |bool-aux|)))
(declare-const sm@292@07 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@257@07 r)))
    (=
      ($FVF.lookup_bool (as sm@292@07  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@292@07  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef122|)))
(assert (forall ((r $Ref)) (!
  (implies
    (=
      r
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))
    (=
      ($FVF.lookup_bool (as sm@292@07  $FVF<Bool>) r)
      ($FVF.lookup_bool (as sm@258@07  $FVF<Bool>) r)))
  :pattern (($FVF.lookup_bool (as sm@292@07  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool (as sm@258@07  $FVF<Bool>) r))
  :qid |qp.fvfValDef123|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))))))))))))) r) r)
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@258@07  $FVF<Bool>) r) r))
  :pattern (($FVF.lookup_bool (as sm@292@07  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef124|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@290@07 Int) (i12@290@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@290@07 V@39@07) (<= 0 i11@290@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@292@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@290@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@290@07)))
      (and
        (and (< i12@290@07 V@39@07) (<= 0 i12@290@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@292@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@290@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@290@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@290@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@290@07)))
    (= i11@290@07 i12@290@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1142448
;  :arith-add-rows          202041
;  :arith-assert-diseq      42999
;  :arith-assert-lower      325605
;  :arith-assert-upper      274046
;  :arith-bound-prop        17277
;  :arith-conflicts         832
;  :arith-eq-adapter        178729
;  :arith-fixed-eqs         199784
;  :arith-offset-eqs        54659
;  :arith-pivots            43725
;  :conflicts               2088
;  :datatype-accessor-ax    618
;  :datatype-constructor-ax 1679
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               119786
;  :del-clause              1758068
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.35
;  :minimized-lits          226
;  :mk-bool-var             2033121
;  :mk-clause               1759942
;  :num-allocs              6875609
;  :num-checks              354
;  :propagations            642323
;  :quant-instantiations    828688
;  :restarts                4
;  :rlimit-count            17753803
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@290@07 Int)) (!
  (implies
    (and (< i1@290@07 V@39@07) (<= 0 i1@290@07))
    (=
      (inv@291@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@290@07))
      i1@290@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@290@07))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@291@07 r) V@39@07) (<= 0 (inv@291@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@291@07 r))
      r))
  :pattern ((inv@291@07 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@291@07 r) V@39@07) (<= 0 (inv@291@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@292@07  $FVF<Bool>) r) r))
  :pattern ((inv@291@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@293@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@291@07 r) V@39@07) (<= 0 (inv@291@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@257@07 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@294@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@291@07 r) V@39@07) (<= 0 (inv@291@07 r)))
    ($Perm.min
      (ite
        (=
          r
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@293@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@257@07 r))
      (pTaken@293@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1148964
;  :arith-add-rows          203346
;  :arith-assert-diseq      43139
;  :arith-assert-lower      326776
;  :arith-assert-upper      274792
;  :arith-bound-prop        17376
;  :arith-conflicts         846
;  :arith-eq-adapter        179657
;  :arith-fixed-eqs         200427
;  :arith-offset-eqs        54805
;  :arith-pivots            43943
;  :conflicts               2116
;  :datatype-accessor-ax    623
;  :datatype-constructor-ax 1699
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               120733
;  :del-clause              1774515
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.70
;  :minimized-lits          228
;  :mk-bool-var             2046861
;  :mk-clause               1776362
;  :num-allocs              6905254
;  :num-checks              356
;  :propagations            646587
;  :quant-instantiations    832440
;  :restarts                4
;  :rlimit-count            17891416
;  :time                    0.06)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@291@07 r) V@39@07) (<= 0 (inv@291@07 r)))
    (= (- $Perm.Write (pTaken@293@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1177999
;  :arith-add-rows          209950
;  :arith-assert-diseq      43576
;  :arith-assert-lower      334044
;  :arith-assert-upper      280904
;  :arith-bound-prop        18137
;  :arith-conflicts         862
;  :arith-eq-adapter        185657
;  :arith-fixed-eqs         205414
;  :arith-offset-eqs        55480
;  :arith-pivots            45499
;  :conflicts               2148
;  :datatype-accessor-ax    627
;  :datatype-constructor-ax 1710
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               123920
;  :del-clause              1857389
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.78
;  :minimized-lits          231
;  :mk-bool-var             2134121
;  :mk-clause               1859236
;  :num-allocs              7163169
;  :num-checks              357
;  :propagations            661654
;  :quant-instantiations    866058
;  :restarts                4
;  :rlimit-count            18423921
;  :time                    0.50)
; Chunk depleted?
(push) ; 14
(assert (not (=
  (-
    (ite
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))
      $Perm.Write
      $Perm.No)
    (pTaken@294@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
  $Perm.No)))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1179427
;  :arith-add-rows          210403
;  :arith-assert-diseq      43622
;  :arith-assert-lower      334354
;  :arith-assert-upper      281080
;  :arith-bound-prop        18180
;  :arith-conflicts         867
;  :arith-eq-adapter        185860
;  :arith-fixed-eqs         205542
;  :arith-offset-eqs        55577
;  :arith-pivots            45553
;  :conflicts               2159
;  :datatype-accessor-ax    628
;  :datatype-constructor-ax 1714
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124104
;  :del-clause              1860635
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.73
;  :minimized-lits          231
;  :mk-bool-var             2137001
;  :mk-clause               1862482
;  :num-allocs              7171072
;  :num-checks              358
;  :propagations            662501
;  :quant-instantiations    866818
;  :restarts                4
;  :rlimit-count            18467430
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@291@07 r) V@39@07) (<= 0 (inv@291@07 r)))
    (= (- (- $Perm.Write (pTaken@293@07 r)) (pTaken@294@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1181009
;  :arith-add-rows          210604
;  :arith-assert-diseq      43674
;  :arith-assert-lower      334644
;  :arith-assert-upper      281262
;  :arith-bound-prop        18238
;  :arith-conflicts         873
;  :arith-eq-adapter        186103
;  :arith-fixed-eqs         205677
;  :arith-offset-eqs        55691
;  :arith-pivots            45631
;  :conflicts               2183
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1718
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124293
;  :del-clause              1864064
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.63
;  :minimized-lits          234
;  :mk-bool-var             2140019
;  :mk-clause               1865911
;  :num-allocs              7179432
;  :num-checks              359
;  :propagations            663352
;  :quant-instantiations    867620
;  :restarts                4
;  :rlimit-count            18507725
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(pop) ; 13
(push) ; 13
; [else-branch: 160 | !(0 < Lookup(int,sm@250@07,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), u@188@07))), v@193@07)) && !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07))))]
(assert (not
  (and
    (<
      0
      ($FVF.lookup_int (as sm@250@07  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
    (not
      ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))))))
(pop) ; 13
; [eval] !(!aloc(opt_get1(visited), v).bool && 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int)
; [eval] !aloc(opt_get1(visited), v).bool && 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int
; [eval] !aloc(opt_get1(visited), v).bool
; [eval] aloc(opt_get1(visited), v)
; [eval] opt_get1(visited)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 13
; Joined path conditions
(set-option :timeout 0)
(push) ; 13
(assert (not (and
  (<
    (inv@219@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))
    V@39@07)
  (<=
    0
    (inv@219@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1181009
;  :arith-add-rows          210912
;  :arith-assert-diseq      43674
;  :arith-assert-lower      334644
;  :arith-assert-upper      281263
;  :arith-bound-prop        18238
;  :arith-conflicts         874
;  :arith-eq-adapter        186103
;  :arith-fixed-eqs         205677
;  :arith-offset-eqs        55691
;  :arith-pivots            45718
;  :conflicts               2184
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1718
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124293
;  :del-clause              1864830
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          234
;  :mk-bool-var             2140019
;  :mk-clause               1865911
;  :num-allocs              7179567
;  :num-checks              360
;  :propagations            663352
;  :quant-instantiations    867620
;  :restarts                4
;  :rlimit-count            18513613)
(push) ; 13
; [then-branch: 177 | !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07))) | live]
; [else-branch: 177 | Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07)) | live]
(push) ; 14
; [then-branch: 177 | !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07)))]
(assert (not
  ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))))
; [eval] 0 < aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k).int
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), u).option$array$), k)
; [eval] opt_get1(aloc(opt_get1(Gf), u).option$array$)
; [eval] aloc(opt_get1(Gf), u)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< u@188@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1181116
;  :arith-add-rows          210938
;  :arith-assert-diseq      43674
;  :arith-assert-lower      334656
;  :arith-assert-upper      281276
;  :arith-bound-prop        18246
;  :arith-conflicts         874
;  :arith-eq-adapter        186115
;  :arith-fixed-eqs         205688
;  :arith-offset-eqs        55706
;  :arith-pivots            45729
;  :conflicts               2184
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1718
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124293
;  :del-clause              1864830
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.40
;  :minimized-lits          234
;  :mk-bool-var             2140336
;  :mk-clause               1866107
;  :num-allocs              7180939
;  :num-checks              361
;  :propagations            663375
;  :quant-instantiations    867728
;  :restarts                4
;  :rlimit-count            18519346)
(assert (< u@188@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 15
; Joined path conditions
(assert (< u@188@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1181116
;  :arith-add-rows          210955
;  :arith-assert-diseq      43674
;  :arith-assert-lower      334656
;  :arith-assert-upper      281277
;  :arith-bound-prop        18246
;  :arith-conflicts         875
;  :arith-eq-adapter        186115
;  :arith-fixed-eqs         205688
;  :arith-offset-eqs        55706
;  :arith-pivots            45730
;  :conflicts               2185
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1718
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124293
;  :del-clause              1864830
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          234
;  :mk-bool-var             2140336
;  :mk-clause               1866107
;  :num-allocs              7181117
;  :num-checks              362
;  :propagations            663375
;  :quant-instantiations    867728
;  :restarts                4
;  :rlimit-count            18519928)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1181116
;  :arith-add-rows          210955
;  :arith-assert-diseq      43674
;  :arith-assert-lower      334656
;  :arith-assert-upper      281277
;  :arith-bound-prop        18246
;  :arith-conflicts         875
;  :arith-eq-adapter        186115
;  :arith-fixed-eqs         205688
;  :arith-offset-eqs        55706
;  :arith-pivots            45730
;  :conflicts               2186
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1718
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124293
;  :del-clause              1864830
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          234
;  :mk-bool-var             2140336
;  :mk-clause               1866107
;  :num-allocs              7181206
;  :num-checks              363
;  :propagations            663375
;  :quant-instantiations    867728
;  :restarts                4
;  :rlimit-count            18520019)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  v@193@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1181116
;  :arith-add-rows          210955
;  :arith-assert-diseq      43674
;  :arith-assert-lower      334656
;  :arith-assert-upper      281277
;  :arith-bound-prop        18246
;  :arith-conflicts         875
;  :arith-eq-adapter        186115
;  :arith-fixed-eqs         205688
;  :arith-offset-eqs        55706
;  :arith-pivots            45730
;  :conflicts               2187
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1718
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124293
;  :del-clause              1864830
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          234
;  :mk-bool-var             2140336
;  :mk-clause               1866107
;  :num-allocs              7181355
;  :num-checks              364
;  :propagations            663375
;  :quant-instantiations    867728
;  :restarts                4
;  :rlimit-count            18520246)
(assert (<
  v@193@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))))))
(pop) ; 15
; Joined path conditions
(assert (<
  v@193@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))))))
(declare-const sm@295@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@295@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@295@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@295@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@295@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@295@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef127|)))
(declare-const pm@296@07 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@296@07  $FPM) r)
    (+
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@296@07  $FPM) r))
  :qid |qp.resPrmSumDef128|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@295@07  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@296@07  $FPM) r))
  :qid |qp.resTrgDef129|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@295@07  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
(push) ; 15
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@296@07  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1182317
;  :arith-add-rows          211208
;  :arith-assert-diseq      43689
;  :arith-assert-lower      334902
;  :arith-assert-upper      281433
;  :arith-bound-prop        18336
;  :arith-conflicts         880
;  :arith-eq-adapter        186294
;  :arith-fixed-eqs         205845
;  :arith-offset-eqs        55801
;  :arith-pivots            45845
;  :conflicts               2200
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1722
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124332
;  :del-clause              1866466
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.41
;  :minimized-lits          234
;  :mk-bool-var             2142508
;  :mk-clause               1867745
;  :num-allocs              7190246
;  :num-checks              365
;  :propagations            663886
;  :quant-instantiations    868507
;  :restarts                4
;  :rlimit-count            18554184
;  :time                    0.01)
(pop) ; 14
(push) ; 14
; [else-branch: 177 | Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07))]
(assert ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@295@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@295@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@295@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@295@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@295@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef127|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@296@07  $FPM) r)
    (+
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@296@07  $FPM) r))
  :qid |qp.resPrmSumDef128|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@295@07  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@296@07  $FPM) r))
  :qid |qp.resTrgDef129|)))
(assert (implies
  (not
    ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
  (and
    (not
      ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))
    (< u@188@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))
        (as None<option<array>>  option<array>)))
    (<
      v@193@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@295@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))))
; Joined path conditions
(set-option :timeout 10)
(push) ; 13
(assert (not (and
  (<
    0
    ($FVF.lookup_int (as sm@295@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
  (not
    ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1183501
;  :arith-add-rows          211497
;  :arith-assert-diseq      43704
;  :arith-assert-lower      335138
;  :arith-assert-upper      281585
;  :arith-bound-prop        18417
;  :arith-conflicts         882
;  :arith-eq-adapter        186474
;  :arith-fixed-eqs         206005
;  :arith-offset-eqs        55884
;  :arith-pivots            45975
;  :conflicts               2203
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1726
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124363
;  :del-clause              1868275
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.39
;  :minimized-lits          234
;  :mk-bool-var             2144644
;  :mk-clause               1869363
;  :num-allocs              7199120
;  :num-checks              366
;  :propagations            664337
;  :quant-instantiations    869365
;  :restarts                4
;  :rlimit-count            18591471
;  :time                    0.01)
(push) ; 13
(assert (not (not
  (and
    (<
      0
      ($FVF.lookup_int (as sm@295@07  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
    (not
      ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))))))
(check-sat)
; unknown
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1184578
;  :arith-add-rows          211704
;  :arith-assert-diseq      43719
;  :arith-assert-lower      335346
;  :arith-assert-upper      281717
;  :arith-bound-prop        18483
;  :arith-conflicts         884
;  :arith-eq-adapter        186630
;  :arith-fixed-eqs         206146
;  :arith-offset-eqs        55967
;  :arith-pivots            46055
;  :conflicts               2206
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1730
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124392
;  :del-clause              1869650
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          234
;  :mk-bool-var             2146423
;  :mk-clause               1870738
;  :num-allocs              7205623
;  :num-checks              367
;  :propagations            664766
;  :quant-instantiations    870085
;  :restarts                4
;  :rlimit-count            18620021
;  :time                    0.01)
; [then-branch: 178 | !(0 < Lookup(int,sm@295@07,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), u@188@07))), v@193@07)) && !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07)))) | live]
; [else-branch: 178 | 0 < Lookup(int,sm@295@07,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), u@188@07))), v@193@07)) && !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07))) | live]
(push) ; 13
; [then-branch: 178 | !(0 < Lookup(int,sm@295@07,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), u@188@07))), v@193@07)) && !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07))))]
(assert (not
  (and
    (<
      0
      ($FVF.lookup_int (as sm@295@07  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
    (not
      ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07))))))
; [exec]
; flatten := v
; [exec]
; v := v + 1
; [eval] v + 1
(declare-const v@297@07 Int)
(assert (= v@297@07 (+ v@193@07 1)))
; [exec]
; evaluationDummy2 := flatten
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop1
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@298@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 179 | 0 <= i1@298@07 | live]
; [else-branch: 179 | !(0 <= i1@298@07) | live]
(push) ; 16
; [then-branch: 179 | 0 <= i1@298@07]
(assert (<= 0 i1@298@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 179 | !(0 <= i1@298@07)]
(assert (not (<= 0 i1@298@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@298@07 V@39@07) (<= 0 i1@298@07)))
(declare-const $k@299@07 $Perm)
(assert ($Perm.isReadVar $k@299@07 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@298@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1184579
;  :arith-add-rows          211705
;  :arith-assert-diseq      43720
;  :arith-assert-lower      335351
;  :arith-assert-upper      281719
;  :arith-bound-prop        18483
;  :arith-conflicts         884
;  :arith-eq-adapter        186632
;  :arith-fixed-eqs         206146
;  :arith-offset-eqs        55967
;  :arith-pivots            46056
;  :conflicts               2206
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1730
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124392
;  :del-clause              1869650
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.39
;  :minimized-lits          234
;  :mk-bool-var             2146433
;  :mk-clause               1870744
;  :num-allocs              7205907
;  :num-checks              368
;  :propagations            664769
;  :quant-instantiations    870085
;  :restarts                4
;  :rlimit-count            18620613)
(assert (< i1@298@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@298@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 14
(declare-fun inv@300@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@299@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@298@07 Int)) (!
  (< i1@298@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@298@07))
  :qid |option$array$-aux|)))
(push) ; 14
(assert (not (forall ((i1@298@07 Int)) (!
  (implies
    (and (< i1@298@07 V@39@07) (<= 0 i1@298@07))
    (or (= $k@299@07 $Perm.No) (< $Perm.No $k@299@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1184579
;  :arith-add-rows          211705
;  :arith-assert-diseq      43721
;  :arith-assert-lower      335353
;  :arith-assert-upper      281720
;  :arith-bound-prop        18483
;  :arith-conflicts         884
;  :arith-eq-adapter        186633
;  :arith-fixed-eqs         206146
;  :arith-offset-eqs        55967
;  :arith-pivots            46056
;  :conflicts               2207
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1730
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124392
;  :del-clause              1869652
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          234
;  :mk-bool-var             2146440
;  :mk-clause               1870746
;  :num-allocs              7206340
;  :num-checks              369
;  :propagations            664770
;  :quant-instantiations    870085
;  :restarts                4
;  :rlimit-count            18621159)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@298@07 Int) (i12@298@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@298@07 V@39@07) (<= 0 i11@298@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@298@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@298@07)))
        (< $Perm.No $k@299@07))
      (and
        (and
          (and (< i12@298@07 V@39@07) (<= 0 i12@298@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@298@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@298@07)))
        (< $Perm.No $k@299@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@298@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@298@07)))
    (= i11@298@07 i12@298@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1184597
;  :arith-add-rows          211707
;  :arith-assert-diseq      43722
;  :arith-assert-lower      335357
;  :arith-assert-upper      281720
;  :arith-bound-prop        18483
;  :arith-conflicts         884
;  :arith-eq-adapter        186634
;  :arith-fixed-eqs         206146
;  :arith-offset-eqs        55967
;  :arith-pivots            46056
;  :conflicts               2208
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1730
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124392
;  :del-clause              1869659
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          234
;  :mk-bool-var             2146472
;  :mk-clause               1870753
;  :num-allocs              7206792
;  :num-checks              370
;  :propagations            664770
;  :quant-instantiations    870114
;  :restarts                4
;  :rlimit-count            18622298)
; Definitional axioms for inverse functions
(assert (forall ((i1@298@07 Int)) (!
  (implies
    (and (and (< i1@298@07 V@39@07) (<= 0 i1@298@07)) (< $Perm.No $k@299@07))
    (=
      (inv@300@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@298@07))
      i1@298@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@298@07))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@300@07 r) V@39@07) (<= 0 (inv@300@07 r)))
      (< $Perm.No $k@299@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@300@07 r))
      r))
  :pattern ((inv@300@07 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@300@07 r) V@39@07) (<= 0 (inv@300@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) r) r))
  :pattern ((inv@300@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@301@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@300@07 r) V@39@07) (<= 0 (inv@300@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
        $k@197@07
        $Perm.No)
      $k@299@07)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@299@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
          $k@197@07
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
      (<
        (ite
          (and (< (inv@300@07 r) V@39@07) (<= 0 (inv@300@07 r)))
          $k@299@07
          $Perm.No)
        $k@197@07)
      (<
        (ite
          (and (< (inv@300@07 r) V@39@07) (<= 0 (inv@300@07 r)))
          $k@299@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@198@07 r))
  :pattern ((inv@300@07 r))
  :qid |qp.srp130|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@300@07 r) V@39@07) (<= 0 (inv@300@07 r)))
    (= (- $k@299@07 (pTaken@301@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186455
;  :arith-add-rows          212051
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335741
;  :arith-assert-upper      281952
;  :arith-bound-prop        18583
;  :arith-conflicts         889
;  :arith-eq-adapter        186926
;  :arith-fixed-eqs         206406
;  :arith-offset-eqs        56112
;  :arith-pivots            46202
;  :conflicts               2231
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872255
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2149791
;  :mk-clause               1873436
;  :num-allocs              7219777
;  :num-checks              372
;  :propagations            665608
;  :quant-instantiations    871383
;  :restarts                4
;  :rlimit-count            18673913
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@302@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 180 | 0 <= i1@302@07 | live]
; [else-branch: 180 | !(0 <= i1@302@07) | live]
(push) ; 16
; [then-branch: 180 | 0 <= i1@302@07]
(assert (<= 0 i1@302@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 180 | !(0 <= i1@302@07)]
(assert (not (<= 0 i1@302@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 181 | i1@302@07 < V@39@07 && 0 <= i1@302@07 | live]
; [else-branch: 181 | !(i1@302@07 < V@39@07 && 0 <= i1@302@07) | live]
(push) ; 16
; [then-branch: 181 | i1@302@07 < V@39@07 && 0 <= i1@302@07]
(assert (and (< i1@302@07 V@39@07) (<= 0 i1@302@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@302@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186455
;  :arith-add-rows          212051
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335743
;  :arith-assert-upper      281952
;  :arith-bound-prop        18583
;  :arith-conflicts         889
;  :arith-eq-adapter        186926
;  :arith-fixed-eqs         206406
;  :arith-offset-eqs        56112
;  :arith-pivots            46202
;  :conflicts               2231
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872255
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2149793
;  :mk-clause               1873436
;  :num-allocs              7219888
;  :num-checks              373
;  :propagations            665608
;  :quant-instantiations    871383
;  :restarts                4
;  :rlimit-count            18674101)
(assert (< i1@302@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 17
; Joined path conditions
(assert (< i1@302@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186492
;  :arith-add-rows          212075
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335750
;  :arith-assert-upper      281960
;  :arith-bound-prop        18590
;  :arith-conflicts         890
;  :arith-eq-adapter        186933
;  :arith-fixed-eqs         206413
;  :arith-offset-eqs        56112
;  :arith-pivots            46210
;  :conflicts               2232
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872255
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.40
;  :minimized-lits          236
;  :mk-bool-var             2149949
;  :mk-clause               1873528
;  :num-allocs              7220903
;  :num-checks              374
;  :propagations            665610
;  :quant-instantiations    871447
;  :restarts                4
;  :rlimit-count            18677845)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 181 | !(i1@302@07 < V@39@07 && 0 <= i1@302@07)]
(assert (not (and (< i1@302@07 V@39@07) (<= 0 i1@302@07))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@302@07 V@39@07) (<= 0 i1@302@07))
  (and
    (< i1@302@07 V@39@07)
    (<= 0 i1@302@07)
    (< i1@302@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@302@07 Int)) (!
  (implies
    (and (< i1@302@07 V@39@07) (<= 0 i1@302@07))
    (and
      (< i1@302@07 V@39@07)
      (<= 0 i1@302@07)
      (< i1@302@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@302@07 Int)) (!
  (implies
    (and (< i1@302@07 V@39@07) (<= 0 i1@302@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186501
;  :arith-add-rows          212086
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335753
;  :arith-assert-upper      281961
;  :arith-bound-prop        18591
;  :arith-conflicts         890
;  :arith-eq-adapter        186934
;  :arith-fixed-eqs         206414
;  :arith-offset-eqs        56112
;  :arith-pivots            46220
;  :conflicts               2233
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872415
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2150034
;  :mk-clause               1873596
;  :num-allocs              7221944
;  :num-checks              375
;  :propagations            665612
;  :quant-instantiations    871497
;  :restarts                4
;  :rlimit-count            18681032)
(assert (forall ((i1@302@07 Int)) (!
  (implies
    (and (< i1@302@07 V@39@07) (<= 0 i1@302@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@302@07))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@303@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 182 | 0 <= i1@303@07 | live]
; [else-branch: 182 | !(0 <= i1@303@07) | live]
(push) ; 16
; [then-branch: 182 | 0 <= i1@303@07]
(assert (<= 0 i1@303@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 182 | !(0 <= i1@303@07)]
(assert (not (<= 0 i1@303@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 183 | i1@303@07 < V@39@07 && 0 <= i1@303@07 | live]
; [else-branch: 183 | !(i1@303@07 < V@39@07 && 0 <= i1@303@07) | live]
(push) ; 16
; [then-branch: 183 | i1@303@07 < V@39@07 && 0 <= i1@303@07]
(assert (and (< i1@303@07 V@39@07) (<= 0 i1@303@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@303@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186501
;  :arith-add-rows          212086
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335755
;  :arith-assert-upper      281961
;  :arith-bound-prop        18591
;  :arith-conflicts         890
;  :arith-eq-adapter        186934
;  :arith-fixed-eqs         206414
;  :arith-offset-eqs        56112
;  :arith-pivots            46220
;  :conflicts               2233
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872415
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.39
;  :minimized-lits          236
;  :mk-bool-var             2150037
;  :mk-clause               1873596
;  :num-allocs              7222245
;  :num-checks              376
;  :propagations            665612
;  :quant-instantiations    871497
;  :restarts                4
;  :rlimit-count            18681531)
(assert (< i1@303@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 17
; Joined path conditions
(assert (< i1@303@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07)))
(push) ; 17
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186538
;  :arith-add-rows          212110
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335762
;  :arith-assert-upper      281969
;  :arith-bound-prop        18598
;  :arith-conflicts         891
;  :arith-eq-adapter        186941
;  :arith-fixed-eqs         206421
;  :arith-offset-eqs        56112
;  :arith-pivots            46228
;  :conflicts               2234
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872415
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2150193
;  :mk-clause               1873688
;  :num-allocs              7223272
;  :num-checks              377
;  :propagations            665614
;  :quant-instantiations    871562
;  :restarts                4
;  :rlimit-count            18685485)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186538
;  :arith-add-rows          212110
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335762
;  :arith-assert-upper      281969
;  :arith-bound-prop        18598
;  :arith-conflicts         891
;  :arith-eq-adapter        186941
;  :arith-fixed-eqs         206421
;  :arith-offset-eqs        56112
;  :arith-pivots            46228
;  :conflicts               2235
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872415
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2150193
;  :mk-clause               1873688
;  :num-allocs              7223362
;  :num-checks              378
;  :propagations            665614
;  :quant-instantiations    871562
;  :restarts                4
;  :rlimit-count            18685580)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 183 | !(i1@303@07 < V@39@07 && 0 <= i1@303@07)]
(assert (not (and (< i1@303@07 V@39@07) (<= 0 i1@303@07))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@303@07 V@39@07) (<= 0 i1@303@07))
  (and
    (< i1@303@07 V@39@07)
    (<= 0 i1@303@07)
    (< i1@303@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@303@07 Int)) (!
  (implies
    (and (< i1@303@07 V@39@07) (<= 0 i1@303@07))
    (and
      (< i1@303@07 V@39@07)
      (<= 0 i1@303@07)
      (< i1@303@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@303@07 Int)) (!
  (implies
    (and (< i1@303@07 V@39@07) (<= 0 i1@303@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186538
;  :arith-add-rows          212119
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335764
;  :arith-assert-upper      281969
;  :arith-bound-prop        18598
;  :arith-conflicts         891
;  :arith-eq-adapter        186942
;  :arith-fixed-eqs         206421
;  :arith-offset-eqs        56112
;  :arith-pivots            46236
;  :conflicts               2236
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872517
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          236
;  :mk-bool-var             2150219
;  :mk-clause               1873698
;  :num-allocs              7223907
;  :num-checks              379
;  :propagations            665614
;  :quant-instantiations    871585
;  :restarts                4
;  :rlimit-count            18686973)
(assert (forall ((i1@303@07 Int)) (!
  (implies
    (and (< i1@303@07 V@39@07) (<= 0 i1@303@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@303@07)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@304@07 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@305@07 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 184 | 0 <= i1@304@07 | live]
; [else-branch: 184 | !(0 <= i1@304@07) | live]
(push) ; 17
; [then-branch: 184 | 0 <= i1@304@07]
(assert (<= 0 i1@304@07))
; [eval] i1 < V
(push) ; 18
; [then-branch: 185 | i1@304@07 < V@39@07 | live]
; [else-branch: 185 | !(i1@304@07 < V@39@07) | live]
(push) ; 19
; [then-branch: 185 | i1@304@07 < V@39@07]
(assert (< i1@304@07 V@39@07))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 186 | 0 <= i2@305@07 | live]
; [else-branch: 186 | !(0 <= i2@305@07) | live]
(push) ; 21
; [then-branch: 186 | 0 <= i2@305@07]
(assert (<= 0 i2@305@07))
; [eval] i2 < V
(push) ; 22
; [then-branch: 187 | i2@305@07 < V@39@07 | live]
; [else-branch: 187 | !(i2@305@07 < V@39@07) | live]
(push) ; 23
; [then-branch: 187 | i2@305@07 < V@39@07]
(assert (< i2@305@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186538
;  :arith-add-rows          212119
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335768
;  :arith-assert-upper      281969
;  :arith-bound-prop        18598
;  :arith-conflicts         891
;  :arith-eq-adapter        186942
;  :arith-fixed-eqs         206421
;  :arith-offset-eqs        56112
;  :arith-pivots            46236
;  :conflicts               2236
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872517
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          236
;  :mk-bool-var             2150224
;  :mk-clause               1873698
;  :num-allocs              7224386
;  :num-checks              380
;  :propagations            665614
;  :quant-instantiations    871585
;  :restarts                4
;  :rlimit-count            18687615)
(assert (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 24
; Joined path conditions
(assert (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186575
;  :arith-add-rows          212143
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335775
;  :arith-assert-upper      281977
;  :arith-bound-prop        18605
;  :arith-conflicts         892
;  :arith-eq-adapter        186949
;  :arith-fixed-eqs         206428
;  :arith-offset-eqs        56112
;  :arith-pivots            46244
;  :conflicts               2237
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872517
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2150380
;  :mk-clause               1873790
;  :num-allocs              7225422
;  :num-checks              381
;  :propagations            665616
;  :quant-instantiations    871650
;  :restarts                4
;  :rlimit-count            18691575)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186575
;  :arith-add-rows          212143
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335775
;  :arith-assert-upper      281977
;  :arith-bound-prop        18605
;  :arith-conflicts         892
;  :arith-eq-adapter        186949
;  :arith-fixed-eqs         206428
;  :arith-offset-eqs        56112
;  :arith-pivots            46244
;  :conflicts               2237
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872517
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2150380
;  :mk-clause               1873790
;  :num-allocs              7225448
;  :num-checks              382
;  :propagations            665616
;  :quant-instantiations    871650
;  :restarts                4
;  :rlimit-count            18691605)
(assert (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 24
; Joined path conditions
(assert (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
(push) ; 24
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186611
;  :arith-add-rows          212169
;  :arith-assert-diseq      43760
;  :arith-assert-lower      335782
;  :arith-assert-upper      281985
;  :arith-bound-prop        18612
;  :arith-conflicts         893
;  :arith-eq-adapter        186957
;  :arith-fixed-eqs         206435
;  :arith-offset-eqs        56112
;  :arith-pivots            46252
;  :conflicts               2238
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872517
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.39
;  :minimized-lits          236
;  :mk-bool-var             2150553
;  :mk-clause               1873900
;  :num-allocs              7226535
;  :num-checks              383
;  :propagations            665630
;  :quant-instantiations    871726
;  :restarts                4
;  :rlimit-count            18696334)
(pop) ; 23
(push) ; 23
; [else-branch: 187 | !(i2@305@07 < V@39@07)]
(assert (not (< i2@305@07 V@39@07)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@305@07 V@39@07)
  (and
    (< i2@305@07 V@39@07)
    (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
    (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 186 | !(0 <= i2@305@07)]
(assert (not (<= 0 i2@305@07)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@305@07)
  (and
    (<= 0 i2@305@07)
    (implies
      (< i2@305@07 V@39@07)
      (and
        (< i2@305@07 V@39@07)
        (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
        (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 185 | !(i1@304@07 < V@39@07)]
(assert (not (< i1@304@07 V@39@07)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@304@07 V@39@07)
  (and
    (< i1@304@07 V@39@07)
    (implies
      (<= 0 i2@305@07)
      (and
        (<= 0 i2@305@07)
        (implies
          (< i2@305@07 V@39@07)
          (and
            (< i2@305@07 V@39@07)
            (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
            (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 184 | !(0 <= i1@304@07)]
(assert (not (<= 0 i1@304@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@304@07)
  (and
    (<= 0 i1@304@07)
    (implies
      (< i1@304@07 V@39@07)
      (and
        (< i1@304@07 V@39@07)
        (implies
          (<= 0 i2@305@07)
          (and
            (<= 0 i2@305@07)
            (implies
              (< i2@305@07 V@39@07)
              (and
                (< i2@305@07 V@39@07)
                (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
                (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 188 | Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@304@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@305@07)) && i2@305@07 < V@39@07 && 0 <= i2@305@07 && i1@304@07 < V@39@07 && 0 <= i1@304@07 | live]
; [else-branch: 188 | !(Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@304@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@305@07)) && i2@305@07 < V@39@07 && 0 <= i2@305@07 && i1@304@07 < V@39@07 && 0 <= i1@304@07) | live]
(push) ; 17
; [then-branch: 188 | Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@304@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@305@07)) && i2@305@07 < V@39@07 && 0 <= i2@305@07 && i1@304@07 < V@39@07 && 0 <= i1@304@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
        (< i2@305@07 V@39@07))
      (<= 0 i2@305@07))
    (< i1@304@07 V@39@07))
  (<= 0 i1@304@07)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 188 | !(Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@304@07)) == Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@305@07)) && i2@305@07 < V@39@07 && 0 <= i2@305@07 && i1@304@07 < V@39@07 && 0 <= i1@304@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
          (< i2@305@07 V@39@07))
        (<= 0 i2@305@07))
      (< i1@304@07 V@39@07))
    (<= 0 i1@304@07))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
          (< i2@305@07 V@39@07))
        (<= 0 i2@305@07))
      (< i1@304@07 V@39@07))
    (<= 0 i1@304@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
      ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
    (< i2@305@07 V@39@07)
    (<= 0 i2@305@07)
    (< i1@304@07 V@39@07)
    (<= 0 i1@304@07))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@305@07 Int)) (!
  (and
    (implies
      (<= 0 i1@304@07)
      (and
        (<= 0 i1@304@07)
        (implies
          (< i1@304@07 V@39@07)
          (and
            (< i1@304@07 V@39@07)
            (implies
              (<= 0 i2@305@07)
              (and
                (<= 0 i2@305@07)
                (implies
                  (< i2@305@07 V@39@07)
                  (and
                    (< i2@305@07 V@39@07)
                    (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
                    (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
              (< i2@305@07 V@39@07))
            (<= 0 i2@305@07))
          (< i1@304@07 V@39@07))
        (<= 0 i1@304@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
          ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
        (< i2@305@07 V@39@07)
        (<= 0 i2@305@07)
        (< i1@304@07 V@39@07)
        (<= 0 i1@304@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@304@07 Int)) (!
  (forall ((i2@305@07 Int)) (!
    (and
      (implies
        (<= 0 i1@304@07)
        (and
          (<= 0 i1@304@07)
          (implies
            (< i1@304@07 V@39@07)
            (and
              (< i1@304@07 V@39@07)
              (implies
                (<= 0 i2@305@07)
                (and
                  (<= 0 i2@305@07)
                  (implies
                    (< i2@305@07 V@39@07)
                    (and
                      (< i2@305@07 V@39@07)
                      (< i1@304@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
                      (< i2@305@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
                  ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
                (< i2@305@07 V@39@07))
              (<= 0 i2@305@07))
            (< i1@304@07 V@39@07))
          (<= 0 i1@304@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
            ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
          (< i2@305@07 V@39@07)
          (<= 0 i2@305@07)
          (< i1@304@07 V@39@07)
          (<= 0 i1@304@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 14
(assert (not (forall ((i1@304@07 Int)) (!
  (forall ((i2@305@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
              (< i2@305@07 V@39@07))
            (<= 0 i2@305@07))
          (< i1@304@07 V@39@07))
        (<= 0 i1@304@07))
      (= i1@304@07 i2@305@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186657
;  :arith-add-rows          212193
;  :arith-assert-diseq      43762
;  :arith-assert-lower      335788
;  :arith-assert-upper      281987
;  :arith-bound-prop        18614
;  :arith-conflicts         893
;  :arith-eq-adapter        186972
;  :arith-fixed-eqs         206437
;  :arith-offset-eqs        56112
;  :arith-pivots            46272
;  :conflicts               2239
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872899
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          236
;  :mk-bool-var             2150869
;  :mk-clause               1874080
;  :num-allocs              7229044
;  :num-checks              384
;  :propagations            665640
;  :quant-instantiations    871862
;  :restarts                4
;  :rlimit-count            18706067
;  :time                    0.00)
(assert (forall ((i1@304@07 Int)) (!
  (forall ((i2@305@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
                ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07)))
              (< i2@305@07 V@39@07))
            (<= 0 i2@305@07))
          (< i1@304@07 V@39@07))
        (<= 0 i1@304@07))
      (= i1@304@07 i2@305@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@305@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@304@07))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@306@07 Int)
(declare-const j1@307@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 189 | 0 <= i1@306@07 | live]
; [else-branch: 189 | !(0 <= i1@306@07) | live]
(push) ; 16
; [then-branch: 189 | 0 <= i1@306@07]
(assert (<= 0 i1@306@07))
; [eval] i1 < V
(push) ; 17
; [then-branch: 190 | i1@306@07 < V@39@07 | live]
; [else-branch: 190 | !(i1@306@07 < V@39@07) | live]
(push) ; 18
; [then-branch: 190 | i1@306@07 < V@39@07]
(assert (< i1@306@07 V@39@07))
; [eval] 0 <= j1
(push) ; 19
; [then-branch: 191 | 0 <= j1@307@07 | live]
; [else-branch: 191 | !(0 <= j1@307@07) | live]
(push) ; 20
; [then-branch: 191 | 0 <= j1@307@07]
(assert (<= 0 j1@307@07))
; [eval] j1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 191 | !(0 <= j1@307@07)]
(assert (not (<= 0 j1@307@07)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 190 | !(i1@306@07 < V@39@07)]
(assert (not (< i1@306@07 V@39@07)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 189 | !(0 <= i1@306@07)]
(assert (not (<= 0 i1@306@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@307@07 V@39@07) (<= 0 j1@307@07)) (< i1@306@07 V@39@07))
  (<= 0 i1@306@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@306@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186657
;  :arith-add-rows          212193
;  :arith-assert-diseq      43762
;  :arith-assert-lower      335794
;  :arith-assert-upper      281987
;  :arith-bound-prop        18614
;  :arith-conflicts         893
;  :arith-eq-adapter        186972
;  :arith-fixed-eqs         206437
;  :arith-offset-eqs        56112
;  :arith-pivots            46272
;  :conflicts               2239
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872899
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          236
;  :mk-bool-var             2150876
;  :mk-clause               1874080
;  :num-allocs              7229651
;  :num-checks              385
;  :propagations            665640
;  :quant-instantiations    871862
;  :restarts                4
;  :rlimit-count            18707066)
(assert (< i1@306@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@306@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))
      V@39@07)
    (<=
      0
      (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))))
  (< $Perm.No $k@197@07)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186695
;  :arith-add-rows          212217
;  :arith-assert-diseq      43762
;  :arith-assert-lower      335801
;  :arith-assert-upper      281995
;  :arith-bound-prop        18621
;  :arith-conflicts         894
;  :arith-eq-adapter        186979
;  :arith-fixed-eqs         206444
;  :arith-offset-eqs        56112
;  :arith-pivots            46280
;  :conflicts               2240
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872899
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2151035
;  :mk-clause               1874172
;  :num-allocs              7230746
;  :num-checks              386
;  :propagations            665642
;  :quant-instantiations    871930
;  :restarts                4
;  :rlimit-count            18711332)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186695
;  :arith-add-rows          212217
;  :arith-assert-diseq      43762
;  :arith-assert-lower      335801
;  :arith-assert-upper      281995
;  :arith-bound-prop        18621
;  :arith-conflicts         894
;  :arith-eq-adapter        186979
;  :arith-fixed-eqs         206444
;  :arith-offset-eqs        56112
;  :arith-pivots            46280
;  :conflicts               2241
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872899
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2151035
;  :mk-clause               1874172
;  :num-allocs              7230836
;  :num-checks              387
;  :propagations            665642
;  :quant-instantiations    871930
;  :restarts                4
;  :rlimit-count            18711427)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j1@307@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186701
;  :arith-add-rows          212222
;  :arith-assert-diseq      43762
;  :arith-assert-lower      335803
;  :arith-assert-upper      281997
;  :arith-bound-prop        18621
;  :arith-conflicts         895
;  :arith-eq-adapter        186980
;  :arith-fixed-eqs         206445
;  :arith-offset-eqs        56112
;  :arith-pivots            46284
;  :conflicts               2242
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1872903
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          236
;  :mk-bool-var             2151046
;  :mk-clause               1874176
;  :num-allocs              7231034
;  :num-checks              388
;  :propagations            665644
;  :quant-instantiations    871939
;  :restarts                4
;  :rlimit-count            18711969)
(assert (<
  j1@307@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j1@307@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))))))
(pop) ; 14
(declare-fun inv@308@07 ($Ref) Int)
(declare-fun inv@309@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@306@07 Int) (j1@307@07 Int)) (!
  (and
    (< i1@306@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@307@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))) j1@307@07))
  :qid |int-aux|)))
(declare-const sm@310@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@310@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@310@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef131|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@310@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@310@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef132|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@310@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef133|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@306@07 Int) (j11@307@07 Int) (i12@306@07 Int) (j12@307@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@307@07 V@39@07) (<= 0 j11@307@07))
            (< i11@306@07 V@39@07))
          (<= 0 i11@306@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@310@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@306@07))) j11@307@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@306@07))) j11@307@07)))
      (and
        (and
          (and
            (and (< j12@307@07 V@39@07) (<= 0 j12@307@07))
            (< i12@306@07 V@39@07))
          (<= 0 i12@306@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@310@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@306@07))) j12@307@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@306@07))) j12@307@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@306@07))) j11@307@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@306@07))) j12@307@07)))
    (and (= i11@306@07 i12@306@07) (= j11@307@07 j12@307@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1186753
;  :arith-add-rows          212232
;  :arith-assert-diseq      43762
;  :arith-assert-lower      335812
;  :arith-assert-upper      281998
;  :arith-bound-prop        18621
;  :arith-conflicts         895
;  :arith-eq-adapter        186990
;  :arith-fixed-eqs         206445
;  :arith-offset-eqs        56112
;  :arith-pivots            46292
;  :conflicts               2243
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1738
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124458
;  :del-clause              1873115
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          236
;  :mk-bool-var             2151250
;  :mk-clause               1874296
;  :num-allocs              7233230
;  :num-checks              389
;  :propagations            665660
;  :quant-instantiations    872043
;  :restarts                4
;  :rlimit-count            18719411
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@306@07 Int) (j1@307@07 Int)) (!
  (implies
    (and
      (and (and (< j1@307@07 V@39@07) (<= 0 j1@307@07)) (< i1@306@07 V@39@07))
      (<= 0 i1@306@07))
    (and
      (=
        (inv@308@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))) j1@307@07))
        i1@306@07)
      (=
        (inv@309@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))) j1@307@07))
        j1@307@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@306@07))) j1@307@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@309@07 r) V@39@07) (<= 0 (inv@309@07 r)))
        (< (inv@308@07 r) V@39@07))
      (<= 0 (inv@308@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@308@07 r)))) (inv@309@07 r))
      r))
  :pattern ((inv@308@07 r))
  :pattern ((inv@309@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@309@07 r) V@39@07) (<= 0 (inv@309@07 r)))
        (< (inv@308@07 r) V@39@07))
      (<= 0 (inv@308@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@310@07  $FVF<Int>) r) r))
  :pattern ((inv@308@07 r) (inv@309@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@311@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@309@07 r) V@39@07) (<= 0 (inv@309@07 r)))
        (< (inv@308@07 r) V@39@07))
      (<= 0 (inv@308@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@312@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@309@07 r) V@39@07) (<= 0 (inv@309@07 r)))
        (< (inv@308@07 r) V@39@07))
      (<= 0 (inv@308@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@311@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@311@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1188703
;  :arith-add-rows          212545
;  :arith-assert-diseq      43799
;  :arith-assert-lower      336250
;  :arith-assert-upper      282257
;  :arith-bound-prop        18671
;  :arith-conflicts         898
;  :arith-eq-adapter        187275
;  :arith-fixed-eqs         206726
;  :arith-offset-eqs        56273
;  :arith-pivots            46435
;  :conflicts               2266
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1746
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124612
;  :del-clause              1876756
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.40
;  :minimized-lits          236
;  :mk-bool-var             2155483
;  :mk-clause               1877947
;  :num-allocs              7248322
;  :num-checks              391
;  :propagations            666930
;  :quant-instantiations    873406
;  :restarts                4
;  :rlimit-count            18778486
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@309@07 r) V@39@07) (<= 0 (inv@309@07 r)))
        (< (inv@308@07 r) V@39@07))
      (<= 0 (inv@308@07 r)))
    (= (- $Perm.Write (pTaken@311@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1189558
;  :arith-add-rows          212627
;  :arith-assert-diseq      43816
;  :arith-assert-lower      336421
;  :arith-assert-upper      282357
;  :arith-bound-prop        18692
;  :arith-conflicts         900
;  :arith-eq-adapter        187382
;  :arith-fixed-eqs         206842
;  :arith-offset-eqs        56349
;  :arith-pivots            46471
;  :conflicts               2284
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1750
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124645
;  :del-clause              1877908
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.40
;  :minimized-lits          236
;  :mk-bool-var             2156780
;  :mk-clause               1879099
;  :num-allocs              7253126
;  :num-checks              392
;  :propagations            667362
;  :quant-instantiations    873951
;  :restarts                4
;  :rlimit-count            18801878
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@313@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 192 | 0 <= i1@313@07 | live]
; [else-branch: 192 | !(0 <= i1@313@07) | live]
(push) ; 16
; [then-branch: 192 | 0 <= i1@313@07]
(assert (<= 0 i1@313@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 192 | !(0 <= i1@313@07)]
(assert (not (<= 0 i1@313@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@313@07 V@39@07) (<= 0 i1@313@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@313@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1189558
;  :arith-add-rows          212627
;  :arith-assert-diseq      43816
;  :arith-assert-lower      336423
;  :arith-assert-upper      282357
;  :arith-bound-prop        18692
;  :arith-conflicts         900
;  :arith-eq-adapter        187382
;  :arith-fixed-eqs         206842
;  :arith-offset-eqs        56349
;  :arith-pivots            46471
;  :conflicts               2284
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1750
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124645
;  :del-clause              1877908
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.40
;  :minimized-lits          236
;  :mk-bool-var             2156782
;  :mk-clause               1879099
;  :num-allocs              7253236
;  :num-checks              393
;  :propagations            667362
;  :quant-instantiations    873951
;  :restarts                4
;  :rlimit-count            18802058)
(assert (< i1@313@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@313@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 14
(declare-fun inv@314@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@313@07 Int)) (!
  (< i1@313@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@313@07))
  :qid |int-aux|)))
(declare-const sm@315@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@315@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@315@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@315@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef135|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@313@07 Int) (i12@313@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@313@07 V@39@07) (<= 0 i11@313@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@315@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@313@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@313@07)))
      (and
        (and (< i12@313@07 V@39@07) (<= 0 i12@313@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@315@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@313@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@313@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@313@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@313@07)))
    (= i11@313@07 i12@313@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1189596
;  :arith-add-rows          212629
;  :arith-assert-diseq      43817
;  :arith-assert-lower      336427
;  :arith-assert-upper      282357
;  :arith-bound-prop        18692
;  :arith-conflicts         900
;  :arith-eq-adapter        187383
;  :arith-fixed-eqs         206842
;  :arith-offset-eqs        56349
;  :arith-pivots            46471
;  :conflicts               2285
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1750
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124645
;  :del-clause              1877915
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.40
;  :minimized-lits          236
;  :mk-bool-var             2156837
;  :mk-clause               1879106
;  :num-allocs              7254250
;  :num-checks              394
;  :propagations            667362
;  :quant-instantiations    874010
;  :restarts                4
;  :rlimit-count            18804885)
; Definitional axioms for inverse functions
(assert (forall ((i1@313@07 Int)) (!
  (implies
    (and (< i1@313@07 V@39@07) (<= 0 i1@313@07))
    (=
      (inv@314@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@313@07))
      i1@313@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@313@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@314@07 r) V@39@07) (<= 0 (inv@314@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@314@07 r))
      r))
  :pattern ((inv@314@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@314@07 r) V@39@07) (<= 0 (inv@314@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@315@07  $FVF<Int>) r) r))
  :pattern ((inv@314@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@316@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@314@07 r) V@39@07) (<= 0 (inv@314@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@316@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1191602
;  :arith-add-rows          213044
;  :arith-assert-diseq      43863
;  :arith-assert-lower      336837
;  :arith-assert-upper      282597
;  :arith-bound-prop        18735
;  :arith-conflicts         904
;  :arith-eq-adapter        187652
;  :arith-fixed-eqs         207108
;  :arith-offset-eqs        56542
;  :arith-pivots            46563
;  :conflicts               2308
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1758
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124782
;  :del-clause              1881210
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.53
;  :minimized-lits          236
;  :mk-bool-var             2160561
;  :mk-clause               1882436
;  :num-allocs              7267119
;  :num-checks              396
;  :propagations            668592
;  :quant-instantiations    875291
;  :restarts                4
;  :rlimit-count            18862526
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@314@07 r) V@39@07) (<= 0 (inv@314@07 r)))
    (= (- $Perm.Write (pTaken@316@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1191655
;  :arith-add-rows          213060
;  :arith-assert-diseq      43865
;  :arith-assert-lower      336850
;  :arith-assert-upper      282611
;  :arith-bound-prop        18736
;  :arith-conflicts         905
;  :arith-eq-adapter        187664
;  :arith-fixed-eqs         207118
;  :arith-offset-eqs        56542
;  :arith-pivots            46567
;  :conflicts               2309
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1758
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124782
;  :del-clause              1881374
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.61
;  :minimized-lits          236
;  :mk-bool-var             2160770
;  :mk-clause               1882600
;  :num-allocs              7268088
;  :num-checks              397
;  :propagations            668597
;  :quant-instantiations    875368
;  :restarts                4
;  :rlimit-count            18865917
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 14
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(declare-const i1@317@07 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 193 | 0 <= i1@317@07 | live]
; [else-branch: 193 | !(0 <= i1@317@07) | live]
(push) ; 17
; [then-branch: 193 | 0 <= i1@317@07]
(assert (<= 0 i1@317@07))
; [eval] i1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 193 | !(0 <= i1@317@07)]
(assert (not (<= 0 i1@317@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (and (< i1@317@07 V@39@07) (<= 0 i1@317@07)))
(declare-const $k@318@07 $Perm)
(assert ($Perm.isReadVar $k@318@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@317@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1191655
;  :arith-add-rows          213060
;  :arith-assert-diseq      43866
;  :arith-assert-lower      336854
;  :arith-assert-upper      282612
;  :arith-bound-prop        18736
;  :arith-conflicts         905
;  :arith-eq-adapter        187665
;  :arith-fixed-eqs         207118
;  :arith-offset-eqs        56542
;  :arith-pivots            46567
;  :conflicts               2309
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1758
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124782
;  :del-clause              1881374
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.61
;  :minimized-lits          236
;  :mk-bool-var             2160776
;  :mk-clause               1882602
;  :num-allocs              7268265
;  :num-checks              398
;  :propagations            668598
;  :quant-instantiations    875368
;  :restarts                4
;  :rlimit-count            18866249)
(assert (< i1@317@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 16
; Joined path conditions
(assert (< i1@317@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 15
(declare-fun inv@319@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@318@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@317@07 Int)) (!
  (< i1@317@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@317@07))
  :qid |int-aux|)))
(push) ; 15
(assert (not (forall ((i1@317@07 Int)) (!
  (implies
    (and (< i1@317@07 V@39@07) (<= 0 i1@317@07))
    (or (= $k@318@07 $Perm.No) (< $Perm.No $k@318@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1191655
;  :arith-add-rows          213060
;  :arith-assert-diseq      43867
;  :arith-assert-lower      336856
;  :arith-assert-upper      282613
;  :arith-bound-prop        18736
;  :arith-conflicts         905
;  :arith-eq-adapter        187666
;  :arith-fixed-eqs         207118
;  :arith-offset-eqs        56542
;  :arith-pivots            46567
;  :conflicts               2310
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1758
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124782
;  :del-clause              1881376
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.61
;  :minimized-lits          236
;  :mk-bool-var             2160783
;  :mk-clause               1882604
;  :num-allocs              7268696
;  :num-checks              399
;  :propagations            668599
;  :quant-instantiations    875368
;  :restarts                4
;  :rlimit-count            18866795)
(declare-const sm@320@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@320@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@320@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@320@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@320@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@320@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef138|)))
; Check receiver injectivity
(push) ; 15
(assert (not (forall ((i11@317@07 Int) (i12@317@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@317@07 V@39@07) (<= 0 i11@317@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@320@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@317@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@317@07)))
        (< $Perm.No $k@318@07))
      (and
        (and
          (and (< i12@317@07 V@39@07) (<= 0 i12@317@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@320@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@317@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@317@07)))
        (< $Perm.No $k@318@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@317@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@317@07)))
    (= i11@317@07 i12@317@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1191695
;  :arith-add-rows          213062
;  :arith-assert-diseq      43868
;  :arith-assert-lower      336860
;  :arith-assert-upper      282613
;  :arith-bound-prop        18736
;  :arith-conflicts         905
;  :arith-eq-adapter        187667
;  :arith-fixed-eqs         207118
;  :arith-offset-eqs        56542
;  :arith-pivots            46567
;  :conflicts               2311
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1758
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124782
;  :del-clause              1881387
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.60
;  :minimized-lits          236
;  :mk-bool-var             2160847
;  :mk-clause               1882615
;  :num-allocs              7269831
;  :num-checks              400
;  :propagations            668601
;  :quant-instantiations    875432
;  :restarts                4
;  :rlimit-count            18870397)
; Definitional axioms for inverse functions
(assert (forall ((i1@317@07 Int)) (!
  (implies
    (and (and (< i1@317@07 V@39@07) (<= 0 i1@317@07)) (< $Perm.No $k@318@07))
    (=
      (inv@319@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@317@07))
      i1@317@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@317@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
      (< $Perm.No $k@318@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@319@07 r))
      r))
  :pattern ((inv@319@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@320@07  $FVF<Int>) r) r))
  :pattern ((inv@319@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@321@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      $k@318@07)
    $Perm.No))
(define-fun pTaken@322@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@318@07 (pTaken@321@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@318@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
      (<
        (ite
          (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
          $k@318@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
          $k@318@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@210@07 r))
  :pattern ((inv@319@07 r))
  :qid |qp.srp139|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 15
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
    (= (- $k@318@07 (pTaken@321@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1193893
;  :arith-add-rows          213293
;  :arith-assert-diseq      43916
;  :arith-assert-lower      337315
;  :arith-assert-upper      282871
;  :arith-bound-prop        18769
;  :arith-conflicts         908
;  :arith-eq-adapter        187951
;  :arith-fixed-eqs         207390
;  :arith-offset-eqs        56772
;  :arith-pivots            46643
;  :conflicts               2333
;  :datatype-accessor-ax    629
;  :datatype-constructor-ax 1766
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               124981
;  :del-clause              1885396
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.62
;  :minimized-lits          236
;  :mk-bool-var             2164568
;  :mk-clause               1886648
;  :num-allocs              7282298
;  :num-checks              402
;  :propagations            670111
;  :quant-instantiations    876777
;  :restarts                4
;  :rlimit-count            18932443
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@323@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@323@07  $FVF<Int>)))
    (and
      (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
      (< $Perm.No $k@318@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@323@07  $FVF<Int>))))
  :qid |qp.fvfDomDef143|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
        (< $Perm.No $k@318@07))
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r))))
    (=
      ($FVF.lookup_int (as sm@323@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@323@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
        (< $Perm.No $k@318@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@323@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@323@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@323@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef142|)))
(pop) ; 14
; Joined path conditions
(assert ($Perm.isReadVar $k@318@07 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@320@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@320@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@320@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@320@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@320@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef138|)))
(assert (forall ((i1@317@07 Int)) (!
  (implies
    (and (and (< i1@317@07 V@39@07) (<= 0 i1@317@07)) (< $Perm.No $k@318@07))
    (=
      (inv@319@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@317@07))
      i1@317@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@317@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
      (< $Perm.No $k@318@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@319@07 r))
      r))
  :pattern ((inv@319@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@323@07  $FVF<Int>)))
    (and
      (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
      (< $Perm.No $k@318@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@323@07  $FVF<Int>))))
  :qid |qp.fvfDomDef143|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
        (< $Perm.No $k@318@07))
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r))))
    (=
      ($FVF.lookup_int (as sm@323@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@323@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef140|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
        (< $Perm.No $k@318@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@323@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@323@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef141|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@323@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef142|)))
(assert (and
  (forall ((i1@317@07 Int)) (!
    (< i1@317@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@317@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@320@07  $FVF<Int>) r) r))
    :pattern ((inv@319@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        (<
          (ite
            (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
            $k@318@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@319@07 r) V@39@07) (<= 0 (inv@319@07 r)))
            $k@318@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@210@07 r))
    :pattern ((inv@319@07 r))
    :qid |qp.srp139|))))
(set-option :timeout 0)
(push) ; 14
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@323@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 14
; 0.40s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1225699
;  :arith-add-rows          219864
;  :arith-assert-diseq      44823
;  :arith-assert-lower      345803
;  :arith-assert-upper      289521
;  :arith-bound-prop        19525
;  :arith-conflicts         934
;  :arith-eq-adapter        192754
;  :arith-fixed-eqs         212628
;  :arith-offset-eqs        59364
;  :arith-pivots            48743
;  :conflicts               2401
;  :datatype-accessor-ax    632
;  :datatype-constructor-ax 1770
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129122
;  :del-clause              1965069
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.12
;  :minimized-lits          245
;  :mk-bool-var             2246756
;  :mk-clause               1966297
;  :num-allocs              7507542
;  :num-checks              403
;  :propagations            690275
;  :quant-instantiations    900448
;  :restarts                4
;  :rlimit-count            19459673
;  :time                    0.40)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@323@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
; [eval] 0 <= u
; [eval] u < V
; [eval] 0 <= v
(push) ; 14
(assert (not (<= 0 v@297@07)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1225712
;  :arith-add-rows          219884
;  :arith-assert-diseq      44823
;  :arith-assert-lower      345803
;  :arith-assert-upper      289522
;  :arith-bound-prop        19525
;  :arith-conflicts         935
;  :arith-eq-adapter        192754
;  :arith-fixed-eqs         212628
;  :arith-offset-eqs        59364
;  :arith-pivots            48744
;  :conflicts               2402
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1770
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129122
;  :del-clause              1965069
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.12
;  :minimized-lits          245
;  :mk-bool-var             2246831
;  :mk-clause               1966362
;  :num-allocs              7507964
;  :num-checks              404
;  :propagations            690286
;  :quant-instantiations    900461
;  :restarts                4
;  :rlimit-count            19460748
;  :time                    0.00)
(assert (<= 0 v@297@07))
; [eval] v <= V
(push) ; 14
(assert (not (<= v@297@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1225712
;  :arith-add-rows          219922
;  :arith-assert-diseq      44823
;  :arith-assert-lower      345804
;  :arith-assert-upper      289523
;  :arith-bound-prop        19525
;  :arith-conflicts         936
;  :arith-eq-adapter        192754
;  :arith-fixed-eqs         212628
;  :arith-offset-eqs        59364
;  :arith-pivots            48746
;  :conflicts               2403
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1770
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129122
;  :del-clause              1965069
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.12
;  :minimized-lits          245
;  :mk-bool-var             2246833
;  :mk-clause               1966362
;  :num-allocs              7508121
;  :num-checks              405
;  :propagations            690286
;  :quant-instantiations    900461
;  :restarts                4
;  :rlimit-count            19461465)
(assert (<= v@297@07 V@39@07))
; [eval] 0 <= k
; [eval] k < V
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 14
; [eval] this != null
(pop) ; 14
; Joined path conditions
(declare-const i1@324@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 194 | 0 <= i1@324@07 | live]
; [else-branch: 194 | !(0 <= i1@324@07) | live]
(push) ; 16
; [then-branch: 194 | 0 <= i1@324@07]
(assert (<= 0 i1@324@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 194 | !(0 <= i1@324@07)]
(assert (not (<= 0 i1@324@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@324@07 V@39@07) (<= 0 i1@324@07)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i1@324@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1225712
;  :arith-add-rows          219922
;  :arith-assert-diseq      44823
;  :arith-assert-lower      345807
;  :arith-assert-upper      289523
;  :arith-bound-prop        19525
;  :arith-conflicts         936
;  :arith-eq-adapter        192754
;  :arith-fixed-eqs         212628
;  :arith-offset-eqs        59364
;  :arith-pivots            48746
;  :conflicts               2403
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1770
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129122
;  :del-clause              1965069
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.12
;  :minimized-lits          245
;  :mk-bool-var             2246836
;  :mk-clause               1966362
;  :num-allocs              7508302
;  :num-checks              406
;  :propagations            690286
;  :quant-instantiations    900461
;  :restarts                4
;  :rlimit-count            19461711)
(assert (< i1@324@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@324@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 14
(declare-fun inv@325@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@324@07 Int)) (!
  (< i1@324@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@324@07))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@324@07 Int) (i12@324@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@324@07 V@39@07) (<= 0 i11@324@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@324@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@324@07)))
      (and
        (and (< i12@324@07 V@39@07) (<= 0 i12@324@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@324@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@324@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@324@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@324@07)))
    (= i11@324@07 i12@324@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1225731
;  :arith-add-rows          219924
;  :arith-assert-diseq      44824
;  :arith-assert-lower      345811
;  :arith-assert-upper      289523
;  :arith-bound-prop        19525
;  :arith-conflicts         936
;  :arith-eq-adapter        192755
;  :arith-fixed-eqs         212628
;  :arith-offset-eqs        59364
;  :arith-pivots            48746
;  :conflicts               2404
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1770
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129122
;  :del-clause              1965080
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.34
;  :minimized-lits          245
;  :mk-bool-var             2246873
;  :mk-clause               1966373
;  :num-allocs              7508926
;  :num-checks              407
;  :propagations            690286
;  :quant-instantiations    900496
;  :restarts                4
;  :rlimit-count            19463124
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@324@07 Int)) (!
  (implies
    (and (< i1@324@07 V@39@07) (<= 0 i1@324@07))
    (=
      (inv@325@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@324@07))
      i1@324@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@324@07))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@325@07 r) V@39@07) (<= 0 (inv@325@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@325@07 r))
      r))
  :pattern ((inv@325@07 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@325@07 r) V@39@07) (<= 0 (inv@325@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r) r))
  :pattern ((inv@325@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@326@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@325@07 r) V@39@07) (<= 0 (inv@325@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@326@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1227865
;  :arith-add-rows          220199
;  :arith-assert-diseq      44866
;  :arith-assert-lower      346210
;  :arith-assert-upper      289758
;  :arith-bound-prop        19547
;  :arith-conflicts         938
;  :arith-eq-adapter        193022
;  :arith-fixed-eqs         212896
;  :arith-offset-eqs        59637
;  :arith-pivots            48829
;  :conflicts               2426
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1778
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129243
;  :del-clause              1968403
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.24
;  :minimized-lits          245
;  :mk-bool-var             2250310
;  :mk-clause               1969704
;  :num-allocs              7520333
;  :num-checks              409
;  :propagations            691518
;  :quant-instantiations    901777
;  :restarts                4
;  :rlimit-count            19517423
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@325@07 r) V@39@07) (<= 0 (inv@325@07 r)))
    (= (- $Perm.Write (pTaken@326@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1227897
;  :arith-add-rows          220212
;  :arith-assert-diseq      44868
;  :arith-assert-lower      346219
;  :arith-assert-upper      289768
;  :arith-bound-prop        19548
;  :arith-conflicts         939
;  :arith-eq-adapter        193031
;  :arith-fixed-eqs         212902
;  :arith-offset-eqs        59637
;  :arith-pivots            48833
;  :conflicts               2427
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1778
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129243
;  :del-clause              1968442
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.24
;  :minimized-lits          245
;  :mk-bool-var             2250388
;  :mk-clause               1969743
;  :num-allocs              7520879
;  :num-checks              410
;  :propagations            691523
;  :quant-instantiations    901806
;  :restarts                4
;  :rlimit-count            19518985
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(pop) ; 13
(push) ; 13
; [else-branch: 178 | 0 < Lookup(int,sm@295@07,aloc((_, _), opt_get1(_, Lookup(option$array$,sm@199@07,aloc((_, _), opt_get1(_, Gf@38@07), u@188@07))), v@193@07)) && !(Lookup(bool,sm@220@07,aloc((_, _), opt_get1(_, res@106@07), v@193@07)))]
(assert (and
  (<
    0
    ($FVF.lookup_int (as sm@295@07  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@199@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) u@188@07))) v@193@07)))
  (not
    ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@106@07) v@193@07)))))
(pop) ; 13
(pop) ; 12
(push) ; 12
; [else-branch: 158 | !(v@193@07 < V@39@07)]
(assert (not (< v@193@07 V@39@07)))
(pop) ; 12
; [eval] !(v < V)
; [eval] v < V
(set-option :timeout 10)
(push) ; 12
(assert (not (< v@193@07 V@39@07)))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1228998
;  :arith-add-rows          220674
;  :arith-assert-diseq      44883
;  :arith-assert-lower      346463
;  :arith-assert-upper      289925
;  :arith-bound-prop        19625
;  :arith-conflicts         940
;  :arith-eq-adapter        193210
;  :arith-fixed-eqs         213072
;  :arith-offset-eqs        59717
;  :arith-pivots            49011
;  :conflicts               2429
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1782
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129274
;  :del-clause              1970449
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          245
;  :mk-bool-var             2252471
;  :mk-clause               1971445
;  :num-allocs              7528745
;  :num-checks              411
;  :propagations            692015
;  :quant-instantiations    902643
;  :restarts                4
;  :rlimit-count            19556350
;  :time                    0.01)
(push) ; 12
(assert (not (not (< v@193@07 V@39@07))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1230071
;  :arith-add-rows          220891
;  :arith-assert-diseq      44898
;  :arith-assert-lower      346696
;  :arith-assert-upper      290069
;  :arith-bound-prop        19697
;  :arith-conflicts         941
;  :arith-eq-adapter        193386
;  :arith-fixed-eqs         213227
;  :arith-offset-eqs        59786
;  :arith-pivots            49111
;  :conflicts               2431
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1786
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129305
;  :del-clause              1972102
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          245
;  :mk-bool-var             2254487
;  :mk-clause               1973098
;  :num-allocs              7535932
;  :num-checks              412
;  :propagations            692440
;  :quant-instantiations    903442
;  :restarts                4
;  :rlimit-count            19585822
;  :time                    0.01)
; [then-branch: 195 | !(v@193@07 < V@39@07) | live]
; [else-branch: 195 | v@193@07 < V@39@07 | live]
(push) ; 12
; [then-branch: 195 | !(v@193@07 < V@39@07)]
(assert (not (< v@193@07 V@39@07)))
; Loop head block: Re-establish invariant
; [eval] exc == excBeforeLoop
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(declare-const i1@327@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 196 | 0 <= i1@327@07 | live]
; [else-branch: 196 | !(0 <= i1@327@07) | live]
(push) ; 15
; [then-branch: 196 | 0 <= i1@327@07]
(assert (<= 0 i1@327@07))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 196 | !(0 <= i1@327@07)]
(assert (not (<= 0 i1@327@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@327@07 V@39@07) (<= 0 i1@327@07)))
(declare-const $k@328@07 $Perm)
(assert ($Perm.isReadVar $k@328@07 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@327@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1230074
;  :arith-add-rows          220891
;  :arith-assert-diseq      44899
;  :arith-assert-lower      346700
;  :arith-assert-upper      290071
;  :arith-bound-prop        19697
;  :arith-conflicts         941
;  :arith-eq-adapter        193387
;  :arith-fixed-eqs         213228
;  :arith-offset-eqs        59788
;  :arith-pivots            49111
;  :conflicts               2431
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1786
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129305
;  :del-clause              1972102
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          245
;  :mk-bool-var             2254494
;  :mk-clause               1973100
;  :num-allocs              7536177
;  :num-checks              413
;  :propagations            692441
;  :quant-instantiations    903442
;  :restarts                4
;  :rlimit-count            19586219)
(assert (< i1@327@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@327@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 13
(declare-fun inv@329@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@328@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@327@07 Int)) (!
  (< i1@327@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@327@07))
  :qid |option$array$-aux|)))
(push) ; 13
(assert (not (forall ((i1@327@07 Int)) (!
  (implies
    (and (< i1@327@07 V@39@07) (<= 0 i1@327@07))
    (or (= $k@328@07 $Perm.No) (< $Perm.No $k@328@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1230074
;  :arith-add-rows          220891
;  :arith-assert-diseq      44900
;  :arith-assert-lower      346702
;  :arith-assert-upper      290072
;  :arith-bound-prop        19697
;  :arith-conflicts         941
;  :arith-eq-adapter        193388
;  :arith-fixed-eqs         213228
;  :arith-offset-eqs        59788
;  :arith-pivots            49111
;  :conflicts               2432
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1786
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129305
;  :del-clause              1972104
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          245
;  :mk-bool-var             2254501
;  :mk-clause               1973102
;  :num-allocs              7536610
;  :num-checks              414
;  :propagations            692442
;  :quant-instantiations    903442
;  :restarts                4
;  :rlimit-count            19586765)
(declare-const sm@330@07 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
          $k@134@07
          $Perm.No)
        (pTaken@224@07 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r))
  :qid |qp.fvfValDef144|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
      (< $Perm.No $k@197@07)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r))
  :qid |qp.fvfValDef145|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@195@07))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef146|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@327@07 Int) (i12@327@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@327@07 V@39@07) (<= 0 i11@327@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@327@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@327@07)))
        (< $Perm.No $k@328@07))
      (and
        (and
          (and (< i12@327@07 V@39@07) (<= 0 i12@327@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@327@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@327@07)))
        (< $Perm.No $k@328@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@327@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@327@07)))
    (= i11@327@07 i12@327@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1230091
;  :arith-add-rows          220893
;  :arith-assert-diseq      44901
;  :arith-assert-lower      346706
;  :arith-assert-upper      290072
;  :arith-bound-prop        19697
;  :arith-conflicts         941
;  :arith-eq-adapter        193389
;  :arith-fixed-eqs         213228
;  :arith-offset-eqs        59788
;  :arith-pivots            49111
;  :conflicts               2433
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1786
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129305
;  :del-clause              1972127
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          245
;  :mk-bool-var             2254552
;  :mk-clause               1973125
;  :num-allocs              7537663
;  :num-checks              415
;  :propagations            692444
;  :quant-instantiations    903472
;  :restarts                4
;  :rlimit-count            19589449)
; Definitional axioms for inverse functions
(assert (forall ((i1@327@07 Int)) (!
  (implies
    (and (and (< i1@327@07 V@39@07) (<= 0 i1@327@07)) (< $Perm.No $k@328@07))
    (=
      (inv@329@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@327@07))
      i1@327@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@327@07))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@329@07 r) V@39@07) (<= 0 (inv@329@07 r)))
      (< $Perm.No $k@328@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@329@07 r))
      r))
  :pattern ((inv@329@07 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@329@07 r) V@39@07) (<= 0 (inv@329@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) r) r))
  :pattern ((inv@329@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@331@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@329@07 r) V@39@07) (<= 0 (inv@329@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
          $k@134@07
          $Perm.No)
        (pTaken@224@07 r))
      $k@328@07)
    $Perm.No))
(define-fun pTaken@332@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@329@07 r) V@39@07) (<= 0 (inv@329@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@198@07 r) V@39@07) (<= 0 (inv@198@07 r)))
        $k@197@07
        $Perm.No)
      (- $k@328@07 (pTaken@331@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@328@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
            $k@134@07
            $Perm.No)
          (pTaken@224@07 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@329@07 r) V@39@07) (<= 0 (inv@329@07 r)))
        $k@328@07
        $Perm.No)
      (-
        (ite
          (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
          $k@134@07
          $Perm.No)
        (pTaken@224@07 r))))
  :pattern ((inv@135@07 r))
  :pattern ((inv@329@07 r))
  :qid |qp.srp147|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@329@07 r) V@39@07) (<= 0 (inv@329@07 r)))
    (= (- $k@328@07 (pTaken@331@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1232034
;  :arith-add-rows          221377
;  :arith-assert-diseq      44947
;  :arith-assert-lower      347139
;  :arith-assert-upper      290333
;  :arith-bound-prop        19822
;  :arith-conflicts         945
;  :arith-eq-adapter        193712
;  :arith-fixed-eqs         213512
;  :arith-offset-eqs        59982
;  :arith-pivots            49289
;  :conflicts               2457
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1794
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129369
;  :del-clause              1974979
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.19
;  :minimized-lits          246
;  :mk-bool-var             2258080
;  :mk-clause               1976059
;  :num-allocs              7551519
;  :num-checks              417
;  :propagations            693388
;  :quant-instantiations    904764
;  :restarts                4
;  :rlimit-count            19643898
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@333@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 197 | 0 <= i1@333@07 | live]
; [else-branch: 197 | !(0 <= i1@333@07) | live]
(push) ; 15
; [then-branch: 197 | 0 <= i1@333@07]
(assert (<= 0 i1@333@07))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 197 | !(0 <= i1@333@07)]
(assert (not (<= 0 i1@333@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 198 | i1@333@07 < V@39@07 && 0 <= i1@333@07 | live]
; [else-branch: 198 | !(i1@333@07 < V@39@07 && 0 <= i1@333@07) | live]
(push) ; 15
; [then-branch: 198 | i1@333@07 < V@39@07 && 0 <= i1@333@07]
(assert (and (< i1@333@07 V@39@07) (<= 0 i1@333@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@333@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1232034
;  :arith-add-rows          221377
;  :arith-assert-diseq      44947
;  :arith-assert-lower      347141
;  :arith-assert-upper      290333
;  :arith-bound-prop        19822
;  :arith-conflicts         945
;  :arith-eq-adapter        193712
;  :arith-fixed-eqs         213512
;  :arith-offset-eqs        59982
;  :arith-pivots            49289
;  :conflicts               2457
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1794
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129369
;  :del-clause              1974979
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.19
;  :minimized-lits          246
;  :mk-bool-var             2258082
;  :mk-clause               1976059
;  :num-allocs              7551630
;  :num-checks              418
;  :propagations            693388
;  :quant-instantiations    904764
;  :restarts                4
;  :rlimit-count            19644086)
(assert (< i1@333@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 16
; Joined path conditions
(assert (< i1@333@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))
            V@39@07)
          (<=
            0
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))))
        $k@134@07
        $Perm.No)
      (pTaken@224@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07)))
    (ite
      (and
        (<
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))
          V@39@07)
        (<=
          0
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))))
      $k@197@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1232873
;  :arith-add-rows          221598
;  :arith-assert-diseq      44975
;  :arith-assert-lower      347333
;  :arith-assert-upper      290438
;  :arith-bound-prop        19870
;  :arith-conflicts         949
;  :arith-eq-adapter        193852
;  :arith-fixed-eqs         213631
;  :arith-offset-eqs        60083
;  :arith-pivots            49345
;  :conflicts               2478
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1798
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129405
;  :del-clause              1976158
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.21
;  :minimized-lits          246
;  :mk-bool-var             2259612
;  :mk-clause               1977351
;  :num-allocs              7557037
;  :num-checks              419
;  :propagations            693828
;  :quant-instantiations    905248
;  :restarts                4
;  :rlimit-count            19666266
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 198 | !(i1@333@07 < V@39@07 && 0 <= i1@333@07)]
(assert (not (and (< i1@333@07 V@39@07) (<= 0 i1@333@07))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@333@07 V@39@07) (<= 0 i1@333@07))
  (and
    (< i1@333@07 V@39@07)
    (<= 0 i1@333@07)
    (< i1@333@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@333@07 Int)) (!
  (implies
    (and (< i1@333@07 V@39@07) (<= 0 i1@333@07))
    (and
      (< i1@333@07 V@39@07)
      (<= 0 i1@333@07)
      (< i1@333@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@333@07 Int)) (!
  (implies
    (and (< i1@333@07 V@39@07) (<= 0 i1@333@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1233624
;  :arith-add-rows          221749
;  :arith-assert-diseq      44990
;  :arith-assert-lower      347482
;  :arith-assert-upper      290527
;  :arith-bound-prop        19908
;  :arith-conflicts         950
;  :arith-eq-adapter        193954
;  :arith-fixed-eqs         213740
;  :arith-offset-eqs        60178
;  :arith-pivots            49409
;  :conflicts               2496
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1802
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129432
;  :del-clause              1977393
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          246
;  :mk-bool-var             2260875
;  :mk-clause               1978473
;  :num-allocs              7561824
;  :num-checks              420
;  :propagations            694227
;  :quant-instantiations    905733
;  :restarts                4
;  :rlimit-count            19688055
;  :time                    0.01)
(assert (forall ((i1@333@07 Int)) (!
  (implies
    (and (< i1@333@07 V@39@07) (<= 0 i1@333@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@333@07))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@334@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 199 | 0 <= i1@334@07 | live]
; [else-branch: 199 | !(0 <= i1@334@07) | live]
(push) ; 15
; [then-branch: 199 | 0 <= i1@334@07]
(assert (<= 0 i1@334@07))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 199 | !(0 <= i1@334@07)]
(assert (not (<= 0 i1@334@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 200 | i1@334@07 < V@39@07 && 0 <= i1@334@07 | live]
; [else-branch: 200 | !(i1@334@07 < V@39@07 && 0 <= i1@334@07) | live]
(push) ; 15
; [then-branch: 200 | i1@334@07 < V@39@07 && 0 <= i1@334@07]
(assert (and (< i1@334@07 V@39@07) (<= 0 i1@334@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@334@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1233624
;  :arith-add-rows          221749
;  :arith-assert-diseq      44990
;  :arith-assert-lower      347484
;  :arith-assert-upper      290527
;  :arith-bound-prop        19908
;  :arith-conflicts         950
;  :arith-eq-adapter        193954
;  :arith-fixed-eqs         213740
;  :arith-offset-eqs        60178
;  :arith-pivots            49409
;  :conflicts               2496
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1802
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129432
;  :del-clause              1977393
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          246
;  :mk-bool-var             2260878
;  :mk-clause               1978473
;  :num-allocs              7562129
;  :num-checks              421
;  :propagations            694227
;  :quant-instantiations    905733
;  :restarts                4
;  :rlimit-count            19688554)
(assert (< i1@334@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 16
; Joined path conditions
(assert (< i1@334@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
            V@39@07)
          (<=
            0
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))))
        $k@134@07
        $Perm.No)
      (pTaken@224@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07)))
    (ite
      (and
        (<
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
          V@39@07)
        (<=
          0
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))))
      $k@197@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1234563
;  :arith-add-rows          222072
;  :arith-assert-diseq      45019
;  :arith-assert-lower      347715
;  :arith-assert-upper      290638
;  :arith-bound-prop        19960
;  :arith-conflicts         955
;  :arith-eq-adapter        194111
;  :arith-fixed-eqs         213864
;  :arith-offset-eqs        60323
;  :arith-pivots            49476
;  :conflicts               2519
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1806
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129469
;  :del-clause              1978641
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.19
;  :minimized-lits          246
;  :mk-bool-var             2262504
;  :mk-clause               1979834
;  :num-allocs              7567875
;  :num-checks              422
;  :propagations            694761
;  :quant-instantiations    906219
;  :restarts                4
;  :rlimit-count            19712732
;  :time                    0.01)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1234563
;  :arith-add-rows          222072
;  :arith-assert-diseq      45019
;  :arith-assert-lower      347715
;  :arith-assert-upper      290638
;  :arith-bound-prop        19960
;  :arith-conflicts         955
;  :arith-eq-adapter        194111
;  :arith-fixed-eqs         213864
;  :arith-offset-eqs        60323
;  :arith-pivots            49476
;  :conflicts               2520
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1806
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129469
;  :del-clause              1978641
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.19
;  :minimized-lits          246
;  :mk-bool-var             2262504
;  :mk-clause               1979834
;  :num-allocs              7567968
;  :num-checks              423
;  :propagations            694761
;  :quant-instantiations    906219
;  :restarts                4
;  :rlimit-count            19712827)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 200 | !(i1@334@07 < V@39@07 && 0 <= i1@334@07)]
(assert (not (and (< i1@334@07 V@39@07) (<= 0 i1@334@07))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@334@07 V@39@07) (<= 0 i1@334@07))
  (and
    (< i1@334@07 V@39@07)
    (<= 0 i1@334@07)
    (< i1@334@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@334@07 Int)) (!
  (implies
    (and (< i1@334@07 V@39@07) (<= 0 i1@334@07))
    (and
      (< i1@334@07 V@39@07)
      (<= 0 i1@334@07)
      (< i1@334@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@334@07 Int)) (!
  (implies
    (and (< i1@334@07 V@39@07) (<= 0 i1@334@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1235365
;  :arith-add-rows          222205
;  :arith-assert-diseq      45036
;  :arith-assert-lower      347870
;  :arith-assert-upper      290727
;  :arith-bound-prop        19998
;  :arith-conflicts         956
;  :arith-eq-adapter        194214
;  :arith-fixed-eqs         213973
;  :arith-offset-eqs        60422
;  :arith-pivots            49538
;  :conflicts               2538
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1810
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129497
;  :del-clause              1979880
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          246
;  :mk-bool-var             2263770
;  :mk-clause               1980960
;  :num-allocs              7572802
;  :num-checks              424
;  :propagations            695191
;  :quant-instantiations    906717
;  :restarts                4
;  :rlimit-count            19734817
;  :time                    0.01)
(assert (forall ((i1@334@07 Int)) (!
  (implies
    (and (< i1@334@07 V@39@07) (<= 0 i1@334@07))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07))))
      V@39@07))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@334@07)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@335@07 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@336@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 201 | 0 <= i1@335@07 | live]
; [else-branch: 201 | !(0 <= i1@335@07) | live]
(push) ; 16
; [then-branch: 201 | 0 <= i1@335@07]
(assert (<= 0 i1@335@07))
; [eval] i1 < V
(push) ; 17
; [then-branch: 202 | i1@335@07 < V@39@07 | live]
; [else-branch: 202 | !(i1@335@07 < V@39@07) | live]
(push) ; 18
; [then-branch: 202 | i1@335@07 < V@39@07]
(assert (< i1@335@07 V@39@07))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 203 | 0 <= i2@336@07 | live]
; [else-branch: 203 | !(0 <= i2@336@07) | live]
(push) ; 20
; [then-branch: 203 | 0 <= i2@336@07]
(assert (<= 0 i2@336@07))
; [eval] i2 < V
(push) ; 21
; [then-branch: 204 | i2@336@07 < V@39@07 | live]
; [else-branch: 204 | !(i2@336@07 < V@39@07) | live]
(push) ; 22
; [then-branch: 204 | i2@336@07 < V@39@07]
(assert (< i2@336@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1235365
;  :arith-add-rows          222205
;  :arith-assert-diseq      45036
;  :arith-assert-lower      347874
;  :arith-assert-upper      290727
;  :arith-bound-prop        19998
;  :arith-conflicts         956
;  :arith-eq-adapter        194214
;  :arith-fixed-eqs         213973
;  :arith-offset-eqs        60422
;  :arith-pivots            49538
;  :conflicts               2538
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1810
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129497
;  :del-clause              1979880
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.17
;  :minimized-lits          246
;  :mk-bool-var             2263775
;  :mk-clause               1980960
;  :num-allocs              7573287
;  :num-checks              425
;  :propagations            695191
;  :quant-instantiations    906717
;  :restarts                4
;  :rlimit-count            19735459)
(assert (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 23
; Joined path conditions
(assert (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
            V@39@07)
          (<=
            0
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))))
        $k@134@07
        $Perm.No)
      (pTaken@224@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)))
    (ite
      (and
        (<
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
          V@39@07)
        (<=
          0
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))))
      $k@197@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1236156
;  :arith-add-rows          222330
;  :arith-assert-diseq      45055
;  :arith-assert-lower      348035
;  :arith-assert-upper      290822
;  :arith-bound-prop        20040
;  :arith-conflicts         959
;  :arith-eq-adapter        194324
;  :arith-fixed-eqs         214086
;  :arith-offset-eqs        60517
;  :arith-pivots            49584
;  :conflicts               2557
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1814
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129527
;  :del-clause              1980926
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.21
;  :minimized-lits          246
;  :mk-bool-var             2265135
;  :mk-clause               1982119
;  :num-allocs              7578236
;  :num-checks              426
;  :propagations            695586
;  :quant-instantiations    907203
;  :restarts                4
;  :rlimit-count            19756653
;  :time                    0.01)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1236156
;  :arith-add-rows          222330
;  :arith-assert-diseq      45055
;  :arith-assert-lower      348035
;  :arith-assert-upper      290822
;  :arith-bound-prop        20040
;  :arith-conflicts         959
;  :arith-eq-adapter        194324
;  :arith-fixed-eqs         214086
;  :arith-offset-eqs        60517
;  :arith-pivots            49584
;  :conflicts               2557
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1814
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129527
;  :del-clause              1980926
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.21
;  :minimized-lits          246
;  :mk-bool-var             2265135
;  :mk-clause               1982119
;  :num-allocs              7578263
;  :num-checks              427
;  :propagations            695586
;  :quant-instantiations    907203
;  :restarts                4
;  :rlimit-count            19756683)
(assert (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 23
; Joined path conditions
(assert (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))
            V@39@07)
          (<=
            0
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))))
        $k@134@07
        $Perm.No)
      (pTaken@224@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
    (ite
      (and
        (<
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))
          V@39@07)
        (<=
          0
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))))
      $k@197@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1237076
;  :arith-add-rows          222636
;  :arith-assert-diseq      45092
;  :arith-assert-lower      348274
;  :arith-assert-upper      290941
;  :arith-bound-prop        20099
;  :arith-conflicts         966
;  :arith-eq-adapter        194468
;  :arith-fixed-eqs         214214
;  :arith-offset-eqs        60637
;  :arith-pivots            49654
;  :conflicts               2582
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1818
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129572
;  :del-clause              1982149
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.38
;  :minimized-lits          246
;  :mk-bool-var             2266764
;  :mk-clause               1983487
;  :num-allocs              7584075
;  :num-checks              428
;  :propagations            696141
;  :quant-instantiations    907706
;  :restarts                4
;  :rlimit-count            19781978
;  :time                    0.01)
(pop) ; 22
(push) ; 22
; [else-branch: 204 | !(i2@336@07 < V@39@07)]
(assert (not (< i2@336@07 V@39@07)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@336@07 V@39@07)
  (and
    (< i2@336@07 V@39@07)
    (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
    (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 203 | !(0 <= i2@336@07)]
(assert (not (<= 0 i2@336@07)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@336@07)
  (and
    (<= 0 i2@336@07)
    (implies
      (< i2@336@07 V@39@07)
      (and
        (< i2@336@07 V@39@07)
        (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
        (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 202 | !(i1@335@07 < V@39@07)]
(assert (not (< i1@335@07 V@39@07)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@335@07 V@39@07)
  (and
    (< i1@335@07 V@39@07)
    (implies
      (<= 0 i2@336@07)
      (and
        (<= 0 i2@336@07)
        (implies
          (< i2@336@07 V@39@07)
          (and
            (< i2@336@07 V@39@07)
            (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
            (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 201 | !(0 <= i1@335@07)]
(assert (not (<= 0 i1@335@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@335@07)
  (and
    (<= 0 i1@335@07)
    (implies
      (< i1@335@07 V@39@07)
      (and
        (< i1@335@07 V@39@07)
        (implies
          (<= 0 i2@336@07)
          (and
            (<= 0 i2@336@07)
            (implies
              (< i2@336@07 V@39@07)
              (and
                (< i2@336@07 V@39@07)
                (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
                (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 205 | Lookup(option$array$,sm@330@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@335@07)) == Lookup(option$array$,sm@330@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@336@07)) && i2@336@07 < V@39@07 && 0 <= i2@336@07 && i1@335@07 < V@39@07 && 0 <= i1@335@07 | live]
; [else-branch: 205 | !(Lookup(option$array$,sm@330@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@335@07)) == Lookup(option$array$,sm@330@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@336@07)) && i2@336@07 < V@39@07 && 0 <= i2@336@07 && i1@335@07 < V@39@07 && 0 <= i1@335@07) | live]
(push) ; 16
; [then-branch: 205 | Lookup(option$array$,sm@330@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@335@07)) == Lookup(option$array$,sm@330@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@336@07)) && i2@336@07 < V@39@07 && 0 <= i2@336@07 && i1@335@07 < V@39@07 && 0 <= i1@335@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
          ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
        (< i2@336@07 V@39@07))
      (<= 0 i2@336@07))
    (< i1@335@07 V@39@07))
  (<= 0 i1@335@07)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 205 | !(Lookup(option$array$,sm@330@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@335@07)) == Lookup(option$array$,sm@330@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@336@07)) && i2@336@07 < V@39@07 && 0 <= i2@336@07 && i1@335@07 < V@39@07 && 0 <= i1@335@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
            ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
          (< i2@336@07 V@39@07))
        (<= 0 i2@336@07))
      (< i1@335@07 V@39@07))
    (<= 0 i1@335@07))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
            ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
          (< i2@336@07 V@39@07))
        (<= 0 i2@336@07))
      (< i1@335@07 V@39@07))
    (<= 0 i1@335@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
      ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
    (< i2@336@07 V@39@07)
    (<= 0 i2@336@07)
    (< i1@335@07 V@39@07)
    (<= 0 i1@335@07))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@336@07 Int)) (!
  (and
    (implies
      (<= 0 i1@335@07)
      (and
        (<= 0 i1@335@07)
        (implies
          (< i1@335@07 V@39@07)
          (and
            (< i1@335@07 V@39@07)
            (implies
              (<= 0 i2@336@07)
              (and
                (<= 0 i2@336@07)
                (implies
                  (< i2@336@07 V@39@07)
                  (and
                    (< i2@336@07 V@39@07)
                    (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
                    (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
                ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
              (< i2@336@07 V@39@07))
            (<= 0 i2@336@07))
          (< i1@335@07 V@39@07))
        (<= 0 i1@335@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
          ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
        (< i2@336@07 V@39@07)
        (<= 0 i2@336@07)
        (< i1@335@07 V@39@07)
        (<= 0 i1@335@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@335@07 Int)) (!
  (forall ((i2@336@07 Int)) (!
    (and
      (implies
        (<= 0 i1@335@07)
        (and
          (<= 0 i1@335@07)
          (implies
            (< i1@335@07 V@39@07)
            (and
              (< i1@335@07 V@39@07)
              (implies
                (<= 0 i2@336@07)
                (and
                  (<= 0 i2@336@07)
                  (implies
                    (< i2@336@07 V@39@07)
                    (and
                      (< i2@336@07 V@39@07)
                      (< i1@335@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
                      (< i2@336@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
                  ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
                (< i2@336@07 V@39@07))
              (<= 0 i2@336@07))
            (< i1@335@07 V@39@07))
          (<= 0 i1@335@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
            ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
          (< i2@336@07 V@39@07)
          (<= 0 i2@336@07)
          (< i1@335@07 V@39@07)
          (<= 0 i1@335@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 13
(assert (not (forall ((i1@335@07 Int)) (!
  (forall ((i2@336@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
                ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
              (< i2@336@07 V@39@07))
            (<= 0 i2@336@07))
          (< i1@335@07 V@39@07))
        (<= 0 i1@335@07))
      (= i1@335@07 i2@336@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1237918
;  :arith-add-rows          222910
;  :arith-assert-diseq      45108
;  :arith-assert-lower      348437
;  :arith-assert-upper      291041
;  :arith-bound-prop        20155
;  :arith-conflicts         968
;  :arith-eq-adapter        194581
;  :arith-fixed-eqs         214332
;  :arith-offset-eqs        60751
;  :arith-pivots            49748
;  :conflicts               2601
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1822
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129604
;  :del-clause              1983673
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.35
;  :minimized-lits          246
;  :mk-bool-var             2268223
;  :mk-clause               1984753
;  :num-allocs              7590179
;  :num-checks              429
;  :propagations            696605
;  :quant-instantiations    908270
;  :restarts                4
;  :rlimit-count            19812481
;  :time                    0.01)
(assert (forall ((i1@335@07 Int)) (!
  (forall ((i2@336@07 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
                ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07)))
              (< i2@336@07 V@39@07))
            (<= 0 i2@336@07))
          (< i1@335@07 V@39@07))
        (<= 0 i1@335@07))
      (= i1@335@07 i2@336@07))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@336@07))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@335@07))
  :qid |prog.l<no position>|)))
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@337@07 Int)
(declare-const j1@338@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 206 | 0 <= i1@337@07 | live]
; [else-branch: 206 | !(0 <= i1@337@07) | live]
(push) ; 15
; [then-branch: 206 | 0 <= i1@337@07]
(assert (<= 0 i1@337@07))
; [eval] i1 < V
(push) ; 16
; [then-branch: 207 | i1@337@07 < V@39@07 | live]
; [else-branch: 207 | !(i1@337@07 < V@39@07) | live]
(push) ; 17
; [then-branch: 207 | i1@337@07 < V@39@07]
(assert (< i1@337@07 V@39@07))
; [eval] 0 <= j1
(push) ; 18
; [then-branch: 208 | 0 <= j1@338@07 | live]
; [else-branch: 208 | !(0 <= j1@338@07) | live]
(push) ; 19
; [then-branch: 208 | 0 <= j1@338@07]
(assert (<= 0 j1@338@07))
; [eval] j1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 208 | !(0 <= j1@338@07)]
(assert (not (<= 0 j1@338@07)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 207 | !(i1@337@07 < V@39@07)]
(assert (not (< i1@337@07 V@39@07)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 206 | !(0 <= i1@337@07)]
(assert (not (<= 0 i1@337@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@338@07 V@39@07) (<= 0 j1@338@07)) (< i1@337@07 V@39@07))
  (<= 0 i1@337@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@337@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1237918
;  :arith-add-rows          222910
;  :arith-assert-diseq      45108
;  :arith-assert-lower      348443
;  :arith-assert-upper      291041
;  :arith-bound-prop        20155
;  :arith-conflicts         968
;  :arith-eq-adapter        194581
;  :arith-fixed-eqs         214332
;  :arith-offset-eqs        60751
;  :arith-pivots            49748
;  :conflicts               2601
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1822
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129604
;  :del-clause              1983673
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.35
;  :minimized-lits          246
;  :mk-bool-var             2268230
;  :mk-clause               1984753
;  :num-allocs              7590785
;  :num-checks              430
;  :propagations            696605
;  :quant-instantiations    908270
;  :restarts                4
;  :rlimit-count            19813482)
(assert (< i1@337@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@337@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07)))
(push) ; 14
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))
            V@39@07)
          (<=
            0
            (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))))
        $k@134@07
        $Perm.No)
      (pTaken@224@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07)))
    (ite
      (and
        (<
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))
          V@39@07)
        (<=
          0
          (inv@198@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))))
      $k@197@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1238709
;  :arith-add-rows          223030
;  :arith-assert-diseq      45127
;  :arith-assert-lower      348604
;  :arith-assert-upper      291136
;  :arith-bound-prop        20197
;  :arith-conflicts         971
;  :arith-eq-adapter        194691
;  :arith-fixed-eqs         214445
;  :arith-offset-eqs        60846
;  :arith-pivots            49791
;  :conflicts               2620
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1826
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129634
;  :del-clause              1984719
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          246
;  :mk-bool-var             2269599
;  :mk-clause               1985912
;  :num-allocs              7595818
;  :num-checks              431
;  :propagations            697000
;  :quant-instantiations    908759
;  :restarts                4
;  :rlimit-count            19834935
;  :time                    0.01)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1238709
;  :arith-add-rows          223030
;  :arith-assert-diseq      45127
;  :arith-assert-lower      348604
;  :arith-assert-upper      291136
;  :arith-bound-prop        20197
;  :arith-conflicts         971
;  :arith-eq-adapter        194691
;  :arith-fixed-eqs         214445
;  :arith-offset-eqs        60846
;  :arith-pivots            49791
;  :conflicts               2621
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1826
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129634
;  :del-clause              1984719
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          246
;  :mk-bool-var             2269599
;  :mk-clause               1985912
;  :num-allocs              7595909
;  :num-checks              432
;  :propagations            697000
;  :quant-instantiations    908759
;  :restarts                4
;  :rlimit-count            19835030)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))
    (as None<option<array>>  option<array>))))
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (<
  j1@338@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1238715
;  :arith-add-rows          223035
;  :arith-assert-diseq      45127
;  :arith-assert-lower      348606
;  :arith-assert-upper      291138
;  :arith-bound-prop        20197
;  :arith-conflicts         972
;  :arith-eq-adapter        194692
;  :arith-fixed-eqs         214446
;  :arith-offset-eqs        60846
;  :arith-pivots            49795
;  :conflicts               2622
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1826
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129634
;  :del-clause              1984723
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          246
;  :mk-bool-var             2269610
;  :mk-clause               1985916
;  :num-allocs              7596109
;  :num-checks              433
;  :propagations            697002
;  :quant-instantiations    908766
;  :restarts                4
;  :rlimit-count            19835529)
(assert (<
  j1@338@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))))))
(pop) ; 14
; Joined path conditions
(assert (<
  j1@338@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))))))
(pop) ; 13
(declare-fun inv@339@07 ($Ref) Int)
(declare-fun inv@340@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@337@07 Int) (j1@338@07 Int)) (!
  (and
    (< i1@337@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@338@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))) j1@338@07))
  :qid |int-aux|)))
(declare-const sm@341@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@341@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@341@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef148|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@341@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@341@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef149|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@341@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef150|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@337@07 Int) (j11@338@07 Int) (i12@337@07 Int) (j12@338@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@338@07 V@39@07) (<= 0 j11@338@07))
            (< i11@337@07 V@39@07))
          (<= 0 i11@337@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@341@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@337@07))) j11@338@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@337@07))) j11@338@07)))
      (and
        (and
          (and
            (and (< j12@338@07 V@39@07) (<= 0 j12@338@07))
            (< i12@337@07 V@39@07))
          (<= 0 i12@337@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@341@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@337@07))) j12@338@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@337@07))) j12@338@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@337@07))) j11@338@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@337@07))) j12@338@07)))
    (and (= i11@337@07 i12@337@07) (= j11@338@07 j12@338@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1238808
;  :arith-add-rows          223068
;  :arith-assert-diseq      45127
;  :arith-assert-lower      348623
;  :arith-assert-upper      291145
;  :arith-bound-prop        20203
;  :arith-conflicts         972
;  :arith-eq-adapter        194719
;  :arith-fixed-eqs         214452
;  :arith-offset-eqs        60846
;  :arith-pivots            49820
;  :conflicts               2623
;  :datatype-accessor-ax    635
;  :datatype-constructor-ax 1826
;  :datatype-occurs-check   1524
;  :datatype-splits         1337
;  :decisions               129634
;  :del-clause              1985182
;  :final-checks            200
;  :interface-eqs           44
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.34
;  :minimized-lits          246
;  :mk-bool-var             2270216
;  :mk-clause               1986262
;  :num-allocs              7599598
;  :num-checks              434
;  :propagations            697038
;  :quant-instantiations    908971
;  :restarts                4
;  :rlimit-count            19849409
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@337@07 Int) (j1@338@07 Int)) (!
  (implies
    (and
      (and (and (< j1@338@07 V@39@07) (<= 0 j1@338@07)) (< i1@337@07 V@39@07))
      (<= 0 i1@337@07))
    (and
      (=
        (inv@339@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))) j1@338@07))
        i1@337@07)
      (=
        (inv@340@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))) j1@338@07))
        j1@338@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@337@07))) j1@338@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@340@07 r) V@39@07) (<= 0 (inv@340@07 r)))
        (< (inv@339@07 r) V@39@07))
      (<= 0 (inv@339@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@330@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@339@07 r)))) (inv@340@07 r))
      r))
  :pattern ((inv@339@07 r))
  :pattern ((inv@340@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@340@07 r) V@39@07) (<= 0 (inv@340@07 r)))
        (< (inv@339@07 r) V@39@07))
      (<= 0 (inv@339@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@341@07  $FVF<Int>) r) r))
  :pattern ((inv@339@07 r) (inv@340@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@342@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@340@07 r) V@39@07) (<= 0 (inv@340@07 r)))
        (< (inv@339@07 r) V@39@07))
      (<= 0 (inv@339@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@343@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@340@07 r) V@39@07) (<= 0 (inv@340@07 r)))
        (< (inv@339@07 r) V@39@07))
      (<= 0 (inv@339@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@342@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@342@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1283742
;  :arith-add-rows          232870
;  :arith-assert-diseq      45940
;  :arith-assert-lower      360409
;  :arith-assert-upper      299146
;  :arith-bound-prop        21384
;  :arith-conflicts         1021
;  :arith-eq-adapter        201557
;  :arith-fixed-eqs         220895
;  :arith-offset-eqs        63842
;  :arith-pivots            52572
;  :conflicts               2729
;  :datatype-accessor-ax    637
;  :datatype-constructor-ax 1842
;  :datatype-occurs-check   1537
;  :datatype-splits         1349
;  :decisions               135686
;  :del-clause              2075466
;  :final-checks            202
;  :interface-eqs           45
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.63
;  :minimized-lits          258
;  :mk-bool-var             2363149
;  :mk-clause               2076601
;  :num-allocs              7847008
;  :num-checks              436
;  :propagations            725188
;  :quant-instantiations    943351
;  :restarts                5
;  :rlimit-count            20676333
;  :time                    0.50)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@340@07 r) V@39@07) (<= 0 (inv@340@07 r)))
        (< (inv@339@07 r) V@39@07))
      (<= 0 (inv@339@07 r)))
    (= (- $Perm.Write (pTaken@342@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1327965
;  :arith-add-rows          242486
;  :arith-assert-diseq      47111
;  :arith-assert-lower      372562
;  :arith-assert-upper      308132
;  :arith-bound-prop        22554
;  :arith-conflicts         1083
;  :arith-eq-adapter        208275
;  :arith-fixed-eqs         227155
;  :arith-offset-eqs        67029
;  :arith-pivots            55588
;  :conflicts               2844
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1854
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               142755
;  :del-clause              2163519
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.66
;  :minimized-lits          268
;  :mk-bool-var             2453343
;  :mk-clause               2164654
;  :num-allocs              8081123
;  :num-checks              437
;  :propagations            754107
;  :quant-instantiations    976449
;  :restarts                6
;  :rlimit-count            21489857
;  :time                    0.50)
; Chunk depleted?
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@343@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.51s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1370973
;  :arith-add-rows          254144
;  :arith-assert-diseq      48801
;  :arith-assert-lower      385649
;  :arith-assert-upper      317936
;  :arith-bound-prop        23642
;  :arith-conflicts         1158
;  :arith-eq-adapter        214848
;  :arith-fixed-eqs         233620
;  :arith-offset-eqs        71836
;  :arith-pivots            58030
;  :conflicts               2963
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1866
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               150170
;  :del-clause              2266783
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.09
;  :minimized-lits          289
;  :mk-bool-var             2545673
;  :mk-clause               2267918
;  :num-allocs              8282655
;  :num-checks              438
;  :propagations            789951
;  :quant-instantiations    1003618
;  :restarts                7
;  :rlimit-count            22379043
;  :time                    0.51)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@340@07 r) V@39@07) (<= 0 (inv@340@07 r)))
        (< (inv@339@07 r) V@39@07))
      (<= 0 (inv@339@07 r)))
    (= (- (- $Perm.Write (pTaken@342@07 r)) (pTaken@343@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1372047
;  :arith-add-rows          254467
;  :arith-assert-diseq      48842
;  :arith-assert-lower      385889
;  :arith-assert-upper      318098
;  :arith-bound-prop        23685
;  :arith-conflicts         1166
;  :arith-eq-adapter        215010
;  :arith-fixed-eqs         233769
;  :arith-offset-eqs        71920
;  :arith-pivots            58131
;  :conflicts               2976
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1870
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               150209
;  :del-clause              2268101
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.16
;  :minimized-lits          292
;  :mk-bool-var             2547230
;  :mk-clause               2269236
;  :num-allocs              8288765
;  :num-checks              439
;  :propagations            790597
;  :quant-instantiations    1004181
;  :restarts                7
;  :rlimit-count            22412353
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@344@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 209 | 0 <= i1@344@07 | live]
; [else-branch: 209 | !(0 <= i1@344@07) | live]
(push) ; 15
; [then-branch: 209 | 0 <= i1@344@07]
(assert (<= 0 i1@344@07))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 209 | !(0 <= i1@344@07)]
(assert (not (<= 0 i1@344@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@344@07 V@39@07) (<= 0 i1@344@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@344@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1372047
;  :arith-add-rows          254467
;  :arith-assert-diseq      48842
;  :arith-assert-lower      385891
;  :arith-assert-upper      318098
;  :arith-bound-prop        23685
;  :arith-conflicts         1166
;  :arith-eq-adapter        215010
;  :arith-fixed-eqs         233769
;  :arith-offset-eqs        71920
;  :arith-pivots            58131
;  :conflicts               2976
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1870
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               150209
;  :del-clause              2268101
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.16
;  :minimized-lits          292
;  :mk-bool-var             2547232
;  :mk-clause               2269236
;  :num-allocs              8288875
;  :num-checks              440
;  :propagations            790597
;  :quant-instantiations    1004181
;  :restarts                7
;  :rlimit-count            22412531)
(assert (< i1@344@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@344@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 13
(declare-fun inv@345@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@344@07 Int)) (!
  (< i1@344@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@344@07))
  :qid |int-aux|)))
(declare-const sm@346@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
              (< (inv@206@07 r) V@39@07))
            (<= 0 (inv@206@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@343@07 r)))
    (=
      ($FVF.lookup_int (as sm@346@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@346@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef151|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@342@07 r)))
    (=
      ($FVF.lookup_int (as sm@346@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@346@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef152|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@346@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef153|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@344@07 Int) (i12@344@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@344@07 V@39@07) (<= 0 i11@344@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@346@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@344@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@344@07)))
      (and
        (and (< i12@344@07 V@39@07) (<= 0 i12@344@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@346@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@344@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@344@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@344@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@344@07)))
    (= i11@344@07 i12@344@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1372084
;  :arith-add-rows          254469
;  :arith-assert-diseq      48843
;  :arith-assert-lower      385895
;  :arith-assert-upper      318098
;  :arith-bound-prop        23685
;  :arith-conflicts         1166
;  :arith-eq-adapter        215011
;  :arith-fixed-eqs         233769
;  :arith-offset-eqs        71920
;  :arith-pivots            58131
;  :conflicts               2977
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1870
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               150209
;  :del-clause              2268137
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.14
;  :minimized-lits          292
;  :mk-bool-var             2547317
;  :mk-clause               2269272
;  :num-allocs              8290316
;  :num-checks              441
;  :propagations            790599
;  :quant-instantiations    1004241
;  :restarts                7
;  :rlimit-count            22417465
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@344@07 Int)) (!
  (implies
    (and (< i1@344@07 V@39@07) (<= 0 i1@344@07))
    (=
      (inv@345@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@344@07))
      i1@344@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@344@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@345@07 r) V@39@07) (<= 0 (inv@345@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@345@07 r))
      r))
  :pattern ((inv@345@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@345@07 r) V@39@07) (<= 0 (inv@345@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@346@07  $FVF<Int>) r) r))
  :pattern ((inv@345@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@347@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@345@07 r) V@39@07) (<= 0 (inv@345@07 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
              (< (inv@206@07 r) V@39@07))
            (<= 0 (inv@206@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@343@07 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@348@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@345@07 r) V@39@07) (<= 0 (inv@345@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@342@07 r))
      (- $Perm.Write (pTaken@347@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
              (< (inv@206@07 r) V@39@07))
            (<= 0 (inv@206@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@343@07 r))
      (pTaken@347@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1376883
;  :arith-add-rows          255539
;  :arith-assert-diseq      48957
;  :arith-assert-lower      386938
;  :arith-assert-upper      318795
;  :arith-bound-prop        23795
;  :arith-conflicts         1179
;  :arith-eq-adapter        215697
;  :arith-fixed-eqs         234505
;  :arith-offset-eqs        72572
;  :arith-pivots            58553
;  :conflicts               3009
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1878
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               150490
;  :del-clause              2277206
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.10
;  :minimized-lits          296
;  :mk-bool-var             2557662
;  :mk-clause               2278343
;  :num-allocs              8325328
;  :num-checks              443
;  :propagations            793802
;  :quant-instantiations    1007585
;  :restarts                7
;  :rlimit-count            22545395
;  :time                    0.05)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@345@07 r) V@39@07) (<= 0 (inv@345@07 r)))
    (= (- $Perm.Write (pTaken@347@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1415946
;  :arith-add-rows          264191
;  :arith-assert-diseq      50224
;  :arith-assert-lower      397459
;  :arith-assert-upper      327019
;  :arith-bound-prop        24514
;  :arith-conflicts         1223
;  :arith-eq-adapter        222329
;  :arith-fixed-eqs         239941
;  :arith-offset-eqs        74908
;  :arith-pivots            61248
;  :conflicts               3098
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1882
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               155578
;  :del-clause              2366986
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.84
;  :minimized-lits          318
;  :mk-bool-var             2647407
;  :mk-clause               2368123
;  :num-allocs              8568792
;  :num-checks              444
;  :propagations            819056
;  :quant-instantiations    1039084
;  :restarts                7
;  :rlimit-count            23318759
;  :time                    0.51)
; Chunk depleted?
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@342@07 r))
      (pTaken@348@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.31s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1436715
;  :arith-add-rows          272310
;  :arith-assert-diseq      51078
;  :arith-assert-lower      403744
;  :arith-assert-upper      331602
;  :arith-bound-prop        25245
;  :arith-conflicts         1261
;  :arith-eq-adapter        226006
;  :arith-fixed-eqs         243197
;  :arith-offset-eqs        76726
;  :arith-pivots            62906
;  :conflicts               3176
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1886
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               158456
;  :del-clause              2422257
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.85
;  :minimized-lits          340
;  :mk-bool-var             2703846
;  :mk-clause               2423394
;  :num-allocs              8723465
;  :num-checks              445
;  :propagations            833455
;  :quant-instantiations    1053274
;  :restarts                7
;  :rlimit-count            23776307
;  :time                    0.31)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@345@07 r) V@39@07) (<= 0 (inv@345@07 r)))
    (= (- (- $Perm.Write (pTaken@347@07 r)) (pTaken@348@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.26s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1452904
;  :arith-add-rows          277062
;  :arith-assert-diseq      51762
;  :arith-assert-lower      408185
;  :arith-assert-upper      335255
;  :arith-bound-prop        25647
;  :arith-conflicts         1295
;  :arith-eq-adapter        228615
;  :arith-fixed-eqs         245511
;  :arith-offset-eqs        78200
;  :arith-pivots            64018
;  :conflicts               3243
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1890
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               161029
;  :del-clause              2468555
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.87
;  :minimized-lits          355
;  :mk-bool-var             2747284
;  :mk-clause               2469692
;  :num-allocs              8833460
;  :num-checks              446
;  :propagations            845684
;  :quant-instantiations    1064361
;  :restarts                7
;  :rlimit-count            24134411
;  :time                    0.26)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, p, V)
(push) ; 13
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(declare-const i1@349@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 210 | 0 <= i1@349@07 | live]
; [else-branch: 210 | !(0 <= i1@349@07) | live]
(push) ; 16
; [then-branch: 210 | 0 <= i1@349@07]
(assert (<= 0 i1@349@07))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 210 | !(0 <= i1@349@07)]
(assert (not (<= 0 i1@349@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and (< i1@349@07 V@39@07) (<= 0 i1@349@07)))
(declare-const $k@350@07 $Perm)
(assert ($Perm.isReadVar $k@350@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@349@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1452904
;  :arith-add-rows          277062
;  :arith-assert-diseq      51763
;  :arith-assert-lower      408189
;  :arith-assert-upper      335256
;  :arith-bound-prop        25647
;  :arith-conflicts         1295
;  :arith-eq-adapter        228616
;  :arith-fixed-eqs         245511
;  :arith-offset-eqs        78200
;  :arith-pivots            64018
;  :conflicts               3243
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1890
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               161029
;  :del-clause              2468555
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.87
;  :minimized-lits          355
;  :mk-bool-var             2747290
;  :mk-clause               2469694
;  :num-allocs              8833639
;  :num-checks              447
;  :propagations            845685
;  :quant-instantiations    1064361
;  :restarts                7
;  :rlimit-count            24134741)
(assert (< i1@349@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 15
; Joined path conditions
(assert (< i1@349@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 14
(declare-fun inv@351@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@350@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@349@07 Int)) (!
  (< i1@349@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@349@07))
  :qid |int-aux|)))
(push) ; 14
(assert (not (forall ((i1@349@07 Int)) (!
  (implies
    (and (< i1@349@07 V@39@07) (<= 0 i1@349@07))
    (or (= $k@350@07 $Perm.No) (< $Perm.No $k@350@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1452904
;  :arith-add-rows          277062
;  :arith-assert-diseq      51764
;  :arith-assert-lower      408191
;  :arith-assert-upper      335257
;  :arith-bound-prop        25647
;  :arith-conflicts         1295
;  :arith-eq-adapter        228617
;  :arith-fixed-eqs         245511
;  :arith-offset-eqs        78200
;  :arith-pivots            64018
;  :conflicts               3244
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1890
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               161029
;  :del-clause              2468557
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.87
;  :minimized-lits          355
;  :mk-bool-var             2747297
;  :mk-clause               2469696
;  :num-allocs              8834071
;  :num-checks              448
;  :propagations            845686
;  :quant-instantiations    1064361
;  :restarts                7
;  :rlimit-count            24135286)
(declare-const sm@352@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@352@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@352@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@352@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@352@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef155|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@352@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef156|)))
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@349@07 Int) (i12@349@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@349@07 V@39@07) (<= 0 i11@349@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@352@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@349@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@349@07)))
        (< $Perm.No $k@350@07))
      (and
        (and
          (and (< i12@349@07 V@39@07) (<= 0 i12@349@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@352@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@349@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@349@07)))
        (< $Perm.No $k@350@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@349@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@349@07)))
    (= i11@349@07 i12@349@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1452943
;  :arith-add-rows          277064
;  :arith-assert-diseq      51765
;  :arith-assert-lower      408195
;  :arith-assert-upper      335257
;  :arith-bound-prop        25647
;  :arith-conflicts         1295
;  :arith-eq-adapter        228618
;  :arith-fixed-eqs         245511
;  :arith-offset-eqs        78200
;  :arith-pivots            64018
;  :conflicts               3245
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1890
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               161029
;  :del-clause              2468568
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.87
;  :minimized-lits          355
;  :mk-bool-var             2747360
;  :mk-clause               2469707
;  :num-allocs              8835204
;  :num-checks              449
;  :propagations            845688
;  :quant-instantiations    1064425
;  :restarts                7
;  :rlimit-count            24138888
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@349@07 Int)) (!
  (implies
    (and (and (< i1@349@07 V@39@07) (<= 0 i1@349@07)) (< $Perm.No $k@350@07))
    (=
      (inv@351@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@349@07))
      i1@349@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@349@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
      (< $Perm.No $k@350@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@351@07 r))
      r))
  :pattern ((inv@351@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@352@07  $FVF<Int>) r) r))
  :pattern ((inv@351@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@353@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        $Perm.Write
        $Perm.No)
      $k@350@07)
    $Perm.No))
(define-fun pTaken@354@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@350@07 (pTaken@353@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@350@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
              (< (inv@206@07 r) V@39@07))
            (<= 0 (inv@206@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r)))
      (<
        (ite
          (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
          $k@350@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
          $k@350@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@207@07 r))
  :pattern ((inv@206@07 r))
  :pattern ((inv@351@07 r))
  :qid |qp.srp157|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
    (= (- $k@350@07 (pTaken@353@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 14
; 0.50s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1492143
;  :arith-add-rows          289446
;  :arith-assert-diseq      52935
;  :arith-assert-lower      417580
;  :arith-assert-upper      343276
;  :arith-bound-prop        26404
;  :arith-conflicts         1342
;  :arith-eq-adapter        235001
;  :arith-fixed-eqs         250611
;  :arith-offset-eqs        80501
;  :arith-pivots            66728
;  :conflicts               3334
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1898
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               165994
;  :del-clause              2554333
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.97
;  :minimized-lits          372
;  :mk-bool-var             2836230
;  :mk-clause               2555472
;  :num-allocs              9079662
;  :num-checks              451
;  :propagations            868081
;  :quant-instantiations    1096459
;  :restarts                7
;  :rlimit-count            24888769
;  :time                    0.50)
; Constrain original permissions $k@350@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
      (<
        (ite
          (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
          $k@350@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
          $k@350@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@210@07 r))
  :pattern ((inv@351@07 r))
  :qid |qp.srp158|)))
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
    (= (- (- $k@350@07 (pTaken@353@07 r)) (pTaken@354@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1493302
;  :arith-add-rows          289687
;  :arith-assert-diseq      52971
;  :arith-assert-lower      417815
;  :arith-assert-upper      343422
;  :arith-bound-prop        26445
;  :arith-conflicts         1348
;  :arith-eq-adapter        235195
;  :arith-fixed-eqs         250751
;  :arith-offset-eqs        80659
;  :arith-pivots            66812
;  :conflicts               3360
;  :datatype-accessor-ax    639
;  :datatype-constructor-ax 1902
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               166033
;  :del-clause              2556046
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.85
;  :minimized-lits          376
;  :mk-bool-var             2838419
;  :mk-clause               2557185
;  :num-allocs              9087952
;  :num-checks              452
;  :propagations            868697
;  :quant-instantiations    1097123
;  :restarts                7
;  :rlimit-count            24919397
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@355@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@355@07  $FVF<Int>)))
    (and
      (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
      (< $Perm.No $k@350@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@355@07  $FVF<Int>))))
  :qid |qp.fvfDomDef162|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
        (< $Perm.No $k@350@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@355@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@355@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef159|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
        (< $Perm.No $k@350@07))
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r))))
    (=
      ($FVF.lookup_int (as sm@355@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@355@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@355@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef161|)))
(pop) ; 13
; Joined path conditions
(assert ($Perm.isReadVar $k@350@07 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
        (< (inv@206@07 r) V@39@07))
      (<= 0 (inv@206@07 r)))
    (=
      ($FVF.lookup_int (as sm@352@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@352@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef154|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
    (=
      ($FVF.lookup_int (as sm@352@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@352@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef155|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@352@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef156|)))
(assert (forall ((i1@349@07 Int)) (!
  (implies
    (and (and (< i1@349@07 V@39@07) (<= 0 i1@349@07)) (< $Perm.No $k@350@07))
    (=
      (inv@351@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@349@07))
      i1@349@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@349@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
      (< $Perm.No $k@350@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@351@07 r))
      r))
  :pattern ((inv@351@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@355@07  $FVF<Int>)))
    (and
      (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
      (< $Perm.No $k@350@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@355@07  $FVF<Int>))))
  :qid |qp.fvfDomDef162|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
        (< $Perm.No $k@350@07))
      (and
        (and
          (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
          (< (inv@206@07 r) V@39@07))
        (<= 0 (inv@206@07 r))))
    (=
      ($FVF.lookup_int (as sm@355@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@355@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r))
  :qid |qp.fvfValDef159|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
        (< $Perm.No $k@350@07))
      (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r))))
    (=
      ($FVF.lookup_int (as sm@355@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@355@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r))
  :qid |qp.fvfValDef160|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@195@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@355@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef161|)))
(assert (and
  (forall ((i1@349@07 Int)) (!
    (< i1@349@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@349@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@352@07  $FVF<Int>) r) r))
    :pattern ((inv@351@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
                (< (inv@206@07 r) V@39@07))
              (<= 0 (inv@206@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@207@07 r) V@39@07) (<= 0 (inv@207@07 r)))
            (< (inv@206@07 r) V@39@07))
          (<= 0 (inv@206@07 r)))
        (<
          (ite
            (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
            $k@350@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
            $k@350@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@207@07 r))
    :pattern ((inv@206@07 r))
    :pattern ((inv@351@07 r))
    :qid |qp.srp157|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@210@07 r) V@39@07) (<= 0 (inv@210@07 r)))
        (<
          (ite
            (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
            $k@350@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@351@07 r) V@39@07) (<= 0 (inv@351@07 r)))
            $k@350@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@210@07 r))
    :pattern ((inv@351@07 r))
    :qid |qp.srp158|))))
(set-option :timeout 0)
(push) ; 13
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@355@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07)))
(check-sat)
; unsat
(pop) ; 13
; 0.59s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1533679
;  :arith-add-rows          299697
;  :arith-assert-diseq      54432
;  :arith-assert-lower      429395
;  :arith-assert-upper      352379
;  :arith-bound-prop        27594
;  :arith-conflicts         1394
;  :arith-eq-adapter        241672
;  :arith-fixed-eqs         257880
;  :arith-offset-eqs        84737
;  :arith-pivots            69572
;  :conflicts               3441
;  :datatype-accessor-ax    642
;  :datatype-constructor-ax 1906
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171013
;  :del-clause              2656714
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.64
;  :minimized-lits          394
;  :mk-bool-var             2938294
;  :mk-clause               2657853
;  :num-allocs              9356144
;  :num-checks              453
;  :propagations            895150
;  :quant-instantiations    1124547
;  :restarts                7
;  :rlimit-count            25632279
;  :time                    0.59)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@355@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))
; [eval] 0 <= s
; [eval] s < V
; [eval] valid_graph_vertices1(this, queue, V)
(push) ; 13
; [eval] this != null
(pop) ; 13
; Joined path conditions
(declare-const i1@356@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 211 | 0 <= i1@356@07 | live]
; [else-branch: 211 | !(0 <= i1@356@07) | live]
(push) ; 15
; [then-branch: 211 | 0 <= i1@356@07]
(assert (<= 0 i1@356@07))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 211 | !(0 <= i1@356@07)]
(assert (not (<= 0 i1@356@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@356@07 V@39@07) (<= 0 i1@356@07)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< i1@356@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1533692
;  :arith-add-rows          299699
;  :arith-assert-diseq      54432
;  :arith-assert-lower      429397
;  :arith-assert-upper      352379
;  :arith-bound-prop        27594
;  :arith-conflicts         1394
;  :arith-eq-adapter        241672
;  :arith-fixed-eqs         257880
;  :arith-offset-eqs        84737
;  :arith-pivots            69572
;  :conflicts               3441
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1906
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171013
;  :del-clause              2656714
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.64
;  :minimized-lits          394
;  :mk-bool-var             2938370
;  :mk-clause               2657920
;  :num-allocs              9356583
;  :num-checks              454
;  :propagations            895161
;  :quant-instantiations    1124560
;  :restarts                7
;  :rlimit-count            25633143)
(assert (< i1@356@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@356@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 13
(declare-fun inv@357@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@356@07 Int)) (!
  (< i1@356@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@356@07))
  :qid |bool-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@356@07 Int) (i12@356@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@356@07 V@39@07) (<= 0 i11@356@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@356@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@356@07)))
      (and
        (and (< i12@356@07 V@39@07) (<= 0 i12@356@07))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@356@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@356@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i11@356@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i12@356@07)))
    (= i11@356@07 i12@356@07))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1533711
;  :arith-add-rows          299701
;  :arith-assert-diseq      54433
;  :arith-assert-lower      429401
;  :arith-assert-upper      352379
;  :arith-bound-prop        27594
;  :arith-conflicts         1394
;  :arith-eq-adapter        241673
;  :arith-fixed-eqs         257880
;  :arith-offset-eqs        84737
;  :arith-pivots            69572
;  :conflicts               3442
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1906
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171013
;  :del-clause              2656725
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.64
;  :minimized-lits          394
;  :mk-bool-var             2938407
;  :mk-clause               2657931
;  :num-allocs              9357196
;  :num-checks              455
;  :propagations            895161
;  :quant-instantiations    1124594
;  :restarts                7
;  :rlimit-count            25634528
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@356@07 Int)) (!
  (implies
    (and (< i1@356@07 V@39@07) (<= 0 i1@356@07))
    (=
      (inv@357@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@356@07))
      i1@356@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) i1@356@07))
  :qid |bool-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@357@07 r) V@39@07) (<= 0 (inv@357@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) (inv@357@07 r))
      r))
  :pattern ((inv@357@07 r))
  :qid |bool-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@357@07 r) V@39@07) (<= 0 (inv@357@07 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@220@07  $FVF<Bool>) r) r))
  :pattern ((inv@357@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@358@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@357@07 r) V@39@07) (<= 0 (inv@357@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@219@07 r) V@39@07) (<= 0 (inv@219@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@358@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1535950
;  :arith-add-rows          299978
;  :arith-assert-diseq      54480
;  :arith-assert-lower      429846
;  :arith-assert-upper      352641
;  :arith-bound-prop        27608
;  :arith-conflicts         1396
;  :arith-eq-adapter        241970
;  :arith-fixed-eqs         258179
;  :arith-offset-eqs        85140
;  :arith-pivots            69672
;  :conflicts               3464
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1914
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171114
;  :del-clause              2660328
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.39
;  :minimized-lits          395
;  :mk-bool-var             2942115
;  :mk-clause               2661532
;  :num-allocs              9369400
;  :num-checks              457
;  :propagations            896487
;  :quant-instantiations    1125964
;  :restarts                7
;  :rlimit-count            25690170
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@357@07 r) V@39@07) (<= 0 (inv@357@07 r)))
    (= (- $Perm.Write (pTaken@358@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1535986
;  :arith-add-rows          299992
;  :arith-assert-diseq      54482
;  :arith-assert-lower      429855
;  :arith-assert-upper      352651
;  :arith-bound-prop        27609
;  :arith-conflicts         1397
;  :arith-eq-adapter        241979
;  :arith-fixed-eqs         258185
;  :arith-offset-eqs        85140
;  :arith-pivots            69676
;  :conflicts               3465
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1914
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171114
;  :del-clause              2660415
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.39
;  :minimized-lits          395
;  :mk-bool-var             2942236
;  :mk-clause               2661619
;  :num-allocs              9369984
;  :num-checks              458
;  :propagations            896492
;  :quant-instantiations    1126000
;  :restarts                7
;  :rlimit-count            25692026
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(pop) ; 12
(push) ; 12
; [else-branch: 195 | v@193@07 < V@39@07]
(assert (< v@193@07 V@39@07))
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 125 | |queue@129@07| == 0]
(assert (= (Seq_length queue@129@07) 0))
(pop) ; 9
; [eval] !!(|queue| == 0)
; [eval] !(|queue| == 0)
; [eval] |queue| == 0
; [eval] |queue|
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= (Seq_length queue@129@07) 0))))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1536787
;  :arith-add-rows          300685
;  :arith-assert-diseq      54487
;  :arith-assert-lower      430081
;  :arith-assert-upper      352784
;  :arith-bound-prop        27638
;  :arith-conflicts         1403
;  :arith-eq-adapter        242097
;  :arith-fixed-eqs         258312
;  :arith-offset-eqs        85205
;  :arith-pivots            69891
;  :conflicts               3472
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1918
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171176
;  :del-clause              2662450
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          395
;  :mk-bool-var             2943801
;  :mk-clause               2662936
;  :num-allocs              9374588
;  :num-checks              459
;  :propagations            896989
;  :quant-instantiations    1126545
;  :restarts                7
;  :rlimit-count            25718403
;  :time                    0.01)
(push) ; 9
(assert (not (= (Seq_length queue@129@07) 0)))
(check-sat)
; unknown
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1537854
;  :arith-add-rows          301436
;  :arith-assert-diseq      54507
;  :arith-assert-lower      430382
;  :arith-assert-upper      352996
;  :arith-bound-prop        27690
;  :arith-conflicts         1410
;  :arith-eq-adapter        242244
;  :arith-fixed-eqs         258471
;  :arith-offset-eqs        85355
;  :arith-pivots            70001
;  :conflicts               3481
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1922
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171320
;  :del-clause              2664728
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.05
;  :minimized-lits          396
;  :mk-bool-var             2946087
;  :mk-clause               2665214
;  :num-allocs              9380325
;  :num-checks              460
;  :propagations            897691
;  :quant-instantiations    1127231
;  :restarts                7
;  :rlimit-count            25750392
;  :time                    0.01)
; [then-branch: 212 | |queue@129@07| == 0 | live]
; [else-branch: 212 | |queue@129@07| != 0 | live]
(push) ; 9
; [then-branch: 212 | |queue@129@07| == 0]
(assert (= (Seq_length queue@129@07) 0))
; [exec]
; return := aloc(opt_get1(visited), t).bool
; [eval] aloc(opt_get1(visited), t)
; [eval] opt_get1(visited)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< t@41@07 (alen<Int> (opt_get1 $Snap.unit res@106@07)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1537856
;  :arith-add-rows          301436
;  :arith-assert-diseq      54507
;  :arith-assert-lower      430383
;  :arith-assert-upper      352997
;  :arith-bound-prop        27690
;  :arith-conflicts         1410
;  :arith-eq-adapter        242245
;  :arith-fixed-eqs         258471
;  :arith-offset-eqs        85355
;  :arith-pivots            70001
;  :conflicts               3481
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1922
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171320
;  :del-clause              2664728
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.05
;  :minimized-lits          396
;  :mk-bool-var             2946091
;  :mk-clause               2665217
;  :num-allocs              9380429
;  :num-checks              461
;  :propagations            897693
;  :quant-instantiations    1127233
;  :restarts                7
;  :rlimit-count            25750507)
(assert (< t@41@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(pop) ; 10
; Joined path conditions
(assert (< t@41@07 (alen<Int> (opt_get1 $Snap.unit res@106@07))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) t@41@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@106@07) t@41@07)))
(push) ; 10
(assert (not (and
  (<
    (inv@156@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) t@41@07))
    V@39@07)
  (<=
    0
    (inv@156@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@106@07) t@41@07))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1537885
;  :arith-add-rows          301457
;  :arith-assert-diseq      54507
;  :arith-assert-lower      430387
;  :arith-assert-upper      353002
;  :arith-bound-prop        27695
;  :arith-conflicts         1411
;  :arith-eq-adapter        242250
;  :arith-fixed-eqs         258475
;  :arith-offset-eqs        85362
;  :arith-pivots            70006
;  :conflicts               3482
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1922
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171320
;  :del-clause              2664728
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2946138
;  :mk-clause               2665243
;  :num-allocs              9380816
;  :num-checks              462
;  :propagations            897696
;  :quant-instantiations    1127253
;  :restarts                7
;  :rlimit-count            25751653)
(declare-const return@359@07 Bool)
(assert (=
  return@359@07
  ($FVF.lookup_bool (as sm@157@07  $FVF<Bool>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@106@07) t@41@07))))
; [exec]
; label end
; [exec]
; res := return
; [exec]
; label bubble
; [eval] exc == null
; [eval] exc == null ==> Gf != (None(): option[array])
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1538896
;  :arith-add-rows          301973
;  :arith-assert-diseq      54524
;  :arith-assert-lower      430665
;  :arith-assert-upper      353167
;  :arith-bound-prop        27732
;  :arith-conflicts         1417
;  :arith-eq-adapter        242384
;  :arith-fixed-eqs         258628
;  :arith-offset-eqs        85474
;  :arith-pivots            70108
;  :conflicts               3489
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1926
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171447
;  :del-clause              2666203
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2947870
;  :mk-clause               2666720
;  :num-allocs              9385769
;  :num-checks              463
;  :propagations            898305
;  :quant-instantiations    1127864
;  :restarts                7
;  :rlimit-count            25775624
;  :time                    0.01)
; [then-branch: 213 | exc@116@07 == Null | live]
; [else-branch: 213 | exc@116@07 != Null | dead]
(push) ; 11
; [then-branch: 213 | exc@116@07 == Null]
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@116@07 $Ref.null)
  (not (= Gf@38@07 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1538896
;  :arith-add-rows          301973
;  :arith-assert-diseq      54524
;  :arith-assert-lower      430665
;  :arith-assert-upper      353167
;  :arith-bound-prop        27732
;  :arith-conflicts         1417
;  :arith-eq-adapter        242384
;  :arith-fixed-eqs         258628
;  :arith-offset-eqs        85474
;  :arith-pivots            70108
;  :conflicts               3489
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1926
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171447
;  :del-clause              2666203
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2947870
;  :mk-clause               2666720
;  :num-allocs              9385794
;  :num-checks              464
;  :propagations            898305
;  :quant-instantiations    1127864
;  :restarts                7
;  :rlimit-count            25775644)
(assert (implies
  (= exc@116@07 $Ref.null)
  (not (= Gf@38@07 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(Gf)) == V
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1539773
;  :arith-add-rows          302419
;  :arith-assert-diseq      54541
;  :arith-assert-lower      430911
;  :arith-assert-upper      353319
;  :arith-bound-prop        27762
;  :arith-conflicts         1422
;  :arith-eq-adapter        242509
;  :arith-fixed-eqs         258763
;  :arith-offset-eqs        85532
;  :arith-pivots            70196
;  :conflicts               3495
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1930
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171566
;  :del-clause              2667724
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2949548
;  :mk-clause               2668241
;  :num-allocs              9390429
;  :num-checks              465
;  :propagations            898839
;  :quant-instantiations    1128431
;  :restarts                7
;  :rlimit-count            25798543
;  :time                    0.01)
; [then-branch: 214 | exc@116@07 == Null | live]
; [else-branch: 214 | exc@116@07 != Null | dead]
(push) ; 11
; [then-branch: 214 | exc@116@07 == Null]
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@116@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit Gf@38@07)) V@39@07))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1539773
;  :arith-add-rows          302419
;  :arith-assert-diseq      54541
;  :arith-assert-lower      430911
;  :arith-assert-upper      353319
;  :arith-bound-prop        27762
;  :arith-conflicts         1422
;  :arith-eq-adapter        242509
;  :arith-fixed-eqs         258763
;  :arith-offset-eqs        85532
;  :arith-pivots            70196
;  :conflicts               3495
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1930
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171566
;  :del-clause              2667724
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2949548
;  :mk-clause               2668241
;  :num-allocs              9390448
;  :num-checks              466
;  :propagations            898839
;  :quant-instantiations    1128431
;  :restarts                7
;  :rlimit-count            25798568)
(assert (implies
  (= exc@116@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit Gf@38@07)) V@39@07)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1540813
;  :arith-add-rows          303114
;  :arith-assert-diseq      54556
;  :arith-assert-lower      431166
;  :arith-assert-upper      353477
;  :arith-bound-prop        27830
;  :arith-conflicts         1428
;  :arith-eq-adapter        242647
;  :arith-fixed-eqs         258940
;  :arith-offset-eqs        85637
;  :arith-pivots            70323
;  :conflicts               3502
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1934
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171674
;  :del-clause              2669111
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2951200
;  :mk-clause               2669628
;  :num-allocs              9395409
;  :num-checks              467
;  :propagations            899394
;  :quant-instantiations    1129005
;  :restarts                7
;  :rlimit-count            25825847
;  :time                    0.01)
; [then-branch: 215 | exc@116@07 == Null | live]
; [else-branch: 215 | exc@116@07 != Null | dead]
(push) ; 10
; [then-branch: 215 | exc@116@07 == Null]
(declare-const i1@360@07 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 216 | 0 <= i1@360@07 | live]
; [else-branch: 216 | !(0 <= i1@360@07) | live]
(push) ; 13
; [then-branch: 216 | 0 <= i1@360@07]
(assert (<= 0 i1@360@07))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 216 | !(0 <= i1@360@07)]
(assert (not (<= 0 i1@360@07)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@360@07 V@39@07) (<= 0 i1@360@07)))
(declare-const $k@361@07 $Perm)
(assert ($Perm.isReadVar $k@361@07 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@360@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1540813
;  :arith-add-rows          303114
;  :arith-assert-diseq      54557
;  :arith-assert-lower      431170
;  :arith-assert-upper      353478
;  :arith-bound-prop        27830
;  :arith-conflicts         1428
;  :arith-eq-adapter        242648
;  :arith-fixed-eqs         258940
;  :arith-offset-eqs        85637
;  :arith-pivots            70323
;  :conflicts               3502
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1934
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171674
;  :del-clause              2669111
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2951206
;  :mk-clause               2669630
;  :num-allocs              9395575
;  :num-checks              468
;  :propagations            899395
;  :quant-instantiations    1129005
;  :restarts                7
;  :rlimit-count            25826173)
(assert (< i1@360@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 12
; Joined path conditions
(assert (< i1@360@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 11
(declare-fun inv@362@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@361@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@360@07 Int)) (!
  (< i1@360@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@360@07))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@360@07 Int)) (!
  (implies
    (and (< i1@360@07 V@39@07) (<= 0 i1@360@07))
    (or (= $k@361@07 $Perm.No) (< $Perm.No $k@361@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1540813
;  :arith-add-rows          303114
;  :arith-assert-diseq      54558
;  :arith-assert-lower      431172
;  :arith-assert-upper      353479
;  :arith-bound-prop        27830
;  :arith-conflicts         1428
;  :arith-eq-adapter        242649
;  :arith-fixed-eqs         258940
;  :arith-offset-eqs        85637
;  :arith-pivots            70323
;  :conflicts               3503
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1934
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171674
;  :del-clause              2669113
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2951213
;  :mk-clause               2669632
;  :num-allocs              9396008
;  :num-checks              469
;  :propagations            899396
;  :quant-instantiations    1129005
;  :restarts                7
;  :rlimit-count            25826719)
(declare-const sm@363@07 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
          $k@47@07
          $Perm.No)
        (pTaken@161@07 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@45@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@45@07))))) r))
  :qid |qp.fvfValDef163|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
      (< $Perm.No $k@134@07)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r))
  :qid |qp.fvfValDef164|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@45@07))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@132@07))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef165|)))
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@360@07 Int) (i12@360@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@360@07 V@39@07) (<= 0 i11@360@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@360@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@360@07)))
        (< $Perm.No $k@361@07))
      (and
        (and
          (and (< i12@360@07 V@39@07) (<= 0 i12@360@07))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@360@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@360@07)))
        (< $Perm.No $k@361@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@360@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@360@07)))
    (= i11@360@07 i12@360@07))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1540827
;  :arith-add-rows          303116
;  :arith-assert-diseq      54559
;  :arith-assert-lower      431176
;  :arith-assert-upper      353479
;  :arith-bound-prop        27830
;  :arith-conflicts         1428
;  :arith-eq-adapter        242650
;  :arith-fixed-eqs         258940
;  :arith-offset-eqs        85637
;  :arith-pivots            70323
;  :conflicts               3504
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1934
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171674
;  :del-clause              2669136
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  42.06
;  :minimized-lits          396
;  :mk-bool-var             2951261
;  :mk-clause               2669655
;  :num-allocs              9397013
;  :num-checks              470
;  :propagations            899398
;  :quant-instantiations    1129027
;  :restarts                7
;  :rlimit-count            25829279)
; Definitional axioms for inverse functions
(assert (forall ((i1@360@07 Int)) (!
  (implies
    (and (and (< i1@360@07 V@39@07) (<= 0 i1@360@07)) (< $Perm.No $k@361@07))
    (=
      (inv@362@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@360@07))
      i1@360@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@360@07))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@362@07 r) V@39@07) (<= 0 (inv@362@07 r)))
      (< $Perm.No $k@361@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@362@07 r))
      r))
  :pattern ((inv@362@07 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@362@07 r) V@39@07) (<= 0 (inv@362@07 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) r) r))
  :pattern ((inv@362@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@364@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@362@07 r) V@39@07) (<= 0 (inv@362@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
          $k@47@07
          $Perm.No)
        (pTaken@161@07 r))
      $k@361@07)
    $Perm.No))
(define-fun pTaken@365@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@362@07 r) V@39@07) (<= 0 (inv@362@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@135@07 r) V@39@07) (<= 0 (inv@135@07 r)))
        $k@134@07
        $Perm.No)
      (- $k@361@07 (pTaken@364@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@361@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
            $k@47@07
            $Perm.No)
          (pTaken@161@07 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@362@07 r) V@39@07) (<= 0 (inv@362@07 r)))
        $k@361@07
        $Perm.No)
      (-
        (ite
          (and (< (inv@48@07 r) V@39@07) (<= 0 (inv@48@07 r)))
          $k@47@07
          $Perm.No)
        (pTaken@161@07 r))))
  :pattern ((inv@48@07 r))
  :pattern ((inv@362@07 r))
  :qid |qp.srp166|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@362@07 r) V@39@07) (<= 0 (inv@362@07 r)))
    (= (- $k@361@07 (pTaken@364@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1542482
;  :arith-add-rows          304253
;  :arith-assert-diseq      54634
;  :arith-assert-lower      431625
;  :arith-assert-upper      353805
;  :arith-bound-prop        27917
;  :arith-conflicts         1441
;  :arith-eq-adapter        242951
;  :arith-fixed-eqs         259167
;  :arith-offset-eqs        85805
;  :arith-pivots            70504
;  :conflicts               3539
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1942
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               171926
;  :del-clause              2672063
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.88
;  :minimized-lits          397
;  :mk-bool-var             2954556
;  :mk-clause               2672691
;  :num-allocs              9408308
;  :num-checks              472
;  :propagations            900355
;  :quant-instantiations    1129955
;  :restarts                7
;  :rlimit-count            25880632
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1543369
;  :arith-add-rows          304545
;  :arith-assert-diseq      54650
;  :arith-assert-lower      431846
;  :arith-assert-upper      353951
;  :arith-bound-prop        27950
;  :arith-conflicts         1446
;  :arith-eq-adapter        243072
;  :arith-fixed-eqs         259303
;  :arith-offset-eqs        85879
;  :arith-pivots            70569
;  :conflicts               3544
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1946
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172046
;  :del-clause              2673455
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.92
;  :minimized-lits          397
;  :mk-bool-var             2956055
;  :mk-clause               2674083
;  :num-allocs              9412947
;  :num-checks              473
;  :propagations            900775
;  :quant-instantiations    1130515
;  :restarts                7
;  :rlimit-count            25902670
;  :time                    0.01)
; [then-branch: 217 | exc@116@07 == Null | live]
; [else-branch: 217 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 217 | exc@116@07 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@366@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 218 | 0 <= i1@366@07 | live]
; [else-branch: 218 | !(0 <= i1@366@07) | live]
(push) ; 15
; [then-branch: 218 | 0 <= i1@366@07]
(assert (<= 0 i1@366@07))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 218 | !(0 <= i1@366@07)]
(assert (not (<= 0 i1@366@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 219 | i1@366@07 < V@39@07 && 0 <= i1@366@07 | live]
; [else-branch: 219 | !(i1@366@07 < V@39@07 && 0 <= i1@366@07) | live]
(push) ; 15
; [then-branch: 219 | i1@366@07 < V@39@07 && 0 <= i1@366@07]
(assert (and (< i1@366@07 V@39@07) (<= 0 i1@366@07)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@366@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1543369
;  :arith-add-rows          304545
;  :arith-assert-diseq      54650
;  :arith-assert-lower      431848
;  :arith-assert-upper      353951
;  :arith-bound-prop        27950
;  :arith-conflicts         1446
;  :arith-eq-adapter        243072
;  :arith-fixed-eqs         259303
;  :arith-offset-eqs        85879
;  :arith-pivots            70569
;  :conflicts               3544
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1946
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172046
;  :del-clause              2673455
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.92
;  :minimized-lits          397
;  :mk-bool-var             2956057
;  :mk-clause               2674083
;  :num-allocs              9413052
;  :num-checks              474
;  :propagations            900775
;  :quant-instantiations    1130515
;  :restarts                7
;  :rlimit-count            25902865)
(assert (< i1@366@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 16
; Joined path conditions
(assert (< i1@366@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))
            V@39@07)
          (<=
            0
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))))
        $k@47@07
        $Perm.No)
      (pTaken@161@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07)))
    (ite
      (and
        (<
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))
          V@39@07)
        (<=
          0
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))))
      $k@134@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1543747
;  :arith-add-rows          304630
;  :arith-assert-diseq      54658
;  :arith-assert-lower      431936
;  :arith-assert-upper      354006
;  :arith-bound-prop        27977
;  :arith-conflicts         1449
;  :arith-eq-adapter        243139
;  :arith-fixed-eqs         259355
;  :arith-offset-eqs        85904
;  :arith-pivots            70591
;  :conflicts               3563
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1950
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172071
;  :del-clause              2673838
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          397
;  :mk-bool-var             2956690
;  :mk-clause               2674541
;  :num-allocs              9415647
;  :num-checks              475
;  :propagations            900921
;  :quant-instantiations    1130715
;  :restarts                7
;  :rlimit-count            25912815
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 219 | !(i1@366@07 < V@39@07 && 0 <= i1@366@07)]
(assert (not (and (< i1@366@07 V@39@07) (<= 0 i1@366@07))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@366@07 V@39@07) (<= 0 i1@366@07))
  (and
    (< i1@366@07 V@39@07)
    (<= 0 i1@366@07)
    (< i1@366@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@366@07 Int)) (!
  (implies
    (and (< i1@366@07 V@39@07) (<= 0 i1@366@07))
    (and
      (< i1@366@07 V@39@07)
      (<= 0 i1@366@07)
      (< i1@366@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@366@07 Int)) (!
    (implies
      (and (< i1@366@07 V@39@07) (<= 0 i1@366@07))
      (and
        (< i1@366@07 V@39@07)
        (<= 0 i1@366@07)
        (< i1@366@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@366@07 Int)) (!
    (implies
      (and (< i1@366@07 V@39@07) (<= 0 i1@366@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1544096
;  :arith-add-rows          304700
;  :arith-assert-diseq      54662
;  :arith-assert-lower      432011
;  :arith-assert-upper      354056
;  :arith-bound-prop        27999
;  :arith-conflicts         1450
;  :arith-eq-adapter        243198
;  :arith-fixed-eqs         259403
;  :arith-offset-eqs        85929
;  :arith-pivots            70621
;  :conflicts               3581
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1954
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172093
;  :del-clause              2674334
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.92
;  :minimized-lits          397
;  :mk-bool-var             2957221
;  :mk-clause               2674962
;  :num-allocs              9418081
;  :num-checks              476
;  :propagations            901073
;  :quant-instantiations    1130916
;  :restarts                7
;  :rlimit-count            25922853
;  :time                    0.00)
(assert (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@366@07 Int)) (!
    (implies
      (and (< i1@366@07 V@39@07) (<= 0 i1@366@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@366@07))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1545115
;  :arith-add-rows          305137
;  :arith-assert-diseq      54686
;  :arith-assert-lower      432278
;  :arith-assert-upper      354224
;  :arith-bound-prop        28046
;  :arith-conflicts         1458
;  :arith-eq-adapter        243349
;  :arith-fixed-eqs         259533
;  :arith-offset-eqs        86029
;  :arith-pivots            70722
;  :conflicts               3589
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1958
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172284
;  :del-clause              2676699
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.85
;  :minimized-lits          399
;  :mk-bool-var             2959361
;  :mk-clause               2677327
;  :num-allocs              9423575
;  :num-checks              477
;  :propagations            901768
;  :quant-instantiations    1131534
;  :restarts                7
;  :rlimit-count            25952444
;  :time                    0.01)
; [then-branch: 220 | exc@116@07 == Null | live]
; [else-branch: 220 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 220 | exc@116@07 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@367@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 221 | 0 <= i1@367@07 | live]
; [else-branch: 221 | !(0 <= i1@367@07) | live]
(push) ; 15
; [then-branch: 221 | 0 <= i1@367@07]
(assert (<= 0 i1@367@07))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 221 | !(0 <= i1@367@07)]
(assert (not (<= 0 i1@367@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 222 | i1@367@07 < V@39@07 && 0 <= i1@367@07 | live]
; [else-branch: 222 | !(i1@367@07 < V@39@07 && 0 <= i1@367@07) | live]
(push) ; 15
; [then-branch: 222 | i1@367@07 < V@39@07 && 0 <= i1@367@07]
(assert (and (< i1@367@07 V@39@07) (<= 0 i1@367@07)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@367@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1545115
;  :arith-add-rows          305137
;  :arith-assert-diseq      54686
;  :arith-assert-lower      432280
;  :arith-assert-upper      354224
;  :arith-bound-prop        28046
;  :arith-conflicts         1458
;  :arith-eq-adapter        243349
;  :arith-fixed-eqs         259533
;  :arith-offset-eqs        86029
;  :arith-pivots            70722
;  :conflicts               3589
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1958
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172284
;  :del-clause              2676699
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.85
;  :minimized-lits          399
;  :mk-bool-var             2959363
;  :mk-clause               2677327
;  :num-allocs              9423680
;  :num-checks              478
;  :propagations            901768
;  :quant-instantiations    1131534
;  :restarts                7
;  :rlimit-count            25952637)
(assert (< i1@367@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 16
; Joined path conditions
(assert (< i1@367@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
            V@39@07)
          (<=
            0
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))))
        $k@47@07
        $Perm.No)
      (pTaken@161@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)))
    (ite
      (and
        (<
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
          V@39@07)
        (<=
          0
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))))
      $k@134@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1545210
;  :arith-add-rows          305203
;  :arith-assert-diseq      54694
;  :arith-assert-lower      432316
;  :arith-assert-upper      354244
;  :arith-bound-prop        28072
;  :arith-conflicts         1460
;  :arith-eq-adapter        243373
;  :arith-fixed-eqs         259547
;  :arith-offset-eqs        86044
;  :arith-pivots            70745
;  :conflicts               3596
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1958
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172290
;  :del-clause              2676779
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.86
;  :minimized-lits          399
;  :mk-bool-var             2959605
;  :mk-clause               2677482
;  :num-allocs              9424994
;  :num-checks              479
;  :propagations            901802
;  :quant-instantiations    1131579
;  :restarts                7
;  :rlimit-count            25956963)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1545210
;  :arith-add-rows          305203
;  :arith-assert-diseq      54694
;  :arith-assert-lower      432316
;  :arith-assert-upper      354244
;  :arith-bound-prop        28072
;  :arith-conflicts         1460
;  :arith-eq-adapter        243373
;  :arith-fixed-eqs         259547
;  :arith-offset-eqs        86044
;  :arith-pivots            70745
;  :conflicts               3597
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1958
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172290
;  :del-clause              2676779
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.86
;  :minimized-lits          399
;  :mk-bool-var             2959605
;  :mk-clause               2677482
;  :num-allocs              9425085
;  :num-checks              480
;  :propagations            901802
;  :quant-instantiations    1131579
;  :restarts                7
;  :rlimit-count            25957058)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 222 | !(i1@367@07 < V@39@07 && 0 <= i1@367@07)]
(assert (not (and (< i1@367@07 V@39@07) (<= 0 i1@367@07))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@367@07 V@39@07) (<= 0 i1@367@07))
  (and
    (< i1@367@07 V@39@07)
    (<= 0 i1@367@07)
    (< i1@367@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@367@07 Int)) (!
  (implies
    (and (< i1@367@07 V@39@07) (<= 0 i1@367@07))
    (and
      (< i1@367@07 V@39@07)
      (<= 0 i1@367@07)
      (< i1@367@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@367@07 Int)) (!
    (implies
      (and (< i1@367@07 V@39@07) (<= 0 i1@367@07))
      (and
        (< i1@367@07 V@39@07)
        (<= 0 i1@367@07)
        (< i1@367@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@367@07 Int)) (!
    (implies
      (and (< i1@367@07 V@39@07) (<= 0 i1@367@07))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))))
        V@39@07))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1545614
;  :arith-add-rows          305311
;  :arith-assert-diseq      54700
;  :arith-assert-lower      432393
;  :arith-assert-upper      354295
;  :arith-bound-prop        28093
;  :arith-conflicts         1461
;  :arith-eq-adapter        243432
;  :arith-fixed-eqs         259598
;  :arith-offset-eqs        86094
;  :arith-pivots            70779
;  :conflicts               3615
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1962
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172314
;  :del-clause              2677278
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.88
;  :minimized-lits          399
;  :mk-bool-var             2960133
;  :mk-clause               2677906
;  :num-allocs              9427744
;  :num-checks              481
;  :propagations            901966
;  :quant-instantiations    1131791
;  :restarts                7
;  :rlimit-count            25969459
;  :time                    0.01)
(assert (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@367@07 Int)) (!
    (implies
      (and (< i1@367@07 V@39@07) (<= 0 i1@367@07))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07))))
        V@39@07))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@367@07)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1546730
;  :arith-add-rows          305766
;  :arith-assert-diseq      54721
;  :arith-assert-lower      432676
;  :arith-assert-upper      354477
;  :arith-bound-prop        28142
;  :arith-conflicts         1469
;  :arith-eq-adapter        243591
;  :arith-fixed-eqs         259750
;  :arith-offset-eqs        86200
;  :arith-pivots            70890
;  :conflicts               3623
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1966
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172498
;  :del-clause              2679786
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          400
;  :mk-bool-var             2962405
;  :mk-clause               2680414
;  :num-allocs              9433994
;  :num-checks              482
;  :propagations            902750
;  :quant-instantiations    1132472
;  :restarts                7
;  :rlimit-count            26001432
;  :time                    0.01)
; [then-branch: 223 | exc@116@07 == Null | live]
; [else-branch: 223 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 223 | exc@116@07 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@368@07 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@369@07 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 224 | 0 <= i1@368@07 | live]
; [else-branch: 224 | !(0 <= i1@368@07) | live]
(push) ; 16
; [then-branch: 224 | 0 <= i1@368@07]
(assert (<= 0 i1@368@07))
; [eval] i1 < V
(push) ; 17
; [then-branch: 225 | i1@368@07 < V@39@07 | live]
; [else-branch: 225 | !(i1@368@07 < V@39@07) | live]
(push) ; 18
; [then-branch: 225 | i1@368@07 < V@39@07]
(assert (< i1@368@07 V@39@07))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 226 | 0 <= i2@369@07 | live]
; [else-branch: 226 | !(0 <= i2@369@07) | live]
(push) ; 20
; [then-branch: 226 | 0 <= i2@369@07]
(assert (<= 0 i2@369@07))
; [eval] i2 < V
(push) ; 21
; [then-branch: 227 | i2@369@07 < V@39@07 | live]
; [else-branch: 227 | !(i2@369@07 < V@39@07) | live]
(push) ; 22
; [then-branch: 227 | i2@369@07 < V@39@07]
(assert (< i2@369@07 V@39@07))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1546730
;  :arith-add-rows          305766
;  :arith-assert-diseq      54721
;  :arith-assert-lower      432680
;  :arith-assert-upper      354477
;  :arith-bound-prop        28142
;  :arith-conflicts         1469
;  :arith-eq-adapter        243591
;  :arith-fixed-eqs         259750
;  :arith-offset-eqs        86200
;  :arith-pivots            70890
;  :conflicts               3623
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1966
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172498
;  :del-clause              2679786
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          400
;  :mk-bool-var             2962409
;  :mk-clause               2680414
;  :num-allocs              9434276
;  :num-checks              483
;  :propagations            902750
;  :quant-instantiations    1132472
;  :restarts                7
;  :rlimit-count            26001769)
(assert (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 23
; Joined path conditions
(assert (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
            V@39@07)
          (<=
            0
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))))
        $k@47@07
        $Perm.No)
      (pTaken@161@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)))
    (ite
      (and
        (<
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
          V@39@07)
        (<=
          0
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))))
      $k@134@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1547144
;  :arith-add-rows          305893
;  :arith-assert-diseq      54729
;  :arith-assert-lower      432769
;  :arith-assert-upper      354534
;  :arith-bound-prop        28169
;  :arith-conflicts         1472
;  :arith-eq-adapter        243657
;  :arith-fixed-eqs         259806
;  :arith-offset-eqs        86253
;  :arith-pivots            70914
;  :conflicts               3642
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1970
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172521
;  :del-clause              2680181
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          400
;  :mk-bool-var             2963057
;  :mk-clause               2680884
;  :num-allocs              9436915
;  :num-checks              484
;  :propagations            902914
;  :quant-instantiations    1132673
;  :restarts                7
;  :rlimit-count            26011806
;  :time                    0.00)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1547144
;  :arith-add-rows          305893
;  :arith-assert-diseq      54729
;  :arith-assert-lower      432769
;  :arith-assert-upper      354534
;  :arith-bound-prop        28169
;  :arith-conflicts         1472
;  :arith-eq-adapter        243657
;  :arith-fixed-eqs         259806
;  :arith-offset-eqs        86253
;  :arith-pivots            70914
;  :conflicts               3642
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1970
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172521
;  :del-clause              2680181
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          400
;  :mk-bool-var             2963057
;  :mk-clause               2680884
;  :num-allocs              9436942
;  :num-checks              485
;  :propagations            902914
;  :quant-instantiations    1132673
;  :restarts                7
;  :rlimit-count            26011836)
(assert (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 23
; Joined path conditions
(assert (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))
            V@39@07)
          (<=
            0
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))))
        $k@47@07
        $Perm.No)
      (pTaken@161@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
    (ite
      (and
        (<
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))
          V@39@07)
        (<=
          0
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))))
      $k@134@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1547667
;  :arith-add-rows          306205
;  :arith-assert-diseq      54748
;  :arith-assert-lower      432907
;  :arith-assert-upper      354605
;  :arith-bound-prop        28215
;  :arith-conflicts         1477
;  :arith-eq-adapter        243765
;  :arith-fixed-eqs         259870
;  :arith-offset-eqs        86331
;  :arith-pivots            70958
;  :conflicts               3665
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1974
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172551
;  :del-clause              2680801
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.95
;  :minimized-lits          400
;  :mk-bool-var             2964041
;  :mk-clause               2681609
;  :num-allocs              9440616
;  :num-checks              486
;  :propagations            903198
;  :quant-instantiations    1132884
;  :restarts                7
;  :rlimit-count            26025144
;  :time                    0.00)
(pop) ; 22
(push) ; 22
; [else-branch: 227 | !(i2@369@07 < V@39@07)]
(assert (not (< i2@369@07 V@39@07)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@369@07 V@39@07)
  (and
    (< i2@369@07 V@39@07)
    (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
    (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 226 | !(0 <= i2@369@07)]
(assert (not (<= 0 i2@369@07)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@369@07)
  (and
    (<= 0 i2@369@07)
    (implies
      (< i2@369@07 V@39@07)
      (and
        (< i2@369@07 V@39@07)
        (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
        (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 225 | !(i1@368@07 < V@39@07)]
(assert (not (< i1@368@07 V@39@07)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@368@07 V@39@07)
  (and
    (< i1@368@07 V@39@07)
    (implies
      (<= 0 i2@369@07)
      (and
        (<= 0 i2@369@07)
        (implies
          (< i2@369@07 V@39@07)
          (and
            (< i2@369@07 V@39@07)
            (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
            (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 224 | !(0 <= i1@368@07)]
(assert (not (<= 0 i1@368@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@368@07)
  (and
    (<= 0 i1@368@07)
    (implies
      (< i1@368@07 V@39@07)
      (and
        (< i1@368@07 V@39@07)
        (implies
          (<= 0 i2@369@07)
          (and
            (<= 0 i2@369@07)
            (implies
              (< i2@369@07 V@39@07)
              (and
                (< i2@369@07 V@39@07)
                (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 228 | Lookup(option$array$,sm@363@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@368@07)) == Lookup(option$array$,sm@363@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@369@07)) && i2@369@07 < V@39@07 && 0 <= i2@369@07 && i1@368@07 < V@39@07 && 0 <= i1@368@07 | live]
; [else-branch: 228 | !(Lookup(option$array$,sm@363@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@368@07)) == Lookup(option$array$,sm@363@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@369@07)) && i2@369@07 < V@39@07 && 0 <= i2@369@07 && i1@368@07 < V@39@07 && 0 <= i1@368@07) | live]
(push) ; 16
; [then-branch: 228 | Lookup(option$array$,sm@363@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@368@07)) == Lookup(option$array$,sm@363@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@369@07)) && i2@369@07 < V@39@07 && 0 <= i2@369@07 && i1@368@07 < V@39@07 && 0 <= i1@368@07]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
          ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
        (< i2@369@07 V@39@07))
      (<= 0 i2@369@07))
    (< i1@368@07 V@39@07))
  (<= 0 i1@368@07)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 228 | !(Lookup(option$array$,sm@363@07,aloc((_, _), opt_get1(_, Gf@38@07), i1@368@07)) == Lookup(option$array$,sm@363@07,aloc((_, _), opt_get1(_, Gf@38@07), i2@369@07)) && i2@369@07 < V@39@07 && 0 <= i2@369@07 && i1@368@07 < V@39@07 && 0 <= i1@368@07)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
            ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
          (< i2@369@07 V@39@07))
        (<= 0 i2@369@07))
      (< i1@368@07 V@39@07))
    (<= 0 i1@368@07))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
            ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
          (< i2@369@07 V@39@07))
        (<= 0 i2@369@07))
      (< i1@368@07 V@39@07))
    (<= 0 i1@368@07))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
      ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
    (< i2@369@07 V@39@07)
    (<= 0 i2@369@07)
    (< i1@368@07 V@39@07)
    (<= 0 i1@368@07))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@369@07 Int)) (!
  (and
    (implies
      (<= 0 i1@368@07)
      (and
        (<= 0 i1@368@07)
        (implies
          (< i1@368@07 V@39@07)
          (and
            (< i1@368@07 V@39@07)
            (implies
              (<= 0 i2@369@07)
              (and
                (<= 0 i2@369@07)
                (implies
                  (< i2@369@07 V@39@07)
                  (and
                    (< i2@369@07 V@39@07)
                    (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                    (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
              (< i2@369@07 V@39@07))
            (<= 0 i2@369@07))
          (< i1@368@07 V@39@07))
        (<= 0 i1@368@07))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
          ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
        (< i2@369@07 V@39@07)
        (<= 0 i2@369@07)
        (< i1@368@07 V@39@07)
        (<= 0 i1@368@07))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@368@07 Int)) (!
  (forall ((i2@369@07 Int)) (!
    (and
      (implies
        (<= 0 i1@368@07)
        (and
          (<= 0 i1@368@07)
          (implies
            (< i1@368@07 V@39@07)
            (and
              (< i1@368@07 V@39@07)
              (implies
                (<= 0 i2@369@07)
                (and
                  (<= 0 i2@369@07)
                  (implies
                    (< i2@369@07 V@39@07)
                    (and
                      (< i2@369@07 V@39@07)
                      (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                      (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                  ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
                (< i2@369@07 V@39@07))
              (<= 0 i2@369@07))
            (< i1@368@07 V@39@07))
          (<= 0 i1@368@07))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
            ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
          (< i2@369@07 V@39@07)
          (<= 0 i2@369@07)
          (< i1@368@07 V@39@07)
          (<= 0 i1@368@07))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@368@07 Int)) (!
    (forall ((i2@369@07 Int)) (!
      (and
        (implies
          (<= 0 i1@368@07)
          (and
            (<= 0 i1@368@07)
            (implies
              (< i1@368@07 V@39@07)
              (and
                (< i1@368@07 V@39@07)
                (implies
                  (<= 0 i2@369@07)
                  (and
                    (<= 0 i2@369@07)
                    (implies
                      (< i2@369@07 V@39@07)
                      (and
                        (< i2@369@07 V@39@07)
                        (< i1@368@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                        (< i2@369@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                    ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
                  (< i2@369@07 V@39@07))
                (<= 0 i2@369@07))
              (< i1@368@07 V@39@07))
            (<= 0 i1@368@07))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
              ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
            (< i2@369@07 V@39@07)
            (<= 0 i2@369@07)
            (< i1@368@07 V@39@07)
            (<= 0 i1@368@07))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@368@07 Int)) (!
    (forall ((i2@369@07 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                  ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
                (< i2@369@07 V@39@07))
              (<= 0 i2@369@07))
            (< i1@368@07 V@39@07))
          (<= 0 i1@368@07))
        (= i1@368@07 i2@369@07))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1548118
;  :arith-add-rows          306360
;  :arith-assert-diseq      54754
;  :arith-assert-lower      432995
;  :arith-assert-upper      354664
;  :arith-bound-prop        28252
;  :arith-conflicts         1479
;  :arith-eq-adapter        243833
;  :arith-fixed-eqs         259929
;  :arith-offset-eqs        86397
;  :arith-pivots            71019
;  :conflicts               3683
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1978
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172576
;  :del-clause              2681525
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.92
;  :minimized-lits          400
;  :mk-bool-var             2964751
;  :mk-clause               2682153
;  :num-allocs              9444355
;  :num-checks              487
;  :propagations            903395
;  :quant-instantiations    1133140
;  :restarts                7
;  :rlimit-count            26041494
;  :time                    0.00)
(assert (implies
  (= exc@116@07 $Ref.null)
  (forall ((i1@368@07 Int)) (!
    (forall ((i2@369@07 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
                  ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07)))
                (< i2@369@07 V@39@07))
              (<= 0 i2@369@07))
            (< i1@368@07 V@39@07))
          (<= 0 i1@368@07))
        (= i1@368@07 i2@369@07))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i2@369@07))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@368@07))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> p != (None(): option[array])
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1549090
;  :arith-add-rows          306778
;  :arith-assert-diseq      54802
;  :arith-assert-lower      433330
;  :arith-assert-upper      354829
;  :arith-bound-prop        28300
;  :arith-conflicts         1488
;  :arith-eq-adapter        243996
;  :arith-fixed-eqs         260054
;  :arith-offset-eqs        86479
;  :arith-pivots            71096
;  :conflicts               3694
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1982
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172773
;  :del-clause              2683732
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          404
;  :mk-bool-var             2966653
;  :mk-clause               2684360
;  :num-allocs              9449151
;  :num-checks              488
;  :propagations            904075
;  :quant-instantiations    1133619
;  :restarts                7
;  :rlimit-count            26067803
;  :time                    0.01)
; [then-branch: 229 | exc@116@07 == Null | live]
; [else-branch: 229 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 229 | exc@116@07 == Null]
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@116@07 $Ref.null)
  (not (= p@42@07 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1549090
;  :arith-add-rows          306778
;  :arith-assert-diseq      54802
;  :arith-assert-lower      433330
;  :arith-assert-upper      354829
;  :arith-bound-prop        28300
;  :arith-conflicts         1488
;  :arith-eq-adapter        243996
;  :arith-fixed-eqs         260054
;  :arith-offset-eqs        86479
;  :arith-pivots            71096
;  :conflicts               3694
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1982
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               172773
;  :del-clause              2683732
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          404
;  :mk-bool-var             2966653
;  :mk-clause               2684360
;  :num-allocs              9449176
;  :num-checks              489
;  :propagations            904075
;  :quant-instantiations    1133619
;  :restarts                7
;  :rlimit-count            26067823)
(assert (implies
  (= exc@116@07 $Ref.null)
  (not (= p@42@07 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(p)) == V
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1550309
;  :arith-add-rows          307316
;  :arith-assert-diseq      54864
;  :arith-assert-lower      433761
;  :arith-assert-upper      355034
;  :arith-bound-prop        28359
;  :arith-conflicts         1498
;  :arith-eq-adapter        244198
;  :arith-fixed-eqs         260208
;  :arith-offset-eqs        86592
;  :arith-pivots            71205
;  :conflicts               3707
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1986
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               173035
;  :del-clause              2686469
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          410
;  :mk-bool-var             2969054
;  :mk-clause               2687097
;  :num-allocs              9454758
;  :num-checks              490
;  :propagations            904961
;  :quant-instantiations    1134226
;  :restarts                7
;  :rlimit-count            26099994
;  :time                    0.01)
; [then-branch: 230 | exc@116@07 == Null | live]
; [else-branch: 230 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 230 | exc@116@07 == Null]
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@116@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit p@42@07)) V@39@07))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1550309
;  :arith-add-rows          307316
;  :arith-assert-diseq      54864
;  :arith-assert-lower      433761
;  :arith-assert-upper      355034
;  :arith-bound-prop        28359
;  :arith-conflicts         1498
;  :arith-eq-adapter        244198
;  :arith-fixed-eqs         260208
;  :arith-offset-eqs        86592
;  :arith-pivots            71205
;  :conflicts               3707
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1986
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               173035
;  :del-clause              2686469
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          410
;  :mk-bool-var             2969054
;  :mk-clause               2687097
;  :num-allocs              9454777
;  :num-checks              491
;  :propagations            904961
;  :quant-instantiations    1134226
;  :restarts                7
;  :rlimit-count            26100019)
(assert (implies
  (= exc@116@07 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit p@42@07)) V@39@07)))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1551326
;  :arith-add-rows          307726
;  :arith-assert-diseq      54905
;  :arith-assert-lower      434112
;  :arith-assert-upper      355206
;  :arith-bound-prop        28408
;  :arith-conflicts         1508
;  :arith-eq-adapter        244366
;  :arith-fixed-eqs         260337
;  :arith-offset-eqs        86674
;  :arith-pivots            71280
;  :conflicts               3719
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1990
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               173250
;  :del-clause              2689034
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          414
;  :mk-bool-var             2971189
;  :mk-clause               2689662
;  :num-allocs              9459447
;  :num-checks              492
;  :propagations            905722
;  :quant-instantiations    1134744
;  :restarts                7
;  :rlimit-count            26127012
;  :time                    0.01)
; [then-branch: 231 | exc@116@07 == Null | live]
; [else-branch: 231 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 231 | exc@116@07 == Null]
; [eval] 0 <= s
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 11
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1552342
;  :arith-add-rows          308149
;  :arith-assert-diseq      54931
;  :arith-assert-lower      434412
;  :arith-assert-upper      355372
;  :arith-bound-prop        28464
;  :arith-conflicts         1517
;  :arith-eq-adapter        244520
;  :arith-fixed-eqs         260474
;  :arith-offset-eqs        86782
;  :arith-pivots            71375
;  :conflicts               3728
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1994
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               173415
;  :del-clause              2691115
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          414
;  :mk-bool-var             2973149
;  :mk-clause               2691743
;  :num-allocs              9464711
;  :num-checks              493
;  :propagations            906422
;  :quant-instantiations    1135319
;  :restarts                7
;  :rlimit-count            26155141
;  :time                    0.01)
; [then-branch: 232 | exc@116@07 == Null | live]
; [else-branch: 232 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 232 | exc@116@07 == Null]
; [eval] s < V
(pop) ; 12
(pop) ; 11
; Joined path conditions
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 11
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1553291
;  :arith-add-rows          308584
;  :arith-assert-diseq      54950
;  :arith-assert-lower      434657
;  :arith-assert-upper      355524
;  :arith-bound-prop        28514
;  :arith-conflicts         1525
;  :arith-eq-adapter        244661
;  :arith-fixed-eqs         260603
;  :arith-offset-eqs        86871
;  :arith-pivots            71479
;  :conflicts               3736
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1998
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               173569
;  :del-clause              2693235
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          415
;  :mk-bool-var             2975136
;  :mk-clause               2693863
;  :num-allocs              9470038
;  :num-checks              494
;  :propagations            907048
;  :quant-instantiations    1135903
;  :restarts                7
;  :rlimit-count            26183353
;  :time                    0.01)
; [then-branch: 233 | exc@116@07 == Null | live]
; [else-branch: 233 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 233 | exc@116@07 == Null]
; [eval] 0 <= t
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies (= exc@116@07 $Ref.null) (<= 0 t@41@07))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1553291
;  :arith-add-rows          308584
;  :arith-assert-diseq      54950
;  :arith-assert-lower      434657
;  :arith-assert-upper      355524
;  :arith-bound-prop        28514
;  :arith-conflicts         1525
;  :arith-eq-adapter        244661
;  :arith-fixed-eqs         260603
;  :arith-offset-eqs        86871
;  :arith-pivots            71479
;  :conflicts               3736
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 1998
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               173569
;  :del-clause              2693235
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          415
;  :mk-bool-var             2975136
;  :mk-clause               2693863
;  :num-allocs              9470061
;  :num-checks              495
;  :propagations            907048
;  :quant-instantiations    1135903
;  :restarts                7
;  :rlimit-count            26183379)
(assert (implies (= exc@116@07 $Ref.null) (<= 0 t@41@07)))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1554464
;  :arith-add-rows          309066
;  :arith-assert-diseq      54998
;  :arith-assert-lower      435045
;  :arith-assert-upper      355720
;  :arith-bound-prop        28586
;  :arith-conflicts         1537
;  :arith-eq-adapter        244855
;  :arith-fixed-eqs         260743
;  :arith-offset-eqs        86994
;  :arith-pivots            71589
;  :conflicts               3748
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 2002
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               173813
;  :del-clause              2696315
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          415
;  :mk-bool-var             2977698
;  :mk-clause               2696943
;  :num-allocs              9475943
;  :num-checks              496
;  :propagations            908021
;  :quant-instantiations    1136532
;  :restarts                7
;  :rlimit-count            26216234
;  :time                    0.01)
; [then-branch: 234 | exc@116@07 == Null | live]
; [else-branch: 234 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 234 | exc@116@07 == Null]
; [eval] t < V
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies (= exc@116@07 $Ref.null) (< t@41@07 V@39@07))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1554464
;  :arith-add-rows          309066
;  :arith-assert-diseq      54998
;  :arith-assert-lower      435045
;  :arith-assert-upper      355720
;  :arith-bound-prop        28586
;  :arith-conflicts         1537
;  :arith-eq-adapter        244855
;  :arith-fixed-eqs         260743
;  :arith-offset-eqs        86994
;  :arith-pivots            71589
;  :conflicts               3748
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 2002
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               173813
;  :del-clause              2696315
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.93
;  :minimized-lits          415
;  :mk-bool-var             2977698
;  :mk-clause               2696943
;  :num-allocs              9475972
;  :num-checks              497
;  :propagations            908021
;  :quant-instantiations    1136532
;  :restarts                7
;  :rlimit-count            26216263)
(assert (implies (= exc@116@07 $Ref.null) (< t@41@07 V@39@07)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555730
;  :arith-add-rows          309623
;  :arith-assert-diseq      55025
;  :arith-assert-lower      435367
;  :arith-assert-upper      355923
;  :arith-bound-prop        28641
;  :arith-conflicts         1548
;  :arith-eq-adapter        245032
;  :arith-fixed-eqs         260903
;  :arith-offset-eqs        87157
;  :arith-pivots            71709
;  :conflicts               3759
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 2006
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               174037
;  :del-clause              2699114
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.86
;  :minimized-lits          415
;  :mk-bool-var             2980238
;  :mk-clause               2699742
;  :num-allocs              9482329
;  :num-checks              498
;  :propagations            908937
;  :quant-instantiations    1137275
;  :restarts                7
;  :rlimit-count            26251089
;  :time                    0.01)
; [then-branch: 235 | exc@116@07 == Null | live]
; [else-branch: 235 | exc@116@07 != Null | dead]
(push) ; 11
; [then-branch: 235 | exc@116@07 == Null]
(declare-const i1@370@07 Int)
(declare-const j1@371@07 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 236 | 0 <= i1@370@07 | live]
; [else-branch: 236 | !(0 <= i1@370@07) | live]
(push) ; 14
; [then-branch: 236 | 0 <= i1@370@07]
(assert (<= 0 i1@370@07))
; [eval] i1 < V
(push) ; 15
; [then-branch: 237 | i1@370@07 < V@39@07 | live]
; [else-branch: 237 | !(i1@370@07 < V@39@07) | live]
(push) ; 16
; [then-branch: 237 | i1@370@07 < V@39@07]
(assert (< i1@370@07 V@39@07))
; [eval] 0 <= j1
(push) ; 17
; [then-branch: 238 | 0 <= j1@371@07 | live]
; [else-branch: 238 | !(0 <= j1@371@07) | live]
(push) ; 18
; [then-branch: 238 | 0 <= j1@371@07]
(assert (<= 0 j1@371@07))
; [eval] j1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 238 | !(0 <= j1@371@07)]
(assert (not (<= 0 j1@371@07)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 237 | !(i1@370@07 < V@39@07)]
(assert (not (< i1@370@07 V@39@07)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 236 | !(0 <= i1@370@07)]
(assert (not (<= 0 i1@370@07)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@371@07 V@39@07) (<= 0 j1@371@07)) (< i1@370@07 V@39@07))
  (<= 0 i1@370@07)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@370@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555730
;  :arith-add-rows          309623
;  :arith-assert-diseq      55025
;  :arith-assert-lower      435373
;  :arith-assert-upper      355923
;  :arith-bound-prop        28641
;  :arith-conflicts         1548
;  :arith-eq-adapter        245032
;  :arith-fixed-eqs         260903
;  :arith-offset-eqs        87157
;  :arith-pivots            71709
;  :conflicts               3759
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 2006
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               174037
;  :del-clause              2699114
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.86
;  :minimized-lits          415
;  :mk-bool-var             2980244
;  :mk-clause               2699742
;  :num-allocs              9482606
;  :num-checks              499
;  :propagations            908937
;  :quant-instantiations    1137275
;  :restarts                7
;  :rlimit-count            26251560)
(assert (< i1@370@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(pop) ; 13
; Joined path conditions
(assert (< i1@370@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07)))
(push) ; 13
(assert (not (<
  $Perm.No
  (+
    (-
      (ite
        (and
          (<
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))
            V@39@07)
          (<=
            0
            (inv@48@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))))
        $k@47@07
        $Perm.No)
      (pTaken@161@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07)))
    (ite
      (and
        (<
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))
          V@39@07)
        (<=
          0
          (inv@135@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))))
      $k@134@07
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555827
;  :arith-add-rows          309713
;  :arith-assert-diseq      55033
;  :arith-assert-lower      435410
;  :arith-assert-upper      355942
;  :arith-bound-prop        28667
;  :arith-conflicts         1551
;  :arith-eq-adapter        245060
;  :arith-fixed-eqs         260916
;  :arith-offset-eqs        87172
;  :arith-pivots            71735
;  :conflicts               3767
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 2006
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               174048
;  :del-clause              2699239
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.87
;  :minimized-lits          415
;  :mk-bool-var             2980519
;  :mk-clause               2699942
;  :num-allocs              9484042
;  :num-checks              500
;  :propagations            908984
;  :quant-instantiations    1137327
;  :restarts                7
;  :rlimit-count            26257140
;  :time                    0.00)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 14
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555827
;  :arith-add-rows          309713
;  :arith-assert-diseq      55033
;  :arith-assert-lower      435410
;  :arith-assert-upper      355942
;  :arith-bound-prop        28667
;  :arith-conflicts         1551
;  :arith-eq-adapter        245060
;  :arith-fixed-eqs         260916
;  :arith-offset-eqs        87172
;  :arith-pivots            71735
;  :conflicts               3768
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 2006
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               174048
;  :del-clause              2699239
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.87
;  :minimized-lits          415
;  :mk-bool-var             2980519
;  :mk-clause               2699942
;  :num-allocs              9484133
;  :num-checks              501
;  :propagations            908984
;  :quant-instantiations    1137327
;  :restarts                7
;  :rlimit-count            26257235)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))
    (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))
    (as None<option<array>>  option<array>))))
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (<
  j1@371@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07)))))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555833
;  :arith-add-rows          309718
;  :arith-assert-diseq      55033
;  :arith-assert-lower      435412
;  :arith-assert-upper      355944
;  :arith-bound-prop        28667
;  :arith-conflicts         1552
;  :arith-eq-adapter        245061
;  :arith-fixed-eqs         260917
;  :arith-offset-eqs        87172
;  :arith-pivots            71739
;  :conflicts               3769
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 2006
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               174048
;  :del-clause              2699243
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.87
;  :minimized-lits          415
;  :mk-bool-var             2980530
;  :mk-clause               2699946
;  :num-allocs              9484324
;  :num-checks              502
;  :propagations            908986
;  :quant-instantiations    1137334
;  :restarts                7
;  :rlimit-count            26257723)
(assert (<
  j1@371@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))))))
(pop) ; 13
; Joined path conditions
(assert (<
  j1@371@07
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))))))
(pop) ; 12
(declare-fun inv@372@07 ($Ref) Int)
(declare-fun inv@373@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@370@07 Int) (j1@371@07 Int)) (!
  (and
    (< i1@370@07 (alen<Int> (opt_get1 $Snap.unit Gf@38@07)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))
        (as None<option<array>>  option<array>)))
    (<
      j1@371@07
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))) j1@371@07))
  :qid |int-aux|)))
(declare-const sm@374@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@374@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@374@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef167|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@374@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@374@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef168|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@374@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef169|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@370@07 Int) (j11@371@07 Int) (i12@370@07 Int) (j12@371@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@371@07 V@39@07) (<= 0 j11@371@07))
            (< i11@370@07 V@39@07))
          (<= 0 i11@370@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@374@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@370@07))) j11@371@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@370@07))) j11@371@07)))
      (and
        (and
          (and
            (and (< j12@371@07 V@39@07) (<= 0 j12@371@07))
            (< i12@370@07 V@39@07))
          (<= 0 i12@370@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@374@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@370@07))) j12@371@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@370@07))) j12@371@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i11@370@07))) j11@371@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i12@370@07))) j12@371@07)))
    (and (= i11@370@07 i12@370@07) (= j11@371@07 j12@371@07)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1555915
;  :arith-add-rows          309748
;  :arith-assert-diseq      55033
;  :arith-assert-lower      435430
;  :arith-assert-upper      355950
;  :arith-bound-prop        28673
;  :arith-conflicts         1552
;  :arith-eq-adapter        245084
;  :arith-fixed-eqs         260923
;  :arith-offset-eqs        87172
;  :arith-pivots            71764
;  :conflicts               3770
;  :datatype-accessor-ax    645
;  :datatype-constructor-ax 2006
;  :datatype-occurs-check   1550
;  :datatype-splits         1361
;  :decisions               174048
;  :del-clause              2699584
;  :final-checks            204
;  :interface-eqs           46
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  40.89
;  :minimized-lits          415
;  :mk-bool-var             2981005
;  :mk-clause               2700212
;  :num-allocs              9487214
;  :num-checks              503
;  :propagations            909020
;  :quant-instantiations    1137487
;  :restarts                7
;  :rlimit-count            26268976
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@370@07 Int) (j1@371@07 Int)) (!
  (implies
    (and
      (and (and (< j1@371@07 V@39@07) (<= 0 j1@371@07)) (< i1@370@07 V@39@07))
      (<= 0 i1@370@07))
    (and
      (=
        (inv@372@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))) j1@371@07))
        i1@370@07)
      (=
        (inv@373@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))) j1@371@07))
        j1@371@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) i1@370@07))) j1@371@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@07 r) V@39@07) (<= 0 (inv@373@07 r)))
        (< (inv@372@07 r) V@39@07))
      (<= 0 (inv@372@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@363@07  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit Gf@38@07) (inv@372@07 r)))) (inv@373@07 r))
      r))
  :pattern ((inv@372@07 r))
  :pattern ((inv@373@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@07 r) V@39@07) (<= 0 (inv@373@07 r)))
        (< (inv@372@07 r) V@39@07))
      (<= 0 (inv@372@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@374@07  $FVF<Int>) r) r))
  :pattern ((inv@372@07 r) (inv@373@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@375@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@373@07 r) V@39@07) (<= 0 (inv@373@07 r)))
        (< (inv@372@07 r) V@39@07))
      (<= 0 (inv@372@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@376@07 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@373@07 r) V@39@07) (<= 0 (inv@373@07 r)))
        (< (inv@372@07 r) V@39@07))
      (<= 0 (inv@372@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
            (< (inv@143@07 r) V@39@07))
          (<= 0 (inv@143@07 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@375@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@375@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.08s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1564326
;  :arith-add-rows          312087
;  :arith-assert-diseq      55345
;  :arith-assert-lower      437775
;  :arith-assert-upper      357731
;  :arith-bound-prop        28975
;  :arith-conflicts         1591
;  :arith-eq-adapter        246566
;  :arith-fixed-eqs         261964
;  :arith-offset-eqs        87815
;  :arith-pivots            72744
;  :conflicts               3851
;  :datatype-accessor-ax    659
;  :datatype-constructor-ax 2055
;  :datatype-occurs-check   1624
;  :datatype-splits         1407
;  :decisions               175479
;  :del-clause              2714367
;  :final-checks            229
;  :interface-eqs           64
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.20
;  :minimized-lits          430
;  :mk-bool-var             2998117
;  :mk-clause               2715161
;  :num-allocs              9548279
;  :num-checks              505
;  :propagations            914493
;  :quant-instantiations    1143415
;  :restarts                7
;  :rlimit-count            26486853
;  :time                    0.08)
; Intermediate check if already taken enough permissions
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@07 r) V@39@07) (<= 0 (inv@373@07 r)))
        (< (inv@372@07 r) V@39@07))
      (<= 0 (inv@372@07 r)))
    (= (- $Perm.Write (pTaken@375@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1571644
;  :arith-add-rows          313935
;  :arith-assert-diseq      55649
;  :arith-assert-lower      439823
;  :arith-assert-upper      359429
;  :arith-bound-prop        29212
;  :arith-conflicts         1613
;  :arith-eq-adapter        247910
;  :arith-fixed-eqs         262846
;  :arith-offset-eqs        88459
;  :arith-pivots            73616
;  :conflicts               3907
;  :datatype-accessor-ax    676
;  :datatype-constructor-ax 2106
;  :datatype-occurs-check   1706
;  :datatype-splits         1464
;  :decisions               176632
;  :del-clause              2725677
;  :final-checks            256
;  :interface-eqs           83
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.22
;  :minimized-lits          438
;  :mk-bool-var             3011781
;  :mk-clause               2726471
;  :num-allocs              9598131
;  :num-checks              506
;  :propagations            919238
;  :quant-instantiations    1148345
;  :restarts                7
;  :rlimit-count            26666861
;  :time                    0.09)
; Chunk depleted?
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
            (< (inv@143@07 r) V@39@07))
          (<= 0 (inv@143@07 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@376@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.10s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1582350
;  :arith-add-rows          317195
;  :arith-assert-diseq      55976
;  :arith-assert-lower      443207
;  :arith-assert-upper      361356
;  :arith-bound-prop        29563
;  :arith-conflicts         1637
;  :arith-eq-adapter        249699
;  :arith-fixed-eqs         264517
;  :arith-offset-eqs        89681
;  :arith-pivots            74674
;  :conflicts               3960
;  :datatype-accessor-ax    693
;  :datatype-constructor-ax 2157
;  :datatype-occurs-check   1761
;  :datatype-splits         1521
;  :decisions               177634
;  :del-clause              2740217
;  :final-checks            274
;  :interface-eqs           93
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.39
;  :minimized-lits          444
;  :mk-bool-var             3027785
;  :mk-clause               2741011
;  :num-allocs              9649843
;  :num-checks              507
;  :propagations            926275
;  :quant-instantiations    1153804
;  :restarts                7
;  :rlimit-count            26870001
;  :time                    0.10)
; Intermediate check if already taken enough permissions
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@373@07 r) V@39@07) (<= 0 (inv@373@07 r)))
        (< (inv@372@07 r) V@39@07))
      (<= 0 (inv@372@07 r)))
    (= (- (- $Perm.Write (pTaken@375@07 r)) (pTaken@376@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1583147
;  :arith-add-rows          317528
;  :arith-assert-diseq      56009
;  :arith-assert-lower      443379
;  :arith-assert-upper      361482
;  :arith-bound-prop        29636
;  :arith-conflicts         1646
;  :arith-eq-adapter        249846
;  :arith-fixed-eqs         264623
;  :arith-offset-eqs        89821
;  :arith-pivots            74764
;  :conflicts               3985
;  :datatype-accessor-ax    693
;  :datatype-constructor-ax 2161
;  :datatype-occurs-check   1761
;  :datatype-splits         1521
;  :decisions               177669
;  :del-clause              2741028
;  :final-checks            274
;  :interface-eqs           93
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.34
;  :minimized-lits          445
;  :mk-bool-var             3028862
;  :mk-clause               2741822
;  :num-allocs              9653989
;  :num-checks              508
;  :propagations            926681
;  :quant-instantiations    1154075
;  :restarts                7
;  :rlimit-count            26888090
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1584139
;  :arith-add-rows          317757
;  :arith-assert-diseq      56028
;  :arith-assert-lower      443637
;  :arith-assert-upper      361637
;  :arith-bound-prop        29693
;  :arith-conflicts         1649
;  :arith-eq-adapter        250007
;  :arith-fixed-eqs         264759
;  :arith-offset-eqs        89927
;  :arith-pivots            74825
;  :conflicts               3991
;  :datatype-accessor-ax    693
;  :datatype-constructor-ax 2165
;  :datatype-occurs-check   1761
;  :datatype-splits         1521
;  :decisions               177775
;  :del-clause              2742905
;  :final-checks            274
;  :interface-eqs           93
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.32
;  :minimized-lits          447
;  :mk-bool-var             3030657
;  :mk-clause               2743699
;  :num-allocs              9659404
;  :num-checks              509
;  :propagations            927348
;  :quant-instantiations    1154694
;  :restarts                7
;  :rlimit-count            26914465
;  :time                    0.01)
; [then-branch: 239 | exc@116@07 == Null | live]
; [else-branch: 239 | exc@116@07 != Null | dead]
(push) ; 12
; [then-branch: 239 | exc@116@07 == Null]
(declare-const i1@377@07 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 240 | 0 <= i1@377@07 | live]
; [else-branch: 240 | !(0 <= i1@377@07) | live]
(push) ; 15
; [then-branch: 240 | 0 <= i1@377@07]
(assert (<= 0 i1@377@07))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 240 | !(0 <= i1@377@07)]
(assert (not (<= 0 i1@377@07)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< i1@377@07 V@39@07) (<= 0 i1@377@07)))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@377@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1584139
;  :arith-add-rows          317757
;  :arith-assert-diseq      56028
;  :arith-assert-lower      443639
;  :arith-assert-upper      361637
;  :arith-bound-prop        29693
;  :arith-conflicts         1649
;  :arith-eq-adapter        250007
;  :arith-fixed-eqs         264759
;  :arith-offset-eqs        89927
;  :arith-pivots            74825
;  :conflicts               3991
;  :datatype-accessor-ax    693
;  :datatype-constructor-ax 2165
;  :datatype-occurs-check   1761
;  :datatype-splits         1521
;  :decisions               177775
;  :del-clause              2742905
;  :final-checks            274
;  :interface-eqs           93
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.32
;  :minimized-lits          447
;  :mk-bool-var             3030659
;  :mk-clause               2743699
;  :num-allocs              9659508
;  :num-checks              510
;  :propagations            927348
;  :quant-instantiations    1154694
;  :restarts                7
;  :rlimit-count            26914650)
(assert (< i1@377@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 14
; Joined path conditions
(assert (< i1@377@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 13
(declare-fun inv@378@07 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@377@07 Int)) (!
  (< i1@377@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@377@07))
  :qid |int-aux|)))
(declare-const sm@379@07 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
              (< (inv@143@07 r) V@39@07))
            (<= 0 (inv@143@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@376@07 r)))
    (=
      ($FVF.lookup_int (as sm@379@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@379@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef170|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@375@07 r)))
    (=
      ($FVF.lookup_int (as sm@379@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@379@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef171|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@379@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef172|)))
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@377@07 Int) (i12@377@07 Int)) (!
  (implies
    (and
      (and
        (and (< i11@377@07 V@39@07) (<= 0 i11@377@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@379@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@377@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@377@07)))
      (and
        (and (< i12@377@07 V@39@07) (<= 0 i12@377@07))
        ($FVF.loc_int ($FVF.lookup_int (as sm@379@07  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@377@07)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@377@07)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@377@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@377@07)))
    (= i11@377@07 i12@377@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1584164
;  :arith-add-rows          317759
;  :arith-assert-diseq      56029
;  :arith-assert-lower      443643
;  :arith-assert-upper      361637
;  :arith-bound-prop        29693
;  :arith-conflicts         1649
;  :arith-eq-adapter        250008
;  :arith-fixed-eqs         264759
;  :arith-offset-eqs        89927
;  :arith-pivots            74825
;  :conflicts               3992
;  :datatype-accessor-ax    693
;  :datatype-constructor-ax 2165
;  :datatype-occurs-check   1761
;  :datatype-splits         1521
;  :decisions               177775
;  :del-clause              2742941
;  :final-checks            274
;  :interface-eqs           93
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.32
;  :minimized-lits          447
;  :mk-bool-var             3030732
;  :mk-clause               2743735
;  :num-allocs              9660893
;  :num-checks              511
;  :propagations            927350
;  :quant-instantiations    1154734
;  :restarts                7
;  :rlimit-count            26919209)
; Definitional axioms for inverse functions
(assert (forall ((i1@377@07 Int)) (!
  (implies
    (and (< i1@377@07 V@39@07) (<= 0 i1@377@07))
    (=
      (inv@378@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@377@07))
      i1@377@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@377@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@378@07 r) V@39@07) (<= 0 (inv@378@07 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@378@07 r))
      r))
  :pattern ((inv@378@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@378@07 r) V@39@07) (<= 0 (inv@378@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@379@07  $FVF<Int>) r) r))
  :pattern ((inv@378@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@380@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@378@07 r) V@39@07) (<= 0 (inv@378@07 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
              (< (inv@143@07 r) V@39@07))
            (<= 0 (inv@143@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@376@07 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@381@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@378@07 r) V@39@07) (<= 0 (inv@378@07 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@375@07 r))
      (- $Perm.Write (pTaken@380@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
              (< (inv@143@07 r) V@39@07))
            (<= 0 (inv@143@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@376@07 r))
      (pTaken@380@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1586496
;  :arith-add-rows          318809
;  :arith-assert-diseq      56100
;  :arith-assert-lower      444250
;  :arith-assert-upper      362056
;  :arith-bound-prop        29818
;  :arith-conflicts         1664
;  :arith-eq-adapter        250459
;  :arith-fixed-eqs         265116
;  :arith-offset-eqs        90194
;  :arith-pivots            75118
;  :conflicts               4036
;  :datatype-accessor-ax    693
;  :datatype-constructor-ax 2173
;  :datatype-occurs-check   1761
;  :datatype-splits         1521
;  :decisions               177954
;  :del-clause              2747005
;  :final-checks            274
;  :interface-eqs           93
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.33
;  :minimized-lits          453
;  :mk-bool-var             3036593
;  :mk-clause               2747864
;  :num-allocs              9682950
;  :num-checks              513
;  :propagations            928780
;  :quant-instantiations    1156097
;  :restarts                7
;  :rlimit-count            26985789
;  :time                    0.02)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@378@07 r) V@39@07) (<= 0 (inv@378@07 r)))
    (= (- $Perm.Write (pTaken@380@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 13
; 0.13s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1596307
;  :arith-add-rows          321348
;  :arith-assert-diseq      56489
;  :arith-assert-lower      447006
;  :arith-assert-upper      364427
;  :arith-bound-prop        30082
;  :arith-conflicts         1694
;  :arith-eq-adapter        252350
;  :arith-fixed-eqs         266391
;  :arith-offset-eqs        90926
;  :arith-pivots            76118
;  :conflicts               4103
;  :datatype-accessor-ax    707
;  :datatype-constructor-ax 2218
;  :datatype-occurs-check   1832
;  :datatype-splits         1567
;  :decisions               179463
;  :del-clause              2762804
;  :final-checks            298
;  :interface-eqs           110
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.40
;  :minimized-lits          463
;  :mk-bool-var             3056106
;  :mk-clause               2763663
;  :num-allocs              9753644
;  :num-checks              514
;  :propagations            934606
;  :quant-instantiations    1162703
;  :restarts                7
;  :rlimit-count            27204721
;  :time                    0.13)
; Chunk depleted?
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@375@07 r))
      (pTaken@381@07 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1599158
;  :arith-add-rows          322889
;  :arith-assert-diseq      56572
;  :arith-assert-lower      447727
;  :arith-assert-upper      364942
;  :arith-bound-prop        30211
;  :arith-conflicts         1715
;  :arith-eq-adapter        252889
;  :arith-fixed-eqs         266828
;  :arith-offset-eqs        91239
;  :arith-pivots            76522
;  :conflicts               4146
;  :datatype-accessor-ax    707
;  :datatype-constructor-ax 2222
;  :datatype-occurs-check   1832
;  :datatype-splits         1567
;  :decisions               179674
;  :del-clause              2767283
;  :final-checks            298
;  :interface-eqs           110
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.37
;  :minimized-lits          482
;  :mk-bool-var             3062060
;  :mk-clause               2768142
;  :num-allocs              9774528
;  :num-checks              515
;  :propagations            936372
;  :quant-instantiations    1164194
;  :restarts                7
;  :rlimit-count            27281717
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@378@07 r) V@39@07) (<= 0 (inv@378@07 r)))
    (= (- (- $Perm.Write (pTaken@380@07 r)) (pTaken@381@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1600478
;  :arith-add-rows          323650
;  :arith-assert-diseq      56633
;  :arith-assert-lower      448086
;  :arith-assert-upper      365182
;  :arith-bound-prop        30274
;  :arith-conflicts         1728
;  :arith-eq-adapter        253190
;  :arith-fixed-eqs         267014
;  :arith-offset-eqs        91413
;  :arith-pivots            76706
;  :conflicts               4183
;  :datatype-accessor-ax    707
;  :datatype-constructor-ax 2226
;  :datatype-occurs-check   1832
;  :datatype-splits         1567
;  :decisions               179755
;  :del-clause              2769193
;  :final-checks            298
;  :interface-eqs           110
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.36
;  :minimized-lits          489
;  :mk-bool-var             3065088
;  :mk-clause               2770052
;  :num-allocs              9786147
;  :num-checks              516
;  :propagations            937134
;  :quant-instantiations    1164775
;  :restarts                7
;  :rlimit-count            27320354
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> valid_graph_vertices(this, p, V)
; [eval] exc == null
(push) ; 13
(set-option :timeout 10)
(push) ; 14
(assert (not (not (= exc@116@07 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1601287
;  :arith-add-rows          323850
;  :arith-assert-diseq      56647
;  :arith-assert-lower      448292
;  :arith-assert-upper      365322
;  :arith-bound-prop        30305
;  :arith-conflicts         1730
;  :arith-eq-adapter        253325
;  :arith-fixed-eqs         267142
;  :arith-offset-eqs        91493
;  :arith-pivots            76794
;  :conflicts               4185
;  :datatype-accessor-ax    707
;  :datatype-constructor-ax 2230
;  :datatype-occurs-check   1832
;  :datatype-splits         1567
;  :decisions               179840
;  :del-clause              2770619
;  :final-checks            298
;  :interface-eqs           110
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.34
;  :minimized-lits          491
;  :mk-bool-var             3066615
;  :mk-clause               2771478
;  :num-allocs              9791162
;  :num-checks              517
;  :propagations            937636
;  :quant-instantiations    1165260
;  :restarts                7
;  :rlimit-count            27344109
;  :time                    0.01)
; [then-branch: 241 | exc@116@07 == Null | live]
; [else-branch: 241 | exc@116@07 != Null | dead]
(push) ; 14
; [then-branch: 241 | exc@116@07 == Null]
; [eval] valid_graph_vertices(this, p, V)
(push) ; 15
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@382@07 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 242 | 0 <= i1@382@07 | live]
; [else-branch: 242 | !(0 <= i1@382@07) | live]
(push) ; 18
; [then-branch: 242 | 0 <= i1@382@07]
(assert (<= 0 i1@382@07))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 242 | !(0 <= i1@382@07)]
(assert (not (<= 0 i1@382@07)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@382@07 V@39@07) (<= 0 i1@382@07)))
(declare-const $k@383@07 $Perm)
(assert ($Perm.isReadVar $k@383@07 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@382@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1601287
;  :arith-add-rows          323850
;  :arith-assert-diseq      56648
;  :arith-assert-lower      448296
;  :arith-assert-upper      365323
;  :arith-bound-prop        30305
;  :arith-conflicts         1730
;  :arith-eq-adapter        253326
;  :arith-fixed-eqs         267142
;  :arith-offset-eqs        91493
;  :arith-pivots            76794
;  :conflicts               4185
;  :datatype-accessor-ax    707
;  :datatype-constructor-ax 2230
;  :datatype-occurs-check   1832
;  :datatype-splits         1567
;  :decisions               179840
;  :del-clause              2770619
;  :final-checks            298
;  :interface-eqs           110
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.34
;  :minimized-lits          491
;  :mk-bool-var             3066621
;  :mk-clause               2771480
;  :num-allocs              9791335
;  :num-checks              518
;  :propagations            937637
;  :quant-instantiations    1165260
;  :restarts                7
;  :rlimit-count            27344443)
(assert (< i1@382@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 17
; Joined path conditions
(assert (< i1@382@07 (alen<Int> (opt_get1 $Snap.unit p@42@07))))
(pop) ; 16
(declare-fun inv@384@07 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@383@07 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@382@07 Int)) (!
  (< i1@382@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
  :qid |int-aux|)))
(push) ; 16
(assert (not (forall ((i1@382@07 Int)) (!
  (implies
    (and (< i1@382@07 V@39@07) (<= 0 i1@382@07))
    (or (= $k@383@07 $Perm.No) (< $Perm.No $k@383@07)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1601287
;  :arith-add-rows          323850
;  :arith-assert-diseq      56649
;  :arith-assert-lower      448298
;  :arith-assert-upper      365324
;  :arith-bound-prop        30305
;  :arith-conflicts         1730
;  :arith-eq-adapter        253327
;  :arith-fixed-eqs         267142
;  :arith-offset-eqs        91493
;  :arith-pivots            76794
;  :conflicts               4186
;  :datatype-accessor-ax    707
;  :datatype-constructor-ax 2230
;  :datatype-occurs-check   1832
;  :datatype-splits         1567
;  :decisions               179840
;  :del-clause              2770621
;  :final-checks            298
;  :interface-eqs           110
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.34
;  :minimized-lits          491
;  :mk-bool-var             3066628
;  :mk-clause               2771482
;  :num-allocs              9791766
;  :num-checks              519
;  :propagations            937638
;  :quant-instantiations    1165260
;  :restarts                7
;  :rlimit-count            27344989)
(declare-const sm@385@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef175|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@382@07 Int) (i12@382@07 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@382@07 V@39@07) (<= 0 i11@382@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@385@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@382@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@382@07)))
        (< $Perm.No $k@383@07))
      (and
        (and
          (and (< i12@382@07 V@39@07) (<= 0 i12@382@07))
          ($FVF.loc_int ($FVF.lookup_int (as sm@385@07  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@382@07)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@382@07)))
        (< $Perm.No $k@383@07))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i11@382@07)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i12@382@07)))
    (= i11@382@07 i12@382@07))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1601314
;  :arith-add-rows          323852
;  :arith-assert-diseq      56650
;  :arith-assert-lower      448302
;  :arith-assert-upper      365324
;  :arith-bound-prop        30305
;  :arith-conflicts         1730
;  :arith-eq-adapter        253328
;  :arith-fixed-eqs         267142
;  :arith-offset-eqs        91493
;  :arith-pivots            76794
;  :conflicts               4187
;  :datatype-accessor-ax    707
;  :datatype-constructor-ax 2230
;  :datatype-occurs-check   1832
;  :datatype-splits         1567
;  :decisions               179840
;  :del-clause              2770632
;  :final-checks            298
;  :interface-eqs           110
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.34
;  :minimized-lits          491
;  :mk-bool-var             3066679
;  :mk-clause               2771493
;  :num-allocs              9792820
;  :num-checks              520
;  :propagations            937640
;  :quant-instantiations    1165304
;  :restarts                7
;  :rlimit-count            27348217
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@382@07 Int)) (!
  (implies
    (and (and (< i1@382@07 V@39@07) (<= 0 i1@382@07)) (< $Perm.No $k@383@07))
    (=
      (inv@384@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
      i1@382@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
      (< $Perm.No $k@383@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@384@07 r))
      r))
  :pattern ((inv@384@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r) r))
  :pattern ((inv@384@07 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@386@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
            (< (inv@143@07 r) V@39@07))
          (<= 0 (inv@143@07 r)))
        $Perm.Write
        $Perm.No)
      $k@383@07)
    $Perm.No))
(define-fun pTaken@387@07 ((r $Ref)) $Perm
  (ite
    (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
    ($Perm.min
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        $Perm.Write
        $Perm.No)
      (- $k@383@07 (pTaken@386@07 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@383@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
              (< (inv@143@07 r) V@39@07))
            (<= 0 (inv@143@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r)))
      (<
        (ite
          (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
          $k@383@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
          $k@383@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@144@07 r))
  :pattern ((inv@143@07 r))
  :pattern ((inv@384@07 r))
  :qid |qp.srp176|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
    (= (- $k@383@07 (pTaken@386@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.20s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1616030
;  :arith-add-rows          328514
;  :arith-assert-diseq      57178
;  :arith-assert-lower      452262
;  :arith-assert-upper      368670
;  :arith-bound-prop        30650
;  :arith-conflicts         1763
;  :arith-eq-adapter        256054
;  :arith-fixed-eqs         269081
;  :arith-offset-eqs        92549
;  :arith-pivots            78086
;  :conflicts               4269
;  :datatype-accessor-ax    725
;  :datatype-constructor-ax 2287
;  :datatype-occurs-check   1883
;  :datatype-splits         1622
;  :decisions               181783
;  :del-clause              2793164
;  :final-checks            314
;  :interface-eqs           118
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.50
;  :minimized-lits          509
;  :mk-bool-var             3093716
;  :mk-clause               2794060
;  :num-allocs              9888696
;  :num-checks              522
;  :propagations            946758
;  :quant-instantiations    1174935
;  :restarts                7
;  :rlimit-count            27698130
;  :time                    0.20)
; Constrain original permissions $k@383@07
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
      (<
        (ite
          (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
          $k@383@07
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
          $k@383@07
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@147@07 r))
  :pattern ((inv@384@07 r))
  :qid |qp.srp177|)))
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
    (= (- (- $k@383@07 (pTaken@386@07 r)) (pTaken@387@07 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1616643
;  :arith-add-rows          328696
;  :arith-assert-diseq      57207
;  :arith-assert-lower      452386
;  :arith-assert-upper      368761
;  :arith-bound-prop        30665
;  :arith-conflicts         1769
;  :arith-eq-adapter        256188
;  :arith-fixed-eqs         269162
;  :arith-offset-eqs        92626
;  :arith-pivots            78125
;  :conflicts               4294
;  :datatype-accessor-ax    725
;  :datatype-constructor-ax 2291
;  :datatype-occurs-check   1883
;  :datatype-splits         1622
;  :decisions               181811
;  :del-clause              2793903
;  :final-checks            314
;  :interface-eqs           118
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.45
;  :minimized-lits          513
;  :mk-bool-var             3094568
;  :mk-clause               2794799
;  :num-allocs              9892254
;  :num-checks              523
;  :propagations            947132
;  :quant-instantiations    1175184
;  :restarts                7
;  :rlimit-count            27711686
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@388@07 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@388@07  $FVF<Int>)))
    (and
      (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
      (< $Perm.No $k@383@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@388@07  $FVF<Int>))))
  :qid |qp.fvfDomDef181|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
        (< $Perm.No $k@383@07))
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r))))
    (=
      ($FVF.lookup_int (as sm@388@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
        (< $Perm.No $k@383@07))
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r))))
    (=
      ($FVF.lookup_int (as sm@388@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef180|)))
(pop) ; 15
; Joined path conditions
(assert ($Perm.isReadVar $k@383@07 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (forall ((i1@382@07 Int)) (!
  (implies
    (and (and (< i1@382@07 V@39@07) (<= 0 i1@382@07)) (< $Perm.No $k@383@07))
    (=
      (inv@384@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
      i1@382@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
      (< $Perm.No $k@383@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@384@07 r))
      r))
  :pattern ((inv@384@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@388@07  $FVF<Int>)))
    (and
      (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
      (< $Perm.No $k@383@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@388@07  $FVF<Int>))))
  :qid |qp.fvfDomDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
        (< $Perm.No $k@383@07))
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r))))
    (=
      ($FVF.lookup_int (as sm@388@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
        (< $Perm.No $k@383@07))
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r))))
    (=
      ($FVF.lookup_int (as sm@388@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (and
  (forall ((i1@382@07 Int)) (!
    (< i1@382@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r) r))
    :pattern ((inv@384@07 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and
              (and
                (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
                (< (inv@143@07 r) V@39@07))
              (<= 0 (inv@143@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and
          (and
            (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
            (< (inv@143@07 r) V@39@07))
          (<= 0 (inv@143@07 r)))
        (<
          (ite
            (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
            $k@383@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
            $k@383@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@144@07 r))
    :pattern ((inv@143@07 r))
    :pattern ((inv@384@07 r))
    :qid |qp.srp176|))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
        (<
          (ite
            (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
            $k@383@07
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
            $k@383@07
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@147@07 r))
    :pattern ((inv@384@07 r))
    :qid |qp.srp177|))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert ($Perm.isReadVar $k@383@07 $Perm.Write))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
        (< (inv@143@07 r) V@39@07))
      (<= 0 (inv@143@07 r)))
    (=
      ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef173|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
    (=
      ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef174|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@385@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef175|)))
(assert (forall ((i1@382@07 Int)) (!
  (implies
    (and (and (< i1@382@07 V@39@07) (<= 0 i1@382@07)) (< $Perm.No $k@383@07))
    (=
      (inv@384@07 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
      i1@382@07))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
      (< $Perm.No $k@383@07))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) (inv@384@07 r))
      r))
  :pattern ((inv@384@07 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@388@07  $FVF<Int>)))
    (and
      (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
      (< $Perm.No $k@383@07)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@388@07  $FVF<Int>))))
  :qid |qp.fvfDomDef181|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
        (< $Perm.No $k@383@07))
      (and
        (and
          (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
          (< (inv@143@07 r) V@39@07))
        (<= 0 (inv@143@07 r))))
    (=
      ($FVF.lookup_int (as sm@388@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r))
  :qid |qp.fvfValDef178|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
        (< $Perm.No $k@383@07))
      (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r))))
    (=
      ($FVF.lookup_int (as sm@388@07  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r))
  :qid |qp.fvfValDef179|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@132@07)))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@388@07  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef180|)))
(assert (implies
  (= exc@116@07 $Ref.null)
  (and
    (forall ((i1@382@07 Int)) (!
      (< i1@382@07 (alen<Int> (opt_get1 $Snap.unit p@42@07)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@42@07) i1@382@07))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@385@07  $FVF<Int>) r) r))
      :pattern ((inv@384@07 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and
                (and
                  (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
                  (< (inv@143@07 r) V@39@07))
                (<= 0 (inv@143@07 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and
            (and
              (and (< (inv@144@07 r) V@39@07) (<= 0 (inv@144@07 r)))
              (< (inv@143@07 r) V@39@07))
            (<= 0 (inv@143@07 r)))
          (<
            (ite
              (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
              $k@383@07
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
              $k@383@07
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@144@07 r))
      :pattern ((inv@143@07 r))
      :pattern ((inv@384@07 r))
      :qid |qp.srp176|))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@147@07 r) V@39@07) (<= 0 (inv@147@07 r)))
          (<
            (ite
              (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
              $k@383@07
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@384@07 r) V@39@07) (<= 0 (inv@384@07 r)))
              $k@383@07
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@147@07 r))
      :pattern ((inv@384@07 r))
      :qid |qp.srp177|)))))
(set-option :timeout 0)
(push) ; 13
(assert (not (implies
  (= exc@116@07 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@388@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07))))
(check-sat)
; unsat
(pop) ; 13
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1619714
;  :arith-add-rows          329719
;  :arith-assert-diseq      57282
;  :arith-assert-lower      453193
;  :arith-assert-upper      369419
;  :arith-bound-prop        30796
;  :arith-conflicts         1779
;  :arith-eq-adapter        256705
;  :arith-fixed-eqs         269693
;  :arith-offset-eqs        92987
;  :arith-pivots            78511
;  :conflicts               4325
;  :datatype-accessor-ax    728
;  :datatype-constructor-ax 2295
;  :datatype-occurs-check   1883
;  :datatype-splits         1622
;  :decisions               182181
;  :del-clause              2802387
;  :final-checks            314
;  :interface-eqs           118
;  :max-generation          13
;  :max-memory              46.08
;  :memory                  41.70
;  :minimized-lits          517
;  :mk-bool-var             3104578
;  :mk-clause               2803248
;  :num-allocs              9926577
;  :num-checks              524
;  :propagations            949105
;  :quant-instantiations    1177438
;  :restarts                7
;  :rlimit-count            27796665
;  :time                    0.05)
(assert (implies
  (= exc@116@07 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@388@07  $FVF<Int>))))) this@36@07 p@42@07 V@39@07)))
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(push) ; 9
; [else-branch: 212 | |queue@129@07| != 0]
(assert (not (= (Seq_length queue@129@07) 0)))
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
