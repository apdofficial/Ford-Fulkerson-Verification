(get-info :version)
; (:version "4.8.6")
; Started: 2022-06-14 20:18:16
; Silicon.version: 1.1-SNAPSHOT (cd20cf02@(detached))
; Input file: -
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Boogie: default
(set-option :auto_config false) ; Usually a good idea
(set-option :smt.restart_strategy 0)
(set-option :smt.restart_factor |1.5|)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :smt.delay_units_threshold 16)
(set-option :nnf.sk_hack true)
(set-option :type_check true)
(set-option :smt.bv.reflect true)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.qi.cost "(+ weight generation)")
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :smt.phase_selection 0) ; default: 3, Boogie: 0
(set-option :sat.phase caching)
(set-option :sat.random_seed 0)
(set-option :nlsat.randomize true)
(set-option :nlsat.seed 0)
(set-option :nlsat.shuffle_vars false)
(set-option :fp.spacer.order_children 0) ; Not available with Z3 4.5
(set-option :fp.spacer.random_seed 0) ; Not available with Z3 4.5
(set-option :smt.arith.random_initial_value true) ; Boogie: true
(set-option :smt.random_seed 0)
(set-option :sls.random_offset true)
(set-option :sls.random_seed 0)
(set-option :sls.restart_init false)
(set-option :sls.walksat_ucb true)
(set-option :model.v2 true)
; 
; ; /preamble.smt2
(declare-datatypes () ((
    $Snap ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM)
(declare-sort $PPM)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm) (ub $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))
         (< p $Perm.Write)))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Seq<Int>>)
(declare-sort Seq<Int>)
(declare-sort Set<Seq<Seq<Int>>>)
(declare-sort Set<option<array>>)
(declare-sort Set<Seq<Int>>)
(declare-sort Set<Int>)
(declare-sort Set<Bool>)
(declare-sort Set<$Ref>)
(declare-sort Set<$Snap>)
(declare-sort t_null)
(declare-sort any)
(declare-sort void)
(declare-sort option<any>)
(declare-sort option<array>)
(declare-sort array)
(declare-sort $FVF<Int>)
(declare-sort $FVF<option<array>>)
(declare-sort $FVF<Bool>)
(declare-sort $FVF<Seq<Seq<Int>>>)
(declare-sort $FVF<Seq<Int>>)
(declare-sort $FVF<$Ref>)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Seq<Int>>To$Snap (Seq<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Seq<Int>> ($Snap) Seq<Seq<Int>>)
(assert (forall ((x Seq<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSeq<Seq<Int>>($SortWrappers.Seq<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Seq<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSeq<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Seq<Int>>To$Snap($SortWrappers.$SnapToSeq<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSeq<Seq<Int>> x))
    :qid |$Snap.Seq<Seq<Int>>To$SnapToSeq<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<Seq<Seq<Int>>>To$Snap (Set<Seq<Seq<Int>>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Seq<Seq<Int>>> ($Snap) Set<Seq<Seq<Int>>>)
(assert (forall ((x Set<Seq<Seq<Int>>>)) (!
    (= x ($SortWrappers.$SnapToSet<Seq<Seq<Int>>>($SortWrappers.Set<Seq<Seq<Int>>>To$Snap x)))
    :pattern (($SortWrappers.Set<Seq<Seq<Int>>>To$Snap x))
    :qid |$Snap.$SnapToSet<Seq<Seq<Int>>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Seq<Seq<Int>>>To$Snap($SortWrappers.$SnapToSet<Seq<Seq<Int>>> x)))
    :pattern (($SortWrappers.$SnapToSet<Seq<Seq<Int>>> x))
    :qid |$Snap.Set<Seq<Seq<Int>>>To$SnapToSet<Seq<Seq<Int>>>|
    )))
(declare-fun $SortWrappers.Set<option<array>>To$Snap (Set<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<option<array>> ($Snap) Set<option<array>>)
(assert (forall ((x Set<option<array>>)) (!
    (= x ($SortWrappers.$SnapToSet<option<array>>($SortWrappers.Set<option<array>>To$Snap x)))
    :pattern (($SortWrappers.Set<option<array>>To$Snap x))
    :qid |$Snap.$SnapToSet<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<option<array>>To$Snap($SortWrappers.$SnapToSet<option<array>> x)))
    :pattern (($SortWrappers.$SnapToSet<option<array>> x))
    :qid |$Snap.Set<option<array>>To$SnapToSet<option<array>>|
    )))
(declare-fun $SortWrappers.Set<Seq<Int>>To$Snap (Set<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Seq<Int>> ($Snap) Set<Seq<Int>>)
(assert (forall ((x Set<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapToSet<Seq<Int>>($SortWrappers.Set<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.Set<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapToSet<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Seq<Int>>To$Snap($SortWrappers.$SnapToSet<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapToSet<Seq<Int>> x))
    :qid |$Snap.Set<Seq<Int>>To$SnapToSet<Seq<Int>>|
    )))
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.t_nullTo$Snap (t_null) $Snap)
(declare-fun $SortWrappers.$SnapTot_null ($Snap) t_null)
(assert (forall ((x t_null)) (!
    (= x ($SortWrappers.$SnapTot_null($SortWrappers.t_nullTo$Snap x)))
    :pattern (($SortWrappers.t_nullTo$Snap x))
    :qid |$Snap.$SnapTot_nullTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.t_nullTo$Snap($SortWrappers.$SnapTot_null x)))
    :pattern (($SortWrappers.$SnapTot_null x))
    :qid |$Snap.t_nullTo$SnapTot_null|
    )))
(declare-fun $SortWrappers.anyTo$Snap (any) $Snap)
(declare-fun $SortWrappers.$SnapToany ($Snap) any)
(assert (forall ((x any)) (!
    (= x ($SortWrappers.$SnapToany($SortWrappers.anyTo$Snap x)))
    :pattern (($SortWrappers.anyTo$Snap x))
    :qid |$Snap.$SnapToanyTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.anyTo$Snap($SortWrappers.$SnapToany x)))
    :pattern (($SortWrappers.$SnapToany x))
    :qid |$Snap.anyTo$SnapToany|
    )))
(declare-fun $SortWrappers.voidTo$Snap (void) $Snap)
(declare-fun $SortWrappers.$SnapTovoid ($Snap) void)
(assert (forall ((x void)) (!
    (= x ($SortWrappers.$SnapTovoid($SortWrappers.voidTo$Snap x)))
    :pattern (($SortWrappers.voidTo$Snap x))
    :qid |$Snap.$SnapTovoidTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.voidTo$Snap($SortWrappers.$SnapTovoid x)))
    :pattern (($SortWrappers.$SnapTovoid x))
    :qid |$Snap.voidTo$SnapTovoid|
    )))
(declare-fun $SortWrappers.option<any>To$Snap (option<any>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<any> ($Snap) option<any>)
(assert (forall ((x option<any>)) (!
    (= x ($SortWrappers.$SnapTooption<any>($SortWrappers.option<any>To$Snap x)))
    :pattern (($SortWrappers.option<any>To$Snap x))
    :qid |$Snap.$SnapTooption<any>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<any>To$Snap($SortWrappers.$SnapTooption<any> x)))
    :pattern (($SortWrappers.$SnapTooption<any> x))
    :qid |$Snap.option<any>To$SnapTooption<any>|
    )))
(declare-fun $SortWrappers.option<array>To$Snap (option<array>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<array> ($Snap) option<array>)
(assert (forall ((x option<array>)) (!
    (= x ($SortWrappers.$SnapTooption<array>($SortWrappers.option<array>To$Snap x)))
    :pattern (($SortWrappers.option<array>To$Snap x))
    :qid |$Snap.$SnapTooption<array>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<array>To$Snap($SortWrappers.$SnapTooption<array> x)))
    :pattern (($SortWrappers.$SnapTooption<array> x))
    :qid |$Snap.option<array>To$SnapTooption<array>|
    )))
(declare-fun $SortWrappers.arrayTo$Snap (array) $Snap)
(declare-fun $SortWrappers.$SnapToarray ($Snap) array)
(assert (forall ((x array)) (!
    (= x ($SortWrappers.$SnapToarray($SortWrappers.arrayTo$Snap x)))
    :pattern (($SortWrappers.arrayTo$Snap x))
    :qid |$Snap.$SnapToarrayTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.arrayTo$Snap($SortWrappers.$SnapToarray x)))
    :pattern (($SortWrappers.$SnapToarray x))
    :qid |$Snap.arrayTo$SnapToarray|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<Int>To$Snap ($FVF<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Int> ($Snap) $FVF<Int>)
(assert (forall ((x $FVF<Int>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Int>($SortWrappers.$FVF<Int>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Int>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Int>To$Snap($SortWrappers.$SnapTo$FVF<Int> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Int> x))
    :qid |$Snap.$FVF<Int>To$SnapTo$FVF<Int>|
    )))
(declare-fun $SortWrappers.$FVF<option<array>>To$Snap ($FVF<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<option<array>> ($Snap) $FVF<option<array>>)
(assert (forall ((x $FVF<option<array>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<option<array>>($SortWrappers.$FVF<option<array>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<option<array>>To$Snap($SortWrappers.$SnapTo$FVF<option<array>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<option<array>> x))
    :qid |$Snap.$FVF<option<array>>To$SnapTo$FVF<option<array>>|
    )))
(declare-fun $SortWrappers.$FVF<Bool>To$Snap ($FVF<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Bool> ($Snap) $FVF<Bool>)
(assert (forall ((x $FVF<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Bool>($SortWrappers.$FVF<Bool>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Bool>To$Snap($SortWrappers.$SnapTo$FVF<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Bool> x))
    :qid |$Snap.$FVF<Bool>To$SnapTo$FVF<Bool>|
    )))
(declare-fun $SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap ($FVF<Seq<Seq<Int>>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> ($Snap) $FVF<Seq<Seq<Int>>>)
(assert (forall ((x $FVF<Seq<Seq<Int>>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>>($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Seq<Seq<Int>>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Seq<Seq<Int>>> x))
    :qid |$Snap.$FVF<Seq<Seq<Int>>>To$SnapTo$FVF<Seq<Seq<Int>>>|
    )))
(declare-fun $SortWrappers.$FVF<Seq<Int>>To$Snap ($FVF<Seq<Int>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Seq<Int>> ($Snap) $FVF<Seq<Int>>)
(assert (forall ((x $FVF<Seq<Int>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Seq<Int>>($SortWrappers.$FVF<Seq<Int>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Seq<Int>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Seq<Int>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Seq<Int>>To$Snap($SortWrappers.$SnapTo$FVF<Seq<Int>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Seq<Int>> x))
    :qid |$Snap.$FVF<Seq<Int>>To$SnapTo$FVF<Seq<Int>>|
    )))
(declare-fun $SortWrappers.$FVF<$Ref>To$Snap ($FVF<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<$Ref> ($Snap) $FVF<$Ref>)
(assert (forall ((x $FVF<$Ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<$Ref>($SortWrappers.$FVF<$Ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<$Ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<$Ref>To$Snap($SortWrappers.$SnapTo$FVF<$Ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<$Ref> x))
    :qid |$Snap.$FVF<$Ref>To$SnapTo$FVF<$Ref>|
    )))
; ////////// Symbols
(declare-fun Set_in (Seq<Seq<Int>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_card (Set<Seq<Seq<Int>>>) Int)
(declare-const Set_empty Set<Seq<Seq<Int>>>)
(declare-fun Set_singleton (Seq<Seq<Int>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_unionone (Set<Seq<Seq<Int>>> Seq<Seq<Int>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_union (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_disjoint (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_difference (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_intersection (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Set<Seq<Seq<Int>>>)
(declare-fun Set_subset (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_equal (Set<Seq<Seq<Int>>> Set<Seq<Seq<Int>>>) Bool)
(declare-fun Set_in (option<array> Set<option<array>>) Bool)
(declare-fun Set_card (Set<option<array>>) Int)
(declare-const Set_empty Set<option<array>>)
(declare-fun Set_singleton (option<array>) Set<option<array>>)
(declare-fun Set_unionone (Set<option<array>> option<array>) Set<option<array>>)
(declare-fun Set_union (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_disjoint (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_difference (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_intersection (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_subset (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_equal (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_in (Seq<Int> Set<Seq<Int>>) Bool)
(declare-fun Set_card (Set<Seq<Int>>) Int)
(declare-const Set_empty Set<Seq<Int>>)
(declare-fun Set_singleton (Seq<Int>) Set<Seq<Int>>)
(declare-fun Set_unionone (Set<Seq<Int>> Seq<Int>) Set<Seq<Int>>)
(declare-fun Set_union (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_disjoint (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_difference (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_intersection (Set<Seq<Int>> Set<Seq<Int>>) Set<Seq<Int>>)
(declare-fun Set_subset (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_equal (Set<Seq<Int>> Set<Seq<Int>>) Bool)
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_disjoint (Set<Int> Set<Int>) Bool)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_disjoint (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_disjoint (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_disjoint (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Seq_length (Seq<Seq<Int>>) Int)
(declare-const Seq_empty Seq<Seq<Int>>)
(declare-fun Seq_singleton (Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_build (Seq<Seq<Int>> Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_index (Seq<Seq<Int>> Int) Seq<Int>)
(declare-fun Seq_append (Seq<Seq<Int>> Seq<Seq<Int>>) Seq<Seq<Int>>)
(declare-fun Seq_update (Seq<Seq<Int>> Int Seq<Int>) Seq<Seq<Int>>)
(declare-fun Seq_contains (Seq<Seq<Int>> Seq<Int>) Bool)
(declare-fun Seq_take (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_drop (Seq<Seq<Int>> Int) Seq<Seq<Int>>)
(declare-fun Seq_equal (Seq<Seq<Int>> Seq<Seq<Int>>) Bool)
(declare-fun Seq_sameuntil (Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_build (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_sameuntil (Seq<Int> Seq<Int> Int) Bool)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun array_loc<Ref> (array Int) $Ref)
(declare-fun alen<Int> (array) Int)
(declare-fun loc_inv_1<array> ($Ref) array)
(declare-fun loc_inv_2<Int> ($Ref) Int)
(declare-const None<option<array>> option<array>)
(declare-fun some<option<array>> (array) option<array>)
(declare-fun option_get<array> (option<array>) array)
(declare-const v_null<t_null> t_null)
(declare-const None<option<any>> option<any>)
(declare-fun some<option<any>> (any) option<any>)
(declare-fun option_get<any> (option<any>) any)
(declare-const unit<void> void)
; /field_value_functions_declarations.smt2 [int: Int]
(declare-fun $FVF.domain_int ($FVF<Int>) Set<$Ref>)
(declare-fun $FVF.lookup_int ($FVF<Int> $Ref) Int)
(declare-fun $FVF.after_int ($FVF<Int> $FVF<Int>) Bool)
(declare-fun $FVF.loc_int (Int $Ref) Bool)
(declare-fun $FVF.perm_int ($FPM $Ref) $Perm)
(declare-const $fvfTOP_int $FVF<Int>)
; /field_value_functions_declarations.smt2 [option$array$: option[array]]
(declare-fun $FVF.domain_option$array$ ($FVF<option<array>>) Set<$Ref>)
(declare-fun $FVF.lookup_option$array$ ($FVF<option<array>> $Ref) option<array>)
(declare-fun $FVF.after_option$array$ ($FVF<option<array>> $FVF<option<array>>) Bool)
(declare-fun $FVF.loc_option$array$ (option<array> $Ref) Bool)
(declare-fun $FVF.perm_option$array$ ($FPM $Ref) $Perm)
(declare-const $fvfTOP_option$array$ $FVF<option<array>>)
; /field_value_functions_declarations.smt2 [bool: Bool]
(declare-fun $FVF.domain_bool ($FVF<Bool>) Set<$Ref>)
(declare-fun $FVF.lookup_bool ($FVF<Bool> $Ref) Bool)
(declare-fun $FVF.after_bool ($FVF<Bool> $FVF<Bool>) Bool)
(declare-fun $FVF.loc_bool (Bool $Ref) Bool)
(declare-fun $FVF.perm_bool ($FPM $Ref) $Perm)
(declare-const $fvfTOP_bool $FVF<Bool>)
; /field_value_functions_declarations.smt2 [Gf_seq: Seq[Seq[Int]]]
(declare-fun $FVF.domain_Gf_seq ($FVF<Seq<Seq<Int>>>) Set<$Ref>)
(declare-fun $FVF.lookup_Gf_seq ($FVF<Seq<Seq<Int>>> $Ref) Seq<Seq<Int>>)
(declare-fun $FVF.after_Gf_seq ($FVF<Seq<Seq<Int>>> $FVF<Seq<Seq<Int>>>) Bool)
(declare-fun $FVF.loc_Gf_seq (Seq<Seq<Int>> $Ref) Bool)
(declare-fun $FVF.perm_Gf_seq ($FPM $Ref) $Perm)
(declare-const $fvfTOP_Gf_seq $FVF<Seq<Seq<Int>>>)
; /field_value_functions_declarations.smt2 [P_seq: Seq[Int]]
(declare-fun $FVF.domain_P_seq ($FVF<Seq<Int>>) Set<$Ref>)
(declare-fun $FVF.lookup_P_seq ($FVF<Seq<Int>> $Ref) Seq<Int>)
(declare-fun $FVF.after_P_seq ($FVF<Seq<Int>> $FVF<Seq<Int>>) Bool)
(declare-fun $FVF.loc_P_seq (Seq<Int> $Ref) Bool)
(declare-fun $FVF.perm_P_seq ($FPM $Ref) $Perm)
(declare-const $fvfTOP_P_seq $FVF<Seq<Int>>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun valid_graph_vertices1 ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%limited ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun SquareIntMatrix ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SquareIntMatrix%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SumOutgoingFlow ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumOutgoingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumOutgoingFlow%stateless ($Ref Seq<Seq<Int>> Int Int) Bool)
(declare-fun SumIncomingFlow ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumIncomingFlow%limited ($Snap $Ref Seq<Seq<Int>> Int Int) Int)
(declare-fun SumIncomingFlow%stateless ($Ref Seq<Seq<Int>> Int Int) Bool)
(declare-fun AugPath ($Snap $Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun AugPath%stateless ($Ref Seq<Seq<Int>> Int Int Int Seq<Int>) Bool)
(declare-fun aloc ($Snap array Int) $Ref)
(declare-fun aloc%limited ($Snap array Int) $Ref)
(declare-fun aloc%stateless (array Int) Bool)
(declare-fun opt_get1 ($Snap option<array>) array)
(declare-fun opt_get1%limited ($Snap option<array>) array)
(declare-fun opt_get1%stateless (option<array>) Bool)
(declare-fun NonNegativeCapacities ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun NonNegativeCapacities%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry%limited ($Snap $Ref Seq<Seq<Int>> Int) Bool)
(declare-fun SkewSymetry%stateless ($Ref Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun CapacityConstraint%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int) Bool)
(declare-fun FlowConservation ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowConservation%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun any_as ($Snap any) any)
(declare-fun any_as%limited ($Snap any) any)
(declare-fun any_as%stateless (any) Bool)
(declare-fun opt_get ($Snap option<any>) any)
(declare-fun opt_get%limited ($Snap option<any>) any)
(declare-fun opt_get%stateless (option<any>) Bool)
(declare-fun ExAugPath ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%limited ($Snap $Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun ExAugPath%stateless ($Ref Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun initializeSeqWithZeros ($Snap $Ref Seq<Int> Int) Seq<Int>)
(declare-fun initializeSeqWithZeros%limited ($Snap $Ref Seq<Int> Int) Seq<Int>)
(declare-fun initializeSeqWithZeros%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%stateless ($Ref option<array> Int) Bool)
(declare-fun FlowNetwork ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun FlowNetwork%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun scale ($Snap $Perm) $Perm)
(declare-fun scale%limited ($Snap $Perm) $Perm)
(declare-fun scale%stateless ($Perm) Bool)
(declare-fun Flow ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun Flow%limited ($Snap $Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun Flow%stateless ($Ref Seq<Seq<Int>> Seq<Seq<Int>> Int Int Int) Bool)
(declare-fun as_any ($Snap any) any)
(declare-fun as_any%limited ($Snap any) any)
(declare-fun as_any%stateless (any) Bool)
(declare-fun type ($Snap $Ref) Int)
(declare-fun type%limited ($Snap $Ref) Int)
(declare-fun type%stateless ($Ref) Bool)
(declare-fun opt_or_else ($Snap option<any> any) any)
(declare-fun opt_or_else%limited ($Snap option<any> any) any)
(declare-fun opt_or_else%stateless (option<any> any) Bool)
(declare-fun subtype ($Snap Int Int) Bool)
(declare-fun subtype%limited ($Snap Int Int) Bool)
(declare-fun subtype%stateless (Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun lock_inv_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_inv_Object%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_Object%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Seq<Int>>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Seq<Int>>)) 0))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Seq[Int]]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Seq[Int]]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Seq[Int]]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_append|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append (as Seq_empty  Seq<Seq<Int>>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Seq<Int>>) s))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Seq<Int>>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Seq<Int>>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Seq<Int>>)))
  :qid |$Seq[Seq[Int]]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Seq<Int>>)))
      (not (= s2 (as Seq_empty  Seq<Seq<Int>>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Seq[Int]]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Seq<Int>>) e))
  :qid |$Seq[Seq[Int]]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Seq<Int>>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (e Seq<Int>)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Seq[Int]]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Seq[Int]]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Seq<Int>>) (s2 Seq<Seq<Int>>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Seq[Int]]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Seq[Int]]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Seq<Int>>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Seq[Int]]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Seq<Int>>) (i Int) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Seq<Int>>) (e Seq<Int>) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Seq[Int]]_prog.seq_drop_over_build|)))
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Int]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Int]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Int]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Int]_prog.seq_length_over_append|)))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Int]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append (as Seq_empty  Seq<Int>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Int>) s))
  :qid |$Seq[Int]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Int>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Int>)))
  :qid |$Seq[Int]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Int]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Int]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Int]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Int]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Int)) (!
  (not (Seq_contains (as Seq_empty  Seq<Int>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Int>) e))
  :qid |$Seq[Int]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (e Int)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Int]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Int>) (e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Int]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Int]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Int]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Int]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Int]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Int]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Int>) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_build|)))
(assert (forall ((min_ Int) (max Int)) (!
  (ite
    (< min_ max)
    (= (Seq_length (Seq_range min_ max)) (- max min_))
    (= (Seq_length (Seq_range min_ max)) 0))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (i Int)) (!
  (implies
    (and (<= 0 i) (< i (- max min_)))
    (= (Seq_index (Seq_range min_ max) i) (+ min_ i)))
  :pattern ((Seq_index (Seq_range min_ max) i))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (e Int)) (!
  (= (Seq_contains (Seq_range min_ max) e) (and (<= min_ e) (< e max)))
  :pattern ((Seq_contains (Seq_range min_ max) e))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<Seq<Seq<Int>>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Seq[Int]]]_prog.card_non_negative|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (not (Set_in e (as Set_empty  Set<Seq<Seq<Int>>>)))
  :pattern ((Set_in e (as Set_empty  Set<Seq<Seq<Int>>>)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_empty_set|)))
(assert (forall ((s Set<Seq<Seq<Int>>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Seq<Seq<Int>>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Seq<Seq<Int>>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Seq[Int]]]_prog.empty_set_cardinality|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_singleton_set|)))
(assert (forall ((e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_singleton_set_equality|)))
(assert (forall ((e Seq<Seq<Int>>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_unionone_same|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_unionone_other|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e1 Seq<Seq<Int>>) (e2 Seq<Seq<Int>>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Seq[Seq[Int]]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Seq[Int]]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.in_difference|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>) (e Seq<Seq<Int>>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.subset_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.equality_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.native_equality|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Seq<Seq<Int>>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Seq[Seq[Int]]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Seq<Seq<Int>>>) (s2 Set<Seq<Seq<Int>>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Seq[Seq[Int]]]_prog.cardinality_difference|)))
(assert (forall ((s Set<option<array>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.card_non_negative|)))
(assert (forall ((e option<array>)) (!
  (not (Set_in e (as Set_empty  Set<option<array>>)))
  :pattern ((Set_in e (as Set_empty  Set<option<array>>)))
  :qid |$Set[option[array]]_prog.in_empty_set|)))
(assert (forall ((s Set<option<array>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<option<array>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e option<array>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.empty_set_cardinality|)))
(assert (forall ((e option<array>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[option[array]]_prog.in_singleton_set|)))
(assert (forall ((e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[option[array]]_prog.in_singleton_set_equality|)))
(assert (forall ((e option<array>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[option[array]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[option[array]]_prog.in_unionone_same|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[option[array]]_prog.in_unionone_other|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[option[array]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[option[array]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[option[array]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e option<array>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[option[array]]_prog.subset_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e option<array>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.equality_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.native_equality|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e option<array>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[option[array]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_difference|)))
(assert (forall ((s Set<Seq<Int>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Int]]_prog.card_non_negative|)))
(assert (forall ((e Seq<Int>)) (!
  (not (Set_in e (as Set_empty  Set<Seq<Int>>)))
  :pattern ((Set_in e (as Set_empty  Set<Seq<Int>>)))
  :qid |$Set[Seq[Int]]_prog.in_empty_set|)))
(assert (forall ((s Set<Seq<Int>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Seq<Int>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Seq<Int>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Seq[Int]]_prog.empty_set_cardinality|)))
(assert (forall ((e Seq<Int>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Seq[Int]]_prog.in_singleton_set|)))
(assert (forall ((e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Seq[Int]]_prog.in_singleton_set_equality|)))
(assert (forall ((e Seq<Int>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Seq[Int]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Seq[Int]]_prog.in_unionone_same|)))
(assert (forall ((s Set<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Seq[Int]]_prog.in_unionone_other|)))
(assert (forall ((s Set<Seq<Int>>) (e1 Seq<Int>) (e2 Seq<Int>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Seq[Int]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Int]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Seq[Int]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Seq[Int]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Seq[Int]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Seq[Int]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Int]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Seq[Int]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Seq[Int]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Seq[Int]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Seq[Int]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Seq[Int]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Seq[Int]]_prog.in_difference|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>) (e Seq<Int>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Seq[Int]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Seq<Int>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Seq[Int]]_prog.subset_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Seq<Int>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Int]]_prog.equality_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Seq[Int]]_prog.native_equality|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Seq<Int>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Seq[Int]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Seq<Int>>) (s2 Set<Seq<Int>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Seq[Int]]_prog.cardinality_difference|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.card_non_negative|)))
(assert (forall ((e Int)) (!
  (not (Set_in e (as Set_empty  Set<Int>)))
  :pattern ((Set_in e (as Set_empty  Set<Int>)))
  :qid |$Set[Int]_prog.in_empty_set|)))
(assert (forall ((s Set<Int>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Int)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.empty_set_cardinality|)))
(assert (forall ((e Int)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Int]_prog.in_singleton_set|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Int]_prog.in_singleton_set_equality|)))
(assert (forall ((e Int)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Int]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Int]_prog.in_unionone_same|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Int]_prog.in_unionone_other|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Int]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Int]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Int]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Int]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Int]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Int)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Int]_prog.subset_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Int)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.equality_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.native_equality|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Int)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Int]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.cardinality_difference|)))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.card_non_negative|)))
(assert (forall ((e Bool)) (!
  (not (Set_in e (as Set_empty  Set<Bool>)))
  :pattern ((Set_in e (as Set_empty  Set<Bool>)))
  :qid |$Set[Bool]_prog.in_empty_set|)))
(assert (forall ((s Set<Bool>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Bool)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.empty_set_cardinality|)))
(assert (forall ((e Bool)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Bool]_prog.in_singleton_set|)))
(assert (forall ((e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Bool]_prog.in_singleton_set_equality|)))
(assert (forall ((e Bool)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Bool]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Bool]_prog.in_unionone_same|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Bool]_prog.in_unionone_other|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Bool]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Bool]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Bool]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Bool)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Bool]_prog.subset_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Bool)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.equality_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.native_equality|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Bool)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Bool]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.card_non_negative|)))
(assert (forall ((e $Ref)) (!
  (not (Set_in e (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in e (as Set_empty  Set<$Ref>)))
  :qid |$Set[Ref]_prog.in_empty_set|)))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Ref)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.empty_set_cardinality|)))
(assert (forall ((e $Ref)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Ref]_prog.in_singleton_set|)))
(assert (forall ((e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Ref]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Ref)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Ref]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Ref]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Ref]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Ref]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Ref]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Ref]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Ref)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Ref]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Ref)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.native_equality|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Ref)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Ref]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.card_non_negative|)))
(assert (forall ((e $Snap)) (!
  (not (Set_in e (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in e (as Set_empty  Set<$Snap>)))
  :qid |$Set[Snap]_prog.in_empty_set|)))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Snap)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.empty_set_cardinality|)))
(assert (forall ((e $Snap)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Snap]_prog.in_singleton_set|)))
(assert (forall ((e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Snap]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Snap)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Snap]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Snap]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Snap]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Snap]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Snap]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Snap]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Snap)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Snap]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Snap)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.native_equality|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Snap)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Snap]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_difference|)))
(assert (forall ((a2 array)) (!
  (forall ((i1 Int)) (!
    (and
      (= (loc_inv_1<array> (array_loc<Ref> a2 i1)) a2)
      (= (loc_inv_2<Int> (array_loc<Ref> a2 i1)) i1))
    :pattern ((loc_inv_1<array> (array_loc<Ref> a2 i1)))
    :pattern ((loc_inv_2<Int> (array_loc<Ref> a2 i1)))
    ))
  
  )))
(assert (forall ((a2 array)) (!
  (>= (alen<Int> a2) 0)
  :pattern ((alen<Int> a2))
  )))
(assert (forall ((x1 array)) (!
  (not (= (as None<option<array>>  option<array>) (some<option<array>> x1)))
  :pattern ((some<option<array>> x1))
  )))
(assert (forall ((x1 array)) (!
  (= (option_get<array> (some<option<array>> x1)) x1)
  :pattern ((option_get<array> (some<option<array>> x1)))
  )))
(assert (forall ((opt1 option<array>)) (!
  (= (some<option<array>> (option_get<array> opt1)) opt1)
  :pattern ((some<option<array>> (option_get<array> opt1)))
  )))
(assert (forall ((v t_null)) (!
  (= (as v_null<t_null>  t_null) v)
  
  )))
(assert (forall ((x1 any)) (!
  (not (= (as None<option<any>>  option<any>) (some<option<any>> x1)))
  :pattern ((some<option<any>> x1))
  )))
(assert (forall ((x1 any)) (!
  (= (option_get<any> (some<option<any>> x1)) x1)
  :pattern ((option_get<any> (some<option<any>> x1)))
  )))
(assert (forall ((opt1 option<any>)) (!
  (= (some<option<any>> (option_get<any> opt1)) opt1)
  :pattern ((some<option<any>> (option_get<any> opt1)))
  )))
(assert (forall ((v void)) (!
  (= (as unit<void>  void) v)
  
  )))
; /field_value_functions_axioms.smt2 [int: Int]
(assert (forall ((vs $FVF<Int>) (ws $FVF<Int>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_int vs) ($FVF.domain_int ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_int vs))
            (= ($FVF.lookup_int vs x) ($FVF.lookup_int ws x)))
          :pattern (($FVF.lookup_int vs x) ($FVF.lookup_int ws x))
          :qid |qp.$FVF<Int>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Int>To$Snap vs)
              ($SortWrappers.$FVF<Int>To$Snap ws)
              )
    :qid |qp.$FVF<Int>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_int pm r))
    :pattern ($FVF.perm_int pm r))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_int f r) true)
    :pattern ($FVF.loc_int f r))))
; /field_value_functions_axioms.smt2 [option$array$: option[array]]
(assert (forall ((vs $FVF<option<array>>) (ws $FVF<option<array>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_option$array$ vs) ($FVF.domain_option$array$ ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_option$array$ vs))
            (= ($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x)))
          :pattern (($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x))
          :qid |qp.$FVF<option<array>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap vs)
              ($SortWrappers.$FVF<option<array>>To$Snap ws)
              )
    :qid |qp.$FVF<option<array>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_option$array$ pm r))
    :pattern ($FVF.perm_option$array$ pm r))))
(assert (forall ((r $Ref) (f option<array>)) (!
    (= ($FVF.loc_option$array$ f r) true)
    :pattern ($FVF.loc_option$array$ f r))))
; /field_value_functions_axioms.smt2 [bool: Bool]
(assert (forall ((vs $FVF<Bool>) (ws $FVF<Bool>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_bool vs) ($FVF.domain_bool ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_bool vs))
            (= ($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x)))
          :pattern (($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x))
          :qid |qp.$FVF<Bool>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap vs)
              ($SortWrappers.$FVF<Bool>To$Snap ws)
              )
    :qid |qp.$FVF<Bool>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_bool pm r))
    :pattern ($FVF.perm_bool pm r))))
(assert (forall ((r $Ref) (f Bool)) (!
    (= ($FVF.loc_bool f r) true)
    :pattern ($FVF.loc_bool f r))))
; /field_value_functions_axioms.smt2 [Gf_seq: Seq[Seq[Int]]]
(assert (forall ((vs $FVF<Seq<Seq<Int>>>) (ws $FVF<Seq<Seq<Int>>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_Gf_seq vs) ($FVF.domain_Gf_seq ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_Gf_seq vs))
            (= ($FVF.lookup_Gf_seq vs x) ($FVF.lookup_Gf_seq ws x)))
          :pattern (($FVF.lookup_Gf_seq vs x) ($FVF.lookup_Gf_seq ws x))
          :qid |qp.$FVF<Seq<Seq<Int>>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap vs)
              ($SortWrappers.$FVF<Seq<Seq<Int>>>To$Snap ws)
              )
    :qid |qp.$FVF<Seq<Seq<Int>>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_Gf_seq pm r))
    :pattern ($FVF.perm_Gf_seq pm r))))
(assert (forall ((r $Ref) (f Seq<Seq<Int>>)) (!
    (= ($FVF.loc_Gf_seq f r) true)
    :pattern ($FVF.loc_Gf_seq f r))))
; /field_value_functions_axioms.smt2 [P_seq: Seq[Int]]
(assert (forall ((vs $FVF<Seq<Int>>) (ws $FVF<Seq<Int>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_P_seq vs) ($FVF.domain_P_seq ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_P_seq vs))
            (= ($FVF.lookup_P_seq vs x) ($FVF.lookup_P_seq ws x)))
          :pattern (($FVF.lookup_P_seq vs x) ($FVF.lookup_P_seq ws x))
          :qid |qp.$FVF<Seq<Int>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Seq<Int>>To$Snap vs)
              ($SortWrappers.$FVF<Seq<Int>>To$Snap ws)
              )
    :qid |qp.$FVF<Seq<Int>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_P_seq pm r))
    :pattern ($FVF.perm_P_seq pm r))))
(assert (forall ((r $Ref) (f Seq<Int>)) (!
    (= ($FVF.loc_P_seq f r) true)
    :pattern ($FVF.loc_P_seq f r))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun $k@113@00 () $Perm)
(declare-fun inv@114@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@115@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (=
    (valid_graph_vertices1%limited s@$ this@0@00 p@1@00 V@2@00)
    (valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  :pattern ((valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (valid_graph_vertices1%stateless this@0@00 p@1@00 V@2@00)
  :pattern ((valid_graph_vertices1%limited s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@0@00 $Ref) (p@1@00 Seq<Int>) (V@2@00 Int)) (!
  (implies
    (not (= this@0@00 $Ref.null))
    (=
      (valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00)
      (and
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@1@00)))
            (<= 0 (Seq_index p@1@00 unknown_)))
          :pattern ((Seq_index p@1@00 unknown_))
          ))
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@1@00)))
            (< (Seq_index p@1@00 unknown_) V@2@00))
          :pattern ((Seq_index p@1@00 unknown_))
          )))))
  :pattern ((valid_graph_vertices1 s@$ this@0@00 p@1@00 V@2@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (=
    (SquareIntMatrix%limited s@$ this@4@00 G@5@00 V@6@00)
    (SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  :pattern ((SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (SquareIntMatrix%stateless this@4@00 G@5@00 V@6@00)
  :pattern ((SquareIntMatrix%limited s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@4@00 $Ref) (G@5@00 Seq<Seq<Int>>) (V@6@00 Int)) (!
  (implies
    (not (= this@4@00 $Ref.null))
    (=
      (SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00)
      (and
        (= (Seq_length G@5@00) V@6@00)
        (forall ((e Seq<Int>)) (!
          (implies (Seq_contains G@5@00 e) (= (Seq_length e) V@6@00))
          :pattern ((Seq_contains G@5@00 e))
          :pattern ((Seq_length e))
          )))))
  :pattern ((SquareIntMatrix s@$ this@4@00 G@5@00 V@6@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (n@10@00 Int) (v@11@00 Int)) (!
  (=
    (SumOutgoingFlow%limited s@$ this@8@00 G@9@00 n@10@00 v@11@00)
    (SumOutgoingFlow s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  :pattern ((SumOutgoingFlow s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  )))
(assert (forall ((s@$ $Snap) (this@8@00 $Ref) (G@9@00 Seq<Seq<Int>>) (n@10@00 Int) (v@11@00 Int)) (!
  (SumOutgoingFlow%stateless this@8@00 G@9@00 n@10@00 v@11@00)
  :pattern ((SumOutgoingFlow%limited s@$ this@8@00 G@9@00 n@10@00 v@11@00))
  )))
(assert (forall ((s@$ $Snap) (this@13@00 $Ref) (G@14@00 Seq<Seq<Int>>) (n@15@00 Int) (v@16@00 Int)) (!
  (=
    (SumIncomingFlow%limited s@$ this@13@00 G@14@00 n@15@00 v@16@00)
    (SumIncomingFlow s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  :pattern ((SumIncomingFlow s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  )))
(assert (forall ((s@$ $Snap) (this@13@00 $Ref) (G@14@00 Seq<Seq<Int>>) (n@15@00 Int) (v@16@00 Int)) (!
  (SumIncomingFlow%stateless this@13@00 G@14@00 n@15@00 v@16@00)
  :pattern ((SumIncomingFlow%limited s@$ this@13@00 G@14@00 n@15@00 v@16@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (=
    (AugPath%limited s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
    (AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  :pattern ((AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (AugPath%stateless this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
  :pattern ((AugPath%limited s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (this@18@00 $Ref) (G@19@00 Seq<Seq<Int>>) (V@20@00 Int) (s@21@00 Int) (t@22@00 Int) (P@23@00 Seq<Int>)) (!
  (implies
    (and
      (not (= this@18@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@18@00 G@19@00 V@20@00))
    (=
      (AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00)
      (and
        (and
          (and
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (not
                (=
                  (Seq_index P@23@00 0)
                  (Seq_index P@23@00 (- (Seq_length P@23@00) 1)))))
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (valid_graph_vertices1 $Snap.unit this@18@00 P@23@00 V@20@00)))
          (and
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (forall ((unknown_ Int)) (!
                (implies
                  (and (<= 0 unknown_) (< unknown_ (Seq_length P@23@00)))
                  (<= 0 (Seq_index P@23@00 unknown_)))
                :pattern ((Seq_index P@23@00 unknown_))
                )))
            (implies
              (and
                (and
                  (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
                  (< t@22@00 V@20@00))
                (< 1 (Seq_length P@23@00)))
              (forall ((unknown_ Int)) (!
                (implies
                  (and (<= 0 unknown_) (< unknown_ (Seq_length P@23@00)))
                  (< (Seq_index P@23@00 unknown_) V@20@00))
                :pattern ((Seq_index P@23@00 unknown_))
                )))))
        (implies
          (and
            (and
              (and (and (<= 0 s@21@00) (< s@21@00 V@20@00)) (<= 0 t@22@00))
              (< t@22@00 V@20@00))
            (< 1 (Seq_length P@23@00)))
          (forall ((j Int)) (!
            (implies
              (and (<= 0 j) (< j (- (Seq_length P@23@00) 1)))
              (<
                0
                (Seq_index
                  (Seq_index G@19@00 (Seq_index P@23@00 j))
                  (Seq_index P@23@00 (+ j 1)))))
            :pattern ((Seq_index G@19@00 (Seq_index P@23@00 j)))
            ))))))
  :pattern ((AugPath s@$ this@18@00 G@19@00 V@20@00 s@21@00 t@22@00 P@23@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (= (aloc%limited s@$ a2@25@00 i1@26@00) (aloc s@$ a2@25@00 i1@26@00))
  :pattern ((aloc s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (aloc%stateless a2@25@00 i1@26@00)
  :pattern ((aloc%limited s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (let ((result@27@00 (aloc%limited s@$ a2@25@00 i1@26@00))) (implies
    (and (<= 0 i1@26@00) (< i1@26@00 (alen<Int> a2@25@00)))
    (and
      (= (loc_inv_1<array> result@27@00) a2@25@00)
      (= (loc_inv_2<Int> result@27@00) i1@26@00))))
  :pattern ((aloc%limited s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (a2@25@00 array) (i1@26@00 Int)) (!
  (implies
    (and (<= 0 i1@26@00) (< i1@26@00 (alen<Int> a2@25@00)))
    (= (aloc s@$ a2@25@00 i1@26@00) (array_loc<Ref> a2@25@00 i1@26@00)))
  :pattern ((aloc s@$ a2@25@00 i1@26@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (= (opt_get1%limited s@$ opt1@28@00) (opt_get1 s@$ opt1@28@00))
  :pattern ((opt_get1 s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (opt_get1%stateless opt1@28@00)
  :pattern ((opt_get1%limited s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (let ((result@29@00 (opt_get1%limited s@$ opt1@28@00))) (implies
    (not (= opt1@28@00 (as None<option<array>>  option<array>)))
    (= (some<option<array>> result@29@00) opt1@28@00)))
  :pattern ((opt_get1%limited s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@28@00 option<array>)) (!
  (implies
    (not (= opt1@28@00 (as None<option<array>>  option<array>)))
    (= (opt_get1 s@$ opt1@28@00) (option_get<array> opt1@28@00)))
  :pattern ((opt_get1 s@$ opt1@28@00))
  )))
(assert (forall ((s@$ $Snap) (this@30@00 $Ref) (G@31@00 Seq<Seq<Int>>) (V@32@00 Int)) (!
  (=
    (NonNegativeCapacities%limited s@$ this@30@00 G@31@00 V@32@00)
    (NonNegativeCapacities s@$ this@30@00 G@31@00 V@32@00))
  :pattern ((NonNegativeCapacities s@$ this@30@00 G@31@00 V@32@00))
  )))
(assert (forall ((s@$ $Snap) (this@30@00 $Ref) (G@31@00 Seq<Seq<Int>>) (V@32@00 Int)) (!
  (NonNegativeCapacities%stateless this@30@00 G@31@00 V@32@00)
  :pattern ((NonNegativeCapacities%limited s@$ this@30@00 G@31@00 V@32@00))
  )))
(assert (forall ((s@$ $Snap) (this@34@00 $Ref) (G@35@00 Seq<Seq<Int>>) (V@36@00 Int)) (!
  (=
    (SkewSymetry%limited s@$ this@34@00 G@35@00 V@36@00)
    (SkewSymetry s@$ this@34@00 G@35@00 V@36@00))
  :pattern ((SkewSymetry s@$ this@34@00 G@35@00 V@36@00))
  )))
(assert (forall ((s@$ $Snap) (this@34@00 $Ref) (G@35@00 Seq<Seq<Int>>) (V@36@00 Int)) (!
  (SkewSymetry%stateless this@34@00 G@35@00 V@36@00)
  :pattern ((SkewSymetry%limited s@$ this@34@00 G@35@00 V@36@00))
  )))
(assert (forall ((s@$ $Snap) (this@38@00 $Ref) (G@39@00 Seq<Seq<Int>>) (Gf@40@00 Seq<Seq<Int>>) (V@41@00 Int)) (!
  (=
    (CapacityConstraint%limited s@$ this@38@00 G@39@00 Gf@40@00 V@41@00)
    (CapacityConstraint s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  :pattern ((CapacityConstraint s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  )))
(assert (forall ((s@$ $Snap) (this@38@00 $Ref) (G@39@00 Seq<Seq<Int>>) (Gf@40@00 Seq<Seq<Int>>) (V@41@00 Int)) (!
  (CapacityConstraint%stateless this@38@00 G@39@00 Gf@40@00 V@41@00)
  :pattern ((CapacityConstraint%limited s@$ this@38@00 G@39@00 Gf@40@00 V@41@00))
  )))
(assert (forall ((s@$ $Snap) (this@43@00 $Ref) (G@44@00 Seq<Seq<Int>>) (V@45@00 Int) (s@46@00 Int) (t@47@00 Int)) (!
  (=
    (FlowConservation%limited s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00)
    (FlowConservation s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  :pattern ((FlowConservation s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  )))
(assert (forall ((s@$ $Snap) (this@43@00 $Ref) (G@44@00 Seq<Seq<Int>>) (V@45@00 Int) (s@46@00 Int) (t@47@00 Int)) (!
  (FlowConservation%stateless this@43@00 G@44@00 V@45@00 s@46@00 t@47@00)
  :pattern ((FlowConservation%limited s@$ this@43@00 G@44@00 V@45@00 s@46@00 t@47@00))
  )))
(assert (forall ((s@$ $Snap) (t@49@00 any)) (!
  (= (any_as%limited s@$ t@49@00) (any_as s@$ t@49@00))
  :pattern ((any_as s@$ t@49@00))
  )))
(assert (forall ((s@$ $Snap) (t@49@00 any)) (!
  (any_as%stateless t@49@00)
  :pattern ((any_as%limited s@$ t@49@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (= (opt_get%limited s@$ opt1@51@00) (opt_get s@$ opt1@51@00))
  :pattern ((opt_get s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (opt_get%stateless opt1@51@00)
  :pattern ((opt_get%limited s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (let ((result@52@00 (opt_get%limited s@$ opt1@51@00))) (implies
    (not (= opt1@51@00 (as None<option<any>>  option<any>)))
    (= (some<option<any>> result@52@00) opt1@51@00)))
  :pattern ((opt_get%limited s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@51@00 option<any>)) (!
  (implies
    (not (= opt1@51@00 (as None<option<any>>  option<any>)))
    (= (opt_get s@$ opt1@51@00) (option_get<any> opt1@51@00)))
  :pattern ((opt_get s@$ opt1@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (=
    (ExAugPath%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
    (ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  :pattern ((ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (ExAugPath%stateless this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
  :pattern ((ExAugPath%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 Seq<Seq<Int>>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (implies
    (and
      (not (= this@53@00 $Ref.null))
      (SquareIntMatrix $Snap.unit this@53@00 G@54@00 V@55@00))
    (=
      (ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
      (exists ((P Seq<Int>)) (!
        (and
          (AugPath ($Snap.combine $Snap.unit $Snap.unit) this@53@00 G@54@00 V@55@00 s@56@00 t@57@00 P)
          (<= (Seq_length P) V@55@00))
        :pattern ((AugPath%limited ($Snap.combine $Snap.unit $Snap.unit) this@53@00 G@54@00 V@55@00 s@56@00 t@57@00 P))
        :pattern ((Seq_length P))
        ))))
  :pattern ((ExAugPath s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (Seq_equal
    (initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00)
    (initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  :pattern ((initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (initializeSeqWithZeros%stateless this@59@00 p@60@00 n@61@00)
  :pattern ((initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (let ((result@62@00 (initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))) (implies
    (and (not (= this@59@00 $Ref.null)) (<= n@61@00 (Seq_length p@60@00)))
    (and
      (implies
        (< n@61@00 0)
        (=
          (Seq_length
            (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 n@61@00))
          0))
      (implies
        (<= 0 n@61@00)
        (=
          (Seq_length
            (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 n@61@00))
          n@61@00))
      (forall ((i1 Int)) (!
        (implies (and (<= 0 i1) (< i1 n@61@00)) (= (Seq_index p@60@00 i1) 0))
        :pattern ((Seq_index p@60@00 i1))
        )))))
  :pattern ((initializeSeqWithZeros%limited s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@59@00 $Ref) (p@60@00 Seq<Int>) (n@61@00 Int)) (!
  (implies
    (and (not (= this@59@00 $Ref.null)) (<= n@61@00 (Seq_length p@60@00)))
    (Seq_equal
      (initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00)
      (ite
        (< 0 n@61@00)
        (Seq_append
          (Seq_singleton 0)
          (initializeSeqWithZeros%limited ($Snap.combine $Snap.unit $Snap.unit) this@59@00 p@60@00 (-
            n@61@00
            1)))
        (as Seq_empty  Seq<Int>))))
  :pattern ((initializeSeqWithZeros s@$ this@59@00 p@60@00 n@61@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (=
    (valid_graph_vertices%limited s@$ this@63@00 p@64@00 V@65@00)
    (valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  :pattern ((valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (valid_graph_vertices%stateless this@63@00 p@64@00 V@65@00)
  :pattern ((valid_graph_vertices%limited s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@63@00 $Ref) (p@64@00 option<array>) (V@65@00 Int)) (!
  (and
    (forall ((i1@112@00 Int)) (!
      (implies
        (and (and (< i1@112@00 V@65@00) (<= 0 i1@112@00)) (< $Perm.No $k@113@00))
        (=
          (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@64@00) i1@112@00))
          i1@112@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) i1@112@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r) V@65@00)
            (<= 0 (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r)))
          (< $Perm.No $k@113@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r))
          r))
      :pattern ((inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r) V@65@00)
            (<= 0 (inv@114@00 s@$ this@63@00 p@64@00 V@65@00 r)))
          (< $Perm.No $k@113@00)
          false)
        (=
          ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
      :pattern (($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
      :qid |qp.fvfValDef0|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
      :pattern (($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) r))
      :qid |qp.fvfResTrgDef1|))
    ($Perm.isReadVar $k@113@00 $Perm.Write)
    (implies
      (and
        (not (= this@63@00 $Ref.null))
        (not (= p@64@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit p@64@00)) V@65@00))
      (=
        (valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00)
        (and
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@64@00))))
              (<=
                0
                ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
            ))
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@64@00))))
              (<
                ($FVF.lookup_int (sm@115@00 s@$ this@63@00 p@64@00 V@65@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
                V@65@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@64@00) unknown_))
            ))))))
  :pattern ((valid_graph_vertices s@$ this@63@00 p@64@00 V@65@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (=
    (FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
    (FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  :pattern ((FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (FlowNetwork%stateless this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
  :pattern ((FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (let ((result@73@00 (FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))) (implies
    (and
      (not (= this@67@00 $Ref.null))
      (= V@70@00 (Seq_length G@68@00))
      (= V@70@00 (Seq_length Gf@69@00))
      (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))
    (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00)))
  :pattern ((FlowNetwork%limited s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (this@67@00 $Ref) (G@68@00 Seq<Seq<Int>>) (Gf@69@00 Seq<Seq<Int>>) (V@70@00 Int) (s@71@00 Int) (t@72@00 Int)) (!
  (implies
    (and
      (not (= this@67@00 $Ref.null))
      (= V@70@00 (Seq_length G@68@00))
      (= V@70@00 (Seq_length Gf@69@00))
      (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))
    (=
      (FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00)
      (and
        (and
          (SquareIntMatrix $Snap.unit this@67@00 G@68@00 V@70@00)
          (SquareIntMatrix $Snap.unit this@67@00 Gf@69@00 V@70@00))
        (NonNegativeCapacities ($Snap.combine $Snap.unit $Snap.unit) this@67@00 G@68@00 V@70@00))))
  :pattern ((FlowNetwork s@$ this@67@00 G@68@00 Gf@69@00 V@70@00 s@71@00 t@72@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (= (scale%limited s@$ amount@74@00) (scale s@$ amount@74@00))
  :pattern ((scale s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (scale%stateless amount@74@00)
  :pattern ((scale%limited s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (amount@74@00 $Perm)) (!
  (implies (>= amount@74@00 $Perm.No) (= (scale s@$ amount@74@00) amount@74@00))
  :pattern ((scale s@$ amount@74@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (=
    (Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00)
    (Flow s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  :pattern ((Flow s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (Flow%stateless this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00)
  :pattern ((Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (this@76@00 $Ref) (G@77@00 Seq<Seq<Int>>) (Gf@78@00 Seq<Seq<Int>>) (V@79@00 Int) (s@80@00 Int) (t@81@00 Int)) (!
  (let ((result@82@00 (Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))) (implies
    (and
      (not (= this@76@00 $Ref.null))
      (= V@79@00 (Seq_length G@77@00))
      (= V@79@00 (Seq_length Gf@78@00)))
    (and
      (FlowConservation ($Snap.combine $Snap.unit $Snap.unit) this@76@00 G@77@00 V@79@00 s@80@00 t@81@00)
      (CapacityConstraint ($Snap.combine
        $Snap.unit
        ($Snap.combine $Snap.unit $Snap.unit)) this@76@00 G@77@00 Gf@78@00 V@79@00))))
  :pattern ((Flow%limited s@$ this@76@00 G@77@00 Gf@78@00 V@79@00 s@80@00 t@81@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (= (as_any%limited s@$ t@83@00) (as_any s@$ t@83@00))
  :pattern ((as_any s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (as_any%stateless t@83@00)
  :pattern ((as_any%limited s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (t@83@00 any)) (!
  (let ((result@84@00 (as_any%limited s@$ t@83@00))) (=
    (any_as $Snap.unit result@84@00)
    t@83@00))
  :pattern ((as_any%limited s@$ t@83@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (= (type%limited s@$ type1@85@00) (type s@$ type1@85@00))
  :pattern ((type s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (type%stateless type1@85@00)
  :pattern ((type%limited s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (type1@85@00 $Ref)) (!
  (let ((result@86@00 (type%limited s@$ type1@85@00))) (and
    (<= 0 result@86@00)
    (< result@86@00 3)
    (implies (= type1@85@00 $Ref.null) (= result@86@00 0))
    (implies (not (= type1@85@00 $Ref.null)) (not (= result@86@00 0)))))
  :pattern ((type%limited s@$ type1@85@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (=
    (opt_or_else%limited s@$ opt1@87@00 alt@88@00)
    (opt_or_else s@$ opt1@87@00 alt@88@00))
  :pattern ((opt_or_else s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (opt_or_else%stateless opt1@87@00 alt@88@00)
  :pattern ((opt_or_else%limited s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (let ((result@89@00 (opt_or_else%limited s@$ opt1@87@00 alt@88@00))) (and
    (implies
      (= opt1@87@00 (as None<option<any>>  option<any>))
      (= result@89@00 alt@88@00))
    (implies
      (not (= opt1@87@00 (as None<option<any>>  option<any>)))
      (= result@89@00 (opt_get $Snap.unit opt1@87@00)))))
  :pattern ((opt_or_else%limited s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@87@00 option<any>) (alt@88@00 any)) (!
  (=
    (opt_or_else s@$ opt1@87@00 alt@88@00)
    (ite
      (= opt1@87@00 (as None<option<any>>  option<any>))
      alt@88@00
      (opt_get $Snap.unit opt1@87@00)))
  :pattern ((opt_or_else s@$ opt1@87@00 alt@88@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (=
    (subtype%limited s@$ subtype1@90@00 subtype2@91@00)
    (subtype s@$ subtype1@90@00 subtype2@91@00))
  :pattern ((subtype s@$ subtype1@90@00 subtype2@91@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (subtype%stateless subtype1@90@00 subtype2@91@00)
  :pattern ((subtype%limited s@$ subtype1@90@00 subtype2@91@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@90@00 Int) (subtype2@91@00 Int)) (!
  (implies
    (and
      (<= 0 subtype1@90@00)
      (< subtype1@90@00 3)
      (<= 0 subtype2@91@00)
      (<= subtype2@91@00 2))
    (=
      (subtype s@$ subtype1@90@00 subtype2@91@00)
      (and
        (implies (= subtype1@90@00 2) (= subtype2@91@00 2))
        (implies (= subtype1@90@00 1) (= subtype2@91@00 1)))))
  :pattern ((subtype s@$ subtype1@90@00 subtype2@91@00))
  )))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- check_unknown ----------
(declare-const P@0@03 option<array>)
(declare-const V@1@03 Int)
(declare-const i1@2@03 Int)
(declare-const exc@3@03 $Ref)
(declare-const res@4@03 void)
(declare-const P@5@03 option<array>)
(declare-const V@6@03 Int)
(declare-const i1@7@03 Int)
(declare-const exc@8@03 $Ref)
(declare-const res@9@03 void)
(push) ; 1
(declare-const $t@10@03 $Snap)
(assert (= $t@10@03 ($Snap.combine ($Snap.first $t@10@03) ($Snap.second $t@10@03))))
(assert (= ($Snap.first $t@10@03) $Snap.unit))
; [eval] 0 < V ==> P != (None(): option[array])
; [eval] 0 < V
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (< 0 V@6@03))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10
;  :arith-assert-lower      3
;  :arith-assert-upper      2
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    2
;  :datatype-constructor-ax 1
;  :datatype-occurs-check   2
;  :datatype-splits         1
;  :decisions               1
;  :final-checks            2
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.18
;  :mk-bool-var             413
;  :num-allocs              158063
;  :num-checks              1
;  :quant-instantiations    2
;  :rlimit-count            180175)
(push) ; 3
(assert (not (< 0 V@6@03)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12
;  :arith-assert-lower      3
;  :arith-assert-upper      3
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    2
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   4
;  :datatype-splits         2
;  :decisions               2
;  :final-checks            4
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.18
;  :mk-bool-var             415
;  :num-allocs              158433
;  :num-checks              2
;  :quant-instantiations    2
;  :rlimit-count            180671)
; [then-branch: 0 | 0 < V@6@03 | live]
; [else-branch: 0 | !(0 < V@6@03) | live]
(push) ; 3
; [then-branch: 0 | 0 < V@6@03]
(assert (< 0 V@6@03))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
(push) ; 3
; [else-branch: 0 | !(0 < V@6@03)]
(assert (not (< 0 V@6@03)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies (< 0 V@6@03) (not (= P@5@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second $t@10@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@10@03))
    ($Snap.second ($Snap.second $t@10@03)))))
(assert (= ($Snap.first ($Snap.second $t@10@03)) $Snap.unit))
; [eval] 0 < V ==> alen(opt_get1(P)) == V
; [eval] 0 < V
(push) ; 2
(push) ; 3
(assert (not (not (< 0 V@6@03))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20
;  :arith-assert-lower      4
;  :arith-assert-upper      3
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 3
;  :datatype-occurs-check   6
;  :datatype-splits         3
;  :decisions               3
;  :final-checks            6
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             420
;  :mk-clause               1
;  :num-allocs              158976
;  :num-checks              3
;  :propagations            1
;  :quant-instantiations    2
;  :rlimit-count            181437)
(push) ; 3
(assert (not (< 0 V@6@03)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22
;  :arith-assert-lower      4
;  :arith-assert-upper      4
;  :arith-eq-adapter        2
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             421
;  :mk-clause               1
;  :num-allocs              159345
;  :num-checks              4
;  :propagations            1
;  :quant-instantiations    2
;  :rlimit-count            181937)
; [then-branch: 1 | 0 < V@6@03 | live]
; [else-branch: 1 | !(0 < V@6@03) | live]
(push) ; 3
; [then-branch: 1 | 0 < V@6@03]
(assert (< 0 V@6@03))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 5
(assert (not (not (= P@5@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22
;  :arith-assert-lower      5
;  :arith-assert-upper      4
;  :arith-eq-adapter        2
;  :conflicts               1
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          1
;  :max-memory              4.38
;  :memory                  4.20
;  :mk-bool-var             421
;  :mk-clause               1
;  :num-allocs              159487
;  :num-checks              5
;  :propagations            2
;  :quant-instantiations    2
;  :rlimit-count            182045)
(assert (not (= P@5@03 (as None<option<array>>  option<array>))))
(pop) ; 4
; Joined path conditions
(assert (not (= P@5@03 (as None<option<array>>  option<array>))))
(pop) ; 3
(push) ; 3
; [else-branch: 1 | !(0 < V@6@03)]
(assert (not (< 0 V@6@03)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (< 0 V@6@03)
  (and (< 0 V@6@03) (not (= P@5@03 (as None<option<array>>  option<array>))))))
; Joined path conditions
(assert (implies (< 0 V@6@03) (= (alen<Int> (opt_get1 $Snap.unit P@5@03)) V@6@03)))
(assert (=
  ($Snap.second ($Snap.second $t@10@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@10@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@10@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@10@03))) $Snap.unit))
; [eval] 0 <= i1
(assert (<= 0 i1@7@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@10@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@03)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@03))))
  $Snap.unit))
; [eval] i1 < V
(assert (< i1@7@03 V@6@03))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 3
(assert (not (not (= P@5@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40
;  :arith-assert-lower      10
;  :arith-assert-upper      5
;  :arith-bound-prop        1
;  :arith-eq-adapter        3
;  :arith-fixed-eqs         1
;  :arith-pivots            1
;  :conflicts               2
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.21
;  :mk-bool-var             437
;  :mk-clause               7
;  :num-allocs              159935
;  :num-checks              6
;  :propagations            5
;  :quant-instantiations    7
;  :rlimit-count            182812)
(assert (not (= P@5@03 (as None<option<array>>  option<array>))))
(pop) ; 2
; Joined path conditions
(assert (not (= P@5@03 (as None<option<array>>  option<array>))))
(push) ; 2
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 3
(assert (not (< i1@7@03 (alen<Int> (opt_get1 $Snap.unit P@5@03)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40
;  :arith-add-rows          3
;  :arith-assert-lower      10
;  :arith-assert-upper      6
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        3
;  :arith-fixed-eqs         1
;  :arith-pivots            3
;  :conflicts               3
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.21
;  :mk-bool-var             438
;  :mk-clause               7
;  :num-allocs              160094
;  :num-checks              7
;  :propagations            5
;  :quant-instantiations    7
;  :rlimit-count            183014)
(assert (< i1@7@03 (alen<Int> (opt_get1 $Snap.unit P@5@03))))
(pop) ; 2
; Joined path conditions
(assert (< i1@7@03 (alen<Int> (opt_get1 $Snap.unit P@5@03))))
(assert (not
  (=
    (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit P@5@03) i1@7@03)
    $Ref.null)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@11@03 $Snap)
(assert (= $t@11@03 ($Snap.combine ($Snap.first $t@11@03) ($Snap.second $t@11@03))))
(assert (= ($Snap.first $t@11@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@8@03 $Ref.null))
(assert (=
  ($Snap.second $t@11@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@11@03))
    ($Snap.second ($Snap.second $t@11@03)))))
(assert (= ($Snap.first ($Snap.second $t@11@03)) $Snap.unit))
; [eval] exc == null && 0 < V ==> P != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 2 | exc@8@03 == Null | live]
; [else-branch: 2 | exc@8@03 != Null | live]
(push) ; 4
; [then-branch: 2 | exc@8@03 == Null]
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 2 | exc@8@03 != Null]
(assert (not (= exc@8@03 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (and (< 0 V@6@03) (= exc@8@03 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               83
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      8
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        8
;  :arith-pivots            3
;  :conflicts               3
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 7
;  :datatype-occurs-check   15
;  :datatype-splits         7
;  :decisions               9
;  :del-clause              13
;  :final-checks            13
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.25
;  :mk-bool-var             459
;  :mk-clause               15
;  :num-allocs              161522
;  :num-checks              9
;  :propagations            11
;  :quant-instantiations    12
;  :rlimit-count            184750)
(push) ; 4
(assert (not (and (< 0 V@6@03) (= exc@8@03 $Ref.null))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               83
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      8
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        8
;  :arith-pivots            3
;  :conflicts               4
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 7
;  :datatype-occurs-check   15
;  :datatype-splits         7
;  :decisions               9
;  :del-clause              13
;  :final-checks            13
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.25
;  :mk-bool-var             459
;  :mk-clause               15
;  :num-allocs              161592
;  :num-checks              10
;  :propagations            11
;  :quant-instantiations    12
;  :rlimit-count            184802)
; [then-branch: 3 | 0 < V@6@03 && exc@8@03 == Null | live]
; [else-branch: 3 | !(0 < V@6@03 && exc@8@03 == Null) | dead]
(push) ; 4
; [then-branch: 3 | 0 < V@6@03 && exc@8@03 == Null]
(assert (and (< 0 V@6@03) (= exc@8@03 $Ref.null)))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< 0 V@6@03) (= exc@8@03 $Ref.null))
  (not (= P@5@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@11@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@11@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@11@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@11@03))) $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(P)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 4 | exc@8@03 == Null | live]
; [else-branch: 4 | exc@8@03 != Null | live]
(push) ; 4
; [then-branch: 4 | exc@8@03 == Null]
(assert (= exc@8@03 $Ref.null))
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 4 | exc@8@03 != Null]
(assert (not (= exc@8@03 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(push) ; 4
(assert (not (not (and (< 0 V@6@03) (= exc@8@03 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               102
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      9
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        12
;  :arith-pivots            3
;  :conflicts               4
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   19
;  :datatype-splits         9
;  :decisions               12
;  :del-clause              13
;  :final-checks            15
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.25
;  :mk-bool-var             463
;  :mk-clause               15
;  :num-allocs              162242
;  :num-checks              11
;  :propagations            12
;  :quant-instantiations    12
;  :rlimit-count            185574)
(push) ; 4
(assert (not (and (< 0 V@6@03) (= exc@8@03 $Ref.null))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               102
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      9
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        12
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 9
;  :datatype-occurs-check   19
;  :datatype-splits         9
;  :decisions               12
;  :del-clause              13
;  :final-checks            15
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.25
;  :mk-bool-var             463
;  :mk-clause               15
;  :num-allocs              162312
;  :num-checks              12
;  :propagations            12
;  :quant-instantiations    12
;  :rlimit-count            185626)
; [then-branch: 5 | 0 < V@6@03 && exc@8@03 == Null | live]
; [else-branch: 5 | !(0 < V@6@03 && exc@8@03 == Null) | dead]
(push) ; 4
; [then-branch: 5 | 0 < V@6@03 && exc@8@03 == Null]
(assert (and (< 0 V@6@03) (= exc@8@03 $Ref.null)))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< 0 V@6@03) (= exc@8@03 $Ref.null))
  (= (alen<Int> (opt_get1 $Snap.unit P@5@03)) V@6@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@11@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@11@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@11@03))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= i1
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@8@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               122
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      10
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        16
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 11
;  :datatype-occurs-check   25
;  :datatype-splits         11
;  :decisions               15
;  :del-clause              13
;  :final-checks            17
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             467
;  :mk-clause               15
;  :num-allocs              162979
;  :num-checks              13
;  :propagations            13
;  :quant-instantiations    12
;  :rlimit-count            186395)
(push) ; 4
(assert (not (= exc@8@03 $Ref.null)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               122
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      10
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        16
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 11
;  :datatype-occurs-check   25
;  :datatype-splits         11
;  :decisions               15
;  :del-clause              13
;  :final-checks            17
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             467
;  :mk-clause               15
;  :num-allocs              162995
;  :num-checks              14
;  :propagations            13
;  :quant-instantiations    12
;  :rlimit-count            186406)
; [then-branch: 6 | exc@8@03 == Null | live]
; [else-branch: 6 | exc@8@03 != Null | dead]
(push) ; 4
; [then-branch: 6 | exc@8@03 == Null]
(assert (= exc@8@03 $Ref.null))
; [eval] 0 <= i1
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies (= exc@8@03 $Ref.null) (<= 0 i1@7@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03)))))
  $Snap.unit))
; [eval] exc == null ==> i1 < V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@8@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      11
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        20
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    11
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   31
;  :datatype-splits         13
;  :decisions               18
;  :del-clause              13
;  :final-checks            19
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             471
;  :mk-clause               15
;  :num-allocs              163600
;  :num-checks              15
;  :propagations            14
;  :quant-instantiations    12
;  :rlimit-count            187122)
(push) ; 4
(assert (not (= exc@8@03 $Ref.null)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      11
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        20
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    11
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   31
;  :datatype-splits         13
;  :decisions               18
;  :del-clause              13
;  :final-checks            19
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             471
;  :mk-clause               15
;  :num-allocs              163616
;  :num-checks              16
;  :propagations            14
;  :quant-instantiations    12
;  :rlimit-count            187133)
; [then-branch: 7 | exc@8@03 == Null | live]
; [else-branch: 7 | exc@8@03 != Null | dead]
(push) ; 4
; [then-branch: 7 | exc@8@03 == Null]
(assert (= exc@8@03 $Ref.null))
; [eval] i1 < V
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies (= exc@8@03 $Ref.null) (< i1@7@03 V@6@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03)))))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@8@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               163
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      12
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        24
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   37
;  :datatype-splits         16
;  :decisions               22
;  :del-clause              13
;  :final-checks            21
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             475
;  :mk-clause               15
;  :num-allocs              164221
;  :num-checks              17
;  :propagations            15
;  :quant-instantiations    12
;  :rlimit-count            187849)
(push) ; 3
(assert (not (= exc@8@03 $Ref.null)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               163
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      12
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        24
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 16
;  :datatype-occurs-check   37
;  :datatype-splits         16
;  :decisions               22
;  :del-clause              13
;  :final-checks            21
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             475
;  :mk-clause               15
;  :num-allocs              164237
;  :num-checks              18
;  :propagations            15
;  :quant-instantiations    12
;  :rlimit-count            187860)
; [then-branch: 8 | exc@8@03 == Null | live]
; [else-branch: 8 | exc@8@03 != Null | dead]
(push) ; 3
; [then-branch: 8 | exc@8@03 == Null]
(assert (= exc@8@03 $Ref.null))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 4
; Joined path conditions
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03))))))
  $Snap.unit))
; [eval] exc == null ==> aloc(opt_get1(P), i1).int == 0
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@8@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               178
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      13
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        28
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 18
;  :datatype-occurs-check   43
;  :datatype-splits         18
;  :decisions               25
;  :del-clause              13
;  :final-checks            23
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             478
;  :mk-clause               15
;  :num-allocs              164818
;  :num-checks              19
;  :propagations            16
;  :quant-instantiations    12
;  :rlimit-count            188508)
; [then-branch: 9 | exc@8@03 == Null | live]
; [else-branch: 9 | exc@8@03 != Null | dead]
(push) ; 5
; [then-branch: 9 | exc@8@03 == Null]
; [eval] aloc(opt_get1(P), i1).int == 0
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@8@03 $Ref.null)
  (=
    ($SortWrappers.$SnapToInt ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@11@03)))))))
    0)))
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; var return: void
(declare-const return@12@03 void)
; [exec]
; exc := null
; [exec]
; aloc(opt_get1(P), i1).int := 0
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 3
; Joined path conditions
; [exec]
; label end
; [exec]
; res := return
; [exec]
; label bubble
; [eval] exc == null
; [eval] exc == null && 0 < V ==> P != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 10 | True | live]
; [else-branch: 10 | False | live]
(push) ; 4
; [then-branch: 10 | True]
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 10 | False]
(assert false)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(push) ; 4
(assert (not (not (< 0 V@6@03))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               186
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      14
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        32
;  :arith-pivots            3
;  :conflicts               5
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 19
;  :datatype-occurs-check   46
;  :datatype-splits         19
;  :decisions               27
;  :del-clause              13
;  :final-checks            25
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             479
;  :mk-clause               15
;  :num-allocs              165355
;  :num-checks              20
;  :propagations            17
;  :quant-instantiations    12
;  :rlimit-count            189121)
(push) ; 4
(assert (not (< 0 V@6@03)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               186
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      14
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        32
;  :arith-pivots            3
;  :conflicts               6
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 19
;  :datatype-occurs-check   46
;  :datatype-splits         19
;  :decisions               27
;  :del-clause              13
;  :final-checks            25
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             479
;  :mk-clause               15
;  :num-allocs              165425
;  :num-checks              21
;  :propagations            17
;  :quant-instantiations    12
;  :rlimit-count            189169)
; [then-branch: 11 | 0 < V@6@03 | live]
; [else-branch: 11 | !(0 < V@6@03) | dead]
(push) ; 4
; [then-branch: 11 | 0 < V@6@03]
(assert (< 0 V@6@03))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
; [eval] exc == null && 0 < V ==> alen(opt_get1(P)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 12 | True | live]
; [else-branch: 12 | False | live]
(push) ; 4
; [then-branch: 12 | True]
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 12 | False]
(assert false)
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(push) ; 4
(assert (not (not (< 0 V@6@03))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               194
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      15
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        36
;  :arith-pivots            3
;  :conflicts               6
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 20
;  :datatype-occurs-check   49
;  :datatype-splits         20
;  :decisions               29
;  :del-clause              13
;  :final-checks            27
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             480
;  :mk-clause               15
;  :num-allocs              165963
;  :num-checks              22
;  :propagations            18
;  :quant-instantiations    12
;  :rlimit-count            189743)
(push) ; 4
(assert (not (< 0 V@6@03)))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               194
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      15
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        36
;  :arith-pivots            3
;  :conflicts               7
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 20
;  :datatype-occurs-check   49
;  :datatype-splits         20
;  :decisions               29
;  :del-clause              13
;  :final-checks            27
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             480
;  :mk-clause               15
;  :num-allocs              166033
;  :num-checks              23
;  :propagations            18
;  :quant-instantiations    12
;  :rlimit-count            189791)
; [then-branch: 13 | 0 < V@6@03 | live]
; [else-branch: 13 | !(0 < V@6@03) | dead]
(push) ; 4
; [then-branch: 13 | 0 < V@6@03]
(assert (< 0 V@6@03))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
; [eval] exc == null ==> 0 <= i1
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               202
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      16
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        40
;  :arith-pivots            3
;  :conflicts               7
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   52
;  :datatype-splits         21
;  :decisions               31
;  :del-clause              13
;  :final-checks            29
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             481
;  :mk-clause               15
;  :num-allocs              166575
;  :num-checks              24
;  :propagations            19
;  :quant-instantiations    12
;  :rlimit-count            190344)
; [then-branch: 14 | True | live]
; [else-branch: 14 | False | dead]
(push) ; 4
; [then-branch: 14 | True]
; [eval] 0 <= i1
(pop) ; 4
(pop) ; 3
; Joined path conditions
; [eval] exc == null ==> i1 < V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not false))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               210
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      17
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        44
;  :arith-pivots            3
;  :conflicts               7
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 22
;  :datatype-occurs-check   55
;  :datatype-splits         22
;  :decisions               33
;  :del-clause              13
;  :final-checks            31
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             482
;  :mk-clause               15
;  :num-allocs              167052
;  :num-checks              25
;  :propagations            20
;  :quant-instantiations    12
;  :rlimit-count            190845)
; [then-branch: 15 | True | live]
; [else-branch: 15 | False | dead]
(push) ; 4
; [then-branch: 15 | True]
; [eval] i1 < V
(pop) ; 4
(pop) ; 3
; Joined path conditions
; [eval] exc == null
(push) ; 3
(assert (not false))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               218
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      18
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        48
;  :arith-pivots            3
;  :conflicts               7
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 23
;  :datatype-occurs-check   58
;  :datatype-splits         23
;  :decisions               35
;  :del-clause              13
;  :final-checks            33
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             483
;  :mk-clause               15
;  :num-allocs              167529
;  :num-checks              26
;  :propagations            21
;  :quant-instantiations    12
;  :rlimit-count            191341)
; [then-branch: 16 | True | live]
; [else-branch: 16 | False | dead]
(push) ; 3
; [then-branch: 16 | True]
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
; Joined path conditions
(push) ; 4
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 4
; Joined path conditions
; [eval] exc == null ==> aloc(opt_get1(P), i1).int == 0
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not false))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               226
;  :arith-add-rows          4
;  :arith-assert-lower      11
;  :arith-assert-upper      19
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         1
;  :arith-offset-eqs        52
;  :arith-pivots            3
;  :conflicts               7
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               37
;  :del-clause              13
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          2
;  :max-memory              4.38
;  :memory                  4.26
;  :mk-bool-var             484
;  :mk-clause               15
;  :num-allocs              168006
;  :num-checks              27
;  :propagations            22
;  :quant-instantiations    12
;  :rlimit-count            191852)
; [then-branch: 17 | True | live]
; [else-branch: 17 | False | dead]
(push) ; 5
; [then-branch: 17 | True]
; [eval] aloc(opt_get1(P), i1).int == 0
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(pop) ; 3
(pop) ; 2
(pop) ; 1
; ---------- max_flow ----------
(declare-const this@13@03 $Ref)
(declare-const tid@14@03 Int)
(declare-const G@15@03 option<array>)
(declare-const s@16@03 Int)
(declare-const t@17@03 Int)
(declare-const V@18@03 Int)
(declare-const exc@19@03 $Ref)
(declare-const res@20@03 Int)
(declare-const this@21@03 $Ref)
(declare-const tid@22@03 Int)
(declare-const G@23@03 option<array>)
(declare-const s@24@03 Int)
(declare-const t@25@03 Int)
(declare-const V@26@03 Int)
(declare-const exc@27@03 $Ref)
(declare-const res@28@03 Int)
(push) ; 1
(declare-const $t@29@03 $Snap)
(assert (= $t@29@03 ($Snap.combine ($Snap.first $t@29@03) ($Snap.second $t@29@03))))
(assert (= ($Snap.first $t@29@03) $Snap.unit))
; [eval] this != null
(assert (not (= this@21@03 $Ref.null)))
(assert (=
  ($Snap.second $t@29@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@29@03))
    ($Snap.second ($Snap.second $t@29@03)))))
(assert (=
  ($Snap.second ($Snap.second $t@29@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@29@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@29@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@29@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@29@03))))
  $Snap.unit))
; [eval] |this.Gf_seq| == V
; [eval] |this.Gf_seq|
(assert (=
  (Seq_length
    ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03))))
  V@26@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))
  $Snap.unit))
; [eval] |this.P_seq| == V
; [eval] |this.P_seq|
(assert (=
  (Seq_length
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second $t@29@03)))))
  V@26@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))
  $Snap.unit))
; [eval] SquareIntMatrix(this, this.Gf_seq, V)
(push) ; 2
; [eval] this != null
(pop) ; 2
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03))) V@26@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))
  $Snap.unit))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= G@23@03 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))
  $Snap.unit))
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit G@23@03)) V@26@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))
(declare-const i1@30@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 18 | 0 <= i1@30@03 | live]
; [else-branch: 18 | !(0 <= i1@30@03) | live]
(push) ; 4
; [then-branch: 18 | 0 <= i1@30@03]
(assert (<= 0 i1@30@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 18 | !(0 <= i1@30@03)]
(assert (not (<= 0 i1@30@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@30@03 V@26@03) (<= 0 i1@30@03)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 4
(assert (not (< i1@30@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               291
;  :arith-add-rows          12
;  :arith-assert-diseq      3
;  :arith-assert-lower      21
;  :arith-assert-upper      24
;  :arith-bound-prop        5
;  :arith-conflicts         1
;  :arith-eq-adapter        10
;  :arith-fixed-eqs         4
;  :arith-offset-eqs        52
;  :arith-pivots            9
;  :conflicts               7
;  :datatype-accessor-ax    22
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               37
;  :del-clause              15
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.29
;  :mk-bool-var             552
;  :mk-clause               50
;  :num-allocs              169143
;  :num-checks              28
;  :propagations            32
;  :quant-instantiations    28
;  :rlimit-count            194313)
(assert (< i1@30@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 3
; Joined path conditions
(assert (< i1@30@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(declare-const $k@31@03 $Perm)
(assert ($Perm.isReadVar $k@31@03 $Perm.Write))
(pop) ; 2
(declare-fun inv@32@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@31@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@30@03 Int)) (!
  (< i1@30@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@30@03))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@30@03 Int)) (!
  (implies
    (and (< i1@30@03 V@26@03) (<= 0 i1@30@03))
    (or (= $k@31@03 $Perm.No) (< $Perm.No $k@31@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               293
;  :arith-add-rows          17
;  :arith-assert-diseq      4
;  :arith-assert-lower      23
;  :arith-assert-upper      25
;  :arith-bound-prop        5
;  :arith-conflicts         1
;  :arith-eq-adapter        11
;  :arith-fixed-eqs         4
;  :arith-offset-eqs        52
;  :arith-pivots            10
;  :conflicts               8
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               37
;  :del-clause              26
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.30
;  :mk-bool-var             559
;  :mk-clause               52
;  :num-allocs              169613
;  :num-checks              29
;  :propagations            33
;  :quant-instantiations    28
;  :rlimit-count            194947)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@30@03 Int) (i12@30@03 Int)) (!
  (implies
    (and
      (and (and (< i11@30@03 V@26@03) (<= 0 i11@30@03)) (< $Perm.No $k@31@03))
      (and (and (< i12@30@03 V@26@03) (<= 0 i12@30@03)) (< $Perm.No $k@31@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@30@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@30@03)))
    (= i11@30@03 i12@30@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               313
;  :arith-add-rows          53
;  :arith-assert-diseq      9
;  :arith-assert-lower      29
;  :arith-assert-upper      30
;  :arith-bound-prop        11
;  :arith-conflicts         1
;  :arith-eq-adapter        12
;  :arith-fixed-eqs         4
;  :arith-offset-eqs        54
;  :arith-pivots            17
;  :conflicts               10
;  :datatype-accessor-ax    23
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              54
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.34
;  :mk-bool-var             590
;  :mk-clause               80
;  :num-allocs              170114
;  :num-checks              30
;  :propagations            53
;  :quant-instantiations    39
;  :rlimit-count            196544)
; Definitional axioms for inverse functions
(assert (forall ((i1@30@03 Int)) (!
  (implies
    (and (and (< i1@30@03 V@26@03) (<= 0 i1@30@03)) (< $Perm.No $k@31@03))
    (=
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@30@03))
      i1@30@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@30@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
      (< $Perm.No $k@31@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@32@03 r))
      r))
  :pattern ((inv@32@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@30@03 Int)) (!
  (<= $Perm.No $k@31@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@30@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@30@03 Int)) (!
  (<= $k@31@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@30@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@30@03 Int)) (!
  (implies
    (and (and (< i1@30@03 V@26@03) (<= 0 i1@30@03)) (< $Perm.No $k@31@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@30@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@30@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@33@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
      (< $Perm.No $k@31@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef1|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) r) r))
  :pattern ((inv@32@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@34@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 19 | 0 <= i1@34@03 | live]
; [else-branch: 19 | !(0 <= i1@34@03) | live]
(push) ; 4
; [then-branch: 19 | 0 <= i1@34@03]
(assert (<= 0 i1@34@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 19 | !(0 <= i1@34@03)]
(assert (not (<= 0 i1@34@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 20 | i1@34@03 < V@26@03 && 0 <= i1@34@03 | live]
; [else-branch: 20 | !(i1@34@03 < V@26@03 && 0 <= i1@34@03) | live]
(push) ; 4
; [then-branch: 20 | i1@34@03 < V@26@03 && 0 <= i1@34@03]
(assert (and (< i1@34@03 V@26@03) (<= 0 i1@34@03)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@34@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               319
;  :arith-add-rows          55
;  :arith-assert-diseq      12
;  :arith-assert-lower      32
;  :arith-assert-upper      33
;  :arith-bound-prop        14
;  :arith-conflicts         1
;  :arith-eq-adapter        12
;  :arith-fixed-eqs         4
;  :arith-offset-eqs        54
;  :arith-pivots            17
;  :conflicts               10
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              54
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.34
;  :mk-bool-var             609
;  :mk-clause               91
;  :num-allocs              171417
;  :num-checks              31
;  :propagations            57
;  :quant-instantiations    40
;  :rlimit-count            199216)
(assert (< i1@34@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 5
; Joined path conditions
(assert (< i1@34@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03))
      V@26@03)
    (<=
      0
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03))))
  (< $Perm.No $k@31@03)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               324
;  :arith-add-rows          61
;  :arith-assert-diseq      12
;  :arith-assert-lower      33
;  :arith-assert-upper      35
;  :arith-bound-prop        15
;  :arith-conflicts         2
;  :arith-eq-adapter        13
;  :arith-fixed-eqs         5
;  :arith-offset-eqs        54
;  :arith-pivots            19
;  :conflicts               11
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              54
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.36
;  :mk-bool-var             627
;  :mk-clause               98
;  :num-allocs              171726
;  :num-checks              32
;  :propagations            57
;  :quant-instantiations    50
;  :rlimit-count            199902)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 20 | !(i1@34@03 < V@26@03 && 0 <= i1@34@03)]
(assert (not (and (< i1@34@03 V@26@03) (<= 0 i1@34@03))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@34@03 V@26@03) (<= 0 i1@34@03))
  (and
    (< i1@34@03 V@26@03)
    (<= 0 i1@34@03)
    (< i1@34@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@34@03 Int)) (!
  (implies
    (and (< i1@34@03 V@26@03) (<= 0 i1@34@03))
    (and
      (< i1@34@03 V@26@03)
      (<= 0 i1@34@03)
      (< i1@34@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@34@03 Int)) (!
  (implies
    (and (< i1@34@03 V@26@03) (<= 0 i1@34@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@34@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@35@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 21 | 0 <= i1@35@03 | live]
; [else-branch: 21 | !(0 <= i1@35@03) | live]
(push) ; 4
; [then-branch: 21 | 0 <= i1@35@03]
(assert (<= 0 i1@35@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 21 | !(0 <= i1@35@03)]
(assert (not (<= 0 i1@35@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 22 | i1@35@03 < V@26@03 && 0 <= i1@35@03 | live]
; [else-branch: 22 | !(i1@35@03 < V@26@03 && 0 <= i1@35@03) | live]
(push) ; 4
; [then-branch: 22 | i1@35@03 < V@26@03 && 0 <= i1@35@03]
(assert (and (< i1@35@03 V@26@03) (<= 0 i1@35@03)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               330
;  :arith-add-rows          65
;  :arith-assert-diseq      15
;  :arith-assert-lower      36
;  :arith-assert-upper      37
;  :arith-bound-prop        18
;  :arith-conflicts         2
;  :arith-eq-adapter        13
;  :arith-fixed-eqs         5
;  :arith-offset-eqs        54
;  :arith-pivots            22
;  :conflicts               11
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              72
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.35
;  :mk-bool-var             641
;  :mk-clause               109
;  :num-allocs              172352
;  :num-checks              33
;  :propagations            61
;  :quant-instantiations    51
;  :rlimit-count            201257)
(assert (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 5
; Joined path conditions
(assert (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))
      V@26@03)
    (<=
      0
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))))
  (< $Perm.No $k@31@03)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               339
;  :arith-add-rows          73
;  :arith-assert-diseq      15
;  :arith-assert-lower      37
;  :arith-assert-upper      39
;  :arith-bound-prop        20
;  :arith-conflicts         3
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         6
;  :arith-offset-eqs        55
;  :arith-pivots            24
;  :conflicts               12
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              72
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.36
;  :mk-bool-var             661
;  :mk-clause               116
;  :num-allocs              172644
;  :num-checks              34
;  :propagations            64
;  :quant-instantiations    63
;  :rlimit-count            201995)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               339
;  :arith-add-rows          73
;  :arith-assert-diseq      15
;  :arith-assert-lower      37
;  :arith-assert-upper      39
;  :arith-bound-prop        20
;  :arith-conflicts         3
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         6
;  :arith-offset-eqs        55
;  :arith-pivots            24
;  :conflicts               13
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              72
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.36
;  :mk-bool-var             661
;  :mk-clause               116
;  :num-allocs              172734
;  :num-checks              35
;  :propagations            64
;  :quant-instantiations    63
;  :rlimit-count            202090)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 22 | !(i1@35@03 < V@26@03 && 0 <= i1@35@03)]
(assert (not (and (< i1@35@03 V@26@03) (<= 0 i1@35@03))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@35@03 V@26@03) (<= 0 i1@35@03))
  (and
    (< i1@35@03 V@26@03)
    (<= 0 i1@35@03)
    (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@35@03 Int)) (!
  (implies
    (and (< i1@35@03 V@26@03) (<= 0 i1@35@03))
    (and
      (< i1@35@03 V@26@03)
      (<= 0 i1@35@03)
      (< i1@35@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@35@03 Int)) (!
  (implies
    (and (< i1@35@03 V@26@03) (<= 0 i1@35@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@35@03)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@36@03 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@37@03 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 23 | 0 <= i1@36@03 | live]
; [else-branch: 23 | !(0 <= i1@36@03) | live]
(push) ; 5
; [then-branch: 23 | 0 <= i1@36@03]
(assert (<= 0 i1@36@03))
; [eval] i1 < V
(push) ; 6
; [then-branch: 24 | i1@36@03 < V@26@03 | live]
; [else-branch: 24 | !(i1@36@03 < V@26@03) | live]
(push) ; 7
; [then-branch: 24 | i1@36@03 < V@26@03]
(assert (< i1@36@03 V@26@03))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 25 | 0 <= i2@37@03 | live]
; [else-branch: 25 | !(0 <= i2@37@03) | live]
(push) ; 9
; [then-branch: 25 | 0 <= i2@37@03]
(assert (<= 0 i2@37@03))
; [eval] i2 < V
(push) ; 10
; [then-branch: 26 | i2@37@03 < V@26@03 | live]
; [else-branch: 26 | !(i2@37@03 < V@26@03) | live]
(push) ; 11
; [then-branch: 26 | i2@37@03 < V@26@03]
(assert (< i2@37@03 V@26@03))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               345
;  :arith-add-rows          78
;  :arith-assert-diseq      18
;  :arith-assert-lower      42
;  :arith-assert-upper      41
;  :arith-bound-prop        23
;  :arith-conflicts         3
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         6
;  :arith-offset-eqs        55
;  :arith-pivots            28
;  :conflicts               13
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              90
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.38
;  :memory                  4.37
;  :mk-bool-var             677
;  :mk-clause               127
;  :num-allocs              173668
;  :num-checks              36
;  :propagations            68
;  :quant-instantiations    64
;  :rlimit-count            203687)
(assert (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
      V@26@03)
    (<=
      0
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))))
  (< $Perm.No $k@31@03)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               353
;  :arith-add-rows          86
;  :arith-assert-diseq      18
;  :arith-assert-lower      43
;  :arith-assert-upper      43
;  :arith-bound-prop        25
;  :arith-conflicts         4
;  :arith-eq-adapter        15
;  :arith-fixed-eqs         7
;  :arith-offset-eqs        56
;  :arith-pivots            30
;  :conflicts               14
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              90
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.39
;  :memory                  4.38
;  :mk-bool-var             696
;  :mk-clause               134
;  :num-allocs              173953
;  :num-checks              37
;  :propagations            71
;  :quant-instantiations    76
;  :rlimit-count            204423)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               353
;  :arith-add-rows          86
;  :arith-assert-diseq      18
;  :arith-assert-lower      43
;  :arith-assert-upper      43
;  :arith-bound-prop        25
;  :arith-conflicts         4
;  :arith-eq-adapter        15
;  :arith-fixed-eqs         7
;  :arith-offset-eqs        56
;  :arith-pivots            30
;  :conflicts               14
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              90
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.39
;  :memory                  4.38
;  :mk-bool-var             696
;  :mk-clause               134
;  :num-allocs              173985
;  :num-checks              38
;  :propagations            71
;  :quant-instantiations    76
;  :rlimit-count            204453)
(assert (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 12
; Joined path conditions
(assert (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03))
      V@26@03)
    (<=
      0
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03))))
  (< $Perm.No $k@31@03)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               360
;  :arith-add-rows          94
;  :arith-assert-diseq      18
;  :arith-assert-lower      44
;  :arith-assert-upper      45
;  :arith-bound-prop        27
;  :arith-conflicts         5
;  :arith-eq-adapter        16
;  :arith-fixed-eqs         8
;  :arith-offset-eqs        56
;  :arith-pivots            32
;  :conflicts               15
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              90
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.43
;  :memory                  4.42
;  :mk-bool-var             715
;  :mk-clause               141
;  :num-allocs              174315
;  :num-checks              39
;  :propagations            74
;  :quant-instantiations    87
;  :rlimit-count            205176)
(pop) ; 11
(push) ; 11
; [else-branch: 26 | !(i2@37@03 < V@26@03)]
(assert (not (< i2@37@03 V@26@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@37@03 V@26@03)
  (and
    (< i2@37@03 V@26@03)
    (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
    (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 25 | !(0 <= i2@37@03)]
(assert (not (<= 0 i2@37@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@37@03)
  (and
    (<= 0 i2@37@03)
    (implies
      (< i2@37@03 V@26@03)
      (and
        (< i2@37@03 V@26@03)
        (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
        (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 24 | !(i1@36@03 < V@26@03)]
(assert (not (< i1@36@03 V@26@03)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@36@03 V@26@03)
  (and
    (< i1@36@03 V@26@03)
    (implies
      (<= 0 i2@37@03)
      (and
        (<= 0 i2@37@03)
        (implies
          (< i2@37@03 V@26@03)
          (and
            (< i2@37@03 V@26@03)
            (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
            (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 23 | !(0 <= i1@36@03)]
(assert (not (<= 0 i1@36@03)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@36@03)
  (and
    (<= 0 i1@36@03)
    (implies
      (< i1@36@03 V@26@03)
      (and
        (< i1@36@03 V@26@03)
        (implies
          (<= 0 i2@37@03)
          (and
            (<= 0 i2@37@03)
            (implies
              (< i2@37@03 V@26@03)
              (and
                (< i2@37@03 V@26@03)
                (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
                (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 27 | Lookup(option$array$,sm@33@03,aloc((_, _), opt_get1(_, G@23@03), i1@36@03)) == Lookup(option$array$,sm@33@03,aloc((_, _), opt_get1(_, G@23@03), i2@37@03)) && i2@37@03 < V@26@03 && 0 <= i2@37@03 && i1@36@03 < V@26@03 && 0 <= i1@36@03 | live]
; [else-branch: 27 | !(Lookup(option$array$,sm@33@03,aloc((_, _), opt_get1(_, G@23@03), i1@36@03)) == Lookup(option$array$,sm@33@03,aloc((_, _), opt_get1(_, G@23@03), i2@37@03)) && i2@37@03 < V@26@03 && 0 <= i2@37@03 && i1@36@03 < V@26@03 && 0 <= i1@36@03) | live]
(push) ; 5
; [then-branch: 27 | Lookup(option$array$,sm@33@03,aloc((_, _), opt_get1(_, G@23@03), i1@36@03)) == Lookup(option$array$,sm@33@03,aloc((_, _), opt_get1(_, G@23@03), i2@37@03)) && i2@37@03 < V@26@03 && 0 <= i2@37@03 && i1@36@03 < V@26@03 && 0 <= i1@36@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
          ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
        (< i2@37@03 V@26@03))
      (<= 0 i2@37@03))
    (< i1@36@03 V@26@03))
  (<= 0 i1@36@03)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 27 | !(Lookup(option$array$,sm@33@03,aloc((_, _), opt_get1(_, G@23@03), i1@36@03)) == Lookup(option$array$,sm@33@03,aloc((_, _), opt_get1(_, G@23@03), i2@37@03)) && i2@37@03 < V@26@03 && 0 <= i2@37@03 && i1@36@03 < V@26@03 && 0 <= i1@36@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
            ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
          (< i2@37@03 V@26@03))
        (<= 0 i2@37@03))
      (< i1@36@03 V@26@03))
    (<= 0 i1@36@03))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
            ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
          (< i2@37@03 V@26@03))
        (<= 0 i2@37@03))
      (< i1@36@03 V@26@03))
    (<= 0 i1@36@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
      ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
    (< i2@37@03 V@26@03)
    (<= 0 i2@37@03)
    (< i1@36@03 V@26@03)
    (<= 0 i1@36@03))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@37@03 Int)) (!
  (and
    (implies
      (<= 0 i1@36@03)
      (and
        (<= 0 i1@36@03)
        (implies
          (< i1@36@03 V@26@03)
          (and
            (< i1@36@03 V@26@03)
            (implies
              (<= 0 i2@37@03)
              (and
                (<= 0 i2@37@03)
                (implies
                  (< i2@37@03 V@26@03)
                  (and
                    (< i2@37@03 V@26@03)
                    (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
                    (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
                ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
              (< i2@37@03 V@26@03))
            (<= 0 i2@37@03))
          (< i1@36@03 V@26@03))
        (<= 0 i1@36@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
          ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
        (< i2@37@03 V@26@03)
        (<= 0 i2@37@03)
        (< i1@36@03 V@26@03)
        (<= 0 i1@36@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@36@03 Int)) (!
  (forall ((i2@37@03 Int)) (!
    (and
      (implies
        (<= 0 i1@36@03)
        (and
          (<= 0 i1@36@03)
          (implies
            (< i1@36@03 V@26@03)
            (and
              (< i1@36@03 V@26@03)
              (implies
                (<= 0 i2@37@03)
                (and
                  (<= 0 i2@37@03)
                  (implies
                    (< i2@37@03 V@26@03)
                    (and
                      (< i2@37@03 V@26@03)
                      (< i1@36@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
                      (< i2@37@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
                  ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
                (< i2@37@03 V@26@03))
              (<= 0 i2@37@03))
            (< i1@36@03 V@26@03))
          (<= 0 i1@36@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
            ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
          (< i2@37@03 V@26@03)
          (<= 0 i2@37@03)
          (< i1@36@03 V@26@03)
          (<= 0 i1@36@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@36@03 Int)) (!
  (forall ((i2@37@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
                ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03)))
              (< i2@37@03 V@26@03))
            (<= 0 i2@37@03))
          (< i1@36@03 V@26@03))
        (<= 0 i1@36@03))
      (= i1@36@03 i2@37@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@37@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@36@03))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))
  $Snap.unit))
; [eval] 0 <= s
(assert (<= 0 s@24@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))
  $Snap.unit))
; [eval] s < V
(assert (< s@24@03 V@26@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))
  $Snap.unit))
; [eval] 0 <= t
(assert (<= 0 t@25@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))
  $Snap.unit))
; [eval] t < V
(assert (< t@25@03 V@26@03))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))))))
(declare-const i1@38@03 Int)
(declare-const j1@39@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 28 | 0 <= i1@38@03 | live]
; [else-branch: 28 | !(0 <= i1@38@03) | live]
(push) ; 4
; [then-branch: 28 | 0 <= i1@38@03]
(assert (<= 0 i1@38@03))
; [eval] i1 < V
(push) ; 5
; [then-branch: 29 | i1@38@03 < V@26@03 | live]
; [else-branch: 29 | !(i1@38@03 < V@26@03) | live]
(push) ; 6
; [then-branch: 29 | i1@38@03 < V@26@03]
(assert (< i1@38@03 V@26@03))
; [eval] 0 <= j1
(push) ; 7
; [then-branch: 30 | 0 <= j1@39@03 | live]
; [else-branch: 30 | !(0 <= j1@39@03) | live]
(push) ; 8
; [then-branch: 30 | 0 <= j1@39@03]
(assert (<= 0 j1@39@03))
; [eval] j1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 30 | !(0 <= j1@39@03)]
(assert (not (<= 0 j1@39@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 29 | !(i1@38@03 < V@26@03)]
(assert (not (< i1@38@03 V@26@03)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 28 | !(0 <= i1@38@03)]
(assert (not (<= 0 i1@38@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@39@03 V@26@03) (<= 0 j1@39@03)) (< i1@38@03 V@26@03))
  (<= 0 i1@38@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@38@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               389
;  :arith-add-rows          106
;  :arith-assert-diseq      21
;  :arith-assert-lower      56
;  :arith-assert-upper      46
;  :arith-bound-prop        30
;  :arith-conflicts         5
;  :arith-eq-adapter        16
;  :arith-fixed-eqs         8
;  :arith-offset-eqs        56
;  :arith-pivots            39
;  :conflicts               15
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              139
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.45
;  :memory                  4.45
;  :mk-bool-var             757
;  :mk-clause               176
;  :num-allocs              175848
;  :num-checks              40
;  :propagations            78
;  :quant-instantiations    88
;  :rlimit-count            209106)
(assert (< i1@38@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 3
; Joined path conditions
(assert (< i1@38@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03)))
(push) ; 3
(assert (not (ite
  (and
    (<
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))
      V@26@03)
    (<=
      0
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))))
  (< $Perm.No $k@31@03)
  false)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               400
;  :arith-add-rows          114
;  :arith-assert-diseq      21
;  :arith-assert-lower      57
;  :arith-assert-upper      48
;  :arith-bound-prop        32
;  :arith-conflicts         6
;  :arith-eq-adapter        17
;  :arith-fixed-eqs         9
;  :arith-offset-eqs        59
;  :arith-pivots            41
;  :conflicts               16
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              139
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.50
;  :mk-bool-var             786
;  :mk-clause               183
;  :num-allocs              176214
;  :num-checks              41
;  :propagations            81
;  :quant-instantiations    103
;  :rlimit-count            210173)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               400
;  :arith-add-rows          114
;  :arith-assert-diseq      21
;  :arith-assert-lower      57
;  :arith-assert-upper      48
;  :arith-bound-prop        32
;  :arith-conflicts         6
;  :arith-eq-adapter        17
;  :arith-fixed-eqs         9
;  :arith-offset-eqs        59
;  :arith-pivots            41
;  :conflicts               17
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              139
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.50
;  :mk-bool-var             786
;  :mk-clause               183
;  :num-allocs              176305
;  :num-checks              42
;  :propagations            81
;  :quant-instantiations    103
;  :rlimit-count            210268)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j1@39@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               406
;  :arith-add-rows          118
;  :arith-assert-diseq      21
;  :arith-assert-lower      60
;  :arith-assert-upper      49
;  :arith-bound-prop        32
;  :arith-conflicts         7
;  :arith-eq-adapter        18
;  :arith-fixed-eqs         10
;  :arith-offset-eqs        59
;  :arith-pivots            43
;  :conflicts               18
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              143
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.50
;  :memory                  4.50
;  :mk-bool-var             797
;  :mk-clause               187
;  :num-allocs              176520
;  :num-checks              43
;  :propagations            83
;  :quant-instantiations    110
;  :rlimit-count            210730)
(assert (<
  j1@39@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j1@39@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))))))
(pop) ; 2
(declare-fun inv@40@03 ($Ref) Int)
(declare-fun inv@41@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@38@03 Int) (j1@39@03 Int)) (!
  (and
    (< i1@38@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@39@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))) j1@39@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@38@03 Int) (j11@39@03 Int) (i12@38@03 Int) (j12@39@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@39@03 V@26@03) (<= 0 j11@39@03)) (< i11@38@03 V@26@03))
        (<= 0 i11@38@03))
      (and
        (and (and (< j12@39@03 V@26@03) (<= 0 j12@39@03)) (< i12@38@03 V@26@03))
        (<= 0 i12@38@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@38@03))) j11@39@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@38@03))) j12@39@03)))
    (and (= i11@38@03 i12@38@03) (= j11@39@03 j12@39@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               454
;  :arith-add-rows          140
;  :arith-assert-diseq      21
;  :arith-assert-lower      72
;  :arith-assert-upper      53
;  :arith-bound-prop        36
;  :arith-conflicts         7
;  :arith-eq-adapter        24
;  :arith-fixed-eqs         12
;  :arith-offset-eqs        65
;  :arith-pivots            54
;  :conflicts               19
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              209
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.73
;  :mk-bool-var             930
;  :mk-clause               246
;  :num-allocs              177824
;  :num-checks              44
;  :propagations            111
;  :quant-instantiations    168
;  :rlimit-count            214436
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@38@03 Int) (j1@39@03 Int)) (!
  (implies
    (and
      (and (and (< j1@39@03 V@26@03) (<= 0 j1@39@03)) (< i1@38@03 V@26@03))
      (<= 0 i1@38@03))
    (and
      (=
        (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))) j1@39@03))
        i1@38@03)
      (=
        (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))) j1@39@03))
        j1@39@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))) j1@39@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
        (< (inv@40@03 r) V@26@03))
      (<= 0 (inv@40@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@40@03 r)))) (inv@41@03 r))
      r))
  :pattern ((inv@40@03 r))
  :pattern ((inv@41@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@38@03 Int) (j1@39@03 Int)) (!
  (implies
    (and
      (and (and (< j1@39@03 V@26@03) (<= 0 j1@39@03)) (< i1@38@03 V@26@03))
      (<= 0 i1@38@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))) j1@39@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@38@03))) j1@39@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@42@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
        (< (inv@40@03 r) V@26@03))
      (<= 0 (inv@40@03 r)))
    (=
      ($FVF.lookup_int (as sm@42@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@42@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@42@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef3|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
        (< (inv@40@03 r) V@26@03))
      (<= 0 (inv@40@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) r) r))
  :pattern ((inv@40@03 r) (inv@41@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { |this.Gf_seq[i1]| } 0 <= i1 && i1 < V ==> |this.Gf_seq[i1]| == V)
(declare-const i1@43@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> |this.Gf_seq[i1]| == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 31 | 0 <= i1@43@03 | live]
; [else-branch: 31 | !(0 <= i1@43@03) | live]
(push) ; 4
; [then-branch: 31 | 0 <= i1@43@03]
(assert (<= 0 i1@43@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 31 | !(0 <= i1@43@03)]
(assert (not (<= 0 i1@43@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 32 | i1@43@03 < V@26@03 && 0 <= i1@43@03 | live]
; [else-branch: 32 | !(i1@43@03 < V@26@03 && 0 <= i1@43@03) | live]
(push) ; 4
; [then-branch: 32 | i1@43@03 < V@26@03 && 0 <= i1@43@03]
(assert (and (< i1@43@03 V@26@03) (<= 0 i1@43@03)))
; [eval] |this.Gf_seq[i1]| == V
; [eval] |this.Gf_seq[i1]|
; [eval] this.Gf_seq[i1]
(push) ; 5
(assert (not (>= i1@43@03 0)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               460
;  :arith-add-rows          141
;  :arith-assert-diseq      21
;  :arith-assert-lower      74
;  :arith-assert-upper      53
;  :arith-bound-prop        36
;  :arith-conflicts         7
;  :arith-eq-adapter        24
;  :arith-fixed-eqs         12
;  :arith-offset-eqs        65
;  :arith-pivots            55
;  :conflicts               19
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              209
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.73
;  :mk-bool-var             940
;  :mk-clause               246
;  :num-allocs              179049
;  :num-checks              45
;  :propagations            111
;  :quant-instantiations    168
;  :rlimit-count            218032)
(push) ; 5
(assert (not (<
  i1@43@03
  (Seq_length
    ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               460
;  :arith-add-rows          141
;  :arith-assert-diseq      21
;  :arith-assert-lower      74
;  :arith-assert-upper      53
;  :arith-bound-prop        36
;  :arith-conflicts         7
;  :arith-eq-adapter        24
;  :arith-fixed-eqs         12
;  :arith-offset-eqs        65
;  :arith-pivots            55
;  :conflicts               19
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              209
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.73
;  :mk-bool-var             940
;  :mk-clause               246
;  :num-allocs              179069
;  :num-checks              46
;  :propagations            111
;  :quant-instantiations    168
;  :rlimit-count            218052)
(pop) ; 4
(push) ; 4
; [else-branch: 32 | !(i1@43@03 < V@26@03 && 0 <= i1@43@03)]
(assert (not (and (< i1@43@03 V@26@03) (<= 0 i1@43@03))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@43@03 Int)) (!
  (implies
    (and (< i1@43@03 V@26@03) (<= 0 i1@43@03))
    (=
      (Seq_length
        (Seq_index
          ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
          i1@43@03))
      V@26@03))
  :pattern ((Seq_length
    (Seq_index
      ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
      i1@43@03)))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03))))))))))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { opt_get1(aloc(opt_get1(G), i1).option$array$) } { this.Gf_seq[i1] } 0 <= i1 && i1 < V ==> (forall j1: Int :: { aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1) } { this.Gf_seq[i1][j1] } 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1]))
(declare-const i1@44@03 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> (forall j1: Int :: { aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1) } { this.Gf_seq[i1][j1] } 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 33 | 0 <= i1@44@03 | live]
; [else-branch: 33 | !(0 <= i1@44@03) | live]
(push) ; 4
; [then-branch: 33 | 0 <= i1@44@03]
(assert (<= 0 i1@44@03))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 33 | !(0 <= i1@44@03)]
(assert (not (<= 0 i1@44@03)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 34 | i1@44@03 < V@26@03 && 0 <= i1@44@03 | live]
; [else-branch: 34 | !(i1@44@03 < V@26@03 && 0 <= i1@44@03) | live]
(push) ; 4
; [then-branch: 34 | i1@44@03 < V@26@03 && 0 <= i1@44@03]
(assert (and (< i1@44@03 V@26@03) (<= 0 i1@44@03)))
; [eval] (forall j1: Int :: { aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1) } { this.Gf_seq[i1][j1] } 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1])
(declare-const j1@45@03 Int)
(push) ; 5
; [eval] 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1]
; [eval] 0 <= j1 && j1 < V
; [eval] 0 <= j1
(push) ; 6
; [then-branch: 35 | 0 <= j1@45@03 | live]
; [else-branch: 35 | !(0 <= j1@45@03) | live]
(push) ; 7
; [then-branch: 35 | 0 <= j1@45@03]
(assert (<= 0 j1@45@03))
; [eval] j1 < V
(pop) ; 7
(push) ; 7
; [else-branch: 35 | !(0 <= j1@45@03)]
(assert (not (<= 0 j1@45@03)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
; [then-branch: 36 | j1@45@03 < V@26@03 && 0 <= j1@45@03 | live]
; [else-branch: 36 | !(j1@45@03 < V@26@03 && 0 <= j1@45@03) | live]
(push) ; 7
; [then-branch: 36 | j1@45@03 < V@26@03 && 0 <= j1@45@03]
(assert (and (< j1@45@03 V@26@03) (<= 0 j1@45@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1]
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 9
(assert (not (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               462
;  :arith-add-rows          143
;  :arith-assert-diseq      21
;  :arith-assert-lower      78
;  :arith-assert-upper      53
;  :arith-bound-prop        36
;  :arith-conflicts         7
;  :arith-eq-adapter        24
;  :arith-fixed-eqs         12
;  :arith-offset-eqs        65
;  :arith-pivots            58
;  :conflicts               19
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              209
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.75
;  :mk-bool-var             946
;  :mk-clause               246
;  :num-allocs              179505
;  :num-checks              47
;  :propagations            111
;  :quant-instantiations    168
;  :rlimit-count            218938)
(assert (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 8
; Joined path conditions
(assert (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))
(push) ; 8
(assert (not (ite
  (and
    (<
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
      V@26@03)
    (<=
      0
      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))))
  (< $Perm.No $k@31@03)
  false)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               474
;  :arith-add-rows          151
;  :arith-assert-diseq      21
;  :arith-assert-lower      79
;  :arith-assert-upper      55
;  :arith-bound-prop        38
;  :arith-conflicts         8
;  :arith-eq-adapter        25
;  :arith-fixed-eqs         13
;  :arith-offset-eqs        68
;  :arith-pivots            60
;  :conflicts               20
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              209
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.78
;  :mk-bool-var             975
;  :mk-clause               253
;  :num-allocs              179863
;  :num-checks              48
;  :propagations            114
;  :quant-instantiations    183
;  :rlimit-count            220025)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 9
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               474
;  :arith-add-rows          151
;  :arith-assert-diseq      21
;  :arith-assert-lower      79
;  :arith-assert-upper      55
;  :arith-bound-prop        38
;  :arith-conflicts         8
;  :arith-eq-adapter        25
;  :arith-fixed-eqs         13
;  :arith-offset-eqs        68
;  :arith-pivots            60
;  :conflicts               21
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              209
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.78
;  :mk-bool-var             975
;  :mk-clause               253
;  :num-allocs              179953
;  :num-checks              49
;  :propagations            114
;  :quant-instantiations    183
;  :rlimit-count            220120)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
    (as None<option<array>>  option<array>))))
(pop) ; 8
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
    (as None<option<array>>  option<array>))))
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 9
(assert (not (<
  j1@45@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               480
;  :arith-add-rows          155
;  :arith-assert-diseq      21
;  :arith-assert-lower      82
;  :arith-assert-upper      56
;  :arith-bound-prop        38
;  :arith-conflicts         9
;  :arith-eq-adapter        26
;  :arith-fixed-eqs         14
;  :arith-offset-eqs        68
;  :arith-pivots            62
;  :conflicts               22
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               38
;  :del-clause              213
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.78
;  :mk-bool-var             986
;  :mk-clause               257
;  :num-allocs              180157
;  :num-checks              50
;  :propagations            116
;  :quant-instantiations    190
;  :rlimit-count            220582)
(assert (<
  j1@45@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))))))
(pop) ; 8
; Joined path conditions
(assert (<
  j1@45@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)))
(push) ; 8
(assert (not (and
  (and
    (and
      (<
        (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))
        V@26@03)
      (<=
        0
        (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
    (<
      (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))
      V@26@03))
  (<=
    0
    (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               511
;  :arith-add-rows          177
;  :arith-assert-diseq      21
;  :arith-assert-lower      88
;  :arith-assert-upper      63
;  :arith-bound-prop        39
;  :arith-conflicts         12
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         17
;  :arith-offset-eqs        72
;  :arith-pivots            68
;  :conflicts               27
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               42
;  :del-clause              214
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.78
;  :mk-bool-var             1025
;  :mk-clause               273
;  :num-allocs              180582
;  :num-checks              51
;  :propagations            125
;  :quant-instantiations    208
;  :rlimit-count            222053)
; [eval] this.Gf_seq[i1][j1]
; [eval] this.Gf_seq[i1]
(push) ; 8
(assert (not (>= i1@44@03 0)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               511
;  :arith-add-rows          177
;  :arith-assert-diseq      21
;  :arith-assert-lower      88
;  :arith-assert-upper      63
;  :arith-bound-prop        39
;  :arith-conflicts         12
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         17
;  :arith-offset-eqs        72
;  :arith-pivots            68
;  :conflicts               27
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               42
;  :del-clause              214
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.78
;  :mk-bool-var             1025
;  :mk-clause               273
;  :num-allocs              180603
;  :num-checks              52
;  :propagations            125
;  :quant-instantiations    208
;  :rlimit-count            222062)
(push) ; 8
(assert (not (<
  i1@44@03
  (Seq_length
    ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               511
;  :arith-add-rows          177
;  :arith-assert-diseq      21
;  :arith-assert-lower      88
;  :arith-assert-upper      63
;  :arith-bound-prop        39
;  :arith-conflicts         12
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         17
;  :arith-offset-eqs        72
;  :arith-pivots            68
;  :conflicts               27
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               42
;  :del-clause              214
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.78
;  :mk-bool-var             1025
;  :mk-clause               273
;  :num-allocs              180623
;  :num-checks              53
;  :propagations            125
;  :quant-instantiations    208
;  :rlimit-count            222082)
(push) ; 8
(assert (not (>= j1@45@03 0)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               511
;  :arith-add-rows          177
;  :arith-assert-diseq      21
;  :arith-assert-lower      88
;  :arith-assert-upper      63
;  :arith-bound-prop        39
;  :arith-conflicts         12
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         17
;  :arith-offset-eqs        72
;  :arith-pivots            68
;  :conflicts               27
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               42
;  :del-clause              214
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          3
;  :max-memory              4.86
;  :memory                  4.78
;  :mk-bool-var             1025
;  :mk-clause               273
;  :num-allocs              180638
;  :num-checks              54
;  :propagations            125
;  :quant-instantiations    208
;  :rlimit-count            222091)
(push) ; 8
(assert (not (<
  j1@45@03
  (Seq_length
    (Seq_index
      ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
      i1@44@03)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               515
;  :arith-add-rows          192
;  :arith-assert-diseq      22
;  :arith-assert-lower      92
;  :arith-assert-upper      64
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        31
;  :arith-fixed-eqs         18
;  :arith-offset-eqs        72
;  :arith-pivots            72
;  :conflicts               28
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 24
;  :datatype-occurs-check   61
;  :datatype-splits         24
;  :decisions               42
;  :del-clause              224
;  :final-checks            35
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.79
;  :mk-bool-var             1036
;  :mk-clause               283
;  :num-allocs              180805
;  :num-checks              55
;  :propagations            128
;  :quant-instantiations    213
;  :rlimit-count            222597)
(pop) ; 7
(push) ; 7
; [else-branch: 36 | !(j1@45@03 < V@26@03 && 0 <= j1@45@03)]
(assert (not (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
  (and
    (< j1@45@03 V@26@03)
    (<= 0 j1@45@03)
    (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@45@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)))))
; Joined path conditions
(pop) ; 5
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((j1@45@03 Int)) (!
  (implies
    (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
    (and
      (< j1@45@03 V@26@03)
      (<= 0 j1@45@03)
      (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
          (as None<option<array>>  option<array>)))
      (<
        j1@45@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((j1@45@03 Int)) (!
  (implies
    (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
    (and
      (< j1@45@03 V@26@03)
      (<= 0 j1@45@03)
      (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
          (as None<option<array>>  option<array>)))
      (<
        j1@45@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
  :pattern ((Seq_index
    (Seq_index
      ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
      i1@44@03)
    j1@45@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 4
(push) ; 4
; [else-branch: 34 | !(i1@44@03 < V@26@03 && 0 <= i1@44@03)]
(assert (not (and (< i1@44@03 V@26@03) (<= 0 i1@44@03))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@44@03 V@26@03) (<= 0 i1@44@03))
  (and
    (< i1@44@03 V@26@03)
    (<= 0 i1@44@03)
    (forall ((j1@45@03 Int)) (!
      (implies
        (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
        (and
          (< j1@45@03 V@26@03)
          (<= 0 j1@45@03)
          (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
              (as None<option<array>>  option<array>)))
          (<
            j1@45@03
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))
      :qid |prog.l<no position>-aux|))
    (forall ((j1@45@03 Int)) (!
      (implies
        (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
        (and
          (< j1@45@03 V@26@03)
          (<= 0 j1@45@03)
          (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
              (as None<option<array>>  option<array>)))
          (<
            j1@45@03
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
      :pattern ((Seq_index
        (Seq_index
          ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
          i1@44@03)
        j1@45@03))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@44@03 Int)) (!
  (implies
    (and (< i1@44@03 V@26@03) (<= 0 i1@44@03))
    (and
      (< i1@44@03 V@26@03)
      (<= 0 i1@44@03)
      (forall ((j1@45@03 Int)) (!
        (implies
          (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
          (and
            (< j1@45@03 V@26@03)
            (<= 0 j1@45@03)
            (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
                (as None<option<array>>  option<array>)))
            (<
              j1@45@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))
        :qid |prog.l<no position>-aux|))
      (forall ((j1@45@03 Int)) (!
        (implies
          (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
          (and
            (< j1@45@03 V@26@03)
            (<= 0 j1@45@03)
            (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
                (as None<option<array>>  option<array>)))
            (<
              j1@45@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
        :pattern ((Seq_index
          (Seq_index
            ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
            i1@44@03)
          j1@45@03))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@44@03 Int)) (!
  (implies
    (and (< i1@44@03 V@26@03) (<= 0 i1@44@03))
    (and
      (< i1@44@03 V@26@03)
      (<= 0 i1@44@03)
      (forall ((j1@45@03 Int)) (!
        (implies
          (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
          (and
            (< j1@45@03 V@26@03)
            (<= 0 j1@45@03)
            (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
                (as None<option<array>>  option<array>)))
            (<
              j1@45@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))
        :qid |prog.l<no position>-aux|))
      (forall ((j1@45@03 Int)) (!
        (implies
          (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
          (and
            (< j1@45@03 V@26@03)
            (<= 0 j1@45@03)
            (< i1@44@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))
                (as None<option<array>>  option<array>)))
            (<
              j1@45@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))))
        :pattern ((Seq_index
          (Seq_index
            ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
            i1@44@03)
          j1@45@03))
        :qid |prog.l<no position>-aux|))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
    i1@44@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@44@03 Int)) (!
  (implies
    (and (< i1@44@03 V@26@03) (<= 0 i1@44@03))
    (forall ((j1@45@03 Int)) (!
      (implies
        (and (< j1@45@03 V@26@03) (<= 0 j1@45@03))
        (=
          ($FVF.lookup_int (as sm@42@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))
          (Seq_index
            (Seq_index
              ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
              i1@44@03)
            j1@45@03)))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))) j1@45@03))
      :pattern ((Seq_index
        (Seq_index
          ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
          i1@44@03)
        j1@45@03))
      :qid |prog.l<no position>|)))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@33@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@44@03))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@29@03)))
    i1@44@03))
  :qid |prog.l<no position>|)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@46@03 $Snap)
(assert (= $t@46@03 ($Snap.combine ($Snap.first $t@46@03) ($Snap.second $t@46@03))))
(assert (= ($Snap.first $t@46@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@27@03 $Ref.null))
(assert (=
  ($Snap.second $t@46@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@46@03))
    ($Snap.second ($Snap.second $t@46@03)))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               549
;  :arith-add-rows          204
;  :arith-assert-diseq      22
;  :arith-assert-lower      92
;  :arith-assert-upper      64
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        31
;  :arith-fixed-eqs         18
;  :arith-offset-eqs        72
;  :arith-pivots            80
;  :conflicts               28
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 34
;  :datatype-occurs-check   66
;  :datatype-splits         30
;  :decisions               52
;  :del-clause              276
;  :final-checks            39
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.80
;  :mk-bool-var             1049
;  :mk-clause               283
;  :num-allocs              183729
;  :num-checks              57
;  :propagations            128
;  :quant-instantiations    213
;  :rlimit-count            228337)
; [then-branch: 37 | exc@27@03 == Null | live]
; [else-branch: 37 | exc@27@03 != Null | dead]
(push) ; 3
; [then-branch: 37 | exc@27@03 == Null]
(assert (=
  ($Snap.second ($Snap.second $t@46@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@46@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))
; [eval] exc == null
(push) ; 4
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               571
;  :arith-add-rows          204
;  :arith-assert-diseq      22
;  :arith-assert-lower      92
;  :arith-assert-upper      64
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        31
;  :arith-fixed-eqs         18
;  :arith-offset-eqs        72
;  :arith-pivots            80
;  :conflicts               28
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 41
;  :datatype-occurs-check   69
;  :datatype-splits         33
;  :decisions               59
;  :del-clause              276
;  :final-checks            41
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.80
;  :mk-bool-var             1053
;  :mk-clause               283
;  :num-allocs              184432
;  :num-checks              58
;  :propagations            128
;  :quant-instantiations    213
;  :rlimit-count            229069)
; [then-branch: 38 | exc@27@03 == Null | live]
; [else-branch: 38 | exc@27@03 != Null | dead]
(push) ; 4
; [then-branch: 38 | exc@27@03 == Null]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@46@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@46@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@46@03))))
  $Snap.unit))
; [eval] exc == null ==> |this.Gf_seq| == V
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               595
;  :arith-add-rows          204
;  :arith-assert-diseq      22
;  :arith-assert-lower      92
;  :arith-assert-upper      64
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        31
;  :arith-fixed-eqs         18
;  :arith-offset-eqs        72
;  :arith-pivots            80
;  :conflicts               28
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 48
;  :datatype-occurs-check   72
;  :datatype-splits         36
;  :decisions               66
;  :del-clause              276
;  :final-checks            43
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.80
;  :mk-bool-var             1058
;  :mk-clause               283
;  :num-allocs              185143
;  :num-checks              59
;  :propagations            128
;  :quant-instantiations    213
;  :rlimit-count            229851)
; [then-branch: 39 | exc@27@03 == Null | live]
; [else-branch: 39 | exc@27@03 != Null | dead]
(push) ; 6
; [then-branch: 39 | exc@27@03 == Null]
; [eval] |this.Gf_seq| == V
; [eval] |this.Gf_seq|
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (=
    (Seq_length
      ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03))))
    V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))
  $Snap.unit))
; [eval] exc == null ==> |this.P_seq| == V
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               625
;  :arith-add-rows          205
;  :arith-assert-diseq      22
;  :arith-assert-lower      94
;  :arith-assert-upper      65
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        32
;  :arith-fixed-eqs         19
;  :arith-offset-eqs        72
;  :arith-pivots            81
;  :conflicts               28
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 55
;  :datatype-occurs-check   75
;  :datatype-splits         39
;  :decisions               73
;  :del-clause              276
;  :final-checks            45
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.80
;  :mk-bool-var             1069
;  :mk-clause               283
;  :num-allocs              185917
;  :num-checks              60
;  :propagations            128
;  :quant-instantiations    215
;  :rlimit-count            230804)
; [then-branch: 40 | exc@27@03 == Null | live]
; [else-branch: 40 | exc@27@03 != Null | dead]
(push) ; 6
; [then-branch: 40 | exc@27@03 == Null]
; [eval] |this.P_seq| == V
; [eval] |this.P_seq|
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (=
    (Seq_length
      ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second $t@46@03)))))
    V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))
  $Snap.unit))
; [eval] exc == null ==> G != (None(): option[array])
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               657
;  :arith-add-rows          206
;  :arith-assert-diseq      22
;  :arith-assert-lower      96
;  :arith-assert-upper      66
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        72
;  :arith-pivots            82
;  :conflicts               28
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 62
;  :datatype-occurs-check   78
;  :datatype-splits         42
;  :decisions               80
;  :del-clause              276
;  :final-checks            47
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.80
;  :mk-bool-var             1080
;  :mk-clause               283
;  :num-allocs              186704
;  :num-checks              61
;  :propagations            128
;  :quant-instantiations    217
;  :rlimit-count            231774)
; [then-branch: 41 | exc@27@03 == Null | live]
; [else-branch: 41 | exc@27@03 != Null | dead]
(push) ; 6
; [then-branch: 41 | exc@27@03 == Null]
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (not (= G@23@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(G)) == V
; [eval] exc == null
(push) ; 5
(push) ; 6
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               686
;  :arith-add-rows          206
;  :arith-assert-diseq      22
;  :arith-assert-lower      96
;  :arith-assert-upper      66
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        72
;  :arith-pivots            82
;  :conflicts               28
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 69
;  :datatype-occurs-check   81
;  :datatype-splits         45
;  :decisions               87
;  :del-clause              276
;  :final-checks            49
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.81
;  :mk-bool-var             1085
;  :mk-clause               283
;  :num-allocs              187440
;  :num-checks              62
;  :propagations            128
;  :quant-instantiations    217
;  :rlimit-count            232605)
; [then-branch: 42 | exc@27@03 == Null | live]
; [else-branch: 42 | exc@27@03 != Null | dead]
(push) ; 6
; [then-branch: 42 | exc@27@03 == Null]
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@23@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))
; [eval] exc == null
(push) ; 5
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               717
;  :arith-add-rows          206
;  :arith-assert-diseq      22
;  :arith-assert-lower      96
;  :arith-assert-upper      66
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        72
;  :arith-pivots            82
;  :conflicts               28
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   84
;  :datatype-splits         49
;  :decisions               95
;  :del-clause              276
;  :final-checks            51
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.81
;  :mk-bool-var             1090
;  :mk-clause               283
;  :num-allocs              188172
;  :num-checks              63
;  :propagations            128
;  :quant-instantiations    217
;  :rlimit-count            233428)
; [then-branch: 43 | exc@27@03 == Null | live]
; [else-branch: 43 | exc@27@03 != Null | dead]
(push) ; 5
; [then-branch: 43 | exc@27@03 == Null]
(declare-const i1@47@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 44 | 0 <= i1@47@03 | live]
; [else-branch: 44 | !(0 <= i1@47@03) | live]
(push) ; 8
; [then-branch: 44 | 0 <= i1@47@03]
(assert (<= 0 i1@47@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 44 | !(0 <= i1@47@03)]
(assert (not (<= 0 i1@47@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@47@03 V@26@03) (<= 0 i1@47@03)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               717
;  :arith-add-rows          207
;  :arith-assert-diseq      22
;  :arith-assert-lower      98
;  :arith-assert-upper      66
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        72
;  :arith-pivots            83
;  :conflicts               28
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   84
;  :datatype-splits         49
;  :decisions               95
;  :del-clause              276
;  :final-checks            51
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.81
;  :mk-bool-var             1092
;  :mk-clause               283
;  :num-allocs              188275
;  :num-checks              64
;  :propagations            128
;  :quant-instantiations    217
;  :rlimit-count            233619)
(assert (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 7
; Joined path conditions
(assert (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(declare-const $k@48@03 $Perm)
(assert ($Perm.isReadVar $k@48@03 $Perm.Write))
(pop) ; 6
(declare-fun inv@49@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@48@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@47@03 Int)) (!
  (< i1@47@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@47@03))
  :qid |option$array$-aux|)))
(push) ; 6
(assert (not (forall ((i1@47@03 Int)) (!
  (implies
    (and (< i1@47@03 V@26@03) (<= 0 i1@47@03))
    (or (= $k@48@03 $Perm.No) (< $Perm.No $k@48@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               717
;  :arith-add-rows          208
;  :arith-assert-diseq      23
;  :arith-assert-lower      100
;  :arith-assert-upper      67
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        34
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        72
;  :arith-pivots            84
;  :conflicts               29
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   84
;  :datatype-splits         49
;  :decisions               95
;  :del-clause              276
;  :final-checks            51
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.81
;  :mk-bool-var             1099
;  :mk-clause               285
;  :num-allocs              188745
;  :num-checks              65
;  :propagations            129
;  :quant-instantiations    217
;  :rlimit-count            234194)
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@47@03 Int) (i12@47@03 Int)) (!
  (implies
    (and
      (and (and (< i11@47@03 V@26@03) (<= 0 i11@47@03)) (< $Perm.No $k@48@03))
      (and (and (< i12@47@03 V@26@03) (<= 0 i12@47@03)) (< $Perm.No $k@48@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@47@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@47@03)))
    (= i11@47@03 i12@47@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               725
;  :arith-add-rows          212
;  :arith-assert-diseq      24
;  :arith-assert-lower      104
;  :arith-assert-upper      67
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        35
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        72
;  :arith-pivots            84
;  :conflicts               30
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 77
;  :datatype-occurs-check   84
;  :datatype-splits         49
;  :decisions               95
;  :del-clause              282
;  :final-checks            51
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.81
;  :mk-bool-var             1117
;  :mk-clause               291
;  :num-allocs              189109
;  :num-checks              66
;  :propagations            129
;  :quant-instantiations    228
;  :rlimit-count            234904)
; Definitional axioms for inverse functions
(assert (forall ((i1@47@03 Int)) (!
  (implies
    (and (and (< i1@47@03 V@26@03) (<= 0 i1@47@03)) (< $Perm.No $k@48@03))
    (=
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@47@03))
      i1@47@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@47@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@49@03 r) V@26@03) (<= 0 (inv@49@03 r)))
      (< $Perm.No $k@48@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@49@03 r))
      r))
  :pattern ((inv@49@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@47@03 Int)) (!
  (<= $Perm.No $k@48@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@47@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@47@03 Int)) (!
  (<= $k@48@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@47@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@47@03 Int)) (!
  (implies
    (and (and (< i1@47@03 V@26@03) (<= 0 i1@47@03)) (< $Perm.No $k@48@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@47@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@47@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@50@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@49@03 r) V@26@03) (<= 0 (inv@49@03 r)))
      (< $Perm.No $k@48@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@49@03 r) V@26@03) (<= 0 (inv@49@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) r) r))
  :pattern ((inv@49@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               759
;  :arith-add-rows          212
;  :arith-assert-diseq      24
;  :arith-assert-lower      104
;  :arith-assert-upper      68
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        35
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        72
;  :arith-pivots            84
;  :conflicts               30
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 85
;  :datatype-occurs-check   87
;  :datatype-splits         53
;  :decisions               103
;  :del-clause              282
;  :final-checks            53
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.82
;  :mk-bool-var             1130
;  :mk-clause               291
;  :num-allocs              190865
;  :num-checks              67
;  :propagations            129
;  :quant-instantiations    228
;  :rlimit-count            237912)
; [then-branch: 45 | exc@27@03 == Null | live]
; [else-branch: 45 | exc@27@03 != Null | dead]
(push) ; 7
; [then-branch: 45 | exc@27@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@51@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 46 | 0 <= i1@51@03 | live]
; [else-branch: 46 | !(0 <= i1@51@03) | live]
(push) ; 10
; [then-branch: 46 | 0 <= i1@51@03]
(assert (<= 0 i1@51@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 46 | !(0 <= i1@51@03)]
(assert (not (<= 0 i1@51@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 47 | i1@51@03 < V@26@03 && 0 <= i1@51@03 | live]
; [else-branch: 47 | !(i1@51@03 < V@26@03 && 0 <= i1@51@03) | live]
(push) ; 10
; [then-branch: 47 | i1@51@03 < V@26@03 && 0 <= i1@51@03]
(assert (and (< i1@51@03 V@26@03) (<= 0 i1@51@03)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@51@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               759
;  :arith-add-rows          213
;  :arith-assert-diseq      24
;  :arith-assert-lower      106
;  :arith-assert-upper      68
;  :arith-bound-prop        40
;  :arith-conflicts         13
;  :arith-eq-adapter        35
;  :arith-fixed-eqs         20
;  :arith-offset-eqs        72
;  :arith-pivots            85
;  :conflicts               30
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 85
;  :datatype-occurs-check   87
;  :datatype-splits         53
;  :decisions               103
;  :del-clause              282
;  :final-checks            53
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.82
;  :mk-bool-var             1132
;  :mk-clause               291
;  :num-allocs              190968
;  :num-checks              68
;  :propagations            129
;  :quant-instantiations    228
;  :rlimit-count            238113)
(assert (< i1@51@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 11
; Joined path conditions
(assert (< i1@51@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03))
      V@26@03)
    (<=
      0
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03))))
  (< $Perm.No $k@48@03)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               781
;  :arith-add-rows          226
;  :arith-assert-diseq      24
;  :arith-assert-lower      108
;  :arith-assert-upper      71
;  :arith-bound-prop        43
;  :arith-conflicts         14
;  :arith-eq-adapter        37
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        77
;  :arith-pivots            88
;  :conflicts               31
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 85
;  :datatype-occurs-check   87
;  :datatype-splits         53
;  :decisions               103
;  :del-clause              282
;  :final-checks            53
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.86
;  :memory                  4.85
;  :mk-bool-var             1182
;  :mk-clause               311
;  :num-allocs              191426
;  :num-checks              69
;  :propagations            133
;  :quant-instantiations    251
;  :rlimit-count            239548)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 47 | !(i1@51@03 < V@26@03 && 0 <= i1@51@03)]
(assert (not (and (< i1@51@03 V@26@03) (<= 0 i1@51@03))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@51@03 V@26@03) (<= 0 i1@51@03))
  (and
    (< i1@51@03 V@26@03)
    (<= 0 i1@51@03)
    (< i1@51@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@51@03 Int)) (!
  (implies
    (and (< i1@51@03 V@26@03) (<= 0 i1@51@03))
    (and
      (< i1@51@03 V@26@03)
      (<= 0 i1@51@03)
      (< i1@51@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (forall ((i1@51@03 Int)) (!
    (implies
      (and (< i1@51@03 V@26@03) (<= 0 i1@51@03))
      (and
        (< i1@51@03 V@26@03)
        (<= 0 i1@51@03)
        (< i1@51@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@27@03 $Ref.null)
  (forall ((i1@51@03 Int)) (!
    (implies
      (and (< i1@51@03 V@26@03) (<= 0 i1@51@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@51@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               816
;  :arith-add-rows          229
;  :arith-assert-diseq      24
;  :arith-assert-lower      108
;  :arith-assert-upper      71
;  :arith-bound-prop        43
;  :arith-conflicts         14
;  :arith-eq-adapter        37
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        77
;  :arith-pivots            91
;  :conflicts               31
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 93
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               111
;  :del-clause              302
;  :final-checks            55
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.87
;  :memory                  4.86
;  :mk-bool-var             1190
;  :mk-clause               311
;  :num-allocs              192539
;  :num-checks              70
;  :propagations            133
;  :quant-instantiations    251
;  :rlimit-count            241270)
; [then-branch: 48 | exc@27@03 == Null | live]
; [else-branch: 48 | exc@27@03 != Null | dead]
(push) ; 7
; [then-branch: 48 | exc@27@03 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@52@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 49 | 0 <= i1@52@03 | live]
; [else-branch: 49 | !(0 <= i1@52@03) | live]
(push) ; 10
; [then-branch: 49 | 0 <= i1@52@03]
(assert (<= 0 i1@52@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 49 | !(0 <= i1@52@03)]
(assert (not (<= 0 i1@52@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 50 | i1@52@03 < V@26@03 && 0 <= i1@52@03 | live]
; [else-branch: 50 | !(i1@52@03 < V@26@03 && 0 <= i1@52@03) | live]
(push) ; 10
; [then-branch: 50 | i1@52@03 < V@26@03 && 0 <= i1@52@03]
(assert (and (< i1@52@03 V@26@03) (<= 0 i1@52@03)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@52@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               816
;  :arith-add-rows          230
;  :arith-assert-diseq      24
;  :arith-assert-lower      110
;  :arith-assert-upper      71
;  :arith-bound-prop        43
;  :arith-conflicts         14
;  :arith-eq-adapter        37
;  :arith-fixed-eqs         22
;  :arith-offset-eqs        77
;  :arith-pivots            92
;  :conflicts               31
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 93
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               111
;  :del-clause              302
;  :final-checks            55
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.87
;  :memory                  4.86
;  :mk-bool-var             1192
;  :mk-clause               311
;  :num-allocs              192642
;  :num-checks              71
;  :propagations            133
;  :quant-instantiations    251
;  :rlimit-count            241471)
(assert (< i1@52@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 11
; Joined path conditions
(assert (< i1@52@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03)))
(push) ; 11
(assert (not (ite
  (and
    (<
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
      V@26@03)
    (<=
      0
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))))
  (< $Perm.No $k@48@03)
  false)))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               838
;  :arith-add-rows          243
;  :arith-assert-diseq      24
;  :arith-assert-lower      112
;  :arith-assert-upper      74
;  :arith-bound-prop        46
;  :arith-conflicts         15
;  :arith-eq-adapter        39
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        82
;  :arith-pivots            95
;  :conflicts               32
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 93
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               111
;  :del-clause              302
;  :final-checks            55
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.87
;  :memory                  4.86
;  :mk-bool-var             1244
;  :mk-clause               331
;  :num-allocs              193074
;  :num-checks              72
;  :propagations            137
;  :quant-instantiations    276
;  :rlimit-count            242927)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               838
;  :arith-add-rows          243
;  :arith-assert-diseq      24
;  :arith-assert-lower      112
;  :arith-assert-upper      74
;  :arith-bound-prop        46
;  :arith-conflicts         15
;  :arith-eq-adapter        39
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        82
;  :arith-pivots            95
;  :conflicts               33
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 93
;  :datatype-occurs-check   90
;  :datatype-splits         57
;  :decisions               111
;  :del-clause              302
;  :final-checks            55
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.87
;  :memory                  4.86
;  :mk-bool-var             1244
;  :mk-clause               331
;  :num-allocs              193163
;  :num-checks              73
;  :propagations            137
;  :quant-instantiations    276
;  :rlimit-count            243022)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 50 | !(i1@52@03 < V@26@03 && 0 <= i1@52@03)]
(assert (not (and (< i1@52@03 V@26@03) (<= 0 i1@52@03))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@52@03 V@26@03) (<= 0 i1@52@03))
  (and
    (< i1@52@03 V@26@03)
    (<= 0 i1@52@03)
    (< i1@52@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@52@03 Int)) (!
  (implies
    (and (< i1@52@03 V@26@03) (<= 0 i1@52@03))
    (and
      (< i1@52@03 V@26@03)
      (<= 0 i1@52@03)
      (< i1@52@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (forall ((i1@52@03 Int)) (!
    (implies
      (and (< i1@52@03 V@26@03) (<= 0 i1@52@03))
      (and
        (< i1@52@03 V@26@03)
        (<= 0 i1@52@03)
        (< i1@52@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@27@03 $Ref.null)
  (forall ((i1@52@03 Int)) (!
    (implies
      (and (< i1@52@03 V@26@03) (<= 0 i1@52@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03))))
        V@26@03))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@52@03)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               874
;  :arith-add-rows          246
;  :arith-assert-diseq      24
;  :arith-assert-lower      112
;  :arith-assert-upper      74
;  :arith-bound-prop        46
;  :arith-conflicts         15
;  :arith-eq-adapter        39
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        82
;  :arith-pivots            98
;  :conflicts               33
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 101
;  :datatype-occurs-check   93
;  :datatype-splits         61
;  :decisions               119
;  :del-clause              322
;  :final-checks            57
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.89
;  :memory                  4.87
;  :mk-bool-var             1252
;  :mk-clause               331
;  :num-allocs              194295
;  :num-checks              74
;  :propagations            137
;  :quant-instantiations    276
;  :rlimit-count            244849)
; [then-branch: 51 | exc@27@03 == Null | live]
; [else-branch: 51 | exc@27@03 != Null | dead]
(push) ; 7
; [then-branch: 51 | exc@27@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@53@03 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@54@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 52 | 0 <= i1@53@03 | live]
; [else-branch: 52 | !(0 <= i1@53@03) | live]
(push) ; 11
; [then-branch: 52 | 0 <= i1@53@03]
(assert (<= 0 i1@53@03))
; [eval] i1 < V
(push) ; 12
; [then-branch: 53 | i1@53@03 < V@26@03 | live]
; [else-branch: 53 | !(i1@53@03 < V@26@03) | live]
(push) ; 13
; [then-branch: 53 | i1@53@03 < V@26@03]
(assert (< i1@53@03 V@26@03))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 54 | 0 <= i2@54@03 | live]
; [else-branch: 54 | !(0 <= i2@54@03) | live]
(push) ; 15
; [then-branch: 54 | 0 <= i2@54@03]
(assert (<= 0 i2@54@03))
; [eval] i2 < V
(push) ; 16
; [then-branch: 55 | i2@54@03 < V@26@03 | live]
; [else-branch: 55 | !(i2@54@03 < V@26@03) | live]
(push) ; 17
; [then-branch: 55 | i2@54@03 < V@26@03]
(assert (< i2@54@03 V@26@03))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               874
;  :arith-add-rows          248
;  :arith-assert-diseq      24
;  :arith-assert-lower      116
;  :arith-assert-upper      74
;  :arith-bound-prop        46
;  :arith-conflicts         15
;  :arith-eq-adapter        39
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        82
;  :arith-pivots            99
;  :conflicts               33
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 101
;  :datatype-occurs-check   93
;  :datatype-splits         61
;  :decisions               119
;  :del-clause              322
;  :final-checks            57
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.89
;  :memory                  4.88
;  :mk-bool-var             1256
;  :mk-clause               331
;  :num-allocs              194628
;  :num-checks              75
;  :propagations            137
;  :quant-instantiations    276
;  :rlimit-count            245196)
(assert (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 18
; Joined path conditions
(assert (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
      V@26@03)
    (<=
      0
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))))
  (< $Perm.No $k@48@03)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               896
;  :arith-add-rows          261
;  :arith-assert-diseq      24
;  :arith-assert-lower      118
;  :arith-assert-upper      77
;  :arith-bound-prop        49
;  :arith-conflicts         16
;  :arith-eq-adapter        41
;  :arith-fixed-eqs         26
;  :arith-offset-eqs        87
;  :arith-pivots            102
;  :conflicts               34
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 101
;  :datatype-occurs-check   93
;  :datatype-splits         61
;  :decisions               119
;  :del-clause              322
;  :final-checks            57
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.89
;  :memory                  4.87
;  :mk-bool-var             1308
;  :mk-clause               351
;  :num-allocs              195059
;  :num-checks              76
;  :propagations            141
;  :quant-instantiations    301
;  :rlimit-count            246652)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               896
;  :arith-add-rows          261
;  :arith-assert-diseq      24
;  :arith-assert-lower      118
;  :arith-assert-upper      77
;  :arith-bound-prop        49
;  :arith-conflicts         16
;  :arith-eq-adapter        41
;  :arith-fixed-eqs         26
;  :arith-offset-eqs        87
;  :arith-pivots            102
;  :conflicts               34
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 101
;  :datatype-occurs-check   93
;  :datatype-splits         61
;  :decisions               119
;  :del-clause              322
;  :final-checks            57
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.89
;  :memory                  4.87
;  :mk-bool-var             1308
;  :mk-clause               351
;  :num-allocs              195085
;  :num-checks              77
;  :propagations            141
;  :quant-instantiations    301
;  :rlimit-count            246682)
(assert (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 18
; Joined path conditions
(assert (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
(push) ; 18
(assert (not (ite
  (and
    (<
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))
      V@26@03)
    (<=
      0
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))))
  (< $Perm.No $k@48@03)
  false)))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               909
;  :arith-add-rows          273
;  :arith-assert-diseq      24
;  :arith-assert-lower      120
;  :arith-assert-upper      80
;  :arith-bound-prop        51
;  :arith-conflicts         17
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        87
;  :arith-pivots            105
;  :conflicts               35
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 101
;  :datatype-occurs-check   93
;  :datatype-splits         61
;  :decisions               119
;  :del-clause              322
;  :final-checks            57
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.93
;  :memory                  4.92
;  :mk-bool-var             1367
;  :mk-clause               383
;  :num-allocs              195582
;  :num-checks              78
;  :propagations            148
;  :quant-instantiations    326
;  :rlimit-count            248231)
(pop) ; 17
(push) ; 17
; [else-branch: 55 | !(i2@54@03 < V@26@03)]
(assert (not (< i2@54@03 V@26@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@54@03 V@26@03)
  (and
    (< i2@54@03 V@26@03)
    (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
    (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 54 | !(0 <= i2@54@03)]
(assert (not (<= 0 i2@54@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@54@03)
  (and
    (<= 0 i2@54@03)
    (implies
      (< i2@54@03 V@26@03)
      (and
        (< i2@54@03 V@26@03)
        (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
        (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 53 | !(i1@53@03 < V@26@03)]
(assert (not (< i1@53@03 V@26@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@53@03 V@26@03)
  (and
    (< i1@53@03 V@26@03)
    (implies
      (<= 0 i2@54@03)
      (and
        (<= 0 i2@54@03)
        (implies
          (< i2@54@03 V@26@03)
          (and
            (< i2@54@03 V@26@03)
            (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
            (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 52 | !(0 <= i1@53@03)]
(assert (not (<= 0 i1@53@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@53@03)
  (and
    (<= 0 i1@53@03)
    (implies
      (< i1@53@03 V@26@03)
      (and
        (< i1@53@03 V@26@03)
        (implies
          (<= 0 i2@54@03)
          (and
            (<= 0 i2@54@03)
            (implies
              (< i2@54@03 V@26@03)
              (and
                (< i2@54@03 V@26@03)
                (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
                (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 56 | Lookup(option$array$,sm@50@03,aloc((_, _), opt_get1(_, G@23@03), i1@53@03)) == Lookup(option$array$,sm@50@03,aloc((_, _), opt_get1(_, G@23@03), i2@54@03)) && i2@54@03 < V@26@03 && 0 <= i2@54@03 && i1@53@03 < V@26@03 && 0 <= i1@53@03 | live]
; [else-branch: 56 | !(Lookup(option$array$,sm@50@03,aloc((_, _), opt_get1(_, G@23@03), i1@53@03)) == Lookup(option$array$,sm@50@03,aloc((_, _), opt_get1(_, G@23@03), i2@54@03)) && i2@54@03 < V@26@03 && 0 <= i2@54@03 && i1@53@03 < V@26@03 && 0 <= i1@53@03) | live]
(push) ; 11
; [then-branch: 56 | Lookup(option$array$,sm@50@03,aloc((_, _), opt_get1(_, G@23@03), i1@53@03)) == Lookup(option$array$,sm@50@03,aloc((_, _), opt_get1(_, G@23@03), i2@54@03)) && i2@54@03 < V@26@03 && 0 <= i2@54@03 && i1@53@03 < V@26@03 && 0 <= i1@53@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
          ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
        (< i2@54@03 V@26@03))
      (<= 0 i2@54@03))
    (< i1@53@03 V@26@03))
  (<= 0 i1@53@03)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 56 | !(Lookup(option$array$,sm@50@03,aloc((_, _), opt_get1(_, G@23@03), i1@53@03)) == Lookup(option$array$,sm@50@03,aloc((_, _), opt_get1(_, G@23@03), i2@54@03)) && i2@54@03 < V@26@03 && 0 <= i2@54@03 && i1@53@03 < V@26@03 && 0 <= i1@53@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
            ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
          (< i2@54@03 V@26@03))
        (<= 0 i2@54@03))
      (< i1@53@03 V@26@03))
    (<= 0 i1@53@03))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
            ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
          (< i2@54@03 V@26@03))
        (<= 0 i2@54@03))
      (< i1@53@03 V@26@03))
    (<= 0 i1@53@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
      ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
    (< i2@54@03 V@26@03)
    (<= 0 i2@54@03)
    (< i1@53@03 V@26@03)
    (<= 0 i1@53@03))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@54@03 Int)) (!
  (and
    (implies
      (<= 0 i1@53@03)
      (and
        (<= 0 i1@53@03)
        (implies
          (< i1@53@03 V@26@03)
          (and
            (< i1@53@03 V@26@03)
            (implies
              (<= 0 i2@54@03)
              (and
                (<= 0 i2@54@03)
                (implies
                  (< i2@54@03 V@26@03)
                  (and
                    (< i2@54@03 V@26@03)
                    (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
                    (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
                ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
              (< i2@54@03 V@26@03))
            (<= 0 i2@54@03))
          (< i1@53@03 V@26@03))
        (<= 0 i1@53@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
          ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
        (< i2@54@03 V@26@03)
        (<= 0 i2@54@03)
        (< i1@53@03 V@26@03)
        (<= 0 i1@53@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@53@03 Int)) (!
  (forall ((i2@54@03 Int)) (!
    (and
      (implies
        (<= 0 i1@53@03)
        (and
          (<= 0 i1@53@03)
          (implies
            (< i1@53@03 V@26@03)
            (and
              (< i1@53@03 V@26@03)
              (implies
                (<= 0 i2@54@03)
                (and
                  (<= 0 i2@54@03)
                  (implies
                    (< i2@54@03 V@26@03)
                    (and
                      (< i2@54@03 V@26@03)
                      (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
                      (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
                  ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
                (< i2@54@03 V@26@03))
              (<= 0 i2@54@03))
            (< i1@53@03 V@26@03))
          (<= 0 i1@53@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
            ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
          (< i2@54@03 V@26@03)
          (<= 0 i2@54@03)
          (< i1@53@03 V@26@03)
          (<= 0 i1@53@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (forall ((i1@53@03 Int)) (!
    (forall ((i2@54@03 Int)) (!
      (and
        (implies
          (<= 0 i1@53@03)
          (and
            (<= 0 i1@53@03)
            (implies
              (< i1@53@03 V@26@03)
              (and
                (< i1@53@03 V@26@03)
                (implies
                  (<= 0 i2@54@03)
                  (and
                    (<= 0 i2@54@03)
                    (implies
                      (< i2@54@03 V@26@03)
                      (and
                        (< i2@54@03 V@26@03)
                        (< i1@53@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
                        (< i2@54@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
                    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
                  (< i2@54@03 V@26@03))
                (<= 0 i2@54@03))
              (< i1@53@03 V@26@03))
            (<= 0 i1@53@03))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
              ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
            (< i2@54@03 V@26@03)
            (<= 0 i2@54@03)
            (< i1@53@03 V@26@03)
            (<= 0 i1@53@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@27@03 $Ref.null)
  (forall ((i1@53@03 Int)) (!
    (forall ((i2@54@03 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
                  ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03)))
                (< i2@54@03 V@26@03))
              (<= 0 i2@54@03))
            (< i1@53@03 V@26@03))
          (<= 0 i1@53@03))
        (= i1@53@03 i2@54@03))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@54@03))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@53@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               946
;  :arith-add-rows          281
;  :arith-assert-diseq      24
;  :arith-assert-lower      120
;  :arith-assert-upper      80
;  :arith-bound-prop        51
;  :arith-conflicts         17
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        87
;  :arith-pivots            111
;  :conflicts               35
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 109
;  :datatype-occurs-check   96
;  :datatype-splits         65
;  :decisions               127
;  :del-clause              398
;  :final-checks            59
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.94
;  :memory                  4.92
;  :mk-bool-var             1388
;  :mk-clause               407
;  :num-allocs              197278
;  :num-checks              79
;  :propagations            148
;  :quant-instantiations    326
;  :rlimit-count            251612)
; [then-branch: 57 | exc@27@03 == Null | live]
; [else-branch: 57 | exc@27@03 != Null | dead]
(push) ; 7
; [then-branch: 57 | exc@27@03 == Null]
; [eval] 0 <= s
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies (= exc@27@03 $Ref.null) (<= 0 s@24@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 6
(push) ; 7
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               984
;  :arith-add-rows          281
;  :arith-assert-diseq      24
;  :arith-assert-lower      120
;  :arith-assert-upper      80
;  :arith-bound-prop        51
;  :arith-conflicts         17
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        87
;  :arith-pivots            111
;  :conflicts               35
;  :datatype-accessor-ax    45
;  :datatype-constructor-ax 117
;  :datatype-occurs-check   99
;  :datatype-splits         69
;  :decisions               135
;  :del-clause              398
;  :final-checks            61
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.94
;  :memory                  4.93
;  :mk-bool-var             1394
;  :mk-clause               407
;  :num-allocs              198051
;  :num-checks              80
;  :propagations            148
;  :quant-instantiations    326
;  :rlimit-count            252557)
; [then-branch: 58 | exc@27@03 == Null | live]
; [else-branch: 58 | exc@27@03 != Null | dead]
(push) ; 7
; [then-branch: 58 | exc@27@03 == Null]
; [eval] s < V
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies (= exc@27@03 $Ref.null) (< s@24@03 V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 6
(push) ; 7
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1023
;  :arith-add-rows          281
;  :arith-assert-diseq      24
;  :arith-assert-lower      120
;  :arith-assert-upper      80
;  :arith-bound-prop        51
;  :arith-conflicts         17
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        87
;  :arith-pivots            111
;  :conflicts               35
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 125
;  :datatype-occurs-check   102
;  :datatype-splits         73
;  :decisions               143
;  :del-clause              398
;  :final-checks            63
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.94
;  :memory                  4.93
;  :mk-bool-var             1400
;  :mk-clause               407
;  :num-allocs              198820
;  :num-checks              81
;  :propagations            148
;  :quant-instantiations    326
;  :rlimit-count            253520)
; [then-branch: 59 | exc@27@03 == Null | live]
; [else-branch: 59 | exc@27@03 != Null | dead]
(push) ; 7
; [then-branch: 59 | exc@27@03 == Null]
; [eval] 0 <= t
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies (= exc@27@03 $Ref.null) (<= 0 t@25@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 6
(push) ; 7
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1063
;  :arith-add-rows          281
;  :arith-assert-diseq      24
;  :arith-assert-lower      120
;  :arith-assert-upper      80
;  :arith-bound-prop        51
;  :arith-conflicts         17
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        87
;  :arith-pivots            111
;  :conflicts               35
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 133
;  :datatype-occurs-check   105
;  :datatype-splits         77
;  :decisions               151
;  :del-clause              398
;  :final-checks            65
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.94
;  :memory                  4.93
;  :mk-bool-var             1406
;  :mk-clause               407
;  :num-allocs              199591
;  :num-checks              82
;  :propagations            148
;  :quant-instantiations    326
;  :rlimit-count            254491)
; [then-branch: 60 | exc@27@03 == Null | live]
; [else-branch: 60 | exc@27@03 != Null | dead]
(push) ; 7
; [then-branch: 60 | exc@27@03 == Null]
; [eval] t < V
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies (= exc@27@03 $Ref.null) (< t@25@03 V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))))))
; [eval] exc == null
(push) ; 6
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1105
;  :arith-add-rows          281
;  :arith-assert-diseq      24
;  :arith-assert-lower      120
;  :arith-assert-upper      80
;  :arith-bound-prop        51
;  :arith-conflicts         17
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        87
;  :arith-pivots            111
;  :conflicts               35
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 142
;  :datatype-occurs-check   108
;  :datatype-splits         82
;  :decisions               160
;  :del-clause              398
;  :final-checks            67
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.95
;  :memory                  4.93
;  :mk-bool-var             1412
;  :mk-clause               407
;  :num-allocs              200363
;  :num-checks              83
;  :propagations            148
;  :quant-instantiations    326
;  :rlimit-count            255463)
; [then-branch: 61 | exc@27@03 == Null | live]
; [else-branch: 61 | exc@27@03 != Null | dead]
(push) ; 6
; [then-branch: 61 | exc@27@03 == Null]
(declare-const i1@55@03 Int)
(declare-const j1@56@03 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 62 | 0 <= i1@55@03 | live]
; [else-branch: 62 | !(0 <= i1@55@03) | live]
(push) ; 9
; [then-branch: 62 | 0 <= i1@55@03]
(assert (<= 0 i1@55@03))
; [eval] i1 < V
(push) ; 10
; [then-branch: 63 | i1@55@03 < V@26@03 | live]
; [else-branch: 63 | !(i1@55@03 < V@26@03) | live]
(push) ; 11
; [then-branch: 63 | i1@55@03 < V@26@03]
(assert (< i1@55@03 V@26@03))
; [eval] 0 <= j1
(push) ; 12
; [then-branch: 64 | 0 <= j1@56@03 | live]
; [else-branch: 64 | !(0 <= j1@56@03) | live]
(push) ; 13
; [then-branch: 64 | 0 <= j1@56@03]
(assert (<= 0 j1@56@03))
; [eval] j1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 64 | !(0 <= j1@56@03)]
(assert (not (<= 0 j1@56@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 63 | !(i1@55@03 < V@26@03)]
(assert (not (< i1@55@03 V@26@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 62 | !(0 <= i1@55@03)]
(assert (not (<= 0 i1@55@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@56@03 V@26@03) (<= 0 j1@56@03)) (< i1@55@03 V@26@03))
  (<= 0 i1@55@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< i1@55@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1105
;  :arith-add-rows          284
;  :arith-assert-diseq      24
;  :arith-assert-lower      126
;  :arith-assert-upper      80
;  :arith-bound-prop        51
;  :arith-conflicts         17
;  :arith-eq-adapter        44
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        87
;  :arith-pivots            112
;  :conflicts               35
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 142
;  :datatype-occurs-check   108
;  :datatype-splits         82
;  :decisions               160
;  :del-clause              398
;  :final-checks            67
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.95
;  :memory                  4.93
;  :mk-bool-var             1418
;  :mk-clause               407
;  :num-allocs              200636
;  :num-checks              84
;  :propagations            148
;  :quant-instantiations    326
;  :rlimit-count            255943)
(assert (< i1@55@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 8
; Joined path conditions
(assert (< i1@55@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03)))
(push) ; 8
(assert (not (ite
  (and
    (<
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))
      V@26@03)
    (<=
      0
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))))
  (< $Perm.No $k@48@03)
  false)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1119
;  :arith-add-rows          294
;  :arith-assert-diseq      24
;  :arith-assert-lower      128
;  :arith-assert-upper      83
;  :arith-bound-prop        53
;  :arith-conflicts         18
;  :arith-eq-adapter        46
;  :arith-fixed-eqs         30
;  :arith-offset-eqs        87
;  :arith-pivots            115
;  :conflicts               36
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 142
;  :datatype-occurs-check   108
;  :datatype-splits         82
;  :decisions               160
;  :del-clause              398
;  :final-checks            67
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.95
;  :memory                  4.94
;  :mk-bool-var             1479
;  :mk-clause               427
;  :num-allocs              201145
;  :num-checks              85
;  :propagations            149
;  :quant-instantiations    354
;  :rlimit-count            257690)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 9
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1119
;  :arith-add-rows          294
;  :arith-assert-diseq      24
;  :arith-assert-lower      128
;  :arith-assert-upper      83
;  :arith-bound-prop        53
;  :arith-conflicts         18
;  :arith-eq-adapter        46
;  :arith-fixed-eqs         30
;  :arith-offset-eqs        87
;  :arith-pivots            115
;  :conflicts               37
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 142
;  :datatype-occurs-check   108
;  :datatype-splits         82
;  :decisions               160
;  :del-clause              398
;  :final-checks            67
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.95
;  :memory                  4.94
;  :mk-bool-var             1479
;  :mk-clause               427
;  :num-allocs              201235
;  :num-checks              86
;  :propagations            149
;  :quant-instantiations    354
;  :rlimit-count            257785)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))
    (as None<option<array>>  option<array>))))
(pop) ; 8
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))
    (as None<option<array>>  option<array>))))
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 9
(assert (not (<
  j1@56@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1125
;  :arith-add-rows          298
;  :arith-assert-diseq      24
;  :arith-assert-lower      131
;  :arith-assert-upper      84
;  :arith-bound-prop        53
;  :arith-conflicts         19
;  :arith-eq-adapter        47
;  :arith-fixed-eqs         31
;  :arith-offset-eqs        87
;  :arith-pivots            117
;  :conflicts               38
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 142
;  :datatype-occurs-check   108
;  :datatype-splits         82
;  :decisions               160
;  :del-clause              402
;  :final-checks            67
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              4.95
;  :memory                  4.95
;  :mk-bool-var             1490
;  :mk-clause               431
;  :num-allocs              201427
;  :num-checks              87
;  :propagations            151
;  :quant-instantiations    361
;  :rlimit-count            258248)
(assert (<
  j1@56@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))))))
(pop) ; 8
; Joined path conditions
(assert (<
  j1@56@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))))))
(pop) ; 7
(declare-fun inv@57@03 ($Ref) Int)
(declare-fun inv@58@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@55@03 Int) (j1@56@03 Int)) (!
  (and
    (< i1@55@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@56@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))) j1@56@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((i11@55@03 Int) (j11@56@03 Int) (i12@55@03 Int) (j12@56@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@56@03 V@26@03) (<= 0 j11@56@03)) (< i11@55@03 V@26@03))
        (<= 0 i11@55@03))
      (and
        (and (and (< j12@56@03 V@26@03) (<= 0 j12@56@03)) (< i12@55@03 V@26@03))
        (<= 0 i12@55@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@55@03))) j11@56@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@55@03))) j12@56@03)))
    (and (= i11@55@03 i12@55@03) (= j11@56@03 j12@56@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1177
;  :arith-add-rows          320
;  :arith-assert-diseq      24
;  :arith-assert-lower      143
;  :arith-assert-upper      88
;  :arith-bound-prop        55
;  :arith-conflicts         19
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        87
;  :arith-pivots            129
;  :conflicts               39
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 142
;  :datatype-occurs-check   108
;  :datatype-splits         82
;  :decisions               160
;  :del-clause              493
;  :final-checks            67
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.11
;  :memory                  5.10
;  :mk-bool-var             1680
;  :mk-clause               502
;  :num-allocs              202884
;  :num-checks              88
;  :propagations            177
;  :quant-instantiations    443
;  :rlimit-count            263154
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@55@03 Int) (j1@56@03 Int)) (!
  (implies
    (and
      (and (and (< j1@56@03 V@26@03) (<= 0 j1@56@03)) (< i1@55@03 V@26@03))
      (<= 0 i1@55@03))
    (and
      (=
        (inv@57@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))) j1@56@03))
        i1@55@03)
      (=
        (inv@58@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))) j1@56@03))
        j1@56@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))) j1@56@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@58@03 r) V@26@03) (<= 0 (inv@58@03 r)))
        (< (inv@57@03 r) V@26@03))
      (<= 0 (inv@57@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@57@03 r)))) (inv@58@03 r))
      r))
  :pattern ((inv@57@03 r))
  :pattern ((inv@58@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@55@03 Int) (j1@56@03 Int)) (!
  (implies
    (and
      (and (and (< j1@56@03 V@26@03) (<= 0 j1@56@03)) (< i1@55@03 V@26@03))
      (<= 0 i1@55@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))) j1@56@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@55@03))) j1@56@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@59@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@58@03 r) V@26@03) (<= 0 (inv@58@03 r)))
        (< (inv@57@03 r) V@26@03))
      (<= 0 (inv@57@03 r)))
    (=
      ($FVF.lookup_int (as sm@59@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@59@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@59@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef7|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@58@03 r) V@26@03) (<= 0 (inv@58@03 r)))
        (< (inv@57@03 r) V@26@03))
      (<= 0 (inv@57@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) r) r))
  :pattern ((inv@57@03 r) (inv@58@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { |this.Gf_seq[i1]| } 0 <= i1 && i1 < V ==> |this.Gf_seq[i1]| == V)
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1222
;  :arith-add-rows          320
;  :arith-assert-diseq      24
;  :arith-assert-lower      143
;  :arith-assert-upper      88
;  :arith-bound-prop        55
;  :arith-conflicts         19
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        87
;  :arith-pivots            129
;  :conflicts               39
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 151
;  :datatype-occurs-check   111
;  :datatype-splits         87
;  :decisions               169
;  :del-clause              493
;  :final-checks            69
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.11
;  :mk-bool-var             1693
;  :mk-clause               502
;  :num-allocs              204645
;  :num-checks              89
;  :propagations            177
;  :quant-instantiations    443
;  :rlimit-count            267235)
; [then-branch: 65 | exc@27@03 == Null | live]
; [else-branch: 65 | exc@27@03 != Null | dead]
(push) ; 8
; [then-branch: 65 | exc@27@03 == Null]
; [eval] (forall i1: Int :: { |this.Gf_seq[i1]| } 0 <= i1 && i1 < V ==> |this.Gf_seq[i1]| == V)
(declare-const i1@60@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> |this.Gf_seq[i1]| == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 66 | 0 <= i1@60@03 | live]
; [else-branch: 66 | !(0 <= i1@60@03) | live]
(push) ; 11
; [then-branch: 66 | 0 <= i1@60@03]
(assert (<= 0 i1@60@03))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 66 | !(0 <= i1@60@03)]
(assert (not (<= 0 i1@60@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 67 | i1@60@03 < V@26@03 && 0 <= i1@60@03 | live]
; [else-branch: 67 | !(i1@60@03 < V@26@03 && 0 <= i1@60@03) | live]
(push) ; 11
; [then-branch: 67 | i1@60@03 < V@26@03 && 0 <= i1@60@03]
(assert (and (< i1@60@03 V@26@03) (<= 0 i1@60@03)))
; [eval] |this.Gf_seq[i1]| == V
; [eval] |this.Gf_seq[i1]|
; [eval] this.Gf_seq[i1]
(set-option :timeout 0)
(push) ; 12
(assert (not (>= i1@60@03 0)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1222
;  :arith-add-rows          321
;  :arith-assert-diseq      24
;  :arith-assert-lower      145
;  :arith-assert-upper      88
;  :arith-bound-prop        55
;  :arith-conflicts         19
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        87
;  :arith-pivots            129
;  :conflicts               39
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 151
;  :datatype-occurs-check   111
;  :datatype-splits         87
;  :decisions               169
;  :del-clause              493
;  :final-checks            69
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.11
;  :mk-bool-var             1695
;  :mk-clause               502
;  :num-allocs              204743
;  :num-checks              90
;  :propagations            177
;  :quant-instantiations    443
;  :rlimit-count            267410)
(push) ; 12
(assert (not (<
  i1@60@03
  (Seq_length
    ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1222
;  :arith-add-rows          321
;  :arith-assert-diseq      24
;  :arith-assert-lower      145
;  :arith-assert-upper      88
;  :arith-bound-prop        55
;  :arith-conflicts         19
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        87
;  :arith-pivots            129
;  :conflicts               39
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 151
;  :datatype-occurs-check   111
;  :datatype-splits         87
;  :decisions               169
;  :del-clause              493
;  :final-checks            69
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.11
;  :mk-bool-var             1695
;  :mk-clause               502
;  :num-allocs              204763
;  :num-checks              91
;  :propagations            177
;  :quant-instantiations    443
;  :rlimit-count            267430)
(pop) ; 11
(push) ; 11
; [else-branch: 67 | !(i1@60@03 < V@26@03 && 0 <= i1@60@03)]
(assert (not (and (< i1@60@03 V@26@03) (<= 0 i1@60@03))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (forall ((i1@60@03 Int)) (!
    (implies
      (and (< i1@60@03 V@26@03) (<= 0 i1@60@03))
      (=
        (Seq_length
          (Seq_index
            ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
            i1@60@03))
        V@26@03))
    :pattern ((Seq_length
      (Seq_index
        ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
        i1@60@03)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { opt_get1(aloc(opt_get1(G), i1).option$array$) } { this.Gf_seq[i1] } 0 <= i1 && i1 < V ==> (forall j1: Int :: { aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1) } { this.Gf_seq[i1][j1] } 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1]))
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1268
;  :arith-add-rows          321
;  :arith-assert-diseq      24
;  :arith-assert-lower      145
;  :arith-assert-upper      88
;  :arith-bound-prop        55
;  :arith-conflicts         19
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        87
;  :arith-pivots            129
;  :conflicts               39
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 160
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               178
;  :del-clause              493
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.11
;  :mk-bool-var             1703
;  :mk-clause               502
;  :num-allocs              205707
;  :num-checks              92
;  :propagations            177
;  :quant-instantiations    443
;  :rlimit-count            268782)
; [then-branch: 68 | exc@27@03 == Null | live]
; [else-branch: 68 | exc@27@03 != Null | dead]
(push) ; 8
; [then-branch: 68 | exc@27@03 == Null]
; [eval] (forall i1: Int :: { opt_get1(aloc(opt_get1(G), i1).option$array$) } { this.Gf_seq[i1] } 0 <= i1 && i1 < V ==> (forall j1: Int :: { aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1) } { this.Gf_seq[i1][j1] } 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1]))
(declare-const i1@61@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> (forall j1: Int :: { aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1) } { this.Gf_seq[i1][j1] } 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 69 | 0 <= i1@61@03 | live]
; [else-branch: 69 | !(0 <= i1@61@03) | live]
(push) ; 11
; [then-branch: 69 | 0 <= i1@61@03]
(assert (<= 0 i1@61@03))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 69 | !(0 <= i1@61@03)]
(assert (not (<= 0 i1@61@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 70 | i1@61@03 < V@26@03 && 0 <= i1@61@03 | live]
; [else-branch: 70 | !(i1@61@03 < V@26@03 && 0 <= i1@61@03) | live]
(push) ; 11
; [then-branch: 70 | i1@61@03 < V@26@03 && 0 <= i1@61@03]
(assert (and (< i1@61@03 V@26@03) (<= 0 i1@61@03)))
; [eval] (forall j1: Int :: { aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1) } { this.Gf_seq[i1][j1] } 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1])
(declare-const j1@62@03 Int)
(push) ; 12
; [eval] 0 <= j1 && j1 < V ==> aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1]
; [eval] 0 <= j1 && j1 < V
; [eval] 0 <= j1
(push) ; 13
; [then-branch: 71 | 0 <= j1@62@03 | live]
; [else-branch: 71 | !(0 <= j1@62@03) | live]
(push) ; 14
; [then-branch: 71 | 0 <= j1@62@03]
(assert (<= 0 j1@62@03))
; [eval] j1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 71 | !(0 <= j1@62@03)]
(assert (not (<= 0 j1@62@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(push) ; 13
; [then-branch: 72 | j1@62@03 < V@26@03 && 0 <= j1@62@03 | live]
; [else-branch: 72 | !(j1@62@03 < V@26@03 && 0 <= j1@62@03) | live]
(push) ; 14
; [then-branch: 72 | j1@62@03 < V@26@03 && 0 <= j1@62@03]
(assert (and (< j1@62@03 V@26@03) (<= 0 j1@62@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1).int == this.Gf_seq[i1][j1]
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1268
;  :arith-add-rows          323
;  :arith-assert-diseq      24
;  :arith-assert-lower      149
;  :arith-assert-upper      88
;  :arith-bound-prop        55
;  :arith-conflicts         19
;  :arith-eq-adapter        55
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        87
;  :arith-pivots            129
;  :conflicts               39
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 160
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               178
;  :del-clause              493
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.12
;  :mk-bool-var             1707
;  :mk-clause               502
;  :num-allocs              205891
;  :num-checks              93
;  :propagations            177
;  :quant-instantiations    443
;  :rlimit-count            269139)
(assert (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 15
; Joined path conditions
(assert (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))
(push) ; 15
(assert (not (ite
  (and
    (<
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
      V@26@03)
    (<=
      0
      (inv@49@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))))
  (< $Perm.No $k@48@03)
  false)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1281
;  :arith-add-rows          333
;  :arith-assert-diseq      24
;  :arith-assert-lower      151
;  :arith-assert-upper      91
;  :arith-bound-prop        57
;  :arith-conflicts         20
;  :arith-eq-adapter        57
;  :arith-fixed-eqs         35
;  :arith-offset-eqs        87
;  :arith-pivots            132
;  :conflicts               40
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 160
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               178
;  :del-clause              493
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.11
;  :mk-bool-var             1767
;  :mk-clause               522
;  :num-allocs              206387
;  :num-checks              94
;  :propagations            178
;  :quant-instantiations    471
;  :rlimit-count            270884)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1281
;  :arith-add-rows          333
;  :arith-assert-diseq      24
;  :arith-assert-lower      151
;  :arith-assert-upper      91
;  :arith-bound-prop        57
;  :arith-conflicts         20
;  :arith-eq-adapter        57
;  :arith-fixed-eqs         35
;  :arith-offset-eqs        87
;  :arith-pivots            132
;  :conflicts               41
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 160
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               178
;  :del-clause              493
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.11
;  :mk-bool-var             1767
;  :mk-clause               522
;  :num-allocs              206477
;  :num-checks              95
;  :propagations            178
;  :quant-instantiations    471
;  :rlimit-count            270979)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j1@62@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1287
;  :arith-add-rows          339
;  :arith-assert-diseq      24
;  :arith-assert-lower      153
;  :arith-assert-upper      93
;  :arith-bound-prop        57
;  :arith-conflicts         21
;  :arith-eq-adapter        58
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        87
;  :arith-pivots            136
;  :conflicts               42
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 160
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               178
;  :del-clause              497
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.11
;  :mk-bool-var             1778
;  :mk-clause               526
;  :num-allocs              206668
;  :num-checks              96
;  :propagations            180
;  :quant-instantiations    478
;  :rlimit-count            271497)
(assert (<
  j1@62@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j1@62@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)))
(push) ; 15
(assert (not (and
  (and
    (and
      (<
        (inv@58@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
        V@26@03)
      (<=
        0
        (inv@58@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
    (<
      (inv@57@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
      V@26@03))
  (<=
    0
    (inv@57@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1334
;  :arith-add-rows          364
;  :arith-assert-diseq      24
;  :arith-assert-lower      160
;  :arith-assert-upper      99
;  :arith-bound-prop        58
;  :arith-conflicts         24
;  :arith-eq-adapter        61
;  :arith-fixed-eqs         39
;  :arith-offset-eqs        91
;  :arith-pivots            143
;  :conflicts               55
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 164
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               190
;  :del-clause              517
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.12
;  :mk-bool-var             1833
;  :mk-clause               561
;  :num-allocs              207136
;  :num-checks              97
;  :propagations            197
;  :quant-instantiations    499
;  :rlimit-count            273461)
; [eval] this.Gf_seq[i1][j1]
; [eval] this.Gf_seq[i1]
(push) ; 15
(assert (not (>= i1@61@03 0)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1334
;  :arith-add-rows          364
;  :arith-assert-diseq      24
;  :arith-assert-lower      160
;  :arith-assert-upper      99
;  :arith-bound-prop        58
;  :arith-conflicts         24
;  :arith-eq-adapter        61
;  :arith-fixed-eqs         39
;  :arith-offset-eqs        91
;  :arith-pivots            143
;  :conflicts               55
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 164
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               190
;  :del-clause              517
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.12
;  :mk-bool-var             1833
;  :mk-clause               561
;  :num-allocs              207157
;  :num-checks              98
;  :propagations            197
;  :quant-instantiations    499
;  :rlimit-count            273470)
(push) ; 15
(assert (not (<
  i1@61@03
  (Seq_length
    ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1334
;  :arith-add-rows          364
;  :arith-assert-diseq      24
;  :arith-assert-lower      160
;  :arith-assert-upper      99
;  :arith-bound-prop        58
;  :arith-conflicts         24
;  :arith-eq-adapter        61
;  :arith-fixed-eqs         39
;  :arith-offset-eqs        91
;  :arith-pivots            143
;  :conflicts               55
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 164
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               190
;  :del-clause              517
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.12
;  :mk-bool-var             1833
;  :mk-clause               561
;  :num-allocs              207177
;  :num-checks              99
;  :propagations            197
;  :quant-instantiations    499
;  :rlimit-count            273490)
(push) ; 15
(assert (not (>= j1@62@03 0)))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1334
;  :arith-add-rows          364
;  :arith-assert-diseq      24
;  :arith-assert-lower      160
;  :arith-assert-upper      99
;  :arith-bound-prop        58
;  :arith-conflicts         24
;  :arith-eq-adapter        61
;  :arith-fixed-eqs         39
;  :arith-offset-eqs        91
;  :arith-pivots            143
;  :conflicts               55
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 164
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               190
;  :del-clause              517
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.12
;  :mk-bool-var             1833
;  :mk-clause               561
;  :num-allocs              207192
;  :num-checks              100
;  :propagations            197
;  :quant-instantiations    499
;  :rlimit-count            273499)
(push) ; 15
(assert (not (<
  j1@62@03
  (Seq_length
    (Seq_index
      ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
      i1@61@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1338
;  :arith-add-rows          384
;  :arith-assert-diseq      25
;  :arith-assert-lower      164
;  :arith-assert-upper      100
;  :arith-bound-prop        58
;  :arith-conflicts         25
;  :arith-eq-adapter        63
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        91
;  :arith-pivots            147
;  :conflicts               56
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 164
;  :datatype-occurs-check   116
;  :datatype-splits         92
;  :decisions               190
;  :del-clause              525
;  :final-checks            71
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.13
;  :memory                  5.12
;  :mk-bool-var             1843
;  :mk-clause               569
;  :num-allocs              207320
;  :num-checks              101
;  :propagations            200
;  :quant-instantiations    503
;  :rlimit-count            274120)
(pop) ; 14
(push) ; 14
; [else-branch: 72 | !(j1@62@03 < V@26@03 && 0 <= j1@62@03)]
(assert (not (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
  (and
    (< j1@62@03 V@26@03)
    (<= 0 j1@62@03)
    (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@62@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((j1@62@03 Int)) (!
  (implies
    (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
    (and
      (< j1@62@03 V@26@03)
      (<= 0 j1@62@03)
      (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
          (as None<option<array>>  option<array>)))
      (<
        j1@62@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((j1@62@03 Int)) (!
  (implies
    (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
    (and
      (< j1@62@03 V@26@03)
      (<= 0 j1@62@03)
      (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
          (as None<option<array>>  option<array>)))
      (<
        j1@62@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
  :pattern ((Seq_index
    (Seq_index
      ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
      i1@61@03)
    j1@62@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
(push) ; 11
; [else-branch: 70 | !(i1@61@03 < V@26@03 && 0 <= i1@61@03)]
(assert (not (and (< i1@61@03 V@26@03) (<= 0 i1@61@03))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@61@03 V@26@03) (<= 0 i1@61@03))
  (and
    (< i1@61@03 V@26@03)
    (<= 0 i1@61@03)
    (forall ((j1@62@03 Int)) (!
      (implies
        (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
        (and
          (< j1@62@03 V@26@03)
          (<= 0 j1@62@03)
          (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
              (as None<option<array>>  option<array>)))
          (<
            j1@62@03
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
      :qid |prog.l<no position>-aux|))
    (forall ((j1@62@03 Int)) (!
      (implies
        (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
        (and
          (< j1@62@03 V@26@03)
          (<= 0 j1@62@03)
          (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
              (as None<option<array>>  option<array>)))
          (<
            j1@62@03
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
      :pattern ((Seq_index
        (Seq_index
          ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
          i1@61@03)
        j1@62@03))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@61@03 Int)) (!
  (implies
    (and (< i1@61@03 V@26@03) (<= 0 i1@61@03))
    (and
      (< i1@61@03 V@26@03)
      (<= 0 i1@61@03)
      (forall ((j1@62@03 Int)) (!
        (implies
          (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
          (and
            (< j1@62@03 V@26@03)
            (<= 0 j1@62@03)
            (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                (as None<option<array>>  option<array>)))
            (<
              j1@62@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
        :qid |prog.l<no position>-aux|))
      (forall ((j1@62@03 Int)) (!
        (implies
          (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
          (and
            (< j1@62@03 V@26@03)
            (<= 0 j1@62@03)
            (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                (as None<option<array>>  option<array>)))
            (<
              j1@62@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
        :pattern ((Seq_index
          (Seq_index
            ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
            i1@61@03)
          j1@62@03))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@61@03 Int)) (!
  (implies
    (and (< i1@61@03 V@26@03) (<= 0 i1@61@03))
    (and
      (< i1@61@03 V@26@03)
      (<= 0 i1@61@03)
      (forall ((j1@62@03 Int)) (!
        (implies
          (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
          (and
            (< j1@62@03 V@26@03)
            (<= 0 j1@62@03)
            (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                (as None<option<array>>  option<array>)))
            (<
              j1@62@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
        :qid |prog.l<no position>-aux|))
      (forall ((j1@62@03 Int)) (!
        (implies
          (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
          (and
            (< j1@62@03 V@26@03)
            (<= 0 j1@62@03)
            (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                (as None<option<array>>  option<array>)))
            (<
              j1@62@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
        :pattern ((Seq_index
          (Seq_index
            ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
            i1@61@03)
          j1@62@03))
        :qid |prog.l<no position>-aux|))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
    i1@61@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (and
    (forall ((i1@61@03 Int)) (!
      (implies
        (and (< i1@61@03 V@26@03) (<= 0 i1@61@03))
        (and
          (< i1@61@03 V@26@03)
          (<= 0 i1@61@03)
          (forall ((j1@62@03 Int)) (!
            (implies
              (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
              (and
                (< j1@62@03 V@26@03)
                (<= 0 j1@62@03)
                (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                    (as None<option<array>>  option<array>)))
                (<
                  j1@62@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
            :qid |prog.l<no position>-aux|))
          (forall ((j1@62@03 Int)) (!
            (implies
              (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
              (and
                (< j1@62@03 V@26@03)
                (<= 0 j1@62@03)
                (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                    (as None<option<array>>  option<array>)))
                (<
                  j1@62@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
            :pattern ((Seq_index
              (Seq_index
                ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
                i1@61@03)
              j1@62@03))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))))
      :qid |prog.l<no position>-aux|))
    (forall ((i1@61@03 Int)) (!
      (implies
        (and (< i1@61@03 V@26@03) (<= 0 i1@61@03))
        (and
          (< i1@61@03 V@26@03)
          (<= 0 i1@61@03)
          (forall ((j1@62@03 Int)) (!
            (implies
              (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
              (and
                (< j1@62@03 V@26@03)
                (<= 0 j1@62@03)
                (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                    (as None<option<array>>  option<array>)))
                (<
                  j1@62@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
            :qid |prog.l<no position>-aux|))
          (forall ((j1@62@03 Int)) (!
            (implies
              (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
              (and
                (< j1@62@03 V@26@03)
                (<= 0 j1@62@03)
                (< i1@61@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))
                    (as None<option<array>>  option<array>)))
                (<
                  j1@62@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))))
            :pattern ((Seq_index
              (Seq_index
                ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
                i1@61@03)
              j1@62@03))
            :qid |prog.l<no position>-aux|))))
      :pattern ((Seq_index
        ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
        i1@61@03))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (= exc@27@03 $Ref.null)
  (forall ((i1@61@03 Int)) (!
    (implies
      (and (< i1@61@03 V@26@03) (<= 0 i1@61@03))
      (forall ((j1@62@03 Int)) (!
        (implies
          (and (< j1@62@03 V@26@03) (<= 0 j1@62@03))
          (=
            ($FVF.lookup_int (as sm@59@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
            (Seq_index
              (Seq_index
                ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
                i1@61@03)
              j1@62@03)))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))) j1@62@03))
        :pattern ((Seq_index
          (Seq_index
            ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
            i1@61@03)
          j1@62@03))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@50@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@61@03))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03)))
      i1@61@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@46@03))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> ExAugPath(this, this.Gf_seq, V, s, t) == false
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@27@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1377
;  :arith-add-rows          397
;  :arith-assert-diseq      25
;  :arith-assert-lower      164
;  :arith-assert-upper      100
;  :arith-bound-prop        58
;  :arith-conflicts         25
;  :arith-eq-adapter        63
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        91
;  :arith-pivots            158
;  :conflicts               56
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 172
;  :datatype-occurs-check   121
;  :datatype-splits         96
;  :decisions               198
;  :del-clause              560
;  :final-checks            73
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.13
;  :mk-bool-var             1851
;  :mk-clause               569
;  :num-allocs              209794
;  :num-checks              102
;  :propagations            200
;  :quant-instantiations    503
;  :rlimit-count            279701)
; [then-branch: 73 | exc@27@03 == Null | live]
; [else-branch: 73 | exc@27@03 != Null | dead]
(push) ; 8
; [then-branch: 73 | exc@27@03 == Null]
; [eval] ExAugPath(this, this.Gf_seq, V, s, t) == false
; [eval] ExAugPath(this, this.Gf_seq, V, s, t)
(push) ; 9
; [eval] this != null
; [eval] SquareIntMatrix(this, G, V)
(push) ; 10
; [eval] this != null
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03))) V@26@03)))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1381
;  :arith-add-rows          403
;  :arith-assert-diseq      28
;  :arith-assert-lower      167
;  :arith-assert-upper      101
;  :arith-bound-prop        58
;  :arith-conflicts         26
;  :arith-eq-adapter        65
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        91
;  :arith-pivots            160
;  :conflicts               57
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 172
;  :datatype-occurs-check   121
;  :datatype-splits         96
;  :decisions               198
;  :del-clause              601
;  :final-checks            73
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1893
;  :mk-clause               610
;  :num-allocs              210119
;  :num-checks              103
;  :propagations            214
;  :quant-instantiations    514
;  :rlimit-count            280801)
(assert (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03))) V@26@03))
(pop) ; 9
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03))) V@26@03))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@27@03 $Ref.null)
  (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03))) V@26@03)))
(assert (implies
  (= exc@27@03 $Ref.null)
  (=
    (ExAugPath ($Snap.combine $Snap.unit $Snap.unit) this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second $t@46@03))) V@26@03 s@24@03 t@25@03)
    false)))
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; var return: Int
(declare-const return@63@03 Int)
; [exec]
; var Gf: option[array]
(declare-const Gf@64@03 option<array>)
; [exec]
; var P: option[array]
(declare-const P@65@03 option<array>)
; [exec]
; var res1: option[array]
(declare-const res1@66@03 option<array>)
; [exec]
; var res2: void
(declare-const res2@67@03 void)
; [exec]
; var res3: option[array]
(declare-const res3@68@03 option<array>)
; [exec]
; var res4: void
(declare-const res4@69@03 void)
; [exec]
; var res5: Int
(declare-const res5@70@03 Int)
; [exec]
; var evaluationDummy: void
(declare-const evaluationDummy@71@03 void)
; [exec]
; var evaluationDummy1: void
(declare-const evaluationDummy1@72@03 void)
; [exec]
; exc := null
; [exec]
; exc, res1 := make_array(tid, V, V)
(declare-const exc@73@03 $Ref)
(declare-const res@74@03 option<array>)
(declare-const $t@75@03 $Snap)
(assert (= $t@75@03 ($Snap.combine ($Snap.first $t@75@03) ($Snap.second $t@75@03))))
(assert (= ($Snap.first $t@75@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@73@03 $Ref.null))
(assert (=
  ($Snap.second $t@75@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@75@03))
    ($Snap.second ($Snap.second $t@75@03)))))
(assert (= ($Snap.first ($Snap.second $t@75@03)) $Snap.unit))
; [eval] exc == null ==> res != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1406
;  :arith-add-rows          403
;  :arith-assert-diseq      28
;  :arith-assert-lower      167
;  :arith-assert-upper      101
;  :arith-bound-prop        58
;  :arith-conflicts         26
;  :arith-eq-adapter        65
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        91
;  :arith-pivots            162
;  :conflicts               57
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 177
;  :datatype-occurs-check   124
;  :datatype-splits         97
;  :decisions               203
;  :del-clause              603
;  :final-checks            75
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1899
;  :mk-clause               610
;  :num-allocs              210892
;  :num-checks              104
;  :propagations            214
;  :quant-instantiations    514
;  :rlimit-count            281724)
; [then-branch: 74 | exc@73@03 == Null | live]
; [else-branch: 74 | exc@73@03 != Null | dead]
(push) ; 4
; [then-branch: 74 | exc@73@03 == Null]
; [eval] res != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@73@03 $Ref.null)
  (not (= res@74@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@75@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@75@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@75@03))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(res)) == dim0
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1425
;  :arith-add-rows          403
;  :arith-assert-diseq      28
;  :arith-assert-lower      167
;  :arith-assert-upper      101
;  :arith-bound-prop        58
;  :arith-conflicts         26
;  :arith-eq-adapter        65
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        91
;  :arith-pivots            162
;  :conflicts               57
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 182
;  :datatype-occurs-check   127
;  :datatype-splits         98
;  :decisions               208
;  :del-clause              603
;  :final-checks            77
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1903
;  :mk-clause               610
;  :num-allocs              211617
;  :num-checks              105
;  :propagations            214
;  :quant-instantiations    514
;  :rlimit-count            282525)
; [then-branch: 75 | exc@73@03 == Null | live]
; [else-branch: 75 | exc@73@03 != Null | dead]
(push) ; 4
; [then-branch: 75 | exc@73@03 == Null]
; [eval] alen(opt_get1(res)) == dim0
; [eval] alen(opt_get1(res))
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@74@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1425
;  :arith-add-rows          403
;  :arith-assert-diseq      28
;  :arith-assert-lower      167
;  :arith-assert-upper      101
;  :arith-bound-prop        58
;  :arith-conflicts         26
;  :arith-eq-adapter        65
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        91
;  :arith-pivots            162
;  :conflicts               57
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 182
;  :datatype-occurs-check   127
;  :datatype-splits         98
;  :decisions               208
;  :del-clause              603
;  :final-checks            77
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1903
;  :mk-clause               610
;  :num-allocs              211641
;  :num-checks              106
;  :propagations            214
;  :quant-instantiations    514
;  :rlimit-count            282546)
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@73@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@74@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@75@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 3
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1452
;  :arith-add-rows          404
;  :arith-assert-diseq      28
;  :arith-assert-lower      169
;  :arith-assert-upper      102
;  :arith-bound-prop        58
;  :arith-conflicts         26
;  :arith-eq-adapter        66
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        91
;  :arith-pivots            163
;  :conflicts               57
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 188
;  :datatype-occurs-check   130
;  :datatype-splits         100
;  :decisions               214
;  :del-clause              603
;  :final-checks            79
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1915
;  :mk-clause               610
;  :num-allocs              212411
;  :num-checks              107
;  :propagations            214
;  :quant-instantiations    519
;  :rlimit-count            283461)
; [then-branch: 76 | exc@73@03 == Null | live]
; [else-branch: 76 | exc@73@03 != Null | dead]
(push) ; 3
; [then-branch: 76 | exc@73@03 == Null]
(declare-const i0@76@03 Int)
(push) ; 4
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 5
; [then-branch: 77 | 0 <= i0@76@03 | live]
; [else-branch: 77 | !(0 <= i0@76@03) | live]
(push) ; 6
; [then-branch: 77 | 0 <= i0@76@03]
(assert (<= 0 i0@76@03))
; [eval] i0 < dim0
(pop) ; 6
(push) ; 6
; [else-branch: 77 | !(0 <= i0@76@03)]
(assert (not (<= 0 i0@76@03)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i0@76@03 V@26@03) (<= 0 i0@76@03)))
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= res@74@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1452
;  :arith-add-rows          405
;  :arith-assert-diseq      28
;  :arith-assert-lower      171
;  :arith-assert-upper      102
;  :arith-bound-prop        58
;  :arith-conflicts         26
;  :arith-eq-adapter        66
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        91
;  :arith-pivots            164
;  :conflicts               57
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 188
;  :datatype-occurs-check   130
;  :datatype-splits         100
;  :decisions               214
;  :del-clause              603
;  :final-checks            79
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1917
;  :mk-clause               610
;  :num-allocs              212510
;  :num-checks              108
;  :propagations            214
;  :quant-instantiations    519
;  :rlimit-count            283638)
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i0@76@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1452
;  :arith-add-rows          405
;  :arith-assert-diseq      28
;  :arith-assert-lower      171
;  :arith-assert-upper      102
;  :arith-bound-prop        58
;  :arith-conflicts         26
;  :arith-eq-adapter        66
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        91
;  :arith-pivots            164
;  :conflicts               57
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 188
;  :datatype-occurs-check   130
;  :datatype-splits         100
;  :decisions               214
;  :del-clause              603
;  :final-checks            79
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1917
;  :mk-clause               610
;  :num-allocs              212530
;  :num-checks              109
;  :propagations            214
;  :quant-instantiations    519
;  :rlimit-count            283669)
(assert (< i0@76@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 5
; Joined path conditions
(assert (< i0@76@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 5
; Joined path conditions
(pop) ; 4
(declare-fun inv@77@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@76@03 Int)) (!
  (and
    (not (= res@74@03 (as None<option<array>>  option<array>)))
    (< i0@76@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@76@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@76@03)))
  :qid |option$array$-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i01@76@03 Int) (i02@76@03 Int)) (!
  (implies
    (and
      (and (< i01@76@03 V@26@03) (<= 0 i01@76@03))
      (and (< i02@76@03 V@26@03) (<= 0 i02@76@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i01@76@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i02@76@03)))
    (= i01@76@03 i02@76@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1464
;  :arith-add-rows          415
;  :arith-assert-diseq      31
;  :arith-assert-lower      176
;  :arith-assert-upper      102
;  :arith-bound-prop        59
;  :arith-conflicts         27
;  :arith-eq-adapter        67
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        91
;  :arith-pivots            169
;  :conflicts               58
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 188
;  :datatype-occurs-check   130
;  :datatype-splits         100
;  :decisions               214
;  :del-clause              617
;  :final-checks            79
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.11
;  :mk-bool-var             1941
;  :mk-clause               624
;  :num-allocs              213084
;  :num-checks              110
;  :propagations            219
;  :quant-instantiations    527
;  :rlimit-count            284831)
; Definitional axioms for inverse functions
(assert (forall ((i0@76@03 Int)) (!
  (implies
    (and (< i0@76@03 V@26@03) (<= 0 i0@76@03))
    (=
      (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@76@03))
      i0@76@03))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@76@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@76@03)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@77@03 r))
      r))
  :pattern ((inv@77@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@76@03 Int)) (!
  (implies
    (and (< i0@76@03 V@26@03) (<= 0 i0@76@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@76@03)
        $Ref.null)))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@76@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@76@03)))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@78@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r))
  :qid |qp.fvfValDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
      (< $Perm.No $k@31@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) r) r))
  :pattern ((inv@77@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1488
;  :arith-add-rows          415
;  :arith-assert-diseq      31
;  :arith-assert-lower      176
;  :arith-assert-upper      102
;  :arith-bound-prop        59
;  :arith-conflicts         27
;  :arith-eq-adapter        67
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        91
;  :arith-pivots            169
;  :conflicts               58
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 194
;  :datatype-occurs-check   133
;  :datatype-splits         102
;  :decisions               220
;  :del-clause              617
;  :final-checks            81
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1952
;  :mk-clause               624
;  :num-allocs              214905
;  :num-checks              111
;  :propagations            219
;  :quant-instantiations    527
;  :rlimit-count            288482)
; [then-branch: 78 | exc@73@03 == Null | live]
; [else-branch: 78 | exc@73@03 != Null | dead]
(push) ; 5
; [then-branch: 78 | exc@73@03 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array]))
(declare-const i0@79@03 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).option$array$ != (None(): option[array])
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 79 | 0 <= i0@79@03 | live]
; [else-branch: 79 | !(0 <= i0@79@03) | live]
(push) ; 8
; [then-branch: 79 | 0 <= i0@79@03]
(assert (<= 0 i0@79@03))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 79 | !(0 <= i0@79@03)]
(assert (not (<= 0 i0@79@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 80 | i0@79@03 < V@26@03 && 0 <= i0@79@03 | live]
; [else-branch: 80 | !(i0@79@03 < V@26@03 && 0 <= i0@79@03) | live]
(push) ; 8
; [then-branch: 80 | i0@79@03 < V@26@03 && 0 <= i0@79@03]
(assert (and (< i0@79@03 V@26@03) (<= 0 i0@79@03)))
; [eval] aloc(opt_get1(res), i0).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@74@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1488
;  :arith-add-rows          416
;  :arith-assert-diseq      31
;  :arith-assert-lower      178
;  :arith-assert-upper      102
;  :arith-bound-prop        59
;  :arith-conflicts         27
;  :arith-eq-adapter        67
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        91
;  :arith-pivots            169
;  :conflicts               58
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 194
;  :datatype-occurs-check   133
;  :datatype-splits         102
;  :decisions               220
;  :del-clause              617
;  :final-checks            81
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1954
;  :mk-clause               624
;  :num-allocs              215004
;  :num-checks              112
;  :propagations            219
;  :quant-instantiations    527
;  :rlimit-count            288664)
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@79@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1488
;  :arith-add-rows          416
;  :arith-assert-diseq      31
;  :arith-assert-lower      178
;  :arith-assert-upper      102
;  :arith-bound-prop        59
;  :arith-conflicts         27
;  :arith-eq-adapter        67
;  :arith-fixed-eqs         41
;  :arith-offset-eqs        91
;  :arith-pivots            169
;  :conflicts               58
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 194
;  :datatype-occurs-check   133
;  :datatype-splits         102
;  :decisions               220
;  :del-clause              617
;  :final-checks            81
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             1954
;  :mk-clause               624
;  :num-allocs              215024
;  :num-checks              113
;  :propagations            219
;  :quant-instantiations    527
;  :rlimit-count            288695)
(assert (< i0@79@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 9
; Joined path conditions
(assert (< i0@79@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1538
;  :arith-add-rows          427
;  :arith-assert-diseq      33
;  :arith-assert-lower      188
;  :arith-assert-upper      114
;  :arith-bound-prop        65
;  :arith-conflicts         30
;  :arith-eq-adapter        77
;  :arith-fixed-eqs         45
;  :arith-offset-eqs        94
;  :arith-pivots            175
;  :conflicts               67
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 198
;  :datatype-occurs-check   133
;  :datatype-splits         102
;  :decisions               228
;  :del-clause              644
;  :final-checks            81
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2031
;  :mk-clause               674
;  :num-allocs              215563
;  :num-checks              114
;  :propagations            251
;  :quant-instantiations    547
;  :rlimit-count            290159)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 80 | !(i0@79@03 < V@26@03 && 0 <= i0@79@03)]
(assert (not (and (< i0@79@03 V@26@03) (<= 0 i0@79@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@79@03 V@26@03) (<= 0 i0@79@03))
  (and
    (< i0@79@03 V@26@03)
    (<= 0 i0@79@03)
    (not (= res@74@03 (as None<option<array>>  option<array>)))
    (< i0@79@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@79@03 Int)) (!
  (implies
    (and (< i0@79@03 V@26@03) (<= 0 i0@79@03))
    (and
      (< i0@79@03 V@26@03)
      (<= 0 i0@79@03)
      (not (= res@74@03 (as None<option<array>>  option<array>)))
      (< i0@79@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@73@03 $Ref.null)
  (forall ((i0@79@03 Int)) (!
    (implies
      (and (< i0@79@03 V@26@03) (<= 0 i0@79@03))
      (and
        (< i0@79@03 V@26@03)
        (<= 0 i0@79@03)
        (not (= res@74@03 (as None<option<array>>  option<array>)))
        (< i0@79@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@73@03 $Ref.null)
  (forall ((i0@79@03 Int)) (!
    (implies
      (and (< i0@79@03 V@26@03) (<= 0 i0@79@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03))
          (as None<option<array>>  option<array>))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@79@03)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1563
;  :arith-add-rows          430
;  :arith-assert-diseq      33
;  :arith-assert-lower      188
;  :arith-assert-upper      114
;  :arith-bound-prop        65
;  :arith-conflicts         30
;  :arith-eq-adapter        77
;  :arith-fixed-eqs         45
;  :arith-offset-eqs        94
;  :arith-pivots            178
;  :conflicts               67
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 204
;  :datatype-occurs-check   136
;  :datatype-splits         104
;  :decisions               234
;  :del-clause              667
;  :final-checks            83
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2037
;  :mk-clause               674
;  :num-allocs              216673
;  :num-checks              115
;  :propagations            251
;  :quant-instantiations    547
;  :rlimit-count            291784)
; [then-branch: 81 | exc@73@03 == Null | live]
; [else-branch: 81 | exc@73@03 != Null | dead]
(push) ; 5
; [then-branch: 81 | exc@73@03 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).option$array$ } 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1)
(declare-const i0@80@03 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 ==> alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 82 | 0 <= i0@80@03 | live]
; [else-branch: 82 | !(0 <= i0@80@03) | live]
(push) ; 8
; [then-branch: 82 | 0 <= i0@80@03]
(assert (<= 0 i0@80@03))
; [eval] i0 < dim0
(pop) ; 8
(push) ; 8
; [else-branch: 82 | !(0 <= i0@80@03)]
(assert (not (<= 0 i0@80@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 83 | i0@80@03 < V@26@03 && 0 <= i0@80@03 | live]
; [else-branch: 83 | !(i0@80@03 < V@26@03 && 0 <= i0@80@03) | live]
(push) ; 8
; [then-branch: 83 | i0@80@03 < V@26@03 && 0 <= i0@80@03]
(assert (and (< i0@80@03 V@26@03) (<= 0 i0@80@03)))
; [eval] alen(opt_get1(aloc(opt_get1(res), i0).option$array$)) == dim1
; [eval] alen(opt_get1(aloc(opt_get1(res), i0).option$array$))
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= res@74@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1563
;  :arith-add-rows          431
;  :arith-assert-diseq      33
;  :arith-assert-lower      190
;  :arith-assert-upper      114
;  :arith-bound-prop        65
;  :arith-conflicts         30
;  :arith-eq-adapter        77
;  :arith-fixed-eqs         45
;  :arith-offset-eqs        94
;  :arith-pivots            178
;  :conflicts               67
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 204
;  :datatype-occurs-check   136
;  :datatype-splits         104
;  :decisions               234
;  :del-clause              667
;  :final-checks            83
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2039
;  :mk-clause               674
;  :num-allocs              216772
;  :num-checks              116
;  :propagations            251
;  :quant-instantiations    547
;  :rlimit-count            291966)
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i0@80@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1563
;  :arith-add-rows          431
;  :arith-assert-diseq      33
;  :arith-assert-lower      190
;  :arith-assert-upper      114
;  :arith-bound-prop        65
;  :arith-conflicts         30
;  :arith-eq-adapter        77
;  :arith-fixed-eqs         45
;  :arith-offset-eqs        94
;  :arith-pivots            178
;  :conflicts               67
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 204
;  :datatype-occurs-check   136
;  :datatype-splits         104
;  :decisions               234
;  :del-clause              667
;  :final-checks            83
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2039
;  :mk-clause               674
;  :num-allocs              216792
;  :num-checks              117
;  :propagations            251
;  :quant-instantiations    547
;  :rlimit-count            291997)
(assert (< i0@80@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 9
; Joined path conditions
(assert (< i0@80@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1611
;  :arith-add-rows          448
;  :arith-assert-diseq      35
;  :arith-assert-lower      201
;  :arith-assert-upper      124
;  :arith-bound-prop        72
;  :arith-conflicts         32
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        98
;  :arith-pivots            184
;  :conflicts               78
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 208
;  :datatype-occurs-check   136
;  :datatype-splits         104
;  :decisions               248
;  :del-clause              739
;  :final-checks            83
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2168
;  :mk-clause               770
;  :num-allocs              217451
;  :num-checks              118
;  :propagations            297
;  :quant-instantiations    571
;  :rlimit-count            293927)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1611
;  :arith-add-rows          448
;  :arith-assert-diseq      35
;  :arith-assert-lower      201
;  :arith-assert-upper      124
;  :arith-bound-prop        72
;  :arith-conflicts         32
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        98
;  :arith-pivots            184
;  :conflicts               79
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 208
;  :datatype-occurs-check   136
;  :datatype-splits         104
;  :decisions               248
;  :del-clause              739
;  :final-checks            83
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2168
;  :mk-clause               770
;  :num-allocs              217540
;  :num-checks              119
;  :propagations            297
;  :quant-instantiations    571
;  :rlimit-count            294022)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 83 | !(i0@80@03 < V@26@03 && 0 <= i0@80@03)]
(assert (not (and (< i0@80@03 V@26@03) (<= 0 i0@80@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i0@80@03 V@26@03) (<= 0 i0@80@03))
  (and
    (< i0@80@03 V@26@03)
    (<= 0 i0@80@03)
    (not (= res@74@03 (as None<option<array>>  option<array>)))
    (< i0@80@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@80@03 Int)) (!
  (implies
    (and (< i0@80@03 V@26@03) (<= 0 i0@80@03))
    (and
      (< i0@80@03 V@26@03)
      (<= 0 i0@80@03)
      (not (= res@74@03 (as None<option<array>>  option<array>)))
      (< i0@80@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
          (as None<option<array>>  option<array>)))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@73@03 $Ref.null)
  (forall ((i0@80@03 Int)) (!
    (implies
      (and (< i0@80@03 V@26@03) (<= 0 i0@80@03))
      (and
        (< i0@80@03 V@26@03)
        (<= 0 i0@80@03)
        (not (= res@74@03 (as None<option<array>>  option<array>)))
        (< i0@80@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))
            (as None<option<array>>  option<array>)))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@73@03 $Ref.null)
  (forall ((i0@80@03 Int)) (!
    (implies
      (and (< i0@80@03 V@26@03) (<= 0 i0@80@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03))))
        V@26@03))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@80@03)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int, j0: Int :: { aloc(opt_get1(res), i0).option$array$,aloc(opt_get1(res), j0).option$array$ } 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1637
;  :arith-add-rows          451
;  :arith-assert-diseq      35
;  :arith-assert-lower      201
;  :arith-assert-upper      124
;  :arith-bound-prop        72
;  :arith-conflicts         32
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        98
;  :arith-pivots            188
;  :conflicts               79
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 214
;  :datatype-occurs-check   139
;  :datatype-splits         106
;  :decisions               254
;  :del-clause              763
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2174
;  :mk-clause               770
;  :num-allocs              218660
;  :num-checks              120
;  :propagations            297
;  :quant-instantiations    571
;  :rlimit-count            295760)
; [then-branch: 84 | exc@73@03 == Null | live]
; [else-branch: 84 | exc@73@03 != Null | dead]
(push) ; 5
; [then-branch: 84 | exc@73@03 == Null]
; [eval] (forall i0: Int, j0: Int :: { aloc(opt_get1(res), i0).option$array$,aloc(opt_get1(res), j0).option$array$ } 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0)
(declare-const i0@81@03 Int)
(declare-const j0@82@03 Int)
(push) ; 6
; [eval] 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$ ==> i0 == j0
; [eval] 0 <= i0 && i0 < dim0 && (0 <= j0 && j0 < dim0) && aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$
; [eval] 0 <= i0
(push) ; 7
; [then-branch: 85 | 0 <= i0@81@03 | live]
; [else-branch: 85 | !(0 <= i0@81@03) | live]
(push) ; 8
; [then-branch: 85 | 0 <= i0@81@03]
(assert (<= 0 i0@81@03))
; [eval] i0 < dim0
(push) ; 9
; [then-branch: 86 | i0@81@03 < V@26@03 | live]
; [else-branch: 86 | !(i0@81@03 < V@26@03) | live]
(push) ; 10
; [then-branch: 86 | i0@81@03 < V@26@03]
(assert (< i0@81@03 V@26@03))
; [eval] 0 <= j0
(push) ; 11
; [then-branch: 87 | 0 <= j0@82@03 | live]
; [else-branch: 87 | !(0 <= j0@82@03) | live]
(push) ; 12
; [then-branch: 87 | 0 <= j0@82@03]
(assert (<= 0 j0@82@03))
; [eval] j0 < dim0
(push) ; 13
; [then-branch: 88 | j0@82@03 < V@26@03 | live]
; [else-branch: 88 | !(j0@82@03 < V@26@03) | live]
(push) ; 14
; [then-branch: 88 | j0@82@03 < V@26@03]
(assert (< j0@82@03 V@26@03))
; [eval] aloc(opt_get1(res), i0).option$array$ == aloc(opt_get1(res), j0).option$array$
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 16
(assert (not (not (= res@74@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1637
;  :arith-add-rows          453
;  :arith-assert-diseq      35
;  :arith-assert-lower      205
;  :arith-assert-upper      124
;  :arith-bound-prop        72
;  :arith-conflicts         32
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        98
;  :arith-pivots            189
;  :conflicts               79
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 214
;  :datatype-occurs-check   139
;  :datatype-splits         106
;  :decisions               254
;  :del-clause              763
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2178
;  :mk-clause               770
;  :num-allocs              218936
;  :num-checks              121
;  :propagations            297
;  :quant-instantiations    571
;  :rlimit-count            296088)
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1637
;  :arith-add-rows          453
;  :arith-assert-diseq      35
;  :arith-assert-lower      205
;  :arith-assert-upper      124
;  :arith-bound-prop        72
;  :arith-conflicts         32
;  :arith-eq-adapter        88
;  :arith-fixed-eqs         47
;  :arith-offset-eqs        98
;  :arith-pivots            189
;  :conflicts               79
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 214
;  :datatype-occurs-check   139
;  :datatype-splits         106
;  :decisions               254
;  :del-clause              763
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.14
;  :memory                  5.12
;  :mk-bool-var             2178
;  :mk-clause               770
;  :num-allocs              218956
;  :num-checks              122
;  :propagations            297
;  :quant-instantiations    571
;  :rlimit-count            296119)
(assert (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 15
; Joined path conditions
(assert (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1693
;  :arith-add-rows          466
;  :arith-assert-diseq      37
;  :arith-assert-lower      217
;  :arith-assert-upper      137
;  :arith-bound-prop        78
;  :arith-conflicts         35
;  :arith-eq-adapter        99
;  :arith-fixed-eqs         52
;  :arith-offset-eqs        101
;  :arith-pivots            197
;  :conflicts               88
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   139
;  :datatype-splits         106
;  :decisions               262
;  :del-clause              790
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.13
;  :mk-bool-var             2267
;  :mk-clause               822
;  :num-allocs              219505
;  :num-checks              123
;  :propagations            329
;  :quant-instantiations    600
;  :rlimit-count            297836)
; [eval] aloc(opt_get1(res), j0)
; [eval] opt_get1(res)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1693
;  :arith-add-rows          466
;  :arith-assert-diseq      37
;  :arith-assert-lower      217
;  :arith-assert-upper      137
;  :arith-bound-prop        78
;  :arith-conflicts         35
;  :arith-eq-adapter        99
;  :arith-fixed-eqs         52
;  :arith-offset-eqs        101
;  :arith-pivots            197
;  :conflicts               88
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 218
;  :datatype-occurs-check   139
;  :datatype-splits         106
;  :decisions               262
;  :del-clause              790
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.13
;  :mk-bool-var             2267
;  :mk-clause               822
;  :num-allocs              219531
;  :num-checks              124
;  :propagations            329
;  :quant-instantiations    600
;  :rlimit-count            297866)
(assert (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 15
; Joined path conditions
(assert (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1752
;  :arith-add-rows          480
;  :arith-assert-diseq      39
;  :arith-assert-lower      231
;  :arith-assert-upper      154
;  :arith-bound-prop        88
;  :arith-conflicts         39
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        104
;  :arith-pivots            204
;  :conflicts               101
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 222
;  :datatype-occurs-check   139
;  :datatype-splits         106
;  :decisions               274
;  :del-clause              836
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.14
;  :mk-bool-var             2367
;  :mk-clause               886
;  :num-allocs              220096
;  :num-checks              125
;  :propagations            364
;  :quant-instantiations    629
;  :rlimit-count            299717)
(pop) ; 14
(push) ; 14
; [else-branch: 88 | !(j0@82@03 < V@26@03)]
(assert (not (< j0@82@03 V@26@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (< j0@82@03 V@26@03)
  (and
    (< j0@82@03 V@26@03)
    (not (= res@74@03 (as None<option<array>>  option<array>)))
    (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
    (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 87 | !(0 <= j0@82@03)]
(assert (not (<= 0 j0@82@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (<= 0 j0@82@03)
  (and
    (<= 0 j0@82@03)
    (implies
      (< j0@82@03 V@26@03)
      (and
        (< j0@82@03 V@26@03)
        (not (= res@74@03 (as None<option<array>>  option<array>)))
        (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
        (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 86 | !(i0@81@03 < V@26@03)]
(assert (not (< i0@81@03 V@26@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (< i0@81@03 V@26@03)
  (and
    (< i0@81@03 V@26@03)
    (implies
      (<= 0 j0@82@03)
      (and
        (<= 0 j0@82@03)
        (implies
          (< j0@82@03 V@26@03)
          (and
            (< j0@82@03 V@26@03)
            (not (= res@74@03 (as None<option<array>>  option<array>)))
            (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
            (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))))))))
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 85 | !(0 <= i0@81@03)]
(assert (not (<= 0 i0@81@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (<= 0 i0@81@03)
  (and
    (<= 0 i0@81@03)
    (implies
      (< i0@81@03 V@26@03)
      (and
        (< i0@81@03 V@26@03)
        (implies
          (<= 0 j0@82@03)
          (and
            (<= 0 j0@82@03)
            (implies
              (< j0@82@03 V@26@03)
              (and
                (< j0@82@03 V@26@03)
                (not (= res@74@03 (as None<option<array>>  option<array>)))
                (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
                (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))))))))))
; Joined path conditions
(push) ; 7
; [then-branch: 89 | Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i0@81@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), j0@82@03)) && j0@82@03 < V@26@03 && 0 <= j0@82@03 && i0@81@03 < V@26@03 && 0 <= i0@81@03 | live]
; [else-branch: 89 | !(Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i0@81@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), j0@82@03)) && j0@82@03 < V@26@03 && 0 <= j0@82@03 && i0@81@03 < V@26@03 && 0 <= i0@81@03) | live]
(push) ; 8
; [then-branch: 89 | Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i0@81@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), j0@82@03)) && j0@82@03 < V@26@03 && 0 <= j0@82@03 && i0@81@03 < V@26@03 && 0 <= i0@81@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
        (< j0@82@03 V@26@03))
      (<= 0 j0@82@03))
    (< i0@81@03 V@26@03))
  (<= 0 i0@81@03)))
; [eval] i0 == j0
(pop) ; 8
(push) ; 8
; [else-branch: 89 | !(Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i0@81@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), j0@82@03)) && j0@82@03 < V@26@03 && 0 <= j0@82@03 && i0@81@03 < V@26@03 && 0 <= i0@81@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
          (< j0@82@03 V@26@03))
        (<= 0 j0@82@03))
      (< i0@81@03 V@26@03))
    (<= 0 i0@81@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
          (< j0@82@03 V@26@03))
        (<= 0 j0@82@03))
      (< i0@81@03 V@26@03))
    (<= 0 i0@81@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
      ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
    (< j0@82@03 V@26@03)
    (<= 0 j0@82@03)
    (< i0@81@03 V@26@03)
    (<= 0 i0@81@03))))
; Joined path conditions
; Definitional axioms for snapshot map values
; Definitional axioms for snapshot map values
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@81@03 Int) (j0@82@03 Int)) (!
  (and
    (implies
      (<= 0 i0@81@03)
      (and
        (<= 0 i0@81@03)
        (implies
          (< i0@81@03 V@26@03)
          (and
            (< i0@81@03 V@26@03)
            (implies
              (<= 0 j0@82@03)
              (and
                (<= 0 j0@82@03)
                (implies
                  (< j0@82@03 V@26@03)
                  (and
                    (< j0@82@03 V@26@03)
                    (not (= res@74@03 (as None<option<array>>  option<array>)))
                    (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
                    (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
              (< j0@82@03 V@26@03))
            (<= 0 j0@82@03))
          (< i0@81@03 V@26@03))
        (<= 0 i0@81@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
        (< j0@82@03 V@26@03)
        (<= 0 j0@82@03)
        (< i0@81@03 V@26@03)
        (<= 0 i0@81@03))))
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@73@03 $Ref.null)
  (forall ((i0@81@03 Int) (j0@82@03 Int)) (!
    (and
      (implies
        (<= 0 i0@81@03)
        (and
          (<= 0 i0@81@03)
          (implies
            (< i0@81@03 V@26@03)
            (and
              (< i0@81@03 V@26@03)
              (implies
                (<= 0 j0@82@03)
                (and
                  (<= 0 j0@82@03)
                  (implies
                    (< j0@82@03 V@26@03)
                    (and
                      (< j0@82@03 V@26@03)
                      (not (= res@74@03 (as None<option<array>>  option<array>)))
                      (< i0@81@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
                      (< j0@82@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
                  ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
                (< j0@82@03 V@26@03))
              (<= 0 j0@82@03))
            (< i0@81@03 V@26@03))
          (<= 0 i0@81@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
          (< j0@82@03 V@26@03)
          (<= 0 j0@82@03)
          (< i0@81@03 V@26@03)
          (<= 0 i0@81@03))))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@73@03 $Ref.null)
  (forall ((i0@81@03 Int) (j0@82@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03))
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
              (< j0@82@03 V@26@03))
            (<= 0 j0@82@03))
          (< i0@81@03 V@26@03))
        (<= 0 i0@81@03))
      (= i0@81@03 j0@82@03))
    :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@81@03)) ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) j0@82@03)))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03)))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1780
;  :arith-add-rows          488
;  :arith-assert-diseq      39
;  :arith-assert-lower      231
;  :arith-assert-upper      154
;  :arith-bound-prop        88
;  :arith-conflicts         39
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        104
;  :arith-pivots            213
;  :conflicts               101
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   142
;  :datatype-splits         109
;  :decisions               281
;  :del-clause              903
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.16
;  :memory                  5.15
;  :mk-bool-var             2386
;  :mk-clause               910
;  :num-allocs              221427
;  :num-checks              126
;  :propagations            364
;  :quant-instantiations    629
;  :rlimit-count            302609)
; [then-branch: 90 | exc@73@03 == Null | live]
; [else-branch: 90 | exc@73@03 != Null | dead]
(push) ; 4
; [then-branch: 90 | exc@73@03 == Null]
(declare-const i0@83@03 Int)
(declare-const i1@84@03 Int)
(push) ; 5
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1)
; [eval] 0 <= i0
(push) ; 6
; [then-branch: 91 | 0 <= i0@83@03 | live]
; [else-branch: 91 | !(0 <= i0@83@03) | live]
(push) ; 7
; [then-branch: 91 | 0 <= i0@83@03]
(assert (<= 0 i0@83@03))
; [eval] i0 < dim0
(push) ; 8
; [then-branch: 92 | i0@83@03 < V@26@03 | live]
; [else-branch: 92 | !(i0@83@03 < V@26@03) | live]
(push) ; 9
; [then-branch: 92 | i0@83@03 < V@26@03]
(assert (< i0@83@03 V@26@03))
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 93 | 0 <= i1@84@03 | live]
; [else-branch: 93 | !(0 <= i1@84@03) | live]
(push) ; 11
; [then-branch: 93 | 0 <= i1@84@03]
(assert (<= 0 i1@84@03))
; [eval] i1 < dim1
(pop) ; 11
(push) ; 11
; [else-branch: 93 | !(0 <= i1@84@03)]
(assert (not (<= 0 i1@84@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 92 | !(i0@83@03 < V@26@03)]
(assert (not (< i0@83@03 V@26@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 91 | !(0 <= i0@83@03)]
(assert (not (<= 0 i0@83@03)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< i1@84@03 V@26@03) (<= 0 i1@84@03)) (< i0@83@03 V@26@03))
  (<= 0 i0@83@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 7
(assert (not (not (= res@74@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1780
;  :arith-add-rows          491
;  :arith-assert-diseq      39
;  :arith-assert-lower      237
;  :arith-assert-upper      154
;  :arith-bound-prop        88
;  :arith-conflicts         39
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        104
;  :arith-pivots            216
;  :conflicts               101
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   142
;  :datatype-splits         109
;  :decisions               281
;  :del-clause              903
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.16
;  :memory                  5.15
;  :mk-bool-var             2392
;  :mk-clause               910
;  :num-allocs              221696
;  :num-checks              127
;  :propagations            364
;  :quant-instantiations    629
;  :rlimit-count            303085)
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< i0@83@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1780
;  :arith-add-rows          491
;  :arith-assert-diseq      39
;  :arith-assert-lower      237
;  :arith-assert-upper      154
;  :arith-bound-prop        88
;  :arith-conflicts         39
;  :arith-eq-adapter        110
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        104
;  :arith-pivots            216
;  :conflicts               101
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 229
;  :datatype-occurs-check   142
;  :datatype-splits         109
;  :decisions               281
;  :del-clause              903
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.16
;  :memory                  5.15
;  :mk-bool-var             2392
;  :mk-clause               910
;  :num-allocs              221716
;  :num-checks              128
;  :propagations            364
;  :quant-instantiations    629
;  :rlimit-count            303116)
(assert (< i0@83@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 6
; Joined path conditions
(assert (< i0@83@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1828
;  :arith-add-rows          507
;  :arith-assert-diseq      41
;  :arith-assert-lower      249
;  :arith-assert-upper      166
;  :arith-bound-prop        92
;  :arith-conflicts         42
;  :arith-eq-adapter        121
;  :arith-fixed-eqs         63
;  :arith-offset-eqs        106
;  :arith-pivots            223
;  :conflicts               109
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   142
;  :datatype-splits         109
;  :decisions               288
;  :del-clause              926
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.17
;  :memory                  5.15
;  :mk-bool-var             2483
;  :mk-clause               958
;  :num-allocs              222261
;  :num-checks              129
;  :propagations            390
;  :quant-instantiations    658
;  :rlimit-count            304932)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1828
;  :arith-add-rows          507
;  :arith-assert-diseq      41
;  :arith-assert-lower      249
;  :arith-assert-upper      166
;  :arith-bound-prop        92
;  :arith-conflicts         42
;  :arith-eq-adapter        121
;  :arith-fixed-eqs         63
;  :arith-offset-eqs        106
;  :arith-pivots            223
;  :conflicts               110
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   142
;  :datatype-splits         109
;  :decisions               288
;  :del-clause              926
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.17
;  :memory                  5.15
;  :mk-bool-var             2483
;  :mk-clause               958
;  :num-allocs              222350
;  :num-checks              130
;  :propagations            390
;  :quant-instantiations    658
;  :rlimit-count            305027)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  i1@84@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1828
;  :arith-add-rows          510
;  :arith-assert-diseq      41
;  :arith-assert-lower      250
;  :arith-assert-upper      166
;  :arith-bound-prop        92
;  :arith-conflicts         43
;  :arith-eq-adapter        121
;  :arith-fixed-eqs         63
;  :arith-offset-eqs        106
;  :arith-pivots            225
;  :conflicts               111
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   142
;  :datatype-splits         109
;  :decisions               288
;  :del-clause              926
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.17
;  :memory                  5.15
;  :mk-bool-var             2484
;  :mk-clause               958
;  :num-allocs              222501
;  :num-checks              131
;  :propagations            390
;  :quant-instantiations    658
;  :rlimit-count            305329)
(assert (<
  i1@84@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))))))
(pop) ; 6
; Joined path conditions
(assert (<
  i1@84@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))))))
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 6
; Joined path conditions
(pop) ; 5
(declare-fun inv@85@03 ($Ref) Int)
(declare-fun inv@86@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@83@03 Int) (i1@84@03 Int)) (!
  (and
    (not (= res@74@03 (as None<option<array>>  option<array>)))
    (< i0@83@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))
        (as None<option<array>>  option<array>)))
    (<
      i1@84@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))))))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03)))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i01@83@03 Int) (i11@84@03 Int) (i02@83@03 Int) (i12@84@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< i11@84@03 V@26@03) (<= 0 i11@84@03)) (< i01@83@03 V@26@03))
        (<= 0 i01@83@03))
      (and
        (and (and (< i12@84@03 V@26@03) (<= 0 i12@84@03)) (< i02@83@03 V@26@03))
        (<= 0 i02@83@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i01@83@03))) i11@84@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i02@83@03))) i12@84@03)))
    (and (= i01@83@03 i02@83@03) (= i11@84@03 i12@84@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2011
;  :arith-add-rows          628
;  :arith-assert-diseq      45
;  :arith-assert-lower      276
;  :arith-assert-upper      183
;  :arith-bound-prop        108
;  :arith-conflicts         45
;  :arith-eq-adapter        140
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        115
;  :arith-pivots            263
;  :conflicts               127
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 237
;  :datatype-occurs-check   142
;  :datatype-splits         109
;  :decisions               303
;  :del-clause              1209
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.22
;  :memory                  5.20
;  :mk-bool-var             2881
;  :mk-clause               1216
;  :num-allocs              224171
;  :num-checks              132
;  :propagations            524
;  :quant-instantiations    770
;  :rlimit-count            312693
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i0@83@03 Int) (i1@84@03 Int)) (!
  (implies
    (and
      (and (and (< i1@84@03 V@26@03) (<= 0 i1@84@03)) (< i0@83@03 V@26@03))
      (<= 0 i0@83@03))
    (and
      (=
        (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03))
        i0@83@03)
      (=
        (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03))
        i1@84@03)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
        (< (inv@85@03 r) V@26@03))
      (<= 0 (inv@85@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@85@03 r)))) (inv@86@03 r))
      r))
  :pattern ((inv@85@03 r))
  :pattern ((inv@86@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@83@03 Int) (i1@84@03 Int)) (!
  (implies
    (and
      (and (and (< i1@84@03 V@26@03) (<= 0 i1@84@03)) (< i0@83@03 V@26@03))
      (<= 0 i0@83@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03)
        $Ref.null)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@83@03))) i1@84@03)))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@87@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
        (< (inv@85@03 r) V@26@03))
      (<= 0 (inv@85@03 r)))
    (=
      ($FVF.lookup_int (as sm@87@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@87@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
        (< (inv@40@03 r) V@26@03))
      (<= 0 (inv@40@03 r)))
    (=
      ($FVF.lookup_int (as sm@87@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@87@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@87@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
        (< (inv@85@03 r) V@26@03))
      (<= 0 (inv@85@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) r) r))
  :pattern ((inv@85@03 r) (inv@86@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int, i1: Int :: { aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int } 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0)
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2034
;  :arith-add-rows          628
;  :arith-assert-diseq      45
;  :arith-assert-lower      276
;  :arith-assert-upper      183
;  :arith-bound-prop        108
;  :arith-conflicts         45
;  :arith-eq-adapter        140
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        115
;  :arith-pivots            263
;  :conflicts               127
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 243
;  :datatype-occurs-check   145
;  :datatype-splits         111
;  :decisions               309
;  :del-clause              1209
;  :final-checks            89
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.24
;  :memory                  5.23
;  :mk-bool-var             2891
;  :mk-clause               1216
;  :num-allocs              225998
;  :num-checks              133
;  :propagations            524
;  :quant-instantiations    770
;  :rlimit-count            317444
;  :time                    0.00)
; [then-branch: 94 | exc@73@03 == Null | live]
; [else-branch: 94 | exc@73@03 != Null | dead]
(push) ; 6
; [then-branch: 94 | exc@73@03 == Null]
; [eval] (forall i0: Int, i1: Int :: { aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int } 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0)
(declare-const i0@88@03 Int)
(declare-const i1@89@03 Int)
(push) ; 7
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1) ==> aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0
; [eval] 0 <= i0 && i0 < dim0 && (0 <= i1 && i1 < dim1)
; [eval] 0 <= i0
(push) ; 8
; [then-branch: 95 | 0 <= i0@88@03 | live]
; [else-branch: 95 | !(0 <= i0@88@03) | live]
(push) ; 9
; [then-branch: 95 | 0 <= i0@88@03]
(assert (<= 0 i0@88@03))
; [eval] i0 < dim0
(push) ; 10
; [then-branch: 96 | i0@88@03 < V@26@03 | live]
; [else-branch: 96 | !(i0@88@03 < V@26@03) | live]
(push) ; 11
; [then-branch: 96 | i0@88@03 < V@26@03]
(assert (< i0@88@03 V@26@03))
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 97 | 0 <= i1@89@03 | live]
; [else-branch: 97 | !(0 <= i1@89@03) | live]
(push) ; 13
; [then-branch: 97 | 0 <= i1@89@03]
(assert (<= 0 i1@89@03))
; [eval] i1 < dim1
(pop) ; 13
(push) ; 13
; [else-branch: 97 | !(0 <= i1@89@03)]
(assert (not (<= 0 i1@89@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 96 | !(i0@88@03 < V@26@03)]
(assert (not (< i0@88@03 V@26@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 95 | !(0 <= i0@88@03)]
(assert (not (<= 0 i0@88@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 98 | i1@89@03 < V@26@03 && 0 <= i1@89@03 && i0@88@03 < V@26@03 && 0 <= i0@88@03 | live]
; [else-branch: 98 | !(i1@89@03 < V@26@03 && 0 <= i1@89@03 && i0@88@03 < V@26@03 && 0 <= i0@88@03) | live]
(push) ; 9
; [then-branch: 98 | i1@89@03 < V@26@03 && 0 <= i1@89@03 && i0@88@03 < V@26@03 && 0 <= i0@88@03]
(assert (and
  (and (and (< i1@89@03 V@26@03) (<= 0 i1@89@03)) (< i0@88@03 V@26@03))
  (<= 0 i0@88@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1).int == 0
; [eval] aloc(opt_get1(aloc(opt_get1(res), i0).option$array$), i1)
; [eval] opt_get1(aloc(opt_get1(res), i0).option$array$)
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 11
(assert (not (not (= res@74@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2034
;  :arith-add-rows          631
;  :arith-assert-diseq      45
;  :arith-assert-lower      282
;  :arith-assert-upper      183
;  :arith-bound-prop        108
;  :arith-conflicts         45
;  :arith-eq-adapter        140
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        115
;  :arith-pivots            267
;  :conflicts               127
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 243
;  :datatype-occurs-check   145
;  :datatype-splits         111
;  :decisions               309
;  :del-clause              1209
;  :final-checks            89
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.24
;  :memory                  5.23
;  :mk-bool-var             2897
;  :mk-clause               1216
;  :num-allocs              226267
;  :num-checks              134
;  :propagations            524
;  :quant-instantiations    770
;  :rlimit-count            317935)
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (< i0@88@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2034
;  :arith-add-rows          631
;  :arith-assert-diseq      45
;  :arith-assert-lower      282
;  :arith-assert-upper      183
;  :arith-bound-prop        108
;  :arith-conflicts         45
;  :arith-eq-adapter        140
;  :arith-fixed-eqs         71
;  :arith-offset-eqs        115
;  :arith-pivots            267
;  :conflicts               127
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 243
;  :datatype-occurs-check   145
;  :datatype-splits         111
;  :decisions               309
;  :del-clause              1209
;  :final-checks            89
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.24
;  :memory                  5.23
;  :mk-bool-var             2897
;  :mk-clause               1216
;  :num-allocs              226287
;  :num-checks              135
;  :propagations            524
;  :quant-instantiations    770
;  :rlimit-count            317966)
(assert (< i0@88@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 10
; Joined path conditions
(assert (< i0@88@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2083
;  :arith-add-rows          649
;  :arith-assert-diseq      47
;  :arith-assert-lower      295
;  :arith-assert-upper      195
;  :arith-bound-prop        113
;  :arith-conflicts         47
;  :arith-eq-adapter        152
;  :arith-fixed-eqs         74
;  :arith-offset-eqs        120
;  :arith-pivots            274
;  :conflicts               137
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 247
;  :datatype-occurs-check   145
;  :datatype-splits         111
;  :decisions               324
;  :del-clause              1275
;  :final-checks            89
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.25
;  :memory                  5.24
;  :mk-bool-var             3034
;  :mk-clause               1307
;  :num-allocs              226922
;  :num-checks              136
;  :propagations            567
;  :quant-instantiations    801
;  :rlimit-count            320027)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2083
;  :arith-add-rows          649
;  :arith-assert-diseq      47
;  :arith-assert-lower      295
;  :arith-assert-upper      195
;  :arith-bound-prop        113
;  :arith-conflicts         47
;  :arith-eq-adapter        152
;  :arith-fixed-eqs         74
;  :arith-offset-eqs        120
;  :arith-pivots            274
;  :conflicts               138
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 247
;  :datatype-occurs-check   145
;  :datatype-splits         111
;  :decisions               324
;  :del-clause              1275
;  :final-checks            89
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.25
;  :memory                  5.24
;  :mk-bool-var             3034
;  :mk-clause               1307
;  :num-allocs              227012
;  :num-checks              137
;  :propagations            567
;  :quant-instantiations    801
;  :rlimit-count            320122)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  i1@89@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2083
;  :arith-add-rows          651
;  :arith-assert-diseq      47
;  :arith-assert-lower      296
;  :arith-assert-upper      195
;  :arith-bound-prop        113
;  :arith-conflicts         48
;  :arith-eq-adapter        152
;  :arith-fixed-eqs         74
;  :arith-offset-eqs        120
;  :arith-pivots            274
;  :conflicts               139
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 247
;  :datatype-occurs-check   145
;  :datatype-splits         111
;  :decisions               324
;  :del-clause              1275
;  :final-checks            89
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.25
;  :memory                  5.24
;  :mk-bool-var             3035
;  :mk-clause               1307
;  :num-allocs              227162
;  :num-checks              138
;  :propagations            567
;  :quant-instantiations    801
;  :rlimit-count            320377)
(assert (<
  i1@89@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))))))
(pop) ; 10
; Joined path conditions
(assert (<
  i1@89@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))
              V@26@03)
            (<=
              0
              (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))))
          (<
            (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))
            V@26@03))
        (<=
          0
          (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))
              V@26@03)
            (<=
              0
              (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))))
          (<
            (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))
            V@26@03))
        (<=
          0
          (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2147
;  :arith-add-rows          678
;  :arith-assert-diseq      49
;  :arith-assert-lower      317
;  :arith-assert-upper      221
;  :arith-bound-prop        118
;  :arith-conflicts         52
;  :arith-eq-adapter        165
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        122
;  :arith-pivots            283
;  :conflicts               158
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 251
;  :datatype-occurs-check   145
;  :datatype-splits         111
;  :decisions               349
;  :del-clause              1366
;  :final-checks            89
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.40
;  :memory                  5.37
;  :mk-bool-var             3199
;  :mk-clause               1430
;  :num-allocs              227975
;  :num-checks              139
;  :propagations            629
;  :quant-instantiations    831
;  :rlimit-count            323599
;  :time                    0.00)
(pop) ; 9
(push) ; 9
; [else-branch: 98 | !(i1@89@03 < V@26@03 && 0 <= i1@89@03 && i0@88@03 < V@26@03 && 0 <= i0@88@03)]
(assert (not
  (and
    (and (and (< i1@89@03 V@26@03) (<= 0 i1@89@03)) (< i0@88@03 V@26@03))
    (<= 0 i0@88@03))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and (and (< i1@89@03 V@26@03) (<= 0 i1@89@03)) (< i0@88@03 V@26@03))
    (<= 0 i0@88@03))
  (and
    (< i1@89@03 V@26@03)
    (<= 0 i1@89@03)
    (< i0@88@03 V@26@03)
    (<= 0 i0@88@03)
    (not (= res@74@03 (as None<option<array>>  option<array>)))
    (< i0@88@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
        (as None<option<array>>  option<array>)))
    (<
      i1@89@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@88@03 Int) (i1@89@03 Int)) (!
  (implies
    (and
      (and (and (< i1@89@03 V@26@03) (<= 0 i1@89@03)) (< i0@88@03 V@26@03))
      (<= 0 i0@88@03))
    (and
      (< i1@89@03 V@26@03)
      (<= 0 i1@89@03)
      (< i0@88@03 V@26@03)
      (<= 0 i0@88@03)
      (not (= res@74@03 (as None<option<array>>  option<array>)))
      (< i0@88@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
          (as None<option<array>>  option<array>)))
      (<
        i1@89@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))))
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@73@03 $Ref.null)
  (forall ((i0@88@03 Int) (i1@89@03 Int)) (!
    (implies
      (and
        (and (and (< i1@89@03 V@26@03) (<= 0 i1@89@03)) (< i0@88@03 V@26@03))
        (<= 0 i0@88@03))
      (and
        (< i1@89@03 V@26@03)
        (<= 0 i1@89@03)
        (< i0@88@03 V@26@03)
        (<= 0 i0@88@03)
        (not (= res@74@03 (as None<option<array>>  option<array>)))
        (< i0@88@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))
            (as None<option<array>>  option<array>)))
        (<
          i1@89@03
          (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03)))))
        ($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@73@03 $Ref.null)
  (forall ((i0@88@03 Int) (i1@89@03 Int)) (!
    (implies
      (and
        (and (and (< i1@89@03 V@26@03) (<= 0 i1@89@03)) (< i0@88@03 V@26@03))
        (<= 0 i0@88@03))
      (=
        ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03))
        0))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i0@88@03))) i1@89@03)))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 99 | exc@73@03 != Null | dead]
; [else-branch: 99 | exc@73@03 == Null | live]
(push) ; 5
; [else-branch: 99 | exc@73@03 == Null]
(pop) ; 5
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@73@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2191
;  :arith-add-rows          690
;  :arith-assert-diseq      49
;  :arith-assert-lower      317
;  :arith-assert-upper      221
;  :arith-bound-prop        118
;  :arith-conflicts         52
;  :arith-eq-adapter        165
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        122
;  :arith-pivots            293
;  :conflicts               158
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 263
;  :datatype-occurs-check   151
;  :datatype-splits         115
;  :decisions               361
;  :del-clause              1423
;  :final-checks            93
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.41
;  :memory                  5.39
;  :mk-bool-var             3205
;  :mk-clause               1430
;  :num-allocs              229739
;  :num-checks              141
;  :propagations            629
;  :quant-instantiations    831
;  :rlimit-count            326274)
; [then-branch: 100 | exc@73@03 == Null | live]
; [else-branch: 100 | exc@73@03 != Null | dead]
(push) ; 5
; [then-branch: 100 | exc@73@03 == Null]
; [exec]
; Gf := res1
; [exec]
; exc, res2 := copy(this, tid, G, Gf, V)
; [eval] this != null
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(declare-const i1@90@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 101 | 0 <= i1@90@03 | live]
; [else-branch: 101 | !(0 <= i1@90@03) | live]
(push) ; 8
; [then-branch: 101 | 0 <= i1@90@03]
(assert (<= 0 i1@90@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 101 | !(0 <= i1@90@03)]
(assert (not (<= 0 i1@90@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@90@03 V@26@03) (<= 0 i1@90@03)))
(declare-const $k@91@03 $Perm)
(assert ($Perm.isReadVar $k@91@03 $Perm.Write))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@90@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2191
;  :arith-add-rows          691
;  :arith-assert-diseq      50
;  :arith-assert-lower      321
;  :arith-assert-upper      222
;  :arith-bound-prop        118
;  :arith-conflicts         52
;  :arith-eq-adapter        166
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        122
;  :arith-pivots            294
;  :conflicts               158
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 263
;  :datatype-occurs-check   151
;  :datatype-splits         115
;  :decisions               361
;  :del-clause              1423
;  :final-checks            93
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.41
;  :memory                  5.39
;  :mk-bool-var             3211
;  :mk-clause               1432
;  :num-allocs              229909
;  :num-checks              142
;  :propagations            630
;  :quant-instantiations    831
;  :rlimit-count            326611)
(assert (< i1@90@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 7
; Joined path conditions
(assert (< i1@90@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 6
(declare-fun inv@92@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@91@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@90@03 Int)) (!
  (< i1@90@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@90@03))
  :qid |option$array$-aux|)))
(push) ; 6
(assert (not (forall ((i1@90@03 Int)) (!
  (implies
    (and (< i1@90@03 V@26@03) (<= 0 i1@90@03))
    (or (= $k@91@03 $Perm.No) (< $Perm.No $k@91@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2191
;  :arith-add-rows          692
;  :arith-assert-diseq      51
;  :arith-assert-lower      323
;  :arith-assert-upper      223
;  :arith-bound-prop        118
;  :arith-conflicts         52
;  :arith-eq-adapter        167
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        122
;  :arith-pivots            295
;  :conflicts               159
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 263
;  :datatype-occurs-check   151
;  :datatype-splits         115
;  :decisions               361
;  :del-clause              1425
;  :final-checks            93
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.41
;  :memory                  5.39
;  :mk-bool-var             3218
;  :mk-clause               1434
;  :num-allocs              230338
;  :num-checks              143
;  :propagations            631
;  :quant-instantiations    831
;  :rlimit-count            327162)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@90@03 Int) (i12@90@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@90@03 V@26@03) (<= 0 i11@90@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@90@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@90@03)))
        (< $Perm.No $k@91@03))
      (and
        (and
          (and (< i12@90@03 V@26@03) (<= 0 i12@90@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@90@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@90@03)))
        (< $Perm.No $k@91@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@90@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@90@03)))
    (= i11@90@03 i12@90@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2201
;  :arith-add-rows          700
;  :arith-assert-diseq      52
;  :arith-assert-lower      327
;  :arith-assert-upper      223
;  :arith-bound-prop        118
;  :arith-conflicts         52
;  :arith-eq-adapter        168
;  :arith-fixed-eqs         81
;  :arith-offset-eqs        122
;  :arith-pivots            297
;  :conflicts               160
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 263
;  :datatype-occurs-check   151
;  :datatype-splits         115
;  :decisions               361
;  :del-clause              1436
;  :final-checks            93
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.41
;  :memory                  5.39
;  :mk-bool-var             3247
;  :mk-clause               1445
;  :num-allocs              230748
;  :num-checks              144
;  :propagations            633
;  :quant-instantiations    845
;  :rlimit-count            328130)
; Definitional axioms for inverse functions
(assert (forall ((i1@90@03 Int)) (!
  (implies
    (and (and (< i1@90@03 V@26@03) (<= 0 i1@90@03)) (< $Perm.No $k@91@03))
    (=
      (inv@92@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@90@03))
      i1@90@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@90@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
      (< $Perm.No $k@91@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@92@03 r))
      r))
  :pattern ((inv@92@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) r) r))
  :pattern ((inv@92@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@93@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
        $Perm.Write
        $Perm.No)
      $k@91@03)
    $Perm.No))
(define-fun pTaken@94@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
        $k@31@03
        $Perm.No)
      (- $k@91@03 (pTaken@93@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@91@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
      (<
        (ite
          (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
          $k@91@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
          $k@91@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@77@03 r))
  :pattern ((inv@92@03 r))
  :qid |qp.srp14|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
    (= (- $k@91@03 (pTaken@93@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2311
;  :arith-add-rows          718
;  :arith-assert-diseq      58
;  :arith-assert-lower      339
;  :arith-assert-upper      237
;  :arith-bound-prop        121
;  :arith-conflicts         55
;  :arith-eq-adapter        181
;  :arith-fixed-eqs         84
;  :arith-offset-eqs        126
;  :arith-pivots            310
;  :conflicts               166
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 278
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               389
;  :del-clause              1521
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.51
;  :memory                  5.48
;  :minimized-lits          1
;  :mk-bool-var             3373
;  :mk-clause               1528
;  :num-allocs              233797
;  :num-checks              146
;  :propagations            672
;  :quant-instantiations    875
;  :rlimit-count            333332
;  :time                    0.00)
; Constrain original permissions $k@91@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
          $k@31@03
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
      (<
        (ite
          (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
          $k@91@03
          $Perm.No)
        $k@31@03)
      (<
        (ite
          (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
          $k@91@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@32@03 r))
  :pattern ((inv@92@03 r))
  :qid |qp.srp15|)))
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@92@03 r) V@26@03) (<= 0 (inv@92@03 r)))
    (= (- (- $k@91@03 (pTaken@93@03 r)) (pTaken@94@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2404
;  :arith-add-rows          797
;  :arith-assert-diseq      74
;  :arith-assert-lower      371
;  :arith-assert-upper      261
;  :arith-bound-prop        137
;  :arith-conflicts         61
;  :arith-eq-adapter        214
;  :arith-fixed-eqs         94
;  :arith-offset-eqs        134
;  :arith-pivots            335
;  :conflicts               180
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 282
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               403
;  :del-clause              1697
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.51
;  :memory                  5.48
;  :minimized-lits          9
;  :mk-bool-var             3596
;  :mk-clause               1704
;  :num-allocs              235205
;  :num-checks              147
;  :propagations            729
;  :quant-instantiations    903
;  :rlimit-count            337217
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@95@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 102 | 0 <= i1@95@03 | live]
; [else-branch: 102 | !(0 <= i1@95@03) | live]
(push) ; 8
; [then-branch: 102 | 0 <= i1@95@03]
(assert (<= 0 i1@95@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 102 | !(0 <= i1@95@03)]
(assert (not (<= 0 i1@95@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 103 | i1@95@03 < V@26@03 && 0 <= i1@95@03 | live]
; [else-branch: 103 | !(i1@95@03 < V@26@03 && 0 <= i1@95@03) | live]
(push) ; 8
; [then-branch: 103 | i1@95@03 < V@26@03 && 0 <= i1@95@03]
(assert (and (< i1@95@03 V@26@03) (<= 0 i1@95@03)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@95@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2404
;  :arith-add-rows          798
;  :arith-assert-diseq      74
;  :arith-assert-lower      373
;  :arith-assert-upper      261
;  :arith-bound-prop        137
;  :arith-conflicts         61
;  :arith-eq-adapter        214
;  :arith-fixed-eqs         94
;  :arith-offset-eqs        134
;  :arith-pivots            336
;  :conflicts               180
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 282
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               403
;  :del-clause              1697
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.51
;  :memory                  5.48
;  :minimized-lits          9
;  :mk-bool-var             3598
;  :mk-clause               1704
;  :num-allocs              235314
;  :num-checks              148
;  :propagations            729
;  :quant-instantiations    903
;  :rlimit-count            337413)
(assert (< i1@95@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@95@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2470
;  :arith-add-rows          821
;  :arith-assert-diseq      76
;  :arith-assert-lower      384
;  :arith-assert-upper      273
;  :arith-bound-prop        146
;  :arith-conflicts         63
;  :arith-eq-adapter        226
;  :arith-fixed-eqs         100
;  :arith-offset-eqs        142
;  :arith-pivots            343
;  :conflicts               188
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 286
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               410
;  :del-clause              1720
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.52
;  :memory                  5.50
;  :minimized-lits          9
;  :mk-bool-var             3704
;  :mk-clause               1778
;  :num-allocs              235972
;  :num-checks              149
;  :propagations            771
;  :quant-instantiations    929
;  :rlimit-count            339514)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 103 | !(i1@95@03 < V@26@03 && 0 <= i1@95@03)]
(assert (not (and (< i1@95@03 V@26@03) (<= 0 i1@95@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@95@03 V@26@03) (<= 0 i1@95@03))
  (and
    (< i1@95@03 V@26@03)
    (<= 0 i1@95@03)
    (< i1@95@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@95@03 Int)) (!
  (implies
    (and (< i1@95@03 V@26@03) (<= 0 i1@95@03))
    (and
      (< i1@95@03 V@26@03)
      (<= 0 i1@95@03)
      (< i1@95@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@95@03 Int)) (!
  (implies
    (and (< i1@95@03 V@26@03) (<= 0 i1@95@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2513
;  :arith-add-rows          853
;  :arith-assert-diseq      76
;  :arith-assert-lower      391
;  :arith-assert-upper      280
;  :arith-bound-prop        155
;  :arith-conflicts         64
;  :arith-eq-adapter        230
;  :arith-fixed-eqs         104
;  :arith-offset-eqs        150
;  :arith-pivots            361
;  :conflicts               195
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 290
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               416
;  :del-clause              1838
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.52
;  :memory                  5.49
;  :minimized-lits          9
;  :mk-bool-var             3789
;  :mk-clause               1845
;  :num-allocs              236723
;  :num-checks              150
;  :propagations            785
;  :quant-instantiations    957
;  :rlimit-count            342139
;  :time                    0.00)
(assert (forall ((i1@95@03 Int)) (!
  (implies
    (and (< i1@95@03 V@26@03) (<= 0 i1@95@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@95@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@96@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 104 | 0 <= i1@96@03 | live]
; [else-branch: 104 | !(0 <= i1@96@03) | live]
(push) ; 8
; [then-branch: 104 | 0 <= i1@96@03]
(assert (<= 0 i1@96@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 104 | !(0 <= i1@96@03)]
(assert (not (<= 0 i1@96@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 105 | i1@96@03 < V@26@03 && 0 <= i1@96@03 | live]
; [else-branch: 105 | !(i1@96@03 < V@26@03 && 0 <= i1@96@03) | live]
(push) ; 8
; [then-branch: 105 | i1@96@03 < V@26@03 && 0 <= i1@96@03]
(assert (and (< i1@96@03 V@26@03) (<= 0 i1@96@03)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@96@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2513
;  :arith-add-rows          854
;  :arith-assert-diseq      76
;  :arith-assert-lower      393
;  :arith-assert-upper      280
;  :arith-bound-prop        155
;  :arith-conflicts         64
;  :arith-eq-adapter        230
;  :arith-fixed-eqs         104
;  :arith-offset-eqs        150
;  :arith-pivots            362
;  :conflicts               195
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 290
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               416
;  :del-clause              1838
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.52
;  :memory                  5.49
;  :minimized-lits          9
;  :mk-bool-var             3792
;  :mk-clause               1845
;  :num-allocs              237014
;  :num-checks              151
;  :propagations            785
;  :quant-instantiations    957
;  :rlimit-count            342644)
(assert (< i1@96@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@96@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2580
;  :arith-add-rows          877
;  :arith-assert-diseq      78
;  :arith-assert-lower      404
;  :arith-assert-upper      292
;  :arith-bound-prop        164
;  :arith-conflicts         66
;  :arith-eq-adapter        242
;  :arith-fixed-eqs         110
;  :arith-offset-eqs        158
;  :arith-pivots            369
;  :conflicts               203
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 294
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               423
;  :del-clause              1861
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.52
;  :memory                  5.52
;  :minimized-lits          9
;  :mk-bool-var             3899
;  :mk-clause               1919
;  :num-allocs              237680
;  :num-checks              152
;  :propagations            827
;  :quant-instantiations    985
;  :rlimit-count            344809)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2580
;  :arith-add-rows          877
;  :arith-assert-diseq      78
;  :arith-assert-lower      404
;  :arith-assert-upper      292
;  :arith-bound-prop        164
;  :arith-conflicts         66
;  :arith-eq-adapter        242
;  :arith-fixed-eqs         110
;  :arith-offset-eqs        158
;  :arith-pivots            369
;  :conflicts               204
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 294
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               423
;  :del-clause              1861
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.52
;  :memory                  5.52
;  :minimized-lits          9
;  :mk-bool-var             3899
;  :mk-clause               1919
;  :num-allocs              237769
;  :num-checks              153
;  :propagations            827
;  :quant-instantiations    985
;  :rlimit-count            344904)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 105 | !(i1@96@03 < V@26@03 && 0 <= i1@96@03)]
(assert (not (and (< i1@96@03 V@26@03) (<= 0 i1@96@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@96@03 V@26@03) (<= 0 i1@96@03))
  (and
    (< i1@96@03 V@26@03)
    (<= 0 i1@96@03)
    (< i1@96@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@96@03 Int)) (!
  (implies
    (and (< i1@96@03 V@26@03) (<= 0 i1@96@03))
    (and
      (< i1@96@03 V@26@03)
      (<= 0 i1@96@03)
      (< i1@96@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@96@03 Int)) (!
  (implies
    (and (< i1@96@03 V@26@03) (<= 0 i1@96@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2633
;  :arith-add-rows          909
;  :arith-assert-diseq      80
;  :arith-assert-lower      412
;  :arith-assert-upper      299
;  :arith-bound-prop        173
;  :arith-conflicts         67
;  :arith-eq-adapter        247
;  :arith-fixed-eqs         114
;  :arith-offset-eqs        165
;  :arith-pivots            385
;  :conflicts               211
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 298
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               429
;  :del-clause              1986
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.54
;  :memory                  5.52
;  :minimized-lits          9
;  :mk-bool-var             3999
;  :mk-clause               1993
;  :num-allocs              238674
;  :num-checks              154
;  :propagations            848
;  :quant-instantiations    1022
;  :rlimit-count            348090
;  :time                    0.00)
(assert (forall ((i1@96@03 Int)) (!
  (implies
    (and (< i1@96@03 V@26@03) (<= 0 i1@96@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@96@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@97@03 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@98@03 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 106 | 0 <= i1@97@03 | live]
; [else-branch: 106 | !(0 <= i1@97@03) | live]
(push) ; 9
; [then-branch: 106 | 0 <= i1@97@03]
(assert (<= 0 i1@97@03))
; [eval] i1 < V
(push) ; 10
; [then-branch: 107 | i1@97@03 < V@26@03 | live]
; [else-branch: 107 | !(i1@97@03 < V@26@03) | live]
(push) ; 11
; [then-branch: 107 | i1@97@03 < V@26@03]
(assert (< i1@97@03 V@26@03))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 108 | 0 <= i2@98@03 | live]
; [else-branch: 108 | !(0 <= i2@98@03) | live]
(push) ; 13
; [then-branch: 108 | 0 <= i2@98@03]
(assert (<= 0 i2@98@03))
; [eval] i2 < V
(push) ; 14
; [then-branch: 109 | i2@98@03 < V@26@03 | live]
; [else-branch: 109 | !(i2@98@03 < V@26@03) | live]
(push) ; 15
; [then-branch: 109 | i2@98@03 < V@26@03]
(assert (< i2@98@03 V@26@03))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2633
;  :arith-add-rows          911
;  :arith-assert-diseq      80
;  :arith-assert-lower      416
;  :arith-assert-upper      299
;  :arith-bound-prop        173
;  :arith-conflicts         67
;  :arith-eq-adapter        247
;  :arith-fixed-eqs         114
;  :arith-offset-eqs        165
;  :arith-pivots            385
;  :conflicts               211
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 298
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               429
;  :del-clause              1986
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.54
;  :memory                  5.52
;  :minimized-lits          9
;  :mk-bool-var             4004
;  :mk-clause               1993
;  :num-allocs              239143
;  :num-checks              155
;  :propagations            848
;  :quant-instantiations    1022
;  :rlimit-count            348735)
(assert (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2700
;  :arith-add-rows          931
;  :arith-assert-diseq      81
;  :arith-assert-lower      427
;  :arith-assert-upper      310
;  :arith-bound-prop        184
;  :arith-conflicts         69
;  :arith-eq-adapter        257
;  :arith-fixed-eqs         119
;  :arith-offset-eqs        172
;  :arith-pivots            392
;  :conflicts               219
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 302
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               436
;  :del-clause              2013
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.54
;  :memory                  5.53
;  :minimized-lits          9
;  :mk-bool-var             4118
;  :mk-clause               2071
;  :num-allocs              239833
;  :num-checks              156
;  :propagations            895
;  :quant-instantiations    1050
;  :rlimit-count            350916)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2700
;  :arith-add-rows          931
;  :arith-assert-diseq      81
;  :arith-assert-lower      427
;  :arith-assert-upper      310
;  :arith-bound-prop        184
;  :arith-conflicts         69
;  :arith-eq-adapter        257
;  :arith-fixed-eqs         119
;  :arith-offset-eqs        172
;  :arith-pivots            392
;  :conflicts               219
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 302
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               436
;  :del-clause              2013
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.54
;  :memory                  5.53
;  :minimized-lits          9
;  :mk-bool-var             4118
;  :mk-clause               2071
;  :num-allocs              239859
;  :num-checks              157
;  :propagations            895
;  :quant-instantiations    1050
;  :rlimit-count            350946)
(assert (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 16
; Joined path conditions
(assert (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2812
;  :arith-add-rows          966
;  :arith-assert-diseq      90
;  :arith-assert-lower      456
;  :arith-assert-upper      330
;  :arith-bound-prop        207
;  :arith-conflicts         72
;  :arith-eq-adapter        273
;  :arith-fixed-eqs         128
;  :arith-offset-eqs        187
;  :arith-pivots            405
;  :conflicts               233
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 306
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               456
;  :del-clause              2099
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.60
;  :memory                  5.59
;  :minimized-lits          10
;  :mk-bool-var             4301
;  :mk-clause               2220
;  :num-allocs              240920
;  :num-checks              158
;  :propagations            978
;  :quant-instantiations    1083
;  :rlimit-count            354050
;  :time                    0.00)
(pop) ; 15
(push) ; 15
; [else-branch: 109 | !(i2@98@03 < V@26@03)]
(assert (not (< i2@98@03 V@26@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@98@03 V@26@03)
  (and
    (< i2@98@03 V@26@03)
    (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
    (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 108 | !(0 <= i2@98@03)]
(assert (not (<= 0 i2@98@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@98@03)
  (and
    (<= 0 i2@98@03)
    (implies
      (< i2@98@03 V@26@03)
      (and
        (< i2@98@03 V@26@03)
        (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
        (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 107 | !(i1@97@03 < V@26@03)]
(assert (not (< i1@97@03 V@26@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@97@03 V@26@03)
  (and
    (< i1@97@03 V@26@03)
    (implies
      (<= 0 i2@98@03)
      (and
        (<= 0 i2@98@03)
        (implies
          (< i2@98@03 V@26@03)
          (and
            (< i2@98@03 V@26@03)
            (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
            (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 106 | !(0 <= i1@97@03)]
(assert (not (<= 0 i1@97@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@97@03)
  (and
    (<= 0 i1@97@03)
    (implies
      (< i1@97@03 V@26@03)
      (and
        (< i1@97@03 V@26@03)
        (implies
          (<= 0 i2@98@03)
          (and
            (<= 0 i2@98@03)
            (implies
              (< i2@98@03 V@26@03)
              (and
                (< i2@98@03 V@26@03)
                (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
                (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 110 | Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, G@23@03), i1@97@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, G@23@03), i2@98@03)) && i2@98@03 < V@26@03 && 0 <= i2@98@03 && i1@97@03 < V@26@03 && 0 <= i1@97@03 | live]
; [else-branch: 110 | !(Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, G@23@03), i1@97@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, G@23@03), i2@98@03)) && i2@98@03 < V@26@03 && 0 <= i2@98@03 && i1@97@03 < V@26@03 && 0 <= i1@97@03) | live]
(push) ; 9
; [then-branch: 110 | Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, G@23@03), i1@97@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, G@23@03), i2@98@03)) && i2@98@03 < V@26@03 && 0 <= i2@98@03 && i1@97@03 < V@26@03 && 0 <= i1@97@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
        (< i2@98@03 V@26@03))
      (<= 0 i2@98@03))
    (< i1@97@03 V@26@03))
  (<= 0 i1@97@03)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 110 | !(Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, G@23@03), i1@97@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, G@23@03), i2@98@03)) && i2@98@03 < V@26@03 && 0 <= i2@98@03 && i1@97@03 < V@26@03 && 0 <= i1@97@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
          (< i2@98@03 V@26@03))
        (<= 0 i2@98@03))
      (< i1@97@03 V@26@03))
    (<= 0 i1@97@03))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
          (< i2@98@03 V@26@03))
        (<= 0 i2@98@03))
      (< i1@97@03 V@26@03))
    (<= 0 i1@97@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
      ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
    (< i2@98@03 V@26@03)
    (<= 0 i2@98@03)
    (< i1@97@03 V@26@03)
    (<= 0 i1@97@03))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@98@03 Int)) (!
  (and
    (implies
      (<= 0 i1@97@03)
      (and
        (<= 0 i1@97@03)
        (implies
          (< i1@97@03 V@26@03)
          (and
            (< i1@97@03 V@26@03)
            (implies
              (<= 0 i2@98@03)
              (and
                (<= 0 i2@98@03)
                (implies
                  (< i2@98@03 V@26@03)
                  (and
                    (< i2@98@03 V@26@03)
                    (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
                    (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
              (< i2@98@03 V@26@03))
            (<= 0 i2@98@03))
          (< i1@97@03 V@26@03))
        (<= 0 i1@97@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
        (< i2@98@03 V@26@03)
        (<= 0 i2@98@03)
        (< i1@97@03 V@26@03)
        (<= 0 i1@97@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@97@03 Int)) (!
  (forall ((i2@98@03 Int)) (!
    (and
      (implies
        (<= 0 i1@97@03)
        (and
          (<= 0 i1@97@03)
          (implies
            (< i1@97@03 V@26@03)
            (and
              (< i1@97@03 V@26@03)
              (implies
                (<= 0 i2@98@03)
                (and
                  (<= 0 i2@98@03)
                  (implies
                    (< i2@98@03 V@26@03)
                    (and
                      (< i2@98@03 V@26@03)
                      (< i1@97@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
                      (< i2@98@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
                  ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
                (< i2@98@03 V@26@03))
              (<= 0 i2@98@03))
            (< i1@97@03 V@26@03))
          (<= 0 i1@97@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
          (< i2@98@03 V@26@03)
          (<= 0 i2@98@03)
          (< i1@97@03 V@26@03)
          (<= 0 i1@97@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@97@03 Int)) (!
  (forall ((i2@98@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
              (< i2@98@03 V@26@03))
            (<= 0 i2@98@03))
          (< i1@97@03 V@26@03))
        (<= 0 i1@97@03))
      (= i1@97@03 i2@98@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2885
;  :arith-add-rows          1033
;  :arith-assert-diseq      91
;  :arith-assert-lower      471
;  :arith-assert-upper      341
;  :arith-bound-prop        222
;  :arith-conflicts         74
;  :arith-eq-adapter        282
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        195
;  :arith-pivots            436
;  :conflicts               243
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               465
;  :del-clause              2364
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          10
;  :mk-bool-var             4514
;  :mk-clause               2371
;  :num-allocs              242602
;  :num-checks              159
;  :propagations            1007
;  :quant-instantiations    1144
;  :rlimit-count            360639
;  :time                    0.00)
(assert (forall ((i1@97@03 Int)) (!
  (forall ((i2@98@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03)))
              (< i2@98@03 V@26@03))
            (<= 0 i2@98@03))
          (< i1@97@03 V@26@03))
        (<= 0 i1@97@03))
      (= i1@97@03 i2@98@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@98@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@97@03))
  :qid |prog.l<no position>|)))
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not (= res@74@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2885
;  :arith-add-rows          1033
;  :arith-assert-diseq      91
;  :arith-assert-lower      471
;  :arith-assert-upper      341
;  :arith-bound-prop        222
;  :arith-conflicts         74
;  :arith-eq-adapter        282
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        195
;  :arith-pivots            436
;  :conflicts               243
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               465
;  :del-clause              2364
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          10
;  :mk-bool-var             4515
;  :mk-clause               2371
;  :num-allocs              242946
;  :num-checks              160
;  :propagations            1007
;  :quant-instantiations    1144
;  :rlimit-count            361179)
(assert (not (= res@74@03 (as None<option<array>>  option<array>))))
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
(assert (not (= (alen<Int> (opt_get1 $Snap.unit res@74@03)) V@26@03)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2885
;  :arith-add-rows          1033
;  :arith-assert-diseq      91
;  :arith-assert-lower      471
;  :arith-assert-upper      341
;  :arith-bound-prop        222
;  :arith-conflicts         74
;  :arith-eq-adapter        282
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        195
;  :arith-pivots            436
;  :conflicts               243
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               465
;  :del-clause              2364
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          10
;  :mk-bool-var             4515
;  :mk-clause               2371
;  :num-allocs              242962
;  :num-checks              161
;  :propagations            1007
;  :quant-instantiations    1144
;  :rlimit-count            361198)
(assert (= (alen<Int> (opt_get1 $Snap.unit res@74@03)) V@26@03))
(declare-const i1@99@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 111 | 0 <= i1@99@03 | live]
; [else-branch: 111 | !(0 <= i1@99@03) | live]
(push) ; 8
; [then-branch: 111 | 0 <= i1@99@03]
(assert (<= 0 i1@99@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 111 | !(0 <= i1@99@03)]
(assert (not (<= 0 i1@99@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@99@03 V@26@03) (<= 0 i1@99@03)))
(declare-const $k@100@03 $Perm)
(assert ($Perm.isReadVar $k@100@03 $Perm.Write))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (< i1@99@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2885
;  :arith-add-rows          1034
;  :arith-assert-diseq      92
;  :arith-assert-lower      475
;  :arith-assert-upper      342
;  :arith-bound-prop        222
;  :arith-conflicts         74
;  :arith-eq-adapter        283
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        195
;  :arith-pivots            437
;  :conflicts               243
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               465
;  :del-clause              2364
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          10
;  :mk-bool-var             4521
;  :mk-clause               2373
;  :num-allocs              243130
;  :num-checks              162
;  :propagations            1008
;  :quant-instantiations    1144
;  :rlimit-count            361529)
(assert (< i1@99@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 7
; Joined path conditions
(assert (< i1@99@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 6
(declare-fun inv@101@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@100@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@99@03 Int)) (!
  (< i1@99@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@99@03))
  :qid |option$array$-aux|)))
(push) ; 6
(assert (not (forall ((i1@99@03 Int)) (!
  (implies
    (and (< i1@99@03 V@26@03) (<= 0 i1@99@03))
    (or (= $k@100@03 $Perm.No) (< $Perm.No $k@100@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2885
;  :arith-add-rows          1035
;  :arith-assert-diseq      93
;  :arith-assert-lower      477
;  :arith-assert-upper      343
;  :arith-bound-prop        222
;  :arith-conflicts         74
;  :arith-eq-adapter        284
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        195
;  :arith-pivots            438
;  :conflicts               244
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               465
;  :del-clause              2366
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          10
;  :mk-bool-var             4528
;  :mk-clause               2375
;  :num-allocs              243559
;  :num-checks              163
;  :propagations            1009
;  :quant-instantiations    1144
;  :rlimit-count            362079)
(declare-const sm@102@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@102@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@102@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@93@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@102@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@102@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@102@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef18|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@99@03 Int) (i12@99@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@99@03 V@26@03) (<= 0 i11@99@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@102@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@99@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@99@03)))
        (< $Perm.No $k@100@03))
      (and
        (and
          (and (< i12@99@03 V@26@03) (<= 0 i12@99@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@102@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@99@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@99@03)))
        (< $Perm.No $k@100@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@99@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@99@03)))
    (= i11@99@03 i12@99@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2904
;  :arith-add-rows          1044
;  :arith-assert-diseq      95
;  :arith-assert-lower      481
;  :arith-assert-upper      343
;  :arith-bound-prop        223
;  :arith-conflicts         74
;  :arith-eq-adapter        286
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        196
;  :arith-pivots            440
;  :conflicts               245
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   160
;  :datatype-splits         122
;  :decisions               465
;  :del-clause              2413
;  :final-checks            99
;  :interface-eqs           2
;  :max-generation          4
;  :max-memory              5.62
;  :memory                  5.60
;  :minimized-lits          10
;  :mk-bool-var             4596
;  :mk-clause               2422
;  :num-allocs              244789
;  :num-checks              164
;  :propagations            1016
;  :quant-instantiations    1167
;  :rlimit-count            365626)
; Definitional axioms for inverse functions
(assert (forall ((i1@99@03 Int)) (!
  (implies
    (and (and (< i1@99@03 V@26@03) (<= 0 i1@99@03)) (< $Perm.No $k@100@03))
    (=
      (inv@101@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@99@03))
      i1@99@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@99@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@101@03 r) V@26@03) (<= 0 (inv@101@03 r)))
      (< $Perm.No $k@100@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@101@03 r))
      r))
  :pattern ((inv@101@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@101@03 r) V@26@03) (<= 0 (inv@101@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@102@03  $FVF<option<array>>) r) r))
  :pattern ((inv@101@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@103@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@101@03 r) V@26@03) (<= 0 (inv@101@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 r))
      $k@100@03)
    $Perm.No))
(define-fun pTaken@104@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@101@03 r) V@26@03) (<= 0 (inv@101@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@93@03 r))
      (- $k@100@03 (pTaken@103@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@100@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
            $k@31@03
            $Perm.No)
          (pTaken@94@03 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@101@03 r) V@26@03) (<= 0 (inv@101@03 r)))
        $k@100@03
        $Perm.No)
      (-
        (ite
          (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 r))))
  :pattern ((inv@32@03 r))
  :pattern ((inv@101@03 r))
  :qid |qp.srp19|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@101@03 r) V@26@03) (<= 0 (inv@101@03 r)))
    (= (- $k@100@03 (pTaken@103@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3273
;  :arith-add-rows          1241
;  :arith-assert-diseq      125
;  :arith-assert-lower      605
;  :arith-assert-upper      409
;  :arith-bound-prop        252
;  :arith-conflicts         81
;  :arith-eq-adapter        375
;  :arith-fixed-eqs         172
;  :arith-offset-eqs        229
;  :arith-pivots            506
;  :conflicts               259
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 325
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               520
;  :del-clause              2842
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.72
;  :memory                  5.68
;  :minimized-lits          12
;  :mk-bool-var             5135
;  :mk-clause               2851
;  :num-allocs              250109
;  :num-checks              166
;  :propagations            1245
;  :quant-instantiations    1278
;  :rlimit-count            381505
;  :time                    0.01)
; Constrain original permissions $k@100@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@101@03 r) V@26@03) (<= 0 (inv@101@03 r)))
        $k@100@03
        $Perm.No)
      (-
        (ite
          (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@93@03 r))))
  :pattern ((inv@77@03 r))
  :pattern ((inv@101@03 r))
  :qid |qp.srp20|)))
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@101@03 r) V@26@03) (<= 0 (inv@101@03 r)))
    (= (- (- $k@100@03 (pTaken@103@03 r)) (pTaken@104@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3565
;  :arith-add-rows          1488
;  :arith-assert-diseq      164
;  :arith-assert-lower      702
;  :arith-assert-upper      474
;  :arith-bound-prop        289
;  :arith-conflicts         90
;  :arith-eq-adapter        462
;  :arith-fixed-eqs         203
;  :arith-offset-eqs        261
;  :arith-pivots            563
;  :conflicts               279
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 329
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               543
;  :del-clause              3294
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.72
;  :memory                  5.70
;  :minimized-lits          23
;  :mk-bool-var             5720
;  :mk-clause               3303
;  :num-allocs              253075
;  :num-checks              167
;  :propagations            1473
;  :quant-instantiations    1387
;  :rlimit-count            393344
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@105@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 112 | 0 <= i1@105@03 | live]
; [else-branch: 112 | !(0 <= i1@105@03) | live]
(push) ; 8
; [then-branch: 112 | 0 <= i1@105@03]
(assert (<= 0 i1@105@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 112 | !(0 <= i1@105@03)]
(assert (not (<= 0 i1@105@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 113 | i1@105@03 < V@26@03 && 0 <= i1@105@03 | live]
; [else-branch: 113 | !(i1@105@03 < V@26@03 && 0 <= i1@105@03) | live]
(push) ; 8
; [then-branch: 113 | i1@105@03 < V@26@03 && 0 <= i1@105@03]
(assert (and (< i1@105@03 V@26@03) (<= 0 i1@105@03)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@105@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3565
;  :arith-add-rows          1489
;  :arith-assert-diseq      164
;  :arith-assert-lower      704
;  :arith-assert-upper      474
;  :arith-bound-prop        289
;  :arith-conflicts         90
;  :arith-eq-adapter        462
;  :arith-fixed-eqs         203
;  :arith-offset-eqs        261
;  :arith-pivots            563
;  :conflicts               279
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 329
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               543
;  :del-clause              3294
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.72
;  :memory                  5.70
;  :minimized-lits          23
;  :mk-bool-var             5722
;  :mk-clause               3303
;  :num-allocs              253184
;  :num-checks              168
;  :propagations            1473
;  :quant-instantiations    1387
;  :rlimit-count            393535)
(assert (< i1@105@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@105@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3636
;  :arith-add-rows          1511
;  :arith-assert-diseq      166
;  :arith-assert-lower      718
;  :arith-assert-upper      489
;  :arith-bound-prop        299
;  :arith-conflicts         93
;  :arith-eq-adapter        478
;  :arith-fixed-eqs         210
;  :arith-offset-eqs        268
;  :arith-pivots            571
;  :conflicts               288
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 333
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               551
;  :del-clause              3334
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.73
;  :minimized-lits          23
;  :mk-bool-var             5873
;  :mk-clause               3417
;  :num-allocs              253994
;  :num-checks              169
;  :propagations            1522
;  :quant-instantiations    1427
;  :rlimit-count            396146)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 113 | !(i1@105@03 < V@26@03 && 0 <= i1@105@03)]
(assert (not (and (< i1@105@03 V@26@03) (<= 0 i1@105@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@105@03 V@26@03) (<= 0 i1@105@03))
  (and
    (< i1@105@03 V@26@03)
    (<= 0 i1@105@03)
    (< i1@105@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@105@03 Int)) (!
  (implies
    (and (< i1@105@03 V@26@03) (<= 0 i1@105@03))
    (and
      (< i1@105@03 V@26@03)
      (<= 0 i1@105@03)
      (< i1@105@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@105@03 Int)) (!
  (implies
    (and (< i1@105@03 V@26@03) (<= 0 i1@105@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3648
;  :arith-add-rows          1527
;  :arith-assert-diseq      166
;  :arith-assert-lower      721
;  :arith-assert-upper      490
;  :arith-bound-prop        300
;  :arith-conflicts         93
;  :arith-eq-adapter        484
;  :arith-fixed-eqs         211
;  :arith-offset-eqs        268
;  :arith-pivots            579
;  :conflicts               289
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 333
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               551
;  :del-clause              3484
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.71
;  :minimized-lits          23
;  :mk-bool-var             5975
;  :mk-clause               3493
;  :num-allocs              254779
;  :num-checks              170
;  :propagations            1527
;  :quant-instantiations    1456
;  :rlimit-count            398289
;  :time                    0.00)
(assert (forall ((i1@105@03 Int)) (!
  (implies
    (and (< i1@105@03 V@26@03) (<= 0 i1@105@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@105@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@106@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 114 | 0 <= i1@106@03 | live]
; [else-branch: 114 | !(0 <= i1@106@03) | live]
(push) ; 8
; [then-branch: 114 | 0 <= i1@106@03]
(assert (<= 0 i1@106@03))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 114 | !(0 <= i1@106@03)]
(assert (not (<= 0 i1@106@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 115 | i1@106@03 < V@26@03 && 0 <= i1@106@03 | live]
; [else-branch: 115 | !(i1@106@03 < V@26@03 && 0 <= i1@106@03) | live]
(push) ; 8
; [then-branch: 115 | i1@106@03 < V@26@03 && 0 <= i1@106@03]
(assert (and (< i1@106@03 V@26@03) (<= 0 i1@106@03)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3648
;  :arith-add-rows          1528
;  :arith-assert-diseq      166
;  :arith-assert-lower      723
;  :arith-assert-upper      490
;  :arith-bound-prop        300
;  :arith-conflicts         93
;  :arith-eq-adapter        484
;  :arith-fixed-eqs         211
;  :arith-offset-eqs        268
;  :arith-pivots            579
;  :conflicts               289
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 333
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               551
;  :del-clause              3484
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.71
;  :minimized-lits          23
;  :mk-bool-var             5978
;  :mk-clause               3493
;  :num-allocs              255070
;  :num-checks              171
;  :propagations            1527
;  :quant-instantiations    1456
;  :rlimit-count            398789)
(assert (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3821
;  :arith-add-rows          1653
;  :arith-assert-diseq      183
;  :arith-assert-lower      796
;  :arith-assert-upper      525
;  :arith-bound-prop        321
;  :arith-conflicts         97
;  :arith-eq-adapter        523
;  :arith-fixed-eqs         232
;  :arith-offset-eqs        275
;  :arith-pivots            607
;  :conflicts               299
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 337
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               574
;  :del-clause              3745
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.74
;  :minimized-lits          23
;  :mk-bool-var             6361
;  :mk-clause               3829
;  :num-allocs              256895
;  :num-checks              172
;  :propagations            1668
;  :quant-instantiations    1541
;  :rlimit-count            406617
;  :time                    0.00)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3821
;  :arith-add-rows          1653
;  :arith-assert-diseq      183
;  :arith-assert-lower      796
;  :arith-assert-upper      525
;  :arith-bound-prop        321
;  :arith-conflicts         97
;  :arith-eq-adapter        523
;  :arith-fixed-eqs         232
;  :arith-offset-eqs        275
;  :arith-pivots            607
;  :conflicts               300
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 337
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               574
;  :del-clause              3745
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.74
;  :minimized-lits          23
;  :mk-bool-var             6361
;  :mk-clause               3829
;  :num-allocs              256985
;  :num-checks              173
;  :propagations            1668
;  :quant-instantiations    1541
;  :rlimit-count            406712)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 115 | !(i1@106@03 < V@26@03 && 0 <= i1@106@03)]
(assert (not (and (< i1@106@03 V@26@03) (<= 0 i1@106@03))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@106@03 V@26@03) (<= 0 i1@106@03))
  (and
    (< i1@106@03 V@26@03)
    (<= 0 i1@106@03)
    (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@106@03 Int)) (!
  (implies
    (and (< i1@106@03 V@26@03) (<= 0 i1@106@03))
    (and
      (< i1@106@03 V@26@03)
      (<= 0 i1@106@03)
      (< i1@106@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@106@03 Int)) (!
  (implies
    (and (< i1@106@03 V@26@03) (<= 0 i1@106@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3826
;  :arith-add-rows          1669
;  :arith-assert-diseq      184
;  :arith-assert-lower      799
;  :arith-assert-upper      525
;  :arith-bound-prop        321
;  :arith-conflicts         97
;  :arith-eq-adapter        527
;  :arith-fixed-eqs         232
;  :arith-offset-eqs        275
;  :arith-pivots            616
;  :conflicts               301
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 337
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               574
;  :del-clause              3882
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.73
;  :minimized-lits          23
;  :mk-bool-var             6448
;  :mk-clause               3891
;  :num-allocs              257747
;  :num-checks              174
;  :propagations            1673
;  :quant-instantiations    1572
;  :rlimit-count            408871
;  :time                    0.00)
(assert (forall ((i1@106@03 Int)) (!
  (implies
    (and (< i1@106@03 V@26@03) (<= 0 i1@106@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@106@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@107@03 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@108@03 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 116 | 0 <= i1@107@03 | live]
; [else-branch: 116 | !(0 <= i1@107@03) | live]
(push) ; 9
; [then-branch: 116 | 0 <= i1@107@03]
(assert (<= 0 i1@107@03))
; [eval] i1 < V
(push) ; 10
; [then-branch: 117 | i1@107@03 < V@26@03 | live]
; [else-branch: 117 | !(i1@107@03 < V@26@03) | live]
(push) ; 11
; [then-branch: 117 | i1@107@03 < V@26@03]
(assert (< i1@107@03 V@26@03))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 118 | 0 <= i2@108@03 | live]
; [else-branch: 118 | !(0 <= i2@108@03) | live]
(push) ; 13
; [then-branch: 118 | 0 <= i2@108@03]
(assert (<= 0 i2@108@03))
; [eval] i2 < V
(push) ; 14
; [then-branch: 119 | i2@108@03 < V@26@03 | live]
; [else-branch: 119 | !(i2@108@03 < V@26@03) | live]
(push) ; 15
; [then-branch: 119 | i2@108@03 < V@26@03]
(assert (< i2@108@03 V@26@03))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3826
;  :arith-add-rows          1671
;  :arith-assert-diseq      184
;  :arith-assert-lower      803
;  :arith-assert-upper      525
;  :arith-bound-prop        321
;  :arith-conflicts         97
;  :arith-eq-adapter        527
;  :arith-fixed-eqs         232
;  :arith-offset-eqs        275
;  :arith-pivots            616
;  :conflicts               301
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 337
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               574
;  :del-clause              3882
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.73
;  :minimized-lits          23
;  :mk-bool-var             6453
;  :mk-clause               3891
;  :num-allocs              258216
;  :num-checks              175
;  :propagations            1673
;  :quant-instantiations    1572
;  :rlimit-count            409516)
(assert (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 16
; Joined path conditions
(assert (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3894
;  :arith-add-rows          1695
;  :arith-assert-diseq      186
;  :arith-assert-lower      818
;  :arith-assert-upper      540
;  :arith-bound-prop        331
;  :arith-conflicts         100
;  :arith-eq-adapter        542
;  :arith-fixed-eqs         239
;  :arith-offset-eqs        284
;  :arith-pivots            627
;  :conflicts               309
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 341
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               581
;  :del-clause              3918
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.74
;  :minimized-lits          23
;  :mk-bool-var             6597
;  :mk-clause               4001
;  :num-allocs              259041
;  :num-checks              176
;  :propagations            1720
;  :quant-instantiations    1613
;  :rlimit-count            412236)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3894
;  :arith-add-rows          1695
;  :arith-assert-diseq      186
;  :arith-assert-lower      818
;  :arith-assert-upper      540
;  :arith-bound-prop        331
;  :arith-conflicts         100
;  :arith-eq-adapter        542
;  :arith-fixed-eqs         239
;  :arith-offset-eqs        284
;  :arith-pivots            627
;  :conflicts               309
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 341
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               581
;  :del-clause              3918
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.75
;  :memory                  5.74
;  :minimized-lits          23
;  :mk-bool-var             6597
;  :mk-clause               4001
;  :num-allocs              259067
;  :num-checks              177
;  :propagations            1720
;  :quant-instantiations    1613
;  :rlimit-count            412266)
(assert (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 16
; Joined path conditions
(assert (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4056
;  :arith-add-rows          1809
;  :arith-assert-diseq      197
;  :arith-assert-lower      879
;  :arith-assert-upper      580
;  :arith-bound-prop        358
;  :arith-conflicts         105
;  :arith-eq-adapter        578
;  :arith-fixed-eqs         257
;  :arith-offset-eqs        296
;  :arith-pivots            654
;  :conflicts               329
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 345
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               603
;  :del-clause              4089
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.85
;  :memory                  5.84
;  :minimized-lits          23
;  :mk-bool-var             6958
;  :mk-clause               4245
;  :num-allocs              261055
;  :num-checks              178
;  :propagations            1835
;  :quant-instantiations    1707
;  :rlimit-count            420120
;  :time                    0.00)
(pop) ; 15
(push) ; 15
; [else-branch: 119 | !(i2@108@03 < V@26@03)]
(assert (not (< i2@108@03 V@26@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@108@03 V@26@03)
  (and
    (< i2@108@03 V@26@03)
    (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
    (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 118 | !(0 <= i2@108@03)]
(assert (not (<= 0 i2@108@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@108@03)
  (and
    (<= 0 i2@108@03)
    (implies
      (< i2@108@03 V@26@03)
      (and
        (< i2@108@03 V@26@03)
        (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
        (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 117 | !(i1@107@03 < V@26@03)]
(assert (not (< i1@107@03 V@26@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@107@03 V@26@03)
  (and
    (< i1@107@03 V@26@03)
    (implies
      (<= 0 i2@108@03)
      (and
        (<= 0 i2@108@03)
        (implies
          (< i2@108@03 V@26@03)
          (and
            (< i2@108@03 V@26@03)
            (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
            (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 116 | !(0 <= i1@107@03)]
(assert (not (<= 0 i1@107@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@107@03)
  (and
    (<= 0 i1@107@03)
    (implies
      (< i1@107@03 V@26@03)
      (and
        (< i1@107@03 V@26@03)
        (implies
          (<= 0 i2@108@03)
          (and
            (<= 0 i2@108@03)
            (implies
              (< i2@108@03 V@26@03)
              (and
                (< i2@108@03 V@26@03)
                (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
                (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 120 | Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i1@107@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i2@108@03)) && i2@108@03 < V@26@03 && 0 <= i2@108@03 && i1@107@03 < V@26@03 && 0 <= i1@107@03 | live]
; [else-branch: 120 | !(Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i1@107@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i2@108@03)) && i2@108@03 < V@26@03 && 0 <= i2@108@03 && i1@107@03 < V@26@03 && 0 <= i1@107@03) | live]
(push) ; 9
; [then-branch: 120 | Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i1@107@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i2@108@03)) && i2@108@03 < V@26@03 && 0 <= i2@108@03 && i1@107@03 < V@26@03 && 0 <= i1@107@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
        (< i2@108@03 V@26@03))
      (<= 0 i2@108@03))
    (< i1@107@03 V@26@03))
  (<= 0 i1@107@03)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 120 | !(Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i1@107@03)) == Lookup(option$array$,sm@78@03,aloc((_, _), opt_get1(_, res@74@03), i2@108@03)) && i2@108@03 < V@26@03 && 0 <= i2@108@03 && i1@107@03 < V@26@03 && 0 <= i1@107@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
          (< i2@108@03 V@26@03))
        (<= 0 i2@108@03))
      (< i1@107@03 V@26@03))
    (<= 0 i1@107@03))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
          (< i2@108@03 V@26@03))
        (<= 0 i2@108@03))
      (< i1@107@03 V@26@03))
    (<= 0 i1@107@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
      ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
    (< i2@108@03 V@26@03)
    (<= 0 i2@108@03)
    (< i1@107@03 V@26@03)
    (<= 0 i1@107@03))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@108@03 Int)) (!
  (and
    (implies
      (<= 0 i1@107@03)
      (and
        (<= 0 i1@107@03)
        (implies
          (< i1@107@03 V@26@03)
          (and
            (< i1@107@03 V@26@03)
            (implies
              (<= 0 i2@108@03)
              (and
                (<= 0 i2@108@03)
                (implies
                  (< i2@108@03 V@26@03)
                  (and
                    (< i2@108@03 V@26@03)
                    (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
                    (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
              (< i2@108@03 V@26@03))
            (<= 0 i2@108@03))
          (< i1@107@03 V@26@03))
        (<= 0 i1@107@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
          ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
        (< i2@108@03 V@26@03)
        (<= 0 i2@108@03)
        (< i1@107@03 V@26@03)
        (<= 0 i1@107@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@107@03 Int)) (!
  (forall ((i2@108@03 Int)) (!
    (and
      (implies
        (<= 0 i1@107@03)
        (and
          (<= 0 i1@107@03)
          (implies
            (< i1@107@03 V@26@03)
            (and
              (< i1@107@03 V@26@03)
              (implies
                (<= 0 i2@108@03)
                (and
                  (<= 0 i2@108@03)
                  (implies
                    (< i2@108@03 V@26@03)
                    (and
                      (< i2@108@03 V@26@03)
                      (< i1@107@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
                      (< i2@108@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
                  ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
                (< i2@108@03 V@26@03))
              (<= 0 i2@108@03))
            (< i1@107@03 V@26@03))
          (<= 0 i1@107@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
            ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
          (< i2@108@03 V@26@03)
          (<= 0 i2@108@03)
          (< i1@107@03 V@26@03)
          (<= 0 i1@107@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 6
(assert (not (forall ((i1@107@03 Int)) (!
  (forall ((i2@108@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
              (< i2@108@03 V@26@03))
            (<= 0 i2@108@03))
          (< i1@107@03 V@26@03))
        (<= 0 i1@107@03))
      (= i1@107@03 i2@108@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4080
;  :arith-add-rows          1839
;  :arith-assert-diseq      199
;  :arith-assert-lower      883
;  :arith-assert-upper      580
;  :arith-bound-prop        358
;  :arith-conflicts         105
;  :arith-eq-adapter        591
;  :arith-fixed-eqs         257
;  :arith-offset-eqs        296
;  :arith-pivots            670
;  :conflicts               330
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 345
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               603
;  :del-clause              4408
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.85
;  :memory                  5.83
;  :minimized-lits          23
;  :mk-bool-var             7191
;  :mk-clause               4417
;  :num-allocs              262834
;  :num-checks              179
;  :propagations            1841
;  :quant-instantiations    1770
;  :rlimit-count            425911
;  :time                    0.00)
(assert (forall ((i1@107@03 Int)) (!
  (forall ((i2@108@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
                ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03)))
              (< i2@108@03 V@26@03))
            (<= 0 i2@108@03))
          (< i1@107@03 V@26@03))
        (<= 0 i1@107@03))
      (= i1@107@03 i2@108@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@108@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@107@03))
  :qid |prog.l<no position>|)))
(declare-const i1@109@03 Int)
(declare-const j1@110@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 121 | 0 <= i1@109@03 | live]
; [else-branch: 121 | !(0 <= i1@109@03) | live]
(push) ; 8
; [then-branch: 121 | 0 <= i1@109@03]
(assert (<= 0 i1@109@03))
; [eval] i1 < V
(push) ; 9
; [then-branch: 122 | i1@109@03 < V@26@03 | live]
; [else-branch: 122 | !(i1@109@03 < V@26@03) | live]
(push) ; 10
; [then-branch: 122 | i1@109@03 < V@26@03]
(assert (< i1@109@03 V@26@03))
; [eval] 0 <= j1
(push) ; 11
; [then-branch: 123 | 0 <= j1@110@03 | live]
; [else-branch: 123 | !(0 <= j1@110@03) | live]
(push) ; 12
; [then-branch: 123 | 0 <= j1@110@03]
(assert (<= 0 j1@110@03))
; [eval] j1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 123 | !(0 <= j1@110@03)]
(assert (not (<= 0 j1@110@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 122 | !(i1@109@03 < V@26@03)]
(assert (not (< i1@109@03 V@26@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 121 | !(0 <= i1@109@03)]
(assert (not (<= 0 i1@109@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@110@03 V@26@03) (<= 0 j1@110@03)) (< i1@109@03 V@26@03))
  (<= 0 i1@109@03)))
(declare-const $k@111@03 $Perm)
(assert ($Perm.isReadVar $k@111@03 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (< i1@109@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4080
;  :arith-add-rows          1842
;  :arith-assert-diseq      200
;  :arith-assert-lower      891
;  :arith-assert-upper      581
;  :arith-bound-prop        358
;  :arith-conflicts         105
;  :arith-eq-adapter        592
;  :arith-fixed-eqs         257
;  :arith-offset-eqs        296
;  :arith-pivots            670
;  :conflicts               330
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 345
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               603
;  :del-clause              4408
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.85
;  :memory                  5.83
;  :minimized-lits          23
;  :mk-bool-var             7202
;  :mk-clause               4419
;  :num-allocs              263494
;  :num-checks              180
;  :propagations            1842
;  :quant-instantiations    1770
;  :rlimit-count            427051)
(assert (< i1@109@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 7
; Joined path conditions
(assert (< i1@109@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03)))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4174
;  :arith-add-rows          1888
;  :arith-assert-diseq      205
;  :arith-assert-lower      915
;  :arith-assert-upper      598
;  :arith-bound-prop        375
;  :arith-conflicts         107
;  :arith-eq-adapter        612
;  :arith-fixed-eqs         264
;  :arith-offset-eqs        307
;  :arith-pivots            685
;  :conflicts               340
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 349
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               617
;  :del-clause              4464
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.85
;  :memory                  5.84
;  :minimized-lits          24
;  :mk-bool-var             7390
;  :mk-clause               4546
;  :num-allocs              264530
;  :num-checks              181
;  :propagations            1908
;  :quant-instantiations    1805
;  :rlimit-count            430511)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4174
;  :arith-add-rows          1888
;  :arith-assert-diseq      205
;  :arith-assert-lower      915
;  :arith-assert-upper      598
;  :arith-bound-prop        375
;  :arith-conflicts         107
;  :arith-eq-adapter        612
;  :arith-fixed-eqs         264
;  :arith-offset-eqs        307
;  :arith-pivots            685
;  :conflicts               341
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 349
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               617
;  :del-clause              4464
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.85
;  :memory                  5.84
;  :minimized-lits          24
;  :mk-bool-var             7390
;  :mk-clause               4546
;  :num-allocs              264619
;  :num-checks              182
;  :propagations            1908
;  :quant-instantiations    1805
;  :rlimit-count            430606)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))
    (as None<option<array>>  option<array>))))
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (<
  j1@110@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03)))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4180
;  :arith-add-rows          1894
;  :arith-assert-diseq      205
;  :arith-assert-lower      918
;  :arith-assert-upper      599
;  :arith-bound-prop        375
;  :arith-conflicts         108
;  :arith-eq-adapter        613
;  :arith-fixed-eqs         265
;  :arith-offset-eqs        307
;  :arith-pivots            689
;  :conflicts               342
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 349
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               617
;  :del-clause              4468
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.85
;  :memory                  5.84
;  :minimized-lits          24
;  :mk-bool-var             7401
;  :mk-clause               4550
;  :num-allocs              264811
;  :num-checks              183
;  :propagations            1910
;  :quant-instantiations    1812
;  :rlimit-count            431129)
(assert (<
  j1@110@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))))))
(pop) ; 7
; Joined path conditions
(assert (<
  j1@110@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))))))
(pop) ; 6
(declare-fun inv@112@03 ($Ref) Int)
(declare-fun inv@113@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@111@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@109@03 Int) (j1@110@03 Int)) (!
  (and
    (< i1@109@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@110@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))) j1@110@03))
  :qid |int-aux|)))
(push) ; 6
(assert (not (forall ((i1@109@03 Int) (j1@110@03 Int)) (!
  (implies
    (and
      (and (and (< j1@110@03 V@26@03) (<= 0 j1@110@03)) (< i1@109@03 V@26@03))
      (<= 0 i1@109@03))
    (or (= $k@111@03 $Perm.No) (< $Perm.No $k@111@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4180
;  :arith-add-rows          1901
;  :arith-assert-diseq      206
;  :arith-assert-lower      920
;  :arith-assert-upper      600
;  :arith-bound-prop        375
;  :arith-conflicts         108
;  :arith-eq-adapter        614
;  :arith-fixed-eqs         265
;  :arith-offset-eqs        307
;  :arith-pivots            695
;  :conflicts               343
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 349
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               617
;  :del-clause              4541
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              5.85
;  :memory                  5.83
;  :minimized-lits          24
;  :mk-bool-var             7410
;  :mk-clause               4552
;  :num-allocs              265332
;  :num-checks              184
;  :propagations            1911
;  :quant-instantiations    1812
;  :rlimit-count            432142)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@109@03 Int) (j11@110@03 Int) (i12@109@03 Int) (j12@110@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j11@110@03 V@26@03) (<= 0 j11@110@03))
              (< i11@109@03 V@26@03))
            (<= 0 i11@109@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@109@03))) j11@110@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@109@03))) j11@110@03)))
        (< $Perm.No $k@111@03))
      (and
        (and
          (and
            (and
              (and (< j12@110@03 V@26@03) (<= 0 j12@110@03))
              (< i12@109@03 V@26@03))
            (<= 0 i12@109@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@109@03))) j12@110@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@109@03))) j12@110@03)))
        (< $Perm.No $k@111@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@109@03))) j11@110@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@109@03))) j12@110@03)))
    (and (= i11@109@03 i12@109@03) (= j11@110@03 j12@110@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4248
;  :arith-add-rows          1936
;  :arith-assert-diseq      206
;  :arith-assert-lower      932
;  :arith-assert-upper      604
;  :arith-bound-prop        377
;  :arith-conflicts         108
;  :arith-eq-adapter        630
;  :arith-fixed-eqs         267
;  :arith-offset-eqs        307
;  :arith-pivots            703
;  :conflicts               344
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 349
;  :datatype-occurs-check   169
;  :datatype-splits         129
;  :decisions               617
;  :del-clause              4740
;  :final-checks            106
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.52
;  :memory                  6.18
;  :minimized-lits          24
;  :mk-bool-var             7747
;  :mk-clause               4751
;  :num-allocs              267036
;  :num-checks              185
;  :propagations            1943
;  :quant-instantiations    1915
;  :rlimit-count            438340
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@109@03 Int) (j1@110@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@110@03 V@26@03) (<= 0 j1@110@03)) (< i1@109@03 V@26@03))
        (<= 0 i1@109@03))
      (< $Perm.No $k@111@03))
    (and
      (=
        (inv@112@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))) j1@110@03))
        i1@109@03)
      (=
        (inv@113@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))) j1@110@03))
        j1@110@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@109@03))) j1@110@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
          (< (inv@112@03 r) V@26@03))
        (<= 0 (inv@112@03 r)))
      (< $Perm.No $k@111@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@112@03 r)))) (inv@113@03 r))
      r))
  :pattern ((inv@112@03 r))
  :pattern ((inv@113@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
        (< (inv@112@03 r) V@26@03))
      (<= 0 (inv@112@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@87@03  $FVF<Int>) r) r))
  :pattern ((inv@112@03 r) (inv@113@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@114@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
        (< (inv@112@03 r) V@26@03))
      (<= 0 (inv@112@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
            (< (inv@85@03 r) V@26@03))
          (<= 0 (inv@85@03 r)))
        $Perm.Write
        $Perm.No)
      $k@111@03)
    $Perm.No))
(define-fun pTaken@115@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
        (< (inv@112@03 r) V@26@03))
      (<= 0 (inv@112@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
            (< (inv@40@03 r) V@26@03))
          (<= 0 (inv@40@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@111@03 (pTaken@114@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@111@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
              (< (inv@85@03 r) V@26@03))
            (<= 0 (inv@85@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
          (< (inv@85@03 r) V@26@03))
        (<= 0 (inv@85@03 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
              (< (inv@112@03 r) V@26@03))
            (<= 0 (inv@112@03 r)))
          $k@111@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
              (< (inv@112@03 r) V@26@03))
            (<= 0 (inv@112@03 r)))
          $k@111@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@86@03 r))
  :pattern ((inv@85@03 r))
  :pattern ((inv@113@03 r))
  :pattern ((inv@112@03 r))
  :qid |qp.srp21|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
        (< (inv@112@03 r) V@26@03))
      (<= 0 (inv@112@03 r)))
    (= (- $k@111@03 (pTaken@114@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4616
;  :arith-add-rows          2131
;  :arith-assert-diseq      224
;  :arith-assert-lower      1020
;  :arith-assert-upper      666
;  :arith-bound-prop        414
;  :arith-conflicts         114
;  :arith-eq-adapter        687
;  :arith-fixed-eqs         301
;  :arith-offset-eqs        357
;  :arith-pivots            778
;  :conflicts               355
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 367
;  :datatype-occurs-check   180
;  :datatype-splits         140
;  :decisions               669
;  :del-clause              5106
;  :final-checks            112
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.52
;  :memory                  6.24
;  :minimized-lits          24
;  :mk-bool-var             8248
;  :mk-clause               5113
;  :num-allocs              272496
;  :num-checks              187
;  :propagations            2103
;  :quant-instantiations    2039
;  :rlimit-count            454542
;  :time                    0.01)
; Constrain original permissions $k@111@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and
            (and
              (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
              (< (inv@40@03 r) V@26@03))
            (<= 0 (inv@40@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and
        (and
          (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
          (< (inv@40@03 r) V@26@03))
        (<= 0 (inv@40@03 r)))
      (<
        (ite
          (and
            (and
              (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
              (< (inv@112@03 r) V@26@03))
            (<= 0 (inv@112@03 r)))
          $k@111@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and
            (and
              (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
              (< (inv@112@03 r) V@26@03))
            (<= 0 (inv@112@03 r)))
          $k@111@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@41@03 r))
  :pattern ((inv@40@03 r))
  :pattern ((inv@113@03 r))
  :pattern ((inv@112@03 r))
  :qid |qp.srp22|)))
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@113@03 r) V@26@03) (<= 0 (inv@113@03 r)))
        (< (inv@112@03 r) V@26@03))
      (<= 0 (inv@112@03 r)))
    (= (- (- $k@111@03 (pTaken@114@03 r)) (pTaken@115@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4877
;  :arith-add-rows          2328
;  :arith-assert-diseq      241
;  :arith-assert-lower      1096
;  :arith-assert-upper      733
;  :arith-bound-prop        438
;  :arith-conflicts         124
;  :arith-eq-adapter        755
;  :arith-fixed-eqs         332
;  :arith-offset-eqs        385
;  :arith-pivots            837
;  :conflicts               374
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 371
;  :datatype-occurs-check   180
;  :datatype-splits         140
;  :decisions               689
;  :del-clause              5419
;  :final-checks            112
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.52
;  :memory                  6.23
;  :minimized-lits          32
;  :mk-bool-var             8722
;  :mk-clause               5426
;  :num-allocs              275315
;  :num-checks              188
;  :propagations            2281
;  :quant-instantiations    2131
;  :rlimit-count            465182
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@116@03 Int)
(declare-const j1@117@03 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 124 | 0 <= i1@116@03 | live]
; [else-branch: 124 | !(0 <= i1@116@03) | live]
(push) ; 8
; [then-branch: 124 | 0 <= i1@116@03]
(assert (<= 0 i1@116@03))
; [eval] i1 < V
(push) ; 9
; [then-branch: 125 | i1@116@03 < V@26@03 | live]
; [else-branch: 125 | !(i1@116@03 < V@26@03) | live]
(push) ; 10
; [then-branch: 125 | i1@116@03 < V@26@03]
(assert (< i1@116@03 V@26@03))
; [eval] 0 <= j1
(push) ; 11
; [then-branch: 126 | 0 <= j1@117@03 | live]
; [else-branch: 126 | !(0 <= j1@117@03) | live]
(push) ; 12
; [then-branch: 126 | 0 <= j1@117@03]
(assert (<= 0 j1@117@03))
; [eval] j1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 126 | !(0 <= j1@117@03)]
(assert (not (<= 0 j1@117@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 125 | !(i1@116@03 < V@26@03)]
(assert (not (< i1@116@03 V@26@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 124 | !(0 <= i1@116@03)]
(assert (not (<= 0 i1@116@03)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@117@03 V@26@03) (<= 0 j1@117@03)) (< i1@116@03 V@26@03))
  (<= 0 i1@116@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@116@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4877
;  :arith-add-rows          2331
;  :arith-assert-diseq      241
;  :arith-assert-lower      1102
;  :arith-assert-upper      733
;  :arith-bound-prop        438
;  :arith-conflicts         124
;  :arith-eq-adapter        755
;  :arith-fixed-eqs         332
;  :arith-offset-eqs        385
;  :arith-pivots            837
;  :conflicts               374
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 371
;  :datatype-occurs-check   180
;  :datatype-splits         140
;  :decisions               689
;  :del-clause              5419
;  :final-checks            112
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.52
;  :memory                  6.23
;  :minimized-lits          32
;  :mk-bool-var             8728
;  :mk-clause               5426
;  :num-allocs              275595
;  :num-checks              189
;  :propagations            2281
;  :quant-instantiations    2131
;  :rlimit-count            465648)
(assert (< i1@116@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 7
; Joined path conditions
(assert (< i1@116@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03)))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))
          V@26@03)
        (<=
          0
          (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (<
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))
          V@26@03)
        (<=
          0
          (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))))
      $k@31@03
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4948
;  :arith-add-rows          2354
;  :arith-assert-diseq      243
;  :arith-assert-lower      1116
;  :arith-assert-upper      748
;  :arith-bound-prop        448
;  :arith-conflicts         127
;  :arith-eq-adapter        771
;  :arith-fixed-eqs         339
;  :arith-offset-eqs        392
;  :arith-pivots            847
;  :conflicts               383
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 375
;  :datatype-occurs-check   180
;  :datatype-splits         140
;  :decisions               697
;  :del-clause              5459
;  :final-checks            112
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.52
;  :memory                  6.25
;  :minimized-lits          32
;  :mk-bool-var             8883
;  :mk-clause               5540
;  :num-allocs              276485
;  :num-checks              190
;  :propagations            2329
;  :quant-instantiations    2176
;  :rlimit-count            468642)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4948
;  :arith-add-rows          2354
;  :arith-assert-diseq      243
;  :arith-assert-lower      1116
;  :arith-assert-upper      748
;  :arith-bound-prop        448
;  :arith-conflicts         127
;  :arith-eq-adapter        771
;  :arith-fixed-eqs         339
;  :arith-offset-eqs        392
;  :arith-pivots            847
;  :conflicts               384
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 375
;  :datatype-occurs-check   180
;  :datatype-splits         140
;  :decisions               697
;  :del-clause              5459
;  :final-checks            112
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.52
;  :memory                  6.25
;  :minimized-lits          32
;  :mk-bool-var             8883
;  :mk-clause               5540
;  :num-allocs              276575
;  :num-checks              191
;  :propagations            2329
;  :quant-instantiations    2176
;  :rlimit-count            468737)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))
    (as None<option<array>>  option<array>))))
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (<
  j1@117@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03)))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4948
;  :arith-add-rows          2357
;  :arith-assert-diseq      243
;  :arith-assert-lower      1116
;  :arith-assert-upper      749
;  :arith-bound-prop        448
;  :arith-conflicts         128
;  :arith-eq-adapter        771
;  :arith-fixed-eqs         339
;  :arith-offset-eqs        392
;  :arith-pivots            849
;  :conflicts               385
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 375
;  :datatype-occurs-check   180
;  :datatype-splits         140
;  :decisions               697
;  :del-clause              5459
;  :final-checks            112
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.52
;  :memory                  6.24
;  :minimized-lits          32
;  :mk-bool-var             8884
;  :mk-clause               5540
;  :num-allocs              276721
;  :num-checks              192
;  :propagations            2329
;  :quant-instantiations    2176
;  :rlimit-count            469039)
(assert (<
  j1@117@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))))))
(pop) ; 7
; Joined path conditions
(assert (<
  j1@117@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))))))
(pop) ; 6
(declare-fun inv@118@03 ($Ref) Int)
(declare-fun inv@119@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@116@03 Int) (j1@117@03 Int)) (!
  (and
    (< i1@116@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@117@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))) j1@117@03))
  :qid |int-aux|)))
(declare-const sm@120@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
              (< (inv@40@03 r) V@26@03))
            (<= 0 (inv@40@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@115@03 r)))
    (=
      ($FVF.lookup_int (as sm@120@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@120@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
              (< (inv@85@03 r) V@26@03))
            (<= 0 (inv@85@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@114@03 r)))
    (=
      ($FVF.lookup_int (as sm@120@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@120@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef24|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@120@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef25|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@116@03 Int) (j11@117@03 Int) (i12@116@03 Int) (j12@117@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@117@03 V@26@03) (<= 0 j11@117@03))
            (< i11@116@03 V@26@03))
          (<= 0 i11@116@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@120@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@116@03))) j11@117@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@116@03))) j11@117@03)))
      (and
        (and
          (and
            (and (< j12@117@03 V@26@03) (<= 0 j12@117@03))
            (< i12@116@03 V@26@03))
          (<= 0 i12@116@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@120@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@116@03))) j12@117@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@116@03))) j12@117@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@116@03))) j11@117@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@116@03))) j12@117@03)))
    (and (= i11@116@03 i12@116@03) (= j11@117@03 j12@117@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5048
;  :arith-add-rows          2406
;  :arith-assert-diseq      243
;  :arith-assert-lower      1130
;  :arith-assert-upper      753
;  :arith-bound-prop        451
;  :arith-conflicts         128
;  :arith-eq-adapter        796
;  :arith-fixed-eqs         342
;  :arith-offset-eqs        392
;  :arith-pivots            865
;  :conflicts               386
;  :datatype-accessor-ax    62
;  :datatype-constructor-ax 375
;  :datatype-occurs-check   180
;  :datatype-splits         140
;  :decisions               697
;  :del-clause              5796
;  :final-checks            112
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.57
;  :memory                  6.53
;  :minimized-lits          32
;  :mk-bool-var             9253
;  :mk-clause               5803
;  :num-allocs              279605
;  :num-checks              193
;  :propagations            2367
;  :quant-instantiations    2282
;  :rlimit-count            479392
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@116@03 Int) (j1@117@03 Int)) (!
  (implies
    (and
      (and (and (< j1@117@03 V@26@03) (<= 0 j1@117@03)) (< i1@116@03 V@26@03))
      (<= 0 i1@116@03))
    (and
      (=
        (inv@118@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))) j1@117@03))
        i1@116@03)
      (=
        (inv@119@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))) j1@117@03))
        j1@117@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@116@03))) j1@117@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@119@03 r) V@26@03) (<= 0 (inv@119@03 r)))
        (< (inv@118@03 r) V@26@03))
      (<= 0 (inv@118@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@78@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@118@03 r)))) (inv@119@03 r))
      r))
  :pattern ((inv@118@03 r))
  :pattern ((inv@119@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@119@03 r) V@26@03) (<= 0 (inv@119@03 r)))
        (< (inv@118@03 r) V@26@03))
      (<= 0 (inv@118@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@120@03  $FVF<Int>) r) r))
  :pattern ((inv@118@03 r) (inv@119@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@121@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@119@03 r) V@26@03) (<= 0 (inv@119@03 r)))
        (< (inv@118@03 r) V@26@03))
      (<= 0 (inv@118@03 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
              (< (inv@40@03 r) V@26@03))
            (<= 0 (inv@40@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@115@03 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@122@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@119@03 r) V@26@03) (<= 0 (inv@119@03 r)))
        (< (inv@118@03 r) V@26@03))
      (<= 0 (inv@118@03 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
              (< (inv@85@03 r) V@26@03))
            (<= 0 (inv@85@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@114@03 r))
      (- $Perm.Write (pTaken@121@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
              (< (inv@40@03 r) V@26@03))
            (<= 0 (inv@40@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@115@03 r))
      (pTaken@121@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6016
;  :arith-add-rows          2792
;  :arith-assert-diseq      292
;  :arith-assert-lower      1425
;  :arith-assert-upper      930
;  :arith-bound-prop        522
;  :arith-conflicts         142
;  :arith-eq-adapter        1001
;  :arith-fixed-eqs         464
;  :arith-offset-eqs        443
;  :arith-pivots            1023
;  :conflicts               409
;  :datatype-accessor-ax    64
;  :datatype-constructor-ax 393
;  :datatype-occurs-check   191
;  :datatype-splits         151
;  :decisions               768
;  :del-clause              7264
;  :final-checks            118
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.84
;  :memory                  6.78
;  :minimized-lits          36
;  :mk-bool-var             11309
;  :mk-clause               7271
;  :num-allocs              291060
;  :num-checks              195
;  :propagations            2941
;  :quant-instantiations    2867
;  :rlimit-count            514046
;  :time                    0.03)
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@119@03 r) V@26@03) (<= 0 (inv@119@03 r)))
        (< (inv@118@03 r) V@26@03))
      (<= 0 (inv@118@03 r)))
    (= (- $Perm.Write (pTaken@121@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7148
;  :arith-add-rows          3279
;  :arith-assert-diseq      353
;  :arith-assert-lower      1765
;  :arith-assert-upper      1193
;  :arith-bound-prop        603
;  :arith-conflicts         156
;  :arith-eq-adapter        1215
;  :arith-fixed-eqs         585
;  :arith-offset-eqs        581
;  :arith-pivots            1177
;  :conflicts               434
;  :datatype-accessor-ax    66
;  :datatype-constructor-ax 405
;  :datatype-occurs-check   199
;  :datatype-splits         160
;  :decisions               882
;  :del-clause              8780
;  :final-checks            122
;  :interface-eqs           4
;  :max-generation          6
;  :max-memory              6.97
;  :memory                  6.89
;  :minimized-lits          39
;  :mk-bool-var             13276
;  :mk-clause               8787
;  :num-allocs              299441
;  :num-checks              196
;  :propagations            3708
;  :quant-instantiations    3389
;  :rlimit-count            545295
;  :time                    0.03)
; Chunk depleted?
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
              (< (inv@85@03 r) V@26@03))
            (<= 0 (inv@85@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@114@03 r))
      (pTaken@122@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 6
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8503
;  :arith-add-rows          3916
;  :arith-assert-diseq      439
;  :arith-assert-lower      2195
;  :arith-assert-upper      1457
;  :arith-bound-prop        679
;  :arith-conflicts         168
;  :arith-eq-adapter        1500
;  :arith-fixed-eqs         752
;  :arith-offset-eqs        668
;  :arith-pivots            1397
;  :conflicts               462
;  :datatype-accessor-ax    68
;  :datatype-constructor-ax 417
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1002
;  :del-clause              10941
;  :final-checks            129
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.10
;  :minimized-lits          54
;  :mk-bool-var             16021
;  :mk-clause               10948
;  :num-allocs              311309
;  :num-checks              197
;  :propagations            4646
;  :quant-instantiations    4156
;  :rlimit-count            588879
;  :time                    0.03)
; Intermediate check if already taken enough permissions
(push) ; 6
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@119@03 r) V@26@03) (<= 0 (inv@119@03 r)))
        (< (inv@118@03 r) V@26@03))
      (<= 0 (inv@118@03 r)))
    (= (- (- $Perm.Write (pTaken@121@03 r)) (pTaken@122@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9739
;  :arith-add-rows          4548
;  :arith-assert-diseq      519
;  :arith-assert-lower      2630
;  :arith-assert-upper      1761
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1764
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               498
;  :datatype-accessor-ax    68
;  :datatype-constructor-ax 421
;  :datatype-occurs-check   207
;  :datatype-splits         169
;  :decisions               1105
;  :del-clause              12632
;  :final-checks            129
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.10
;  :minimized-lits          66
;  :mk-bool-var             18232
;  :mk-clause               12639
;  :num-allocs              319394
;  :num-checks              198
;  :propagations            5545
;  :quant-instantiations    4665
;  :rlimit-count            622466
;  :time                    0.02)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@123@03 $Ref)
(declare-const res@124@03 void)
(declare-const $t@125@03 $Snap)
(assert (= $t@125@03 ($Snap.combine ($Snap.first $t@125@03) ($Snap.second $t@125@03))))
(assert (= ($Snap.first $t@125@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@123@03 $Ref.null))
(assert (=
  ($Snap.second $t@125@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@125@03))
    ($Snap.second ($Snap.second $t@125@03)))))
(assert (= ($Snap.first ($Snap.second $t@125@03)) $Snap.unit))
; [eval] exc == null ==> source != (None(): option[array])
; [eval] exc == null
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9778
;  :arith-add-rows          4548
;  :arith-assert-diseq      519
;  :arith-assert-lower      2630
;  :arith-assert-upper      1761
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1764
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               498
;  :datatype-accessor-ax    70
;  :datatype-constructor-ax 428
;  :datatype-occurs-check   211
;  :datatype-splits         172
;  :decisions               1112
;  :del-clause              12632
;  :final-checks            131
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.09
;  :minimized-lits          66
;  :mk-bool-var             18240
;  :mk-clause               12639
;  :num-allocs              320238
;  :num-checks              199
;  :propagations            5545
;  :quant-instantiations    4665
;  :rlimit-count            623461)
; [then-branch: 127 | exc@123@03 == Null | live]
; [else-branch: 127 | exc@123@03 != Null | dead]
(push) ; 7
; [then-branch: 127 | exc@123@03 == Null]
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (not (= G@23@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@125@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@125@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@125@03))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(source)) == V
; [eval] exc == null
(push) ; 6
(push) ; 7
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9811
;  :arith-add-rows          4548
;  :arith-assert-diseq      519
;  :arith-assert-lower      2630
;  :arith-assert-upper      1761
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1764
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               498
;  :datatype-accessor-ax    71
;  :datatype-constructor-ax 435
;  :datatype-occurs-check   215
;  :datatype-splits         175
;  :decisions               1119
;  :del-clause              12632
;  :final-checks            133
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.09
;  :minimized-lits          66
;  :mk-bool-var             18245
;  :mk-clause               12639
;  :num-allocs              321018
;  :num-checks              200
;  :propagations            5545
;  :quant-instantiations    4665
;  :rlimit-count            624336)
; [then-branch: 128 | exc@123@03 == Null | live]
; [else-branch: 128 | exc@123@03 != Null | dead]
(push) ; 7
; [then-branch: 128 | exc@123@03 == Null]
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@23@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@125@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))
; [eval] exc == null
(push) ; 6
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9846
;  :arith-add-rows          4548
;  :arith-assert-diseq      519
;  :arith-assert-lower      2630
;  :arith-assert-upper      1761
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1764
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               498
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 443
;  :datatype-occurs-check   219
;  :datatype-splits         179
;  :decisions               1127
;  :del-clause              12632
;  :final-checks            135
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.09
;  :minimized-lits          66
;  :mk-bool-var             18250
;  :mk-clause               12639
;  :num-allocs              321798
;  :num-checks              201
;  :propagations            5545
;  :quant-instantiations    4665
;  :rlimit-count            625203)
; [then-branch: 129 | exc@123@03 == Null | live]
; [else-branch: 129 | exc@123@03 != Null | dead]
(push) ; 6
; [then-branch: 129 | exc@123@03 == Null]
(declare-const i1@126@03 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 130 | 0 <= i1@126@03 | live]
; [else-branch: 130 | !(0 <= i1@126@03) | live]
(push) ; 9
; [then-branch: 130 | 0 <= i1@126@03]
(assert (<= 0 i1@126@03))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 130 | !(0 <= i1@126@03)]
(assert (not (<= 0 i1@126@03)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (and (< i1@126@03 V@26@03) (<= 0 i1@126@03)))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< i1@126@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9846
;  :arith-add-rows          4549
;  :arith-assert-diseq      519
;  :arith-assert-lower      2632
;  :arith-assert-upper      1761
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1764
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               498
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 443
;  :datatype-occurs-check   219
;  :datatype-splits         179
;  :decisions               1127
;  :del-clause              12632
;  :final-checks            135
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.10
;  :minimized-lits          66
;  :mk-bool-var             18252
;  :mk-clause               12639
;  :num-allocs              321902
;  :num-checks              202
;  :propagations            5545
;  :quant-instantiations    4665
;  :rlimit-count            625389)
(assert (< i1@126@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 8
; Joined path conditions
(assert (< i1@126@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(declare-const $k@127@03 $Perm)
(assert ($Perm.isReadVar $k@127@03 $Perm.Write))
(pop) ; 7
(declare-fun inv@128@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@127@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@126@03 Int)) (!
  (< i1@126@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@126@03))
  :qid |option$array$-aux|)))
(push) ; 7
(assert (not (forall ((i1@126@03 Int)) (!
  (implies
    (and (< i1@126@03 V@26@03) (<= 0 i1@126@03))
    (or (= $k@127@03 $Perm.No) (< $Perm.No $k@127@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9846
;  :arith-add-rows          4550
;  :arith-assert-diseq      520
;  :arith-assert-lower      2634
;  :arith-assert-upper      1762
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1765
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               499
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 443
;  :datatype-occurs-check   219
;  :datatype-splits         179
;  :decisions               1127
;  :del-clause              12632
;  :final-checks            135
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.10
;  :minimized-lits          66
;  :mk-bool-var             18259
;  :mk-clause               12641
;  :num-allocs              322368
;  :num-checks              203
;  :propagations            5546
;  :quant-instantiations    4665
;  :rlimit-count            625960)
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((i11@126@03 Int) (i12@126@03 Int)) (!
  (implies
    (and
      (and (and (< i11@126@03 V@26@03) (<= 0 i11@126@03)) (< $Perm.No $k@127@03))
      (and (and (< i12@126@03 V@26@03) (<= 0 i12@126@03)) (< $Perm.No $k@127@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@126@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@126@03)))
    (= i11@126@03 i12@126@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9856
;  :arith-add-rows          4554
;  :arith-assert-diseq      521
;  :arith-assert-lower      2638
;  :arith-assert-upper      1762
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1766
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               500
;  :datatype-accessor-ax    72
;  :datatype-constructor-ax 443
;  :datatype-occurs-check   219
;  :datatype-splits         179
;  :decisions               1127
;  :del-clause              12638
;  :final-checks            135
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.09
;  :minimized-lits          66
;  :mk-bool-var             18279
;  :mk-clause               12647
;  :num-allocs              322743
;  :num-checks              204
;  :propagations            5546
;  :quant-instantiations    4680
;  :rlimit-count            626735)
; Definitional axioms for inverse functions
(assert (forall ((i1@126@03 Int)) (!
  (implies
    (and (and (< i1@126@03 V@26@03) (<= 0 i1@126@03)) (< $Perm.No $k@127@03))
    (=
      (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@126@03))
      i1@126@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@126@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
      (< $Perm.No $k@127@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@128@03 r))
      r))
  :pattern ((inv@128@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@126@03 Int)) (!
  (<= $Perm.No $k@127@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@126@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@126@03 Int)) (!
  (<= $k@127@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@126@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@126@03 Int)) (!
  (implies
    (and (and (< i1@126@03 V@26@03) (<= 0 i1@126@03)) (< $Perm.No $k@127@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@126@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@126@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@129@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
      (< $Perm.No $k@127@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 r))
        (pTaken@104@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
            $k@31@03
            $Perm.No)
          (pTaken@94@03 r))
        (pTaken@103@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r))
  :qid |qp.fvfValDef28|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef29|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) r) r))
  :pattern ((inv@128@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9894
;  :arith-add-rows          4554
;  :arith-assert-diseq      521
;  :arith-assert-lower      2638
;  :arith-assert-upper      1763
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1766
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               500
;  :datatype-accessor-ax    73
;  :datatype-constructor-ax 451
;  :datatype-occurs-check   223
;  :datatype-splits         183
;  :decisions               1135
;  :del-clause              12638
;  :final-checks            137
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.10
;  :minimized-lits          66
;  :mk-bool-var             18294
;  :mk-clause               12647
;  :num-allocs              325348
;  :num-checks              205
;  :propagations            5546
;  :quant-instantiations    4680
;  :rlimit-count            633031)
; [then-branch: 131 | exc@123@03 == Null | live]
; [else-branch: 131 | exc@123@03 != Null | dead]
(push) ; 8
; [then-branch: 131 | exc@123@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@130@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 132 | 0 <= i1@130@03 | live]
; [else-branch: 132 | !(0 <= i1@130@03) | live]
(push) ; 11
; [then-branch: 132 | 0 <= i1@130@03]
(assert (<= 0 i1@130@03))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 132 | !(0 <= i1@130@03)]
(assert (not (<= 0 i1@130@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 133 | i1@130@03 < V@26@03 && 0 <= i1@130@03 | live]
; [else-branch: 133 | !(i1@130@03 < V@26@03 && 0 <= i1@130@03) | live]
(push) ; 11
; [then-branch: 133 | i1@130@03 < V@26@03 && 0 <= i1@130@03]
(assert (and (< i1@130@03 V@26@03) (<= 0 i1@130@03)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@130@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9894
;  :arith-add-rows          4555
;  :arith-assert-diseq      521
;  :arith-assert-lower      2640
;  :arith-assert-upper      1763
;  :arith-bound-prop        762
;  :arith-conflicts         185
;  :arith-eq-adapter        1766
;  :arith-fixed-eqs         909
;  :arith-offset-eqs        805
;  :arith-pivots            1565
;  :conflicts               500
;  :datatype-accessor-ax    73
;  :datatype-constructor-ax 451
;  :datatype-occurs-check   223
;  :datatype-splits         183
;  :decisions               1135
;  :del-clause              12638
;  :final-checks            137
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.10
;  :minimized-lits          66
;  :mk-bool-var             18296
;  :mk-clause               12647
;  :num-allocs              325451
;  :num-checks              206
;  :propagations            5546
;  :quant-instantiations    4680
;  :rlimit-count            633225)
(assert (< i1@130@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@130@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))))
        $k@127@03
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10254
;  :arith-add-rows          5280
;  :arith-assert-diseq      559
;  :arith-assert-lower      2764
;  :arith-assert-upper      1849
;  :arith-bound-prop        826
;  :arith-conflicts         199
;  :arith-eq-adapter        1865
;  :arith-fixed-eqs         950
;  :arith-offset-eqs        866
;  :arith-pivots            1654
;  :conflicts               525
;  :datatype-accessor-ax    73
;  :datatype-constructor-ax 455
;  :datatype-occurs-check   223
;  :datatype-splits         183
;  :decisions               1192
;  :del-clause              13299
;  :final-checks            137
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.14
;  :minimized-lits          69
;  :mk-bool-var             19259
;  :mk-clause               13436
;  :num-allocs              329538
;  :num-checks              207
;  :propagations            5821
;  :quant-instantiations    4811
;  :rlimit-count            663960
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 11
(push) ; 11
; [else-branch: 133 | !(i1@130@03 < V@26@03 && 0 <= i1@130@03)]
(assert (not (and (< i1@130@03 V@26@03) (<= 0 i1@130@03))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@130@03 V@26@03) (<= 0 i1@130@03))
  (and
    (< i1@130@03 V@26@03)
    (<= 0 i1@130@03)
    (< i1@130@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@130@03 Int)) (!
  (implies
    (and (< i1@130@03 V@26@03) (<= 0 i1@130@03))
    (and
      (< i1@130@03 V@26@03)
      (<= 0 i1@130@03)
      (< i1@130@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@130@03 Int)) (!
    (implies
      (and (< i1@130@03 V@26@03) (<= 0 i1@130@03))
      (and
        (< i1@130@03 V@26@03)
        (<= 0 i1@130@03)
        (< i1@130@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@130@03 Int)) (!
    (implies
      (and (< i1@130@03 V@26@03) (<= 0 i1@130@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@130@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10293
;  :arith-add-rows          5291
;  :arith-assert-diseq      559
;  :arith-assert-lower      2764
;  :arith-assert-upper      1849
;  :arith-bound-prop        826
;  :arith-conflicts         199
;  :arith-eq-adapter        1865
;  :arith-fixed-eqs         950
;  :arith-offset-eqs        866
;  :arith-pivots            1666
;  :conflicts               525
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 463
;  :datatype-occurs-check   227
;  :datatype-splits         187
;  :decisions               1200
;  :del-clause              13427
;  :final-checks            139
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.13
;  :minimized-lits          69
;  :mk-bool-var             19267
;  :mk-clause               13436
;  :num-allocs              330716
;  :num-checks              208
;  :propagations            5821
;  :quant-instantiations    4811
;  :rlimit-count            665902)
; [then-branch: 134 | exc@123@03 == Null | live]
; [else-branch: 134 | exc@123@03 != Null | dead]
(push) ; 8
; [then-branch: 134 | exc@123@03 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@131@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 135 | 0 <= i1@131@03 | live]
; [else-branch: 135 | !(0 <= i1@131@03) | live]
(push) ; 11
; [then-branch: 135 | 0 <= i1@131@03]
(assert (<= 0 i1@131@03))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 135 | !(0 <= i1@131@03)]
(assert (not (<= 0 i1@131@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 136 | i1@131@03 < V@26@03 && 0 <= i1@131@03 | live]
; [else-branch: 136 | !(i1@131@03 < V@26@03 && 0 <= i1@131@03) | live]
(push) ; 11
; [then-branch: 136 | i1@131@03 < V@26@03 && 0 <= i1@131@03]
(assert (and (< i1@131@03 V@26@03) (<= 0 i1@131@03)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10293
;  :arith-add-rows          5292
;  :arith-assert-diseq      559
;  :arith-assert-lower      2766
;  :arith-assert-upper      1849
;  :arith-bound-prop        826
;  :arith-conflicts         199
;  :arith-eq-adapter        1865
;  :arith-fixed-eqs         950
;  :arith-offset-eqs        866
;  :arith-pivots            1666
;  :conflicts               525
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 463
;  :datatype-occurs-check   227
;  :datatype-splits         187
;  :decisions               1200
;  :del-clause              13427
;  :final-checks            139
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.13
;  :minimized-lits          69
;  :mk-bool-var             19269
;  :mk-clause               13436
;  :num-allocs              330819
;  :num-checks              209
;  :propagations            5821
;  :quant-instantiations    4811
;  :rlimit-count            666098)
(assert (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 12
; Joined path conditions
(assert (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))))
        $k@127@03
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10706
;  :arith-add-rows          5825
;  :arith-assert-diseq      605
;  :arith-assert-lower      2926
;  :arith-assert-upper      1939
;  :arith-bound-prop        890
;  :arith-conflicts         210
;  :arith-eq-adapter        1970
;  :arith-fixed-eqs         996
;  :arith-offset-eqs        924
;  :arith-pivots            1745
;  :conflicts               545
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 467
;  :datatype-occurs-check   227
;  :datatype-splits         187
;  :decisions               1265
;  :del-clause              14010
;  :final-checks            139
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.16
;  :minimized-lits          72
;  :mk-bool-var             20112
;  :mk-clause               14147
;  :num-allocs              334428
;  :num-checks              210
;  :propagations            6111
;  :quant-instantiations    4943
;  :rlimit-count            691082
;  :time                    0.01)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10706
;  :arith-add-rows          5825
;  :arith-assert-diseq      605
;  :arith-assert-lower      2926
;  :arith-assert-upper      1939
;  :arith-bound-prop        890
;  :arith-conflicts         210
;  :arith-eq-adapter        1970
;  :arith-fixed-eqs         996
;  :arith-offset-eqs        924
;  :arith-pivots            1745
;  :conflicts               546
;  :datatype-accessor-ax    74
;  :datatype-constructor-ax 467
;  :datatype-occurs-check   227
;  :datatype-splits         187
;  :decisions               1265
;  :del-clause              14010
;  :final-checks            139
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.16
;  :minimized-lits          72
;  :mk-bool-var             20112
;  :mk-clause               14147
;  :num-allocs              334519
;  :num-checks              211
;  :propagations            6111
;  :quant-instantiations    4943
;  :rlimit-count            691177)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
    (as None<option<array>>  option<array>))))
(pop) ; 11
(push) ; 11
; [else-branch: 136 | !(i1@131@03 < V@26@03 && 0 <= i1@131@03)]
(assert (not (and (< i1@131@03 V@26@03) (<= 0 i1@131@03))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@131@03 V@26@03) (<= 0 i1@131@03))
  (and
    (< i1@131@03 V@26@03)
    (<= 0 i1@131@03)
    (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@131@03 Int)) (!
  (implies
    (and (< i1@131@03 V@26@03) (<= 0 i1@131@03))
    (and
      (< i1@131@03 V@26@03)
      (<= 0 i1@131@03)
      (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@131@03 Int)) (!
    (implies
      (and (< i1@131@03 V@26@03) (<= 0 i1@131@03))
      (and
        (< i1@131@03 V@26@03)
        (<= 0 i1@131@03)
        (< i1@131@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@131@03 Int)) (!
    (implies
      (and (< i1@131@03 V@26@03) (<= 0 i1@131@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03))))
        V@26@03))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@131@03)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10746
;  :arith-add-rows          5841
;  :arith-assert-diseq      605
;  :arith-assert-lower      2926
;  :arith-assert-upper      1939
;  :arith-bound-prop        890
;  :arith-conflicts         210
;  :arith-eq-adapter        1970
;  :arith-fixed-eqs         996
;  :arith-offset-eqs        924
;  :arith-pivots            1758
;  :conflicts               546
;  :datatype-accessor-ax    75
;  :datatype-constructor-ax 475
;  :datatype-occurs-check   231
;  :datatype-splits         191
;  :decisions               1273
;  :del-clause              14138
;  :final-checks            141
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.15
;  :minimized-lits          72
;  :mk-bool-var             20120
;  :mk-clause               14147
;  :num-allocs              335719
;  :num-checks              212
;  :propagations            6111
;  :quant-instantiations    4943
;  :rlimit-count            693338
;  :time                    0.00)
; [then-branch: 137 | exc@123@03 == Null | live]
; [else-branch: 137 | exc@123@03 != Null | dead]
(push) ; 8
; [then-branch: 137 | exc@123@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@132@03 Int)
(push) ; 9
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@133@03 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 138 | 0 <= i1@132@03 | live]
; [else-branch: 138 | !(0 <= i1@132@03) | live]
(push) ; 12
; [then-branch: 138 | 0 <= i1@132@03]
(assert (<= 0 i1@132@03))
; [eval] i1 < V
(push) ; 13
; [then-branch: 139 | i1@132@03 < V@26@03 | live]
; [else-branch: 139 | !(i1@132@03 < V@26@03) | live]
(push) ; 14
; [then-branch: 139 | i1@132@03 < V@26@03]
(assert (< i1@132@03 V@26@03))
; [eval] 0 <= i2
(push) ; 15
; [then-branch: 140 | 0 <= i2@133@03 | live]
; [else-branch: 140 | !(0 <= i2@133@03) | live]
(push) ; 16
; [then-branch: 140 | 0 <= i2@133@03]
(assert (<= 0 i2@133@03))
; [eval] i2 < V
(push) ; 17
; [then-branch: 141 | i2@133@03 < V@26@03 | live]
; [else-branch: 141 | !(i2@133@03 < V@26@03) | live]
(push) ; 18
; [then-branch: 141 | i2@133@03 < V@26@03]
(assert (< i2@133@03 V@26@03))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10746
;  :arith-add-rows          5843
;  :arith-assert-diseq      605
;  :arith-assert-lower      2930
;  :arith-assert-upper      1939
;  :arith-bound-prop        890
;  :arith-conflicts         210
;  :arith-eq-adapter        1970
;  :arith-fixed-eqs         996
;  :arith-offset-eqs        924
;  :arith-pivots            1758
;  :conflicts               546
;  :datatype-accessor-ax    75
;  :datatype-constructor-ax 475
;  :datatype-occurs-check   231
;  :datatype-splits         191
;  :decisions               1273
;  :del-clause              14138
;  :final-checks            141
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.20
;  :memory                  7.15
;  :minimized-lits          72
;  :mk-bool-var             20124
;  :mk-clause               14147
;  :num-allocs              335999
;  :num-checks              213
;  :propagations            6111
;  :quant-instantiations    4943
;  :rlimit-count            693678)
(assert (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 19
; Joined path conditions
(assert (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))))
        $k@127@03
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11247
;  :arith-add-rows          6554
;  :arith-assert-diseq      644
;  :arith-assert-lower      3114
;  :arith-assert-upper      2049
;  :arith-bound-prop        966
;  :arith-conflicts         223
;  :arith-eq-adapter        2096
;  :arith-fixed-eqs         1061
;  :arith-offset-eqs        1014
;  :arith-pivots            1844
;  :conflicts               572
;  :datatype-accessor-ax    75
;  :datatype-constructor-ax 479
;  :datatype-occurs-check   231
;  :datatype-splits         191
;  :decisions               1318
;  :del-clause              14727
;  :final-checks            141
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.24
;  :memory                  7.21
;  :minimized-lits          79
;  :mk-bool-var             21045
;  :mk-clause               14864
;  :num-allocs              340232
;  :num-checks              214
;  :propagations            6491
;  :quant-instantiations    5101
;  :rlimit-count            719784
;  :time                    0.01)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11247
;  :arith-add-rows          6554
;  :arith-assert-diseq      644
;  :arith-assert-lower      3114
;  :arith-assert-upper      2049
;  :arith-bound-prop        966
;  :arith-conflicts         223
;  :arith-eq-adapter        2096
;  :arith-fixed-eqs         1061
;  :arith-offset-eqs        1014
;  :arith-pivots            1844
;  :conflicts               572
;  :datatype-accessor-ax    75
;  :datatype-constructor-ax 479
;  :datatype-occurs-check   231
;  :datatype-splits         191
;  :decisions               1318
;  :del-clause              14727
;  :final-checks            141
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.24
;  :memory                  7.21
;  :minimized-lits          79
;  :mk-bool-var             21045
;  :mk-clause               14864
;  :num-allocs              340258
;  :num-checks              215
;  :propagations            6491
;  :quant-instantiations    5101
;  :rlimit-count            719814)
(assert (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 19
; Joined path conditions
(assert (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))))
        $k@127@03
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12435
;  :arith-add-rows          7969
;  :arith-assert-diseq      750
;  :arith-assert-lower      3551
;  :arith-assert-upper      2315
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2412
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2003
;  :conflicts               617
;  :datatype-accessor-ax    75
;  :datatype-constructor-ax 483
;  :datatype-occurs-check   231
;  :datatype-splits         191
;  :decisions               1422
;  :del-clause              16442
;  :final-checks            141
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.34
;  :minimized-lits          85
;  :mk-bool-var             23289
;  :mk-clause               16719
;  :num-allocs              348663
;  :num-checks              216
;  :propagations            7478
;  :quant-instantiations    5503
;  :rlimit-count            771415
;  :time                    0.02)
(pop) ; 18
(push) ; 18
; [else-branch: 141 | !(i2@133@03 < V@26@03)]
(assert (not (< i2@133@03 V@26@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i2@133@03 V@26@03)
  (and
    (< i2@133@03 V@26@03)
    (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
    (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 140 | !(0 <= i2@133@03)]
(assert (not (<= 0 i2@133@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i2@133@03)
  (and
    (<= 0 i2@133@03)
    (implies
      (< i2@133@03 V@26@03)
      (and
        (< i2@133@03 V@26@03)
        (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
        (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 139 | !(i1@132@03 < V@26@03)]
(assert (not (< i1@132@03 V@26@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (< i1@132@03 V@26@03)
  (and
    (< i1@132@03 V@26@03)
    (implies
      (<= 0 i2@133@03)
      (and
        (<= 0 i2@133@03)
        (implies
          (< i2@133@03 V@26@03)
          (and
            (< i2@133@03 V@26@03)
            (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
            (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 138 | !(0 <= i1@132@03)]
(assert (not (<= 0 i1@132@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (<= 0 i1@132@03)
  (and
    (<= 0 i1@132@03)
    (implies
      (< i1@132@03 V@26@03)
      (and
        (< i1@132@03 V@26@03)
        (implies
          (<= 0 i2@133@03)
          (and
            (<= 0 i2@133@03)
            (implies
              (< i2@133@03 V@26@03)
              (and
                (< i2@133@03 V@26@03)
                (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))))))))))
; Joined path conditions
(push) ; 11
; [then-branch: 142 | Lookup(option$array$,sm@129@03,aloc((_, _), opt_get1(_, G@23@03), i1@132@03)) == Lookup(option$array$,sm@129@03,aloc((_, _), opt_get1(_, G@23@03), i2@133@03)) && i2@133@03 < V@26@03 && 0 <= i2@133@03 && i1@132@03 < V@26@03 && 0 <= i1@132@03 | live]
; [else-branch: 142 | !(Lookup(option$array$,sm@129@03,aloc((_, _), opt_get1(_, G@23@03), i1@132@03)) == Lookup(option$array$,sm@129@03,aloc((_, _), opt_get1(_, G@23@03), i2@133@03)) && i2@133@03 < V@26@03 && 0 <= i2@133@03 && i1@132@03 < V@26@03 && 0 <= i1@132@03) | live]
(push) ; 12
; [then-branch: 142 | Lookup(option$array$,sm@129@03,aloc((_, _), opt_get1(_, G@23@03), i1@132@03)) == Lookup(option$array$,sm@129@03,aloc((_, _), opt_get1(_, G@23@03), i2@133@03)) && i2@133@03 < V@26@03 && 0 <= i2@133@03 && i1@132@03 < V@26@03 && 0 <= i1@132@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
          ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
        (< i2@133@03 V@26@03))
      (<= 0 i2@133@03))
    (< i1@132@03 V@26@03))
  (<= 0 i1@132@03)))
; [eval] i1 == i2
(pop) ; 12
(push) ; 12
; [else-branch: 142 | !(Lookup(option$array$,sm@129@03,aloc((_, _), opt_get1(_, G@23@03), i1@132@03)) == Lookup(option$array$,sm@129@03,aloc((_, _), opt_get1(_, G@23@03), i2@133@03)) && i2@133@03 < V@26@03 && 0 <= i2@133@03 && i1@132@03 < V@26@03 && 0 <= i1@132@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
            ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
          (< i2@133@03 V@26@03))
        (<= 0 i2@133@03))
      (< i1@132@03 V@26@03))
    (<= 0 i1@132@03))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
            ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
          (< i2@133@03 V@26@03))
        (<= 0 i2@133@03))
      (< i1@132@03 V@26@03))
    (<= 0 i1@132@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
      ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
    (< i2@133@03 V@26@03)
    (<= 0 i2@133@03)
    (< i1@132@03 V@26@03)
    (<= 0 i1@132@03))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@133@03 Int)) (!
  (and
    (implies
      (<= 0 i1@132@03)
      (and
        (<= 0 i1@132@03)
        (implies
          (< i1@132@03 V@26@03)
          (and
            (< i1@132@03 V@26@03)
            (implies
              (<= 0 i2@133@03)
              (and
                (<= 0 i2@133@03)
                (implies
                  (< i2@133@03 V@26@03)
                  (and
                    (< i2@133@03 V@26@03)
                    (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                    (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
              (< i2@133@03 V@26@03))
            (<= 0 i2@133@03))
          (< i1@132@03 V@26@03))
        (<= 0 i1@132@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
          ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
        (< i2@133@03 V@26@03)
        (<= 0 i2@133@03)
        (< i1@132@03 V@26@03)
        (<= 0 i1@132@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@132@03 Int)) (!
  (forall ((i2@133@03 Int)) (!
    (and
      (implies
        (<= 0 i1@132@03)
        (and
          (<= 0 i1@132@03)
          (implies
            (< i1@132@03 V@26@03)
            (and
              (< i1@132@03 V@26@03)
              (implies
                (<= 0 i2@133@03)
                (and
                  (<= 0 i2@133@03)
                  (implies
                    (< i2@133@03 V@26@03)
                    (and
                      (< i2@133@03 V@26@03)
                      (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                      (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                  ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
                (< i2@133@03 V@26@03))
              (<= 0 i2@133@03))
            (< i1@132@03 V@26@03))
          (<= 0 i1@132@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
            ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
          (< i2@133@03 V@26@03)
          (<= 0 i2@133@03)
          (< i1@132@03 V@26@03)
          (<= 0 i1@132@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@132@03 Int)) (!
    (forall ((i2@133@03 Int)) (!
      (and
        (implies
          (<= 0 i1@132@03)
          (and
            (<= 0 i1@132@03)
            (implies
              (< i1@132@03 V@26@03)
              (and
                (< i1@132@03 V@26@03)
                (implies
                  (<= 0 i2@133@03)
                  (and
                    (<= 0 i2@133@03)
                    (implies
                      (< i2@133@03 V@26@03)
                      (and
                        (< i2@133@03 V@26@03)
                        (< i1@132@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                        (< i2@133@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                    ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
                  (< i2@133@03 V@26@03))
                (<= 0 i2@133@03))
              (< i1@132@03 V@26@03))
            (<= 0 i1@132@03))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
              ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
            (< i2@133@03 V@26@03)
            (<= 0 i2@133@03)
            (< i1@132@03 V@26@03)
            (<= 0 i1@132@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@132@03 Int)) (!
    (forall ((i2@133@03 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
                  ($FVF.lookup_option$array$ (as sm@129@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03)))
                (< i2@133@03 V@26@03))
              (<= 0 i2@133@03))
            (< i1@132@03 V@26@03))
          (<= 0 i1@132@03))
        (= i1@132@03 i2@133@03))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@133@03))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@132@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))
  $Snap.unit))
; [eval] exc == null ==> target != (None(): option[array])
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12476
;  :arith-add-rows          8010
;  :arith-assert-diseq      750
;  :arith-assert-lower      3551
;  :arith-assert-upper      2315
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2412
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2038
;  :conflicts               617
;  :datatype-accessor-ax    76
;  :datatype-constructor-ax 491
;  :datatype-occurs-check   235
;  :datatype-splits         195
;  :decisions               1430
;  :del-clause              16734
;  :final-checks            143
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.30
;  :minimized-lits          85
;  :mk-bool-var             23310
;  :mk-clause               16743
;  :num-allocs              350412
;  :num-checks              217
;  :propagations            7478
;  :quant-instantiations    5503
;  :rlimit-count            775531)
; [then-branch: 143 | exc@123@03 == Null | live]
; [else-branch: 143 | exc@123@03 != Null | dead]
(push) ; 8
; [then-branch: 143 | exc@123@03 == Null]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (not (= res@74@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(target)) == V
; [eval] exc == null
(push) ; 7
(push) ; 8
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12518
;  :arith-add-rows          8010
;  :arith-assert-diseq      750
;  :arith-assert-lower      3551
;  :arith-assert-upper      2315
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2412
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2038
;  :conflicts               617
;  :datatype-accessor-ax    77
;  :datatype-constructor-ax 499
;  :datatype-occurs-check   239
;  :datatype-splits         199
;  :decisions               1438
;  :del-clause              16734
;  :final-checks            145
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.30
;  :minimized-lits          85
;  :mk-bool-var             23316
;  :mk-clause               16743
;  :num-allocs              351229
;  :num-checks              218
;  :propagations            7478
;  :quant-instantiations    5503
;  :rlimit-count            776515)
; [then-branch: 144 | exc@123@03 == Null | live]
; [else-branch: 144 | exc@123@03 != Null | dead]
(push) ; 8
; [then-branch: 144 | exc@123@03 == Null]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@74@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))
; [eval] exc == null
(push) ; 7
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12562
;  :arith-add-rows          8010
;  :arith-assert-diseq      750
;  :arith-assert-lower      3551
;  :arith-assert-upper      2315
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2412
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2038
;  :conflicts               617
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 508
;  :datatype-occurs-check   243
;  :datatype-splits         204
;  :decisions               1447
;  :del-clause              16734
;  :final-checks            147
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.30
;  :minimized-lits          85
;  :mk-bool-var             23322
;  :mk-clause               16743
;  :num-allocs              352044
;  :num-checks              219
;  :propagations            7478
;  :quant-instantiations    5503
;  :rlimit-count            777491)
; [then-branch: 145 | exc@123@03 == Null | live]
; [else-branch: 145 | exc@123@03 != Null | dead]
(push) ; 7
; [then-branch: 145 | exc@123@03 == Null]
(declare-const i1@134@03 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 146 | 0 <= i1@134@03 | live]
; [else-branch: 146 | !(0 <= i1@134@03) | live]
(push) ; 10
; [then-branch: 146 | 0 <= i1@134@03]
(assert (<= 0 i1@134@03))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 146 | !(0 <= i1@134@03)]
(assert (not (<= 0 i1@134@03)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and (< i1@134@03 V@26@03) (<= 0 i1@134@03)))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@134@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12562
;  :arith-add-rows          8011
;  :arith-assert-diseq      750
;  :arith-assert-lower      3553
;  :arith-assert-upper      2315
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2412
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2038
;  :conflicts               617
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 508
;  :datatype-occurs-check   243
;  :datatype-splits         204
;  :decisions               1447
;  :del-clause              16734
;  :final-checks            147
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.30
;  :minimized-lits          85
;  :mk-bool-var             23324
;  :mk-clause               16743
;  :num-allocs              352147
;  :num-checks              220
;  :propagations            7478
;  :quant-instantiations    5503
;  :rlimit-count            777675)
(assert (< i1@134@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 9
; Joined path conditions
(assert (< i1@134@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(declare-const $k@135@03 $Perm)
(assert ($Perm.isReadVar $k@135@03 $Perm.Write))
(pop) ; 8
(declare-fun inv@136@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@135@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@134@03 Int)) (!
  (< i1@134@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@134@03))
  :qid |option$array$-aux|)))
(push) ; 8
(assert (not (forall ((i1@134@03 Int)) (!
  (implies
    (and (< i1@134@03 V@26@03) (<= 0 i1@134@03))
    (or (= $k@135@03 $Perm.No) (< $Perm.No $k@135@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12562
;  :arith-add-rows          8012
;  :arith-assert-diseq      751
;  :arith-assert-lower      3555
;  :arith-assert-upper      2316
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2413
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2038
;  :conflicts               618
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 508
;  :datatype-occurs-check   243
;  :datatype-splits         204
;  :decisions               1447
;  :del-clause              16734
;  :final-checks            147
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.30
;  :minimized-lits          85
;  :mk-bool-var             23331
;  :mk-clause               16745
;  :num-allocs              352612
;  :num-checks              221
;  :propagations            7479
;  :quant-instantiations    5503
;  :rlimit-count            778246)
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((i11@134@03 Int) (i12@134@03 Int)) (!
  (implies
    (and
      (and (and (< i11@134@03 V@26@03) (<= 0 i11@134@03)) (< $Perm.No $k@135@03))
      (and (and (< i12@134@03 V@26@03) (<= 0 i12@134@03)) (< $Perm.No $k@135@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@134@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@134@03)))
    (= i11@134@03 i12@134@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12570
;  :arith-add-rows          8016
;  :arith-assert-diseq      752
;  :arith-assert-lower      3559
;  :arith-assert-upper      2316
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2414
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2038
;  :conflicts               619
;  :datatype-accessor-ax    78
;  :datatype-constructor-ax 508
;  :datatype-occurs-check   243
;  :datatype-splits         204
;  :decisions               1447
;  :del-clause              16740
;  :final-checks            147
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.29
;  :minimized-lits          85
;  :mk-bool-var             23348
;  :mk-clause               16751
;  :num-allocs              352967
;  :num-checks              222
;  :propagations            7479
;  :quant-instantiations    5513
;  :rlimit-count            778927)
; Definitional axioms for inverse functions
(assert (forall ((i1@134@03 Int)) (!
  (implies
    (and (and (< i1@134@03 V@26@03) (<= 0 i1@134@03)) (< $Perm.No $k@135@03))
    (=
      (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@134@03))
      i1@134@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@134@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
      (< $Perm.No $k@135@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@136@03 r))
      r))
  :pattern ((inv@136@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@134@03 Int)) (!
  (<= $Perm.No $k@135@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@134@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@134@03 Int)) (!
  (<= $k@135@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@134@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@134@03 Int)) (!
  (implies
    (and (and (< i1@134@03 V@26@03) (<= 0 i1@134@03)) (< $Perm.No $k@135@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@134@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@134@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@137@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
      (< $Perm.No $k@135@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r))
  :qid |qp.fvfValDef30|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
      (< $Perm.No $k@127@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 r))
        (pTaken@104@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
            $k@31@03
            $Perm.No)
          (pTaken@94@03 r))
        (pTaken@103@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r) r))
  :pattern ((inv@136@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 8
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12617
;  :arith-add-rows          8016
;  :arith-assert-diseq      752
;  :arith-assert-lower      3559
;  :arith-assert-upper      2317
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2414
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2038
;  :conflicts               619
;  :datatype-accessor-ax    79
;  :datatype-constructor-ax 517
;  :datatype-occurs-check   247
;  :datatype-splits         209
;  :decisions               1456
;  :del-clause              16740
;  :final-checks            149
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.30
;  :minimized-lits          85
;  :mk-bool-var             23365
;  :mk-clause               16751
;  :num-allocs              355749
;  :num-checks              223
;  :propagations            7479
;  :quant-instantiations    5513
;  :rlimit-count            786105)
; [then-branch: 147 | exc@123@03 == Null | live]
; [else-branch: 147 | exc@123@03 != Null | dead]
(push) ; 9
; [then-branch: 147 | exc@123@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@138@03 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 148 | 0 <= i1@138@03 | live]
; [else-branch: 148 | !(0 <= i1@138@03) | live]
(push) ; 12
; [then-branch: 148 | 0 <= i1@138@03]
(assert (<= 0 i1@138@03))
; [eval] i1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 148 | !(0 <= i1@138@03)]
(assert (not (<= 0 i1@138@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(push) ; 11
; [then-branch: 149 | i1@138@03 < V@26@03 && 0 <= i1@138@03 | live]
; [else-branch: 149 | !(i1@138@03 < V@26@03 && 0 <= i1@138@03) | live]
(push) ; 12
; [then-branch: 149 | i1@138@03 < V@26@03 && 0 <= i1@138@03]
(assert (and (< i1@138@03 V@26@03) (<= 0 i1@138@03)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@138@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12617
;  :arith-add-rows          8017
;  :arith-assert-diseq      752
;  :arith-assert-lower      3561
;  :arith-assert-upper      2317
;  :arith-bound-prop        1083
;  :arith-conflicts         246
;  :arith-eq-adapter        2414
;  :arith-fixed-eqs         1206
;  :arith-offset-eqs        1210
;  :arith-pivots            2038
;  :conflicts               619
;  :datatype-accessor-ax    79
;  :datatype-constructor-ax 517
;  :datatype-occurs-check   247
;  :datatype-splits         209
;  :decisions               1456
;  :del-clause              16740
;  :final-checks            149
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.30
;  :minimized-lits          85
;  :mk-bool-var             23367
;  :mk-clause               16751
;  :num-allocs              355852
;  :num-checks              224
;  :propagations            7479
;  :quant-instantiations    5513
;  :rlimit-count            786299)
(assert (< i1@138@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 13
; Joined path conditions
(assert (< i1@138@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)))
(push) ; 13
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13015
;  :arith-add-rows          8602
;  :arith-assert-diseq      792
;  :arith-assert-lower      3714
;  :arith-assert-upper      2403
;  :arith-bound-prop        1148
;  :arith-conflicts         255
;  :arith-eq-adapter        2520
;  :arith-fixed-eqs         1275
;  :arith-offset-eqs        1307
;  :arith-pivots            2120
;  :conflicts               638
;  :datatype-accessor-ax    79
;  :datatype-constructor-ax 521
;  :datatype-occurs-check   247
;  :datatype-splits         209
;  :decisions               1477
;  :del-clause              17122
;  :final-checks            149
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.33
;  :minimized-lits          87
;  :mk-bool-var             24189
;  :mk-clause               17298
;  :num-allocs              359422
;  :num-checks              225
;  :propagations            7718
;  :quant-instantiations    5591
;  :rlimit-count            806156
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 12
(push) ; 12
; [else-branch: 149 | !(i1@138@03 < V@26@03 && 0 <= i1@138@03)]
(assert (not (and (< i1@138@03 V@26@03) (<= 0 i1@138@03))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and (< i1@138@03 V@26@03) (<= 0 i1@138@03))
  (and
    (< i1@138@03 V@26@03)
    (<= 0 i1@138@03)
    (< i1@138@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@138@03 Int)) (!
  (implies
    (and (< i1@138@03 V@26@03) (<= 0 i1@138@03))
    (and
      (< i1@138@03 V@26@03)
      (<= 0 i1@138@03)
      (< i1@138@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@138@03 Int)) (!
    (implies
      (and (< i1@138@03 V@26@03) (<= 0 i1@138@03))
      (and
        (< i1@138@03 V@26@03)
        (<= 0 i1@138@03)
        (< i1@138@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@138@03 Int)) (!
    (implies
      (and (< i1@138@03 V@26@03) (<= 0 i1@138@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@138@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 8
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13063
;  :arith-add-rows          8612
;  :arith-assert-diseq      792
;  :arith-assert-lower      3714
;  :arith-assert-upper      2403
;  :arith-bound-prop        1148
;  :arith-conflicts         255
;  :arith-eq-adapter        2520
;  :arith-fixed-eqs         1275
;  :arith-offset-eqs        1307
;  :arith-pivots            2135
;  :conflicts               638
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 530
;  :datatype-occurs-check   251
;  :datatype-splits         214
;  :decisions               1486
;  :del-clause              17287
;  :final-checks            151
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.32
;  :minimized-lits          87
;  :mk-bool-var             24198
;  :mk-clause               17298
;  :num-allocs              360607
;  :num-checks              226
;  :propagations            7718
;  :quant-instantiations    5591
;  :rlimit-count            808217)
; [then-branch: 150 | exc@123@03 == Null | live]
; [else-branch: 150 | exc@123@03 != Null | dead]
(push) ; 9
; [then-branch: 150 | exc@123@03 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@139@03 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 151 | 0 <= i1@139@03 | live]
; [else-branch: 151 | !(0 <= i1@139@03) | live]
(push) ; 12
; [then-branch: 151 | 0 <= i1@139@03]
(assert (<= 0 i1@139@03))
; [eval] i1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 151 | !(0 <= i1@139@03)]
(assert (not (<= 0 i1@139@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(push) ; 11
; [then-branch: 152 | i1@139@03 < V@26@03 && 0 <= i1@139@03 | live]
; [else-branch: 152 | !(i1@139@03 < V@26@03 && 0 <= i1@139@03) | live]
(push) ; 12
; [then-branch: 152 | i1@139@03 < V@26@03 && 0 <= i1@139@03]
(assert (and (< i1@139@03 V@26@03) (<= 0 i1@139@03)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13063
;  :arith-add-rows          8613
;  :arith-assert-diseq      792
;  :arith-assert-lower      3716
;  :arith-assert-upper      2403
;  :arith-bound-prop        1148
;  :arith-conflicts         255
;  :arith-eq-adapter        2520
;  :arith-fixed-eqs         1275
;  :arith-offset-eqs        1307
;  :arith-pivots            2135
;  :conflicts               638
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 530
;  :datatype-occurs-check   251
;  :datatype-splits         214
;  :decisions               1486
;  :del-clause              17287
;  :final-checks            151
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.32
;  :minimized-lits          87
;  :mk-bool-var             24200
;  :mk-clause               17298
;  :num-allocs              360710
;  :num-checks              227
;  :propagations            7718
;  :quant-instantiations    5591
;  :rlimit-count            808413)
(assert (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 13
; Joined path conditions
(assert (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)))
(push) ; 13
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)))))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13214
;  :arith-add-rows          8806
;  :arith-assert-diseq      802
;  :arith-assert-lower      3768
;  :arith-assert-upper      2446
;  :arith-bound-prop        1170
;  :arith-conflicts         263
;  :arith-eq-adapter        2558
;  :arith-fixed-eqs         1300
;  :arith-offset-eqs        1320
;  :arith-pivots            2176
;  :conflicts               654
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 534
;  :datatype-occurs-check   251
;  :datatype-splits         214
;  :decisions               1501
;  :del-clause              17399
;  :final-checks            151
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.34
;  :minimized-lits          87
;  :mk-bool-var             24628
;  :mk-clause               17575
;  :num-allocs              362833
;  :num-checks              228
;  :propagations            7805
;  :quant-instantiations    5667
;  :rlimit-count            818062
;  :time                    0.00)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 14
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13214
;  :arith-add-rows          8806
;  :arith-assert-diseq      802
;  :arith-assert-lower      3768
;  :arith-assert-upper      2446
;  :arith-bound-prop        1170
;  :arith-conflicts         263
;  :arith-eq-adapter        2558
;  :arith-fixed-eqs         1300
;  :arith-offset-eqs        1320
;  :arith-pivots            2176
;  :conflicts               655
;  :datatype-accessor-ax    80
;  :datatype-constructor-ax 534
;  :datatype-occurs-check   251
;  :datatype-splits         214
;  :decisions               1501
;  :del-clause              17399
;  :final-checks            151
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.34
;  :minimized-lits          87
;  :mk-bool-var             24628
;  :mk-clause               17575
;  :num-allocs              362922
;  :num-checks              229
;  :propagations            7805
;  :quant-instantiations    5667
;  :rlimit-count            818157)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
    (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
    (as None<option<array>>  option<array>))))
(pop) ; 12
(push) ; 12
; [else-branch: 152 | !(i1@139@03 < V@26@03 && 0 <= i1@139@03)]
(assert (not (and (< i1@139@03 V@26@03) (<= 0 i1@139@03))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and (< i1@139@03 V@26@03) (<= 0 i1@139@03))
  (and
    (< i1@139@03 V@26@03)
    (<= 0 i1@139@03)
    (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@139@03 Int)) (!
  (implies
    (and (< i1@139@03 V@26@03) (<= 0 i1@139@03))
    (and
      (< i1@139@03 V@26@03)
      (<= 0 i1@139@03)
      (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@139@03 Int)) (!
    (implies
      (and (< i1@139@03 V@26@03) (<= 0 i1@139@03))
      (and
        (< i1@139@03 V@26@03)
        (<= 0 i1@139@03)
        (< i1@139@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@139@03 Int)) (!
    (implies
      (and (< i1@139@03 V@26@03) (<= 0 i1@139@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03))))
        V@26@03))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@139@03)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 8
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13263
;  :arith-add-rows          8813
;  :arith-assert-diseq      802
;  :arith-assert-lower      3768
;  :arith-assert-upper      2446
;  :arith-bound-prop        1170
;  :arith-conflicts         263
;  :arith-eq-adapter        2558
;  :arith-fixed-eqs         1300
;  :arith-offset-eqs        1320
;  :arith-pivots            2184
;  :conflicts               655
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 543
;  :datatype-occurs-check   255
;  :datatype-splits         219
;  :decisions               1510
;  :del-clause              17564
;  :final-checks            153
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.32
;  :minimized-lits          87
;  :mk-bool-var             24637
;  :mk-clause               17575
;  :num-allocs              364138
;  :num-checks              230
;  :propagations            7805
;  :quant-instantiations    5667
;  :rlimit-count            820255)
; [then-branch: 153 | exc@123@03 == Null | live]
; [else-branch: 153 | exc@123@03 != Null | dead]
(push) ; 9
; [then-branch: 153 | exc@123@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@140@03 Int)
(push) ; 10
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@141@03 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 154 | 0 <= i1@140@03 | live]
; [else-branch: 154 | !(0 <= i1@140@03) | live]
(push) ; 13
; [then-branch: 154 | 0 <= i1@140@03]
(assert (<= 0 i1@140@03))
; [eval] i1 < V
(push) ; 14
; [then-branch: 155 | i1@140@03 < V@26@03 | live]
; [else-branch: 155 | !(i1@140@03 < V@26@03) | live]
(push) ; 15
; [then-branch: 155 | i1@140@03 < V@26@03]
(assert (< i1@140@03 V@26@03))
; [eval] 0 <= i2
(push) ; 16
; [then-branch: 156 | 0 <= i2@141@03 | live]
; [else-branch: 156 | !(0 <= i2@141@03) | live]
(push) ; 17
; [then-branch: 156 | 0 <= i2@141@03]
(assert (<= 0 i2@141@03))
; [eval] i2 < V
(push) ; 18
; [then-branch: 157 | i2@141@03 < V@26@03 | live]
; [else-branch: 157 | !(i2@141@03 < V@26@03) | live]
(push) ; 19
; [then-branch: 157 | i2@141@03 < V@26@03]
(assert (< i2@141@03 V@26@03))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(push) ; 20
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 21
(assert (not (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13263
;  :arith-add-rows          8815
;  :arith-assert-diseq      802
;  :arith-assert-lower      3772
;  :arith-assert-upper      2446
;  :arith-bound-prop        1170
;  :arith-conflicts         263
;  :arith-eq-adapter        2558
;  :arith-fixed-eqs         1300
;  :arith-offset-eqs        1320
;  :arith-pivots            2184
;  :conflicts               655
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 543
;  :datatype-occurs-check   255
;  :datatype-splits         219
;  :decisions               1510
;  :del-clause              17564
;  :final-checks            153
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.36
;  :memory                  7.33
;  :minimized-lits          87
;  :mk-bool-var             24641
;  :mk-clause               17575
;  :num-allocs              364418
;  :num-checks              231
;  :propagations            7805
;  :quant-instantiations    5667
;  :rlimit-count            820595)
(assert (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 20
; Joined path conditions
(assert (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)))
(push) ; 20
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)))))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13497
;  :arith-add-rows          9064
;  :arith-assert-diseq      816
;  :arith-assert-lower      3849
;  :arith-assert-upper      2503
;  :arith-bound-prop        1189
;  :arith-conflicts         274
;  :arith-eq-adapter        2613
;  :arith-fixed-eqs         1331
;  :arith-offset-eqs        1366
;  :arith-pivots            2240
;  :conflicts               674
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 547
;  :datatype-occurs-check   255
;  :datatype-splits         219
;  :decisions               1531
;  :del-clause              17695
;  :final-checks            153
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.38
;  :memory                  7.36
;  :minimized-lits          87
;  :mk-bool-var             25112
;  :mk-clause               17871
;  :num-allocs              366748
;  :num-checks              232
;  :propagations            7997
;  :quant-instantiations    5749
;  :rlimit-count            832110
;  :time                    0.00)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(push) ; 20
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 21
(assert (not (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               13497
;  :arith-add-rows          9064
;  :arith-assert-diseq      816
;  :arith-assert-lower      3849
;  :arith-assert-upper      2503
;  :arith-bound-prop        1189
;  :arith-conflicts         274
;  :arith-eq-adapter        2613
;  :arith-fixed-eqs         1331
;  :arith-offset-eqs        1366
;  :arith-pivots            2240
;  :conflicts               674
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 547
;  :datatype-occurs-check   255
;  :datatype-splits         219
;  :decisions               1531
;  :del-clause              17695
;  :final-checks            153
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.38
;  :memory                  7.36
;  :minimized-lits          87
;  :mk-bool-var             25112
;  :mk-clause               17871
;  :num-allocs              366774
;  :num-checks              233
;  :propagations            7997
;  :quant-instantiations    5749
;  :rlimit-count            832140)
(assert (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 20
; Joined path conditions
(assert (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
(push) ; 20
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))))))
(check-sat)
; unsat
(pop) ; 20
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15849
;  :arith-add-rows          10680
;  :arith-assert-diseq      997
;  :arith-assert-lower      4678
;  :arith-assert-upper      2985
;  :arith-bound-prop        1364
;  :arith-conflicts         298
;  :arith-eq-adapter        3115
;  :arith-fixed-eqs         1609
;  :arith-offset-eqs        1724
;  :arith-pivots            2425
;  :conflicts               738
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 551
;  :datatype-occurs-check   255
;  :datatype-splits         219
;  :decisions               1761
;  :del-clause              20577
;  :final-checks            153
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.88
;  :memory                  7.85
;  :minimized-lits          97
;  :mk-bool-var             29093
;  :mk-clause               20893
;  :num-allocs              382009
;  :num-checks              234
;  :propagations            10224
;  :quant-instantiations    6632
;  :rlimit-count            923273
;  :time                    0.05)
(pop) ; 19
(push) ; 19
; [else-branch: 157 | !(i2@141@03 < V@26@03)]
(assert (not (< i2@141@03 V@26@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i2@141@03 V@26@03)
  (and
    (< i2@141@03 V@26@03)
    (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
    (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 156 | !(0 <= i2@141@03)]
(assert (not (<= 0 i2@141@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i2@141@03)
  (and
    (<= 0 i2@141@03)
    (implies
      (< i2@141@03 V@26@03)
      (and
        (< i2@141@03 V@26@03)
        (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
        (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 155 | !(i1@140@03 < V@26@03)]
(assert (not (< i1@140@03 V@26@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i1@140@03 V@26@03)
  (and
    (< i1@140@03 V@26@03)
    (implies
      (<= 0 i2@141@03)
      (and
        (<= 0 i2@141@03)
        (implies
          (< i2@141@03 V@26@03)
          (and
            (< i2@141@03 V@26@03)
            (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
            (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 154 | !(0 <= i1@140@03)]
(assert (not (<= 0 i1@140@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i1@140@03)
  (and
    (<= 0 i1@140@03)
    (implies
      (< i1@140@03 V@26@03)
      (and
        (< i1@140@03 V@26@03)
        (implies
          (<= 0 i2@141@03)
          (and
            (<= 0 i2@141@03)
            (implies
              (< i2@141@03 V@26@03)
              (and
                (< i2@141@03 V@26@03)
                (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))))))))))
; Joined path conditions
(push) ; 12
; [then-branch: 158 | Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i1@140@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i2@141@03)) && i2@141@03 < V@26@03 && 0 <= i2@141@03 && i1@140@03 < V@26@03 && 0 <= i1@140@03 | live]
; [else-branch: 158 | !(Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i1@140@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i2@141@03)) && i2@141@03 < V@26@03 && 0 <= i2@141@03 && i1@140@03 < V@26@03 && 0 <= i1@140@03) | live]
(push) ; 13
; [then-branch: 158 | Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i1@140@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i2@141@03)) && i2@141@03 < V@26@03 && 0 <= i2@141@03 && i1@140@03 < V@26@03 && 0 <= i1@140@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
        (< i2@141@03 V@26@03))
      (<= 0 i2@141@03))
    (< i1@140@03 V@26@03))
  (<= 0 i1@140@03)))
; [eval] i1 == i2
(pop) ; 13
(push) ; 13
; [else-branch: 158 | !(Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i1@140@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i2@141@03)) && i2@141@03 < V@26@03 && 0 <= i2@141@03 && i1@140@03 < V@26@03 && 0 <= i1@140@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
          (< i2@141@03 V@26@03))
        (<= 0 i2@141@03))
      (< i1@140@03 V@26@03))
    (<= 0 i1@140@03))))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
          (< i2@141@03 V@26@03))
        (<= 0 i2@141@03))
      (< i1@140@03 V@26@03))
    (<= 0 i1@140@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
    (< i2@141@03 V@26@03)
    (<= 0 i2@141@03)
    (< i1@140@03 V@26@03)
    (<= 0 i1@140@03))))
; Joined path conditions
(pop) ; 11
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@141@03 Int)) (!
  (and
    (implies
      (<= 0 i1@140@03)
      (and
        (<= 0 i1@140@03)
        (implies
          (< i1@140@03 V@26@03)
          (and
            (< i1@140@03 V@26@03)
            (implies
              (<= 0 i2@141@03)
              (and
                (<= 0 i2@141@03)
                (implies
                  (< i2@141@03 V@26@03)
                  (and
                    (< i2@141@03 V@26@03)
                    (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                    (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
              (< i2@141@03 V@26@03))
            (<= 0 i2@141@03))
          (< i1@140@03 V@26@03))
        (<= 0 i1@140@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
        (< i2@141@03 V@26@03)
        (<= 0 i2@141@03)
        (< i1@140@03 V@26@03)
        (<= 0 i1@140@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@140@03 Int)) (!
  (forall ((i2@141@03 Int)) (!
    (and
      (implies
        (<= 0 i1@140@03)
        (and
          (<= 0 i1@140@03)
          (implies
            (< i1@140@03 V@26@03)
            (and
              (< i1@140@03 V@26@03)
              (implies
                (<= 0 i2@141@03)
                (and
                  (<= 0 i2@141@03)
                  (implies
                    (< i2@141@03 V@26@03)
                    (and
                      (< i2@141@03 V@26@03)
                      (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                      (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                  ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
                (< i2@141@03 V@26@03))
              (<= 0 i2@141@03))
            (< i1@140@03 V@26@03))
          (<= 0 i1@140@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
          (< i2@141@03 V@26@03)
          (<= 0 i2@141@03)
          (< i1@140@03 V@26@03)
          (<= 0 i1@140@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@140@03 Int)) (!
    (forall ((i2@141@03 Int)) (!
      (and
        (implies
          (<= 0 i1@140@03)
          (and
            (<= 0 i1@140@03)
            (implies
              (< i1@140@03 V@26@03)
              (and
                (< i1@140@03 V@26@03)
                (implies
                  (<= 0 i2@141@03)
                  (and
                    (<= 0 i2@141@03)
                    (implies
                      (< i2@141@03 V@26@03)
                      (and
                        (< i2@141@03 V@26@03)
                        (< i1@140@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                        (< i2@141@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
                  (< i2@141@03 V@26@03))
                (<= 0 i2@141@03))
              (< i1@140@03 V@26@03))
            (<= 0 i1@140@03))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
              ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
            (< i2@141@03 V@26@03)
            (<= 0 i2@141@03)
            (< i1@140@03 V@26@03)
            (<= 0 i1@140@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((i1@140@03 Int)) (!
    (forall ((i2@141@03 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
                  ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03)))
                (< i2@141@03 V@26@03))
              (<= 0 i2@141@03))
            (< i1@140@03 V@26@03))
          (<= 0 i1@140@03))
        (= i1@140@03 i2@141@03))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@141@03))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@140@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15900
;  :arith-add-rows          10717
;  :arith-assert-diseq      997
;  :arith-assert-lower      4678
;  :arith-assert-upper      2985
;  :arith-bound-prop        1364
;  :arith-conflicts         298
;  :arith-eq-adapter        3115
;  :arith-fixed-eqs         1609
;  :arith-offset-eqs        1724
;  :arith-pivots            2463
;  :conflicts               738
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 561
;  :datatype-occurs-check   259
;  :datatype-splits         225
;  :decisions               1771
;  :del-clause              20906
;  :final-checks            155
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.88
;  :memory                  7.82
;  :minimized-lits          97
;  :mk-bool-var             29115
;  :mk-clause               20917
;  :num-allocs              383709
;  :num-checks              235
;  :propagations            10224
;  :quant-instantiations    6632
;  :rlimit-count            927289)
; [then-branch: 159 | exc@123@03 == Null | live]
; [else-branch: 159 | exc@123@03 != Null | dead]
(push) ; 8
; [then-branch: 159 | exc@123@03 == Null]
(declare-const i1@142@03 Int)
(declare-const j1@143@03 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 160 | 0 <= i1@142@03 | live]
; [else-branch: 160 | !(0 <= i1@142@03) | live]
(push) ; 11
; [then-branch: 160 | 0 <= i1@142@03]
(assert (<= 0 i1@142@03))
; [eval] i1 < V
(push) ; 12
; [then-branch: 161 | i1@142@03 < V@26@03 | live]
; [else-branch: 161 | !(i1@142@03 < V@26@03) | live]
(push) ; 13
; [then-branch: 161 | i1@142@03 < V@26@03]
(assert (< i1@142@03 V@26@03))
; [eval] 0 <= j1
(push) ; 14
; [then-branch: 162 | 0 <= j1@143@03 | live]
; [else-branch: 162 | !(0 <= j1@143@03) | live]
(push) ; 15
; [then-branch: 162 | 0 <= j1@143@03]
(assert (<= 0 j1@143@03))
; [eval] j1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 162 | !(0 <= j1@143@03)]
(assert (not (<= 0 j1@143@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 161 | !(i1@142@03 < V@26@03)]
(assert (not (< i1@142@03 V@26@03)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 160 | !(0 <= i1@142@03)]
(assert (not (<= 0 i1@142@03)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@143@03 V@26@03) (<= 0 j1@143@03)) (< i1@142@03 V@26@03))
  (<= 0 i1@142@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@142@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               15900
;  :arith-add-rows          10720
;  :arith-assert-diseq      997
;  :arith-assert-lower      4684
;  :arith-assert-upper      2985
;  :arith-bound-prop        1364
;  :arith-conflicts         298
;  :arith-eq-adapter        3115
;  :arith-fixed-eqs         1609
;  :arith-offset-eqs        1724
;  :arith-pivots            2463
;  :conflicts               738
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 561
;  :datatype-occurs-check   259
;  :datatype-splits         225
;  :decisions               1771
;  :del-clause              20906
;  :final-checks            155
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.88
;  :memory                  7.84
;  :minimized-lits          97
;  :mk-bool-var             29121
;  :mk-clause               20917
;  :num-allocs              383983
;  :num-checks              236
;  :propagations            10224
;  :quant-instantiations    6632
;  :rlimit-count            927762)
(assert (< i1@142@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 10
; Joined path conditions
(assert (< i1@142@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16508
;  :arith-add-rows          11613
;  :arith-assert-diseq      1057
;  :arith-assert-lower      4915
;  :arith-assert-upper      3121
;  :arith-bound-prop        1448
;  :arith-conflicts         311
;  :arith-eq-adapter        3273
;  :arith-fixed-eqs         1679
;  :arith-offset-eqs        1828
;  :arith-pivots            2570
;  :conflicts               767
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 565
;  :datatype-occurs-check   259
;  :datatype-splits         225
;  :decisions               1828
;  :del-clause              21714
;  :final-checks            155
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.88
;  :memory                  7.85
;  :minimized-lits          99
;  :mk-bool-var             30462
;  :mk-clause               21894
;  :num-allocs              389577
;  :num-checks              237
;  :propagations            10699
;  :quant-instantiations    6801
;  :rlimit-count            963216
;  :time                    0.01)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16556
;  :arith-add-rows          11626
;  :arith-assert-diseq      1057
;  :arith-assert-lower      4916
;  :arith-assert-upper      3123
;  :arith-bound-prop        1454
;  :arith-conflicts         312
;  :arith-eq-adapter        3274
;  :arith-fixed-eqs         1679
;  :arith-offset-eqs        1841
;  :arith-pivots            2571
;  :conflicts               774
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 569
;  :datatype-occurs-check   259
;  :datatype-splits         225
;  :decisions               1834
;  :del-clause              21724
;  :final-checks            155
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.88
;  :memory                  7.85
;  :minimized-lits          99
;  :mk-bool-var             30468
;  :mk-clause               21904
;  :num-allocs              389684
;  :num-checks              238
;  :propagations            10722
;  :quant-instantiations    6802
;  :rlimit-count            963835)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  j1@143@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16740
;  :arith-add-rows          11745
;  :arith-assert-diseq      1066
;  :arith-assert-lower      4972
;  :arith-assert-upper      3154
;  :arith-bound-prop        1468
;  :arith-conflicts         316
;  :arith-eq-adapter        3312
;  :arith-fixed-eqs         1697
;  :arith-offset-eqs        1869
;  :arith-pivots            2594
;  :conflicts               790
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 573
;  :datatype-occurs-check   259
;  :datatype-splits         225
;  :decisions               1859
;  :del-clause              21846
;  :final-checks            155
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.88
;  :memory                  7.85
;  :minimized-lits          100
;  :mk-bool-var             30659
;  :mk-clause               22026
;  :num-allocs              390715
;  :num-checks              239
;  :propagations            10822
;  :quant-instantiations    6837
;  :rlimit-count            968326
;  :time                    0.00)
(assert (<
  j1@143@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))))))
(pop) ; 10
; Joined path conditions
(assert (<
  j1@143@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))))))
(declare-const $k@144@03 $Perm)
(assert ($Perm.isReadVar $k@144@03 $Perm.Write))
(pop) ; 9
(declare-fun inv@145@03 ($Ref) Int)
(declare-fun inv@146@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@144@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@142@03 Int) (j1@143@03 Int)) (!
  (and
    (< i1@142@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@143@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))) j1@143@03))
  :qid |int-aux|)))
(push) ; 9
(assert (not (forall ((i1@142@03 Int) (j1@143@03 Int)) (!
  (implies
    (and
      (and (and (< j1@143@03 V@26@03) (<= 0 j1@143@03)) (< i1@142@03 V@26@03))
      (<= 0 i1@142@03))
    (or (= $k@144@03 $Perm.No) (< $Perm.No $k@144@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16740
;  :arith-add-rows          11774
;  :arith-assert-diseq      1067
;  :arith-assert-lower      4974
;  :arith-assert-upper      3155
;  :arith-bound-prop        1468
;  :arith-conflicts         316
;  :arith-eq-adapter        3313
;  :arith-fixed-eqs         1697
;  :arith-offset-eqs        1869
;  :arith-pivots            2616
;  :conflicts               791
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 573
;  :datatype-occurs-check   259
;  :datatype-splits         225
;  :decisions               1859
;  :del-clause              22015
;  :final-checks            155
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.88
;  :memory                  7.82
;  :minimized-lits          100
;  :mk-bool-var             30668
;  :mk-clause               22028
;  :num-allocs              391273
;  :num-checks              240
;  :propagations            10823
;  :quant-instantiations    6837
;  :rlimit-count            969780)
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((i11@142@03 Int) (j11@143@03 Int) (i12@142@03 Int) (j12@143@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@143@03 V@26@03) (<= 0 j11@143@03))
            (< i11@142@03 V@26@03))
          (<= 0 i11@142@03))
        (< $Perm.No $k@144@03))
      (and
        (and
          (and
            (and (< j12@143@03 V@26@03) (<= 0 j12@143@03))
            (< i12@142@03 V@26@03))
          (<= 0 i12@142@03))
        (< $Perm.No $k@144@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@142@03))) j11@143@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@142@03))) j12@143@03)))
    (and (= i11@142@03 i12@142@03) (= j11@143@03 j12@143@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16920
;  :arith-add-rows          11942
;  :arith-assert-diseq      1070
;  :arith-assert-lower      5018
;  :arith-assert-upper      3180
;  :arith-bound-prop        1500
;  :arith-conflicts         318
;  :arith-eq-adapter        3339
;  :arith-fixed-eqs         1715
;  :arith-offset-eqs        1896
;  :arith-pivots            2668
;  :conflicts               800
;  :datatype-accessor-ax    82
;  :datatype-constructor-ax 577
;  :datatype-occurs-check   259
;  :datatype-splits         225
;  :decisions               1873
;  :del-clause              22401
;  :final-checks            155
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.89
;  :memory                  7.83
;  :minimized-lits          100
;  :mk-bool-var             31280
;  :mk-clause               22414
;  :num-allocs              394148
;  :num-checks              241
;  :propagations            10889
;  :quant-instantiations    6983
;  :rlimit-count            981941
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@142@03 Int) (j1@143@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@143@03 V@26@03) (<= 0 j1@143@03)) (< i1@142@03 V@26@03))
        (<= 0 i1@142@03))
      (< $Perm.No $k@144@03))
    (and
      (=
        (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))) j1@143@03))
        i1@142@03)
      (=
        (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))) j1@143@03))
        j1@143@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))) j1@143@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@145@03 r)))) (inv@146@03 r))
      r))
  :pattern ((inv@145@03 r))
  :pattern ((inv@146@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@142@03 Int) (j1@143@03 Int)) (!
  (<= $Perm.No $k@144@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))) j1@143@03))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@142@03 Int) (j1@143@03 Int)) (!
  (<= $k@144@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))) j1@143@03))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@142@03 Int) (j1@143@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@143@03 V@26@03) (<= 0 j1@143@03)) (< i1@142@03 V@26@03))
        (<= 0 i1@142@03))
      (< $Perm.No $k@144@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))) j1@143@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@142@03))) j1@143@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@147@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@147@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@147@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r)))
    (=
      ($FVF.lookup_int (as sm@147@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@147@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r)))
    (=
      ($FVF.lookup_int (as sm@147@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@147@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@147@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef38|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
        (< (inv@145@03 r) V@26@03))
      (<= 0 (inv@145@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@147@03  $FVF<Int>) r) r))
  :pattern ((inv@145@03 r) (inv@146@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16975
;  :arith-add-rows          11942
;  :arith-assert-diseq      1070
;  :arith-assert-lower      5018
;  :arith-assert-upper      3181
;  :arith-bound-prop        1500
;  :arith-conflicts         318
;  :arith-eq-adapter        3339
;  :arith-fixed-eqs         1715
;  :arith-offset-eqs        1896
;  :arith-pivots            2668
;  :conflicts               800
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 588
;  :datatype-occurs-check   263
;  :datatype-splits         232
;  :decisions               1884
;  :del-clause              22401
;  :final-checks            157
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.89
;  :memory                  7.84
;  :minimized-lits          100
;  :mk-bool-var             31297
;  :mk-clause               22414
;  :num-allocs              396917
;  :num-checks              242
;  :propagations            10889
;  :quant-instantiations    6983
;  :rlimit-count            991280
;  :time                    0.00)
; [then-branch: 163 | exc@123@03 == Null | live]
; [else-branch: 163 | exc@123@03 != Null | dead]
(push) ; 9
; [then-branch: 163 | exc@123@03 == Null]
(declare-const i1@148@03 Int)
(declare-const j1@149@03 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 164 | 0 <= i1@148@03 | live]
; [else-branch: 164 | !(0 <= i1@148@03) | live]
(push) ; 12
; [then-branch: 164 | 0 <= i1@148@03]
(assert (<= 0 i1@148@03))
; [eval] i1 < V
(push) ; 13
; [then-branch: 165 | i1@148@03 < V@26@03 | live]
; [else-branch: 165 | !(i1@148@03 < V@26@03) | live]
(push) ; 14
; [then-branch: 165 | i1@148@03 < V@26@03]
(assert (< i1@148@03 V@26@03))
; [eval] 0 <= j1
(push) ; 15
; [then-branch: 166 | 0 <= j1@149@03 | live]
; [else-branch: 166 | !(0 <= j1@149@03) | live]
(push) ; 16
; [then-branch: 166 | 0 <= j1@149@03]
(assert (<= 0 j1@149@03))
; [eval] j1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 166 | !(0 <= j1@149@03)]
(assert (not (<= 0 j1@149@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 165 | !(i1@148@03 < V@26@03)]
(assert (not (< i1@148@03 V@26@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 164 | !(0 <= i1@148@03)]
(assert (not (<= 0 i1@148@03)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@149@03 V@26@03) (<= 0 j1@149@03)) (< i1@148@03 V@26@03))
  (<= 0 i1@148@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@148@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16975
;  :arith-add-rows          11945
;  :arith-assert-diseq      1070
;  :arith-assert-lower      5024
;  :arith-assert-upper      3181
;  :arith-bound-prop        1500
;  :arith-conflicts         318
;  :arith-eq-adapter        3339
;  :arith-fixed-eqs         1715
;  :arith-offset-eqs        1896
;  :arith-pivots            2668
;  :conflicts               800
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 588
;  :datatype-occurs-check   263
;  :datatype-splits         232
;  :decisions               1884
;  :del-clause              22401
;  :final-checks            157
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.89
;  :memory                  7.84
;  :minimized-lits          100
;  :mk-bool-var             31303
;  :mk-clause               22414
;  :num-allocs              397190
;  :num-checks              243
;  :propagations            10889
;  :quant-instantiations    6983
;  :rlimit-count            991753)
(assert (< i1@148@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 11
; Joined path conditions
(assert (< i1@148@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03)))
(push) ; 11
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17495
;  :arith-add-rows          12368
;  :arith-assert-diseq      1114
;  :arith-assert-lower      5248
;  :arith-assert-upper      3313
;  :arith-bound-prop        1585
;  :arith-conflicts         326
;  :arith-eq-adapter        3465
;  :arith-fixed-eqs         1773
;  :arith-offset-eqs        2011
;  :arith-pivots            2742
;  :conflicts               827
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 592
;  :datatype-occurs-check   263
;  :datatype-splits         232
;  :decisions               1959
;  :del-clause              23153
;  :final-checks            157
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.89
;  :memory                  7.87
;  :minimized-lits          100
;  :mk-bool-var             32621
;  :mk-clause               23332
;  :num-allocs              402323
;  :num-checks              244
;  :propagations            11358
;  :quant-instantiations    7171
;  :rlimit-count            1012563
;  :time                    0.01)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17495
;  :arith-add-rows          12368
;  :arith-assert-diseq      1114
;  :arith-assert-lower      5248
;  :arith-assert-upper      3313
;  :arith-bound-prop        1585
;  :arith-conflicts         326
;  :arith-eq-adapter        3465
;  :arith-fixed-eqs         1773
;  :arith-offset-eqs        2011
;  :arith-pivots            2742
;  :conflicts               828
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 592
;  :datatype-occurs-check   263
;  :datatype-splits         232
;  :decisions               1959
;  :del-clause              23153
;  :final-checks            157
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.89
;  :memory                  7.87
;  :minimized-lits          100
;  :mk-bool-var             32621
;  :mk-clause               23332
;  :num-allocs              402413
;  :num-checks              245
;  :propagations            11358
;  :quant-instantiations    7171
;  :rlimit-count            1012658)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
    (as None<option<array>>  option<array>))))
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 12
(assert (not (<
  j1@149@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17501
;  :arith-add-rows          12374
;  :arith-assert-diseq      1114
;  :arith-assert-lower      5250
;  :arith-assert-upper      3315
;  :arith-bound-prop        1585
;  :arith-conflicts         327
;  :arith-eq-adapter        3466
;  :arith-fixed-eqs         1774
;  :arith-offset-eqs        2011
;  :arith-pivots            2746
;  :conflicts               829
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 592
;  :datatype-occurs-check   263
;  :datatype-splits         232
;  :decisions               1959
;  :del-clause              23157
;  :final-checks            157
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.89
;  :memory                  7.87
;  :minimized-lits          100
;  :mk-bool-var             32632
;  :mk-clause               23336
;  :num-allocs              402598
;  :num-checks              246
;  :propagations            11360
;  :quant-instantiations    7178
;  :rlimit-count            1013174)
(assert (<
  j1@149@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))))))
(pop) ; 11
; Joined path conditions
(assert (<
  j1@149@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))))))
(pop) ; 10
(declare-fun inv@150@03 ($Ref) Int)
(declare-fun inv@151@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@148@03 Int) (j1@149@03 Int)) (!
  (and
    (< i1@148@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@149@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))) j1@149@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 10
(assert (not (forall ((i11@148@03 Int) (j11@149@03 Int) (i12@148@03 Int) (j12@149@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@149@03 V@26@03) (<= 0 j11@149@03))
          (< i11@148@03 V@26@03))
        (<= 0 i11@148@03))
      (and
        (and
          (and (< j12@149@03 V@26@03) (<= 0 j12@149@03))
          (< i12@148@03 V@26@03))
        (<= 0 i12@148@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@148@03))) j11@149@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@148@03))) j12@149@03)))
    (and (= i11@148@03 i12@148@03) (= j11@149@03 j12@149@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17572
;  :arith-add-rows          12438
;  :arith-assert-diseq      1114
;  :arith-assert-lower      5265
;  :arith-assert-upper      3322
;  :arith-bound-prop        1590
;  :arith-conflicts         327
;  :arith-eq-adapter        3490
;  :arith-fixed-eqs         1779
;  :arith-offset-eqs        2011
;  :arith-pivots            2778
;  :conflicts               830
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 592
;  :datatype-occurs-check   263
;  :datatype-splits         232
;  :decisions               1959
;  :del-clause              23663
;  :final-checks            157
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.94
;  :memory                  7.88
;  :minimized-lits          100
;  :mk-bool-var             33141
;  :mk-clause               23676
;  :num-allocs              405259
;  :num-checks              247
;  :propagations            11398
;  :quant-instantiations    7315
;  :rlimit-count            1022628
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@148@03 Int) (j1@149@03 Int)) (!
  (implies
    (and
      (and (and (< j1@149@03 V@26@03) (<= 0 j1@149@03)) (< i1@148@03 V@26@03))
      (<= 0 i1@148@03))
    (and
      (=
        (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))) j1@149@03))
        i1@148@03)
      (=
        (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))) j1@149@03))
        j1@149@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))) j1@149@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
        (< (inv@150@03 r) V@26@03))
      (<= 0 (inv@150@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@150@03 r)))) (inv@151@03 r))
      r))
  :pattern ((inv@150@03 r))
  :pattern ((inv@151@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@148@03 Int) (j1@149@03 Int)) (!
  (implies
    (and
      (and (and (< j1@149@03 V@26@03) (<= 0 j1@149@03)) (< i1@148@03 V@26@03))
      (<= 0 i1@148@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))) j1@149@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@148@03))) j1@149@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@152@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
        (< (inv@150@03 r) V@26@03))
      (<= 0 (inv@150@03 r)))
    (=
      ($FVF.lookup_int (as sm@152@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef39|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@152@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef40|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r)))
    (=
      ($FVF.lookup_int (as sm@152@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef41|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r)))
    (=
      ($FVF.lookup_int (as sm@152@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@152@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@152@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef43|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
        (< (inv@150@03 r) V@26@03))
      (<= 0 (inv@150@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) r) r))
  :pattern ((inv@150@03 r) (inv@151@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17622
;  :arith-add-rows          12438
;  :arith-assert-diseq      1114
;  :arith-assert-lower      5265
;  :arith-assert-upper      3322
;  :arith-bound-prop        1590
;  :arith-conflicts         327
;  :arith-eq-adapter        3490
;  :arith-fixed-eqs         1779
;  :arith-offset-eqs        2011
;  :arith-pivots            2778
;  :conflicts               830
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 602
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               1969
;  :del-clause              23663
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.94
;  :memory                  7.90
;  :minimized-lits          100
;  :mk-bool-var             33157
;  :mk-clause               23676
;  :num-allocs              407942
;  :num-checks              248
;  :propagations            11398
;  :quant-instantiations    7315
;  :rlimit-count            1031741
;  :time                    0.00)
; [then-branch: 167 | exc@123@03 == Null | live]
; [else-branch: 167 | exc@123@03 != Null | dead]
(push) ; 11
; [then-branch: 167 | exc@123@03 == Null]
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@153@03 Int)
(push) ; 12
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 13
; [then-branch: 168 | 0 <= unknown@153@03 | live]
; [else-branch: 168 | !(0 <= unknown@153@03) | live]
(push) ; 14
; [then-branch: 168 | 0 <= unknown@153@03]
(assert (<= 0 unknown@153@03))
; [eval] unknown < V
(pop) ; 14
(push) ; 14
; [else-branch: 168 | !(0 <= unknown@153@03)]
(assert (not (<= 0 unknown@153@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(push) ; 13
; [then-branch: 169 | unknown@153@03 < V@26@03 && 0 <= unknown@153@03 | live]
; [else-branch: 169 | !(unknown@153@03 < V@26@03 && 0 <= unknown@153@03) | live]
(push) ; 14
; [then-branch: 169 | unknown@153@03 < V@26@03 && 0 <= unknown@153@03]
(assert (and (< unknown@153@03 V@26@03) (<= 0 unknown@153@03)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@154@03 Int)
(push) ; 15
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 16
; [then-branch: 170 | 0 <= unknown1@154@03 | live]
; [else-branch: 170 | !(0 <= unknown1@154@03) | live]
(push) ; 17
; [then-branch: 170 | 0 <= unknown1@154@03]
(assert (<= 0 unknown1@154@03))
; [eval] unknown1 < V
(pop) ; 17
(push) ; 17
; [else-branch: 170 | !(0 <= unknown1@154@03)]
(assert (not (<= 0 unknown1@154@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(push) ; 16
; [then-branch: 171 | unknown1@154@03 < V@26@03 && 0 <= unknown1@154@03 | live]
; [else-branch: 171 | !(unknown1@154@03 < V@26@03 && 0 <= unknown1@154@03) | live]
(push) ; 17
; [then-branch: 171 | unknown1@154@03 < V@26@03 && 0 <= unknown1@154@03]
(assert (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17622
;  :arith-add-rows          12440
;  :arith-assert-diseq      1114
;  :arith-assert-lower      5269
;  :arith-assert-upper      3322
;  :arith-bound-prop        1590
;  :arith-conflicts         327
;  :arith-eq-adapter        3490
;  :arith-fixed-eqs         1779
;  :arith-offset-eqs        2011
;  :arith-pivots            2778
;  :conflicts               830
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 602
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               1969
;  :del-clause              23663
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              7.94
;  :memory                  7.90
;  :minimized-lits          100
;  :mk-bool-var             33161
;  :mk-clause               23676
;  :num-allocs              408126
;  :num-checks              249
;  :propagations            11398
;  :quant-instantiations    7315
;  :rlimit-count            1032098)
(assert (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 18
; Joined path conditions
(assert (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18043
;  :arith-add-rows          12746
;  :arith-assert-diseq      1147
;  :arith-assert-lower      5453
;  :arith-assert-upper      3415
;  :arith-bound-prop        1655
;  :arith-conflicts         337
;  :arith-eq-adapter        3602
;  :arith-fixed-eqs         1815
;  :arith-offset-eqs        2101
;  :arith-pivots            2843
;  :conflicts               857
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 606
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2020
;  :del-clause              24196
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              8.53
;  :memory                  8.25
;  :minimized-lits          100
;  :mk-bool-var             34162
;  :mk-clause               24374
;  :num-allocs              412188
;  :num-checks              250
;  :propagations            11767
;  :quant-instantiations    7453
;  :rlimit-count            1048728
;  :time                    0.01)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 19
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18043
;  :arith-add-rows          12746
;  :arith-assert-diseq      1147
;  :arith-assert-lower      5453
;  :arith-assert-upper      3415
;  :arith-bound-prop        1655
;  :arith-conflicts         337
;  :arith-eq-adapter        3602
;  :arith-fixed-eqs         1815
;  :arith-offset-eqs        2101
;  :arith-pivots            2843
;  :conflicts               858
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 606
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2020
;  :del-clause              24196
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              8.53
;  :memory                  8.25
;  :minimized-lits          100
;  :mk-bool-var             34162
;  :mk-clause               24374
;  :num-allocs              412277
;  :num-checks              251
;  :propagations            11767
;  :quant-instantiations    7453
;  :rlimit-count            1048823)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
    (as None<option<array>>  option<array>))))
(pop) ; 18
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
    (as None<option<array>>  option<array>))))
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (<
  unknown1@154@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18049
;  :arith-add-rows          12752
;  :arith-assert-diseq      1147
;  :arith-assert-lower      5455
;  :arith-assert-upper      3417
;  :arith-bound-prop        1655
;  :arith-conflicts         338
;  :arith-eq-adapter        3603
;  :arith-fixed-eqs         1816
;  :arith-offset-eqs        2101
;  :arith-pivots            2847
;  :conflicts               859
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 606
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2020
;  :del-clause              24200
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              8.53
;  :memory                  8.24
;  :minimized-lits          100
;  :mk-bool-var             34173
;  :mk-clause               24378
;  :num-allocs              412464
;  :num-checks              252
;  :propagations            11769
;  :quant-instantiations    7460
;  :rlimit-count            1049328)
(assert (<
  unknown1@154@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))))
(pop) ; 18
; Joined path conditions
(assert (<
  unknown1@154@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (and
              (and
                (<
                  (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                  V@26@03)
                (<=
                  0
                  (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
              (<
                (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                V@26@03))
            (<=
              0
              (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
          $Perm.Write
          $Perm.No)
        (ite
          (and
            (and
              (and
                (<
                  (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                  V@26@03)
                (<=
                  0
                  (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
              (<
                (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                V@26@03))
            (<=
              0
              (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
          $k@144@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (and
                (and
                  (<
                    (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                    V@26@03)
                  (<=
                    0
                    (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
                (<
                  (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                  V@26@03))
              (<=
                0
                (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)))
        (pTaken@122@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
    (-
      (-
        (ite
          (and
            (and
              (and
                (<
                  (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                  V@26@03)
                (<=
                  0
                  (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
              (<
                (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                V@26@03))
            (<=
              0
              (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))))
          $Perm.Write
          $Perm.No)
        (pTaken@115@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)))
      (pTaken@121@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19500
;  :arith-add-rows          13732
;  :arith-assert-diseq      1226
;  :arith-assert-lower      6004
;  :arith-assert-upper      3750
;  :arith-bound-prop        1767
;  :arith-conflicts         360
;  :arith-eq-adapter        3911
;  :arith-fixed-eqs         2012
;  :arith-offset-eqs        2282
;  :arith-pivots            3029
;  :conflicts               902
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 610
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2210
;  :del-clause              26449
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              8.81
;  :memory                  8.78
;  :minimized-lits          102
;  :mk-bool-var             37458
;  :mk-clause               26787
;  :num-allocs              424478
;  :num-checks              253
;  :propagations            12922
;  :quant-instantiations    8112
;  :rlimit-count            1102855
;  :time                    0.04)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19500
;  :arith-add-rows          13732
;  :arith-assert-diseq      1226
;  :arith-assert-lower      6004
;  :arith-assert-upper      3750
;  :arith-bound-prop        1767
;  :arith-conflicts         360
;  :arith-eq-adapter        3911
;  :arith-fixed-eqs         2012
;  :arith-offset-eqs        2282
;  :arith-pivots            3029
;  :conflicts               902
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 610
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2210
;  :del-clause              26449
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              8.81
;  :memory                  8.78
;  :minimized-lits          102
;  :mk-bool-var             37458
;  :mk-clause               26787
;  :num-allocs              424504
;  :num-checks              254
;  :propagations            12922
;  :quant-instantiations    8112
;  :rlimit-count            1102885)
(assert (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 18
; Joined path conditions
(assert (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21782
;  :arith-add-rows          16114
;  :arith-assert-diseq      1372
;  :arith-assert-lower      6734
;  :arith-assert-upper      4218
;  :arith-bound-prop        1979
;  :arith-conflicts         388
;  :arith-eq-adapter        4375
;  :arith-fixed-eqs         2298
;  :arith-offset-eqs        2597
;  :arith-pivots            3257
;  :conflicts               950
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 614
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2474
;  :del-clause              30169
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.06
;  :memory                  9.87
;  :minimized-lits          106
;  :mk-bool-var             41950
;  :mk-clause               30622
;  :num-allocs              439990
;  :num-checks              255
;  :propagations            14645
;  :quant-instantiations    8966
;  :rlimit-count            1204541
;  :time                    0.05)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 19
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 19
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22585
;  :arith-add-rows          16688
;  :arith-assert-diseq      1422
;  :arith-assert-lower      6996
;  :arith-assert-upper      4399
;  :arith-bound-prop        2073
;  :arith-conflicts         403
;  :arith-eq-adapter        4538
;  :arith-fixed-eqs         2401
;  :arith-offset-eqs        2688
;  :arith-pivots            3323
;  :conflicts               986
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 618
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2566
;  :del-clause              31751
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.06
;  :memory                  9.88
;  :minimized-lits          109
;  :mk-bool-var             43745
;  :mk-clause               32204
;  :num-allocs              445961
;  :num-checks              256
;  :propagations            15213
;  :quant-instantiations    9391
;  :rlimit-count            1237862
;  :time                    0.02)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
    (as None<option<array>>  option<array>))))
(pop) ; 18
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
    (as None<option<array>>  option<array>))))
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (<
  unknown1@154@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23216
;  :arith-add-rows          17041
;  :arith-assert-diseq      1447
;  :arith-assert-lower      7185
;  :arith-assert-upper      4526
;  :arith-bound-prop        2143
;  :arith-conflicts         413
;  :arith-eq-adapter        4651
;  :arith-fixed-eqs         2480
;  :arith-offset-eqs        2735
;  :arith-pivots            3371
;  :conflicts               1015
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 622
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2639
;  :del-clause              32988
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.06
;  :memory                  9.89
;  :minimized-lits          112
;  :mk-bool-var             45061
;  :mk-clause               33441
;  :num-allocs              450564
;  :num-checks              257
;  :propagations            15667
;  :quant-instantiations    9757
;  :rlimit-count            1263160
;  :time                    0.01)
(assert (<
  unknown1@154@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))))
(pop) ; 18
; Joined path conditions
(assert (<
  unknown1@154@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (and
              (and
                (<
                  (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
                  V@26@03)
                (<=
                  0
                  (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
              (<
                (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
                V@26@03))
            (<=
              0
              (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
          $Perm.Write
          $Perm.No)
        (ite
          (and
            (and
              (and
                (<
                  (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
                  V@26@03)
                (<=
                  0
                  (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
              (<
                (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
                V@26@03))
            (<=
              0
              (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
          $k@144@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (and
                (and
                  (<
                    (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
                    V@26@03)
                  (<=
                    0
                    (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
                (<
                  (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
                  V@26@03))
              (<=
                0
                (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)))
        (pTaken@122@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
    (-
      (-
        (ite
          (and
            (and
              (and
                (<
                  (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
                  V@26@03)
                (<=
                  0
                  (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
              (<
                (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
                V@26@03))
            (<=
              0
              (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
          $Perm.Write
          $Perm.No)
        (pTaken@115@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)))
      (pTaken@121@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26231
;  :arith-add-rows          19436
;  :arith-assert-diseq      1627
;  :arith-assert-lower      8104
;  :arith-assert-upper      5105
;  :arith-bound-prop        2408
;  :arith-conflicts         451
;  :arith-eq-adapter        5281
;  :arith-fixed-eqs         2822
;  :arith-offset-eqs        3114
;  :arith-pivots            3647
;  :conflicts               1087
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 626
;  :datatype-occurs-check   267
;  :datatype-splits         238
;  :decisions               2844
;  :del-clause              36694
;  :final-checks            159
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.32
;  :minimized-lits          127
;  :mk-bool-var             50317
;  :mk-clause               37255
;  :num-allocs              470749
;  :num-checks              258
;  :propagations            17764
;  :quant-instantiations    10706
;  :rlimit-count            1355775
;  :time                    0.06)
(pop) ; 17
(push) ; 17
; [else-branch: 171 | !(unknown1@154@03 < V@26@03 && 0 <= unknown1@154@03)]
(assert (not (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
  (and
    (< unknown1@154@03 V@26@03)
    (<= 0 unknown1@154@03)
    (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@154@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
    (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@154@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@154@03 Int)) (!
  (implies
    (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
    (and
      (< unknown1@154@03 V@26@03)
      (<= 0 unknown1@154@03)
      (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@154@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
      (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@154@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@154@03 Int)) (!
  (implies
    (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
    (and
      (< unknown1@154@03 V@26@03)
      (<= 0 unknown1@154@03)
      (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@154@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
      (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@154@03
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
(push) ; 14
; [else-branch: 169 | !(unknown@153@03 < V@26@03 && 0 <= unknown@153@03)]
(assert (not (and (< unknown@153@03 V@26@03) (<= 0 unknown@153@03))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and (< unknown@153@03 V@26@03) (<= 0 unknown@153@03))
  (and
    (< unknown@153@03 V@26@03)
    (<= 0 unknown@153@03)
    (forall ((unknown1@154@03 Int)) (!
      (implies
        (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
        (and
          (< unknown1@154@03 V@26@03)
          (<= 0 unknown1@154@03)
          (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@154@03
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
          (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@154@03
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@154@03 Int)) (!
      (implies
        (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
        (and
          (< unknown1@154@03 V@26@03)
          (<= 0 unknown1@154@03)
          (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@154@03
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
          (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@154@03
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@153@03 Int)) (!
  (implies
    (and (< unknown@153@03 V@26@03) (<= 0 unknown@153@03))
    (and
      (< unknown@153@03 V@26@03)
      (<= 0 unknown@153@03)
      (forall ((unknown1@154@03 Int)) (!
        (implies
          (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
          (and
            (< unknown1@154@03 V@26@03)
            (<= 0 unknown1@154@03)
            (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@154@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
            (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@154@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@154@03 Int)) (!
        (implies
          (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
          (and
            (< unknown1@154@03 V@26@03)
            (<= 0 unknown1@154@03)
            (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@154@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
            (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@154@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@153@03 Int)) (!
  (implies
    (and (< unknown@153@03 V@26@03) (<= 0 unknown@153@03))
    (and
      (< unknown@153@03 V@26@03)
      (<= 0 unknown@153@03)
      (forall ((unknown1@154@03 Int)) (!
        (implies
          (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
          (and
            (< unknown1@154@03 V@26@03)
            (<= 0 unknown1@154@03)
            (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@154@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
            (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@154@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@154@03 Int)) (!
        (implies
          (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
          (and
            (< unknown1@154@03 V@26@03)
            (<= 0 unknown1@154@03)
            (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@154@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
            (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@154@03
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (= exc@123@03 $Ref.null)
  (and
    (forall ((unknown@153@03 Int)) (!
      (implies
        (and (< unknown@153@03 V@26@03) (<= 0 unknown@153@03))
        (and
          (< unknown@153@03 V@26@03)
          (<= 0 unknown@153@03)
          (forall ((unknown1@154@03 Int)) (!
            (implies
              (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
              (and
                (< unknown1@154@03 V@26@03)
                (<= 0 unknown1@154@03)
                (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@154@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@154@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@154@03 Int)) (!
            (implies
              (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
              (and
                (< unknown1@154@03 V@26@03)
                (<= 0 unknown1@154@03)
                (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@154@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@154@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@153@03 Int)) (!
      (implies
        (and (< unknown@153@03 V@26@03) (<= 0 unknown@153@03))
        (and
          (< unknown@153@03 V@26@03)
          (<= 0 unknown@153@03)
          (forall ((unknown1@154@03 Int)) (!
            (implies
              (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
              (and
                (< unknown1@154@03 V@26@03)
                (<= 0 unknown1@154@03)
                (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@154@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@154@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@154@03 Int)) (!
            (implies
              (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
              (and
                (< unknown1@154@03 V@26@03)
                (<= 0 unknown1@154@03)
                (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@154@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
                (< unknown@153@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@154@03
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (= exc@123@03 $Ref.null)
  (forall ((unknown@153@03 Int)) (!
    (implies
      (and (< unknown@153@03 V@26@03) (<= 0 unknown@153@03))
      (forall ((unknown1@154@03 Int)) (!
        (implies
          (and (< unknown1@154@03 V@26@03) (<= 0 unknown1@154@03))
          (=
            ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
            ($FVF.lookup_int (as sm@152@03  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))) unknown1@154@03))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))) unknown1@154@03))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) unknown@153@03))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) unknown@153@03))))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 172 | exc@123@03 != Null | dead]
; [else-branch: 172 | exc@123@03 == Null | live]
(push) ; 10
; [else-branch: 172 | exc@123@03 == Null]
(pop) ; 10
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@123@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26329
;  :arith-add-rows          19517
;  :arith-assert-diseq      1627
;  :arith-assert-lower      8104
;  :arith-assert-upper      5105
;  :arith-bound-prop        2408
;  :arith-conflicts         451
;  :arith-eq-adapter        5281
;  :arith-fixed-eqs         2822
;  :arith-offset-eqs        3114
;  :arith-pivots            3746
;  :conflicts               1087
;  :datatype-accessor-ax    83
;  :datatype-constructor-ax 646
;  :datatype-occurs-check   275
;  :datatype-splits         250
;  :decisions               2864
;  :del-clause              37242
;  :final-checks            163
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.21
;  :minimized-lits          127
;  :mk-bool-var             50332
;  :mk-clause               37255
;  :num-allocs              474182
;  :num-checks              260
;  :propagations            17764
;  :quant-instantiations    10706
;  :rlimit-count            1364862)
; [then-branch: 173 | exc@123@03 == Null | live]
; [else-branch: 173 | exc@123@03 != Null | dead]
(push) ; 10
; [then-branch: 173 | exc@123@03 == Null]
; [exec]
; evaluationDummy := res2
; [exec]
; exc, res3 := make_array1(tid, V)
(declare-const exc@155@03 $Ref)
(declare-const res@156@03 option<array>)
(declare-const $t@157@03 $Snap)
(assert (= $t@157@03 ($Snap.combine ($Snap.first $t@157@03) ($Snap.second $t@157@03))))
(assert (= ($Snap.first $t@157@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@155@03 $Ref.null))
(assert (=
  ($Snap.second $t@157@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@157@03))
    ($Snap.second ($Snap.second $t@157@03)))))
(assert (= ($Snap.first ($Snap.second $t@157@03)) $Snap.unit))
; [eval] exc == null ==> res != (None(): option[array])
; [eval] exc == null
(push) ; 11
(push) ; 12
(assert (not (not (= exc@155@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26395
;  :arith-add-rows          19517
;  :arith-assert-diseq      1627
;  :arith-assert-lower      8104
;  :arith-assert-upper      5105
;  :arith-bound-prop        2408
;  :arith-conflicts         451
;  :arith-eq-adapter        5281
;  :arith-fixed-eqs         2822
;  :arith-offset-eqs        3114
;  :arith-pivots            3746
;  :conflicts               1087
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 657
;  :datatype-occurs-check   280
;  :datatype-splits         257
;  :decisions               2875
;  :del-clause              37242
;  :final-checks            165
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.21
;  :minimized-lits          127
;  :mk-bool-var             50344
;  :mk-clause               37255
;  :num-allocs              475069
;  :num-checks              261
;  :propagations            17764
;  :quant-instantiations    10706
;  :rlimit-count            1366022)
; [then-branch: 174 | exc@155@03 == Null | live]
; [else-branch: 174 | exc@155@03 != Null | dead]
(push) ; 12
; [then-branch: 174 | exc@155@03 == Null]
; [eval] res != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@155@03 $Ref.null)
  (not (= res@156@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@157@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@157@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@157@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@157@03))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(res)) == dim0
; [eval] exc == null
(push) ; 11
(push) ; 12
(assert (not (not (= exc@155@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26455
;  :arith-add-rows          19517
;  :arith-assert-diseq      1627
;  :arith-assert-lower      8104
;  :arith-assert-upper      5105
;  :arith-bound-prop        2408
;  :arith-conflicts         451
;  :arith-eq-adapter        5281
;  :arith-fixed-eqs         2822
;  :arith-offset-eqs        3114
;  :arith-pivots            3746
;  :conflicts               1087
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 668
;  :datatype-occurs-check   285
;  :datatype-splits         264
;  :decisions               2886
;  :del-clause              37242
;  :final-checks            167
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.21
;  :minimized-lits          127
;  :mk-bool-var             50354
;  :mk-clause               37255
;  :num-allocs              475918
;  :num-checks              262
;  :propagations            17764
;  :quant-instantiations    10706
;  :rlimit-count            1367108)
; [then-branch: 175 | exc@155@03 == Null | live]
; [else-branch: 175 | exc@155@03 != Null | dead]
(push) ; 12
; [then-branch: 175 | exc@155@03 == Null]
; [eval] alen(opt_get1(res)) == dim0
; [eval] alen(opt_get1(res))
; [eval] opt_get1(res)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 14
(assert (not (not (= res@156@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26455
;  :arith-add-rows          19517
;  :arith-assert-diseq      1627
;  :arith-assert-lower      8104
;  :arith-assert-upper      5105
;  :arith-bound-prop        2408
;  :arith-conflicts         451
;  :arith-eq-adapter        5281
;  :arith-fixed-eqs         2822
;  :arith-offset-eqs        3114
;  :arith-pivots            3746
;  :conflicts               1087
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 668
;  :datatype-occurs-check   285
;  :datatype-splits         264
;  :decisions               2886
;  :del-clause              37242
;  :final-checks            167
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.21
;  :minimized-lits          127
;  :mk-bool-var             50354
;  :mk-clause               37255
;  :num-allocs              475942
;  :num-checks              263
;  :propagations            17764
;  :quant-instantiations    10706
;  :rlimit-count            1367129)
(assert (not (= res@156@03 (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not (= res@156@03 (as None<option<array>>  option<array>))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@155@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@156@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@157@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@157@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@157@03)))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@155@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26523
;  :arith-add-rows          19518
;  :arith-assert-diseq      1627
;  :arith-assert-lower      8106
;  :arith-assert-upper      5106
;  :arith-bound-prop        2408
;  :arith-conflicts         451
;  :arith-eq-adapter        5282
;  :arith-fixed-eqs         2823
;  :arith-offset-eqs        3114
;  :arith-pivots            3747
;  :conflicts               1087
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 680
;  :datatype-occurs-check   290
;  :datatype-splits         272
;  :decisions               2898
;  :del-clause              37242
;  :final-checks            169
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.20
;  :minimized-lits          127
;  :mk-bool-var             50372
;  :mk-clause               37255
;  :num-allocs              476847
;  :num-checks              264
;  :propagations            17764
;  :quant-instantiations    10711
;  :rlimit-count            1368329)
; [then-branch: 176 | exc@155@03 == Null | live]
; [else-branch: 176 | exc@155@03 != Null | dead]
(push) ; 11
; [then-branch: 176 | exc@155@03 == Null]
(declare-const i0@158@03 Int)
(push) ; 12
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 13
; [then-branch: 177 | 0 <= i0@158@03 | live]
; [else-branch: 177 | !(0 <= i0@158@03) | live]
(push) ; 14
; [then-branch: 177 | 0 <= i0@158@03]
(assert (<= 0 i0@158@03))
; [eval] i0 < dim0
(pop) ; 14
(push) ; 14
; [else-branch: 177 | !(0 <= i0@158@03)]
(assert (not (<= 0 i0@158@03)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i0@158@03 V@26@03) (<= 0 i0@158@03)))
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 14
(assert (not (not (= res@156@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26523
;  :arith-add-rows          19519
;  :arith-assert-diseq      1627
;  :arith-assert-lower      8108
;  :arith-assert-upper      5106
;  :arith-bound-prop        2408
;  :arith-conflicts         451
;  :arith-eq-adapter        5282
;  :arith-fixed-eqs         2823
;  :arith-offset-eqs        3114
;  :arith-pivots            3747
;  :conflicts               1087
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 680
;  :datatype-occurs-check   290
;  :datatype-splits         272
;  :decisions               2898
;  :del-clause              37242
;  :final-checks            169
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.20
;  :minimized-lits          127
;  :mk-bool-var             50374
;  :mk-clause               37255
;  :num-allocs              476946
;  :num-checks              265
;  :propagations            17764
;  :quant-instantiations    10711
;  :rlimit-count            1368501)
(assert (not (= res@156@03 (as None<option<array>>  option<array>))))
(pop) ; 13
; Joined path conditions
(assert (not (= res@156@03 (as None<option<array>>  option<array>))))
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 14
(assert (not (< i0@158@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26523
;  :arith-add-rows          19519
;  :arith-assert-diseq      1627
;  :arith-assert-lower      8108
;  :arith-assert-upper      5106
;  :arith-bound-prop        2408
;  :arith-conflicts         451
;  :arith-eq-adapter        5282
;  :arith-fixed-eqs         2823
;  :arith-offset-eqs        3114
;  :arith-pivots            3747
;  :conflicts               1087
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 680
;  :datatype-occurs-check   290
;  :datatype-splits         272
;  :decisions               2898
;  :del-clause              37242
;  :final-checks            169
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.20
;  :minimized-lits          127
;  :mk-bool-var             50374
;  :mk-clause               37255
;  :num-allocs              476966
;  :num-checks              266
;  :propagations            17764
;  :quant-instantiations    10711
;  :rlimit-count            1368532)
(assert (< i0@158@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 13
; Joined path conditions
(assert (< i0@158@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
; Definitional axioms for snapshot map values
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(pop) ; 13
; Joined path conditions
(pop) ; 12
(declare-fun inv@159@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i0@158@03 Int)) (!
  (and
    (not (= res@156@03 (as None<option<array>>  option<array>)))
    (< i0@158@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@157@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@158@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@158@03)))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i01@158@03 Int) (i02@158@03 Int)) (!
  (implies
    (and
      (and (< i01@158@03 V@26@03) (<= 0 i01@158@03))
      (and (< i02@158@03 V@26@03) (<= 0 i02@158@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i01@158@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i02@158@03)))
    (= i01@158@03 i02@158@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26552
;  :arith-add-rows          19534
;  :arith-assert-diseq      1630
;  :arith-assert-lower      8116
;  :arith-assert-upper      5107
;  :arith-bound-prop        2408
;  :arith-conflicts         453
;  :arith-eq-adapter        5283
;  :arith-fixed-eqs         2823
;  :arith-offset-eqs        3114
;  :arith-pivots            3753
;  :conflicts               1094
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 684
;  :datatype-occurs-check   290
;  :datatype-splits         272
;  :decisions               2904
;  :del-clause              37256
;  :final-checks            169
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.19
;  :minimized-lits          127
;  :mk-bool-var             50398
;  :mk-clause               37269
;  :num-allocs              477528
;  :num-checks              267
;  :propagations            17779
;  :quant-instantiations    10719
;  :rlimit-count            1369919)
; Definitional axioms for inverse functions
(assert (forall ((i0@158@03 Int)) (!
  (implies
    (and (< i0@158@03 V@26@03) (<= 0 i0@158@03))
    (=
      (inv@159@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@158@03))
      i0@158@03))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@157@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@158@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@158@03)))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@159@03 r) V@26@03) (<= 0 (inv@159@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@159@03 r))
      r))
  :pattern ((inv@159@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i0@158@03 Int)) (!
  (implies
    (and (< i0@158@03 V@26@03) (<= 0 i0@158@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@158@03)
        $Ref.null)))
  :pattern (($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@157@03))))) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@158@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@158@03)))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@160@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@159@03 r) V@26@03) (<= 0 (inv@159@03 r)))
    (=
      ($FVF.lookup_int (as sm@160@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@157@03))))) r)))
  :pattern (($FVF.lookup_int (as sm@160@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@157@03))))) r))
  :qid |qp.fvfValDef44|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
        (< (inv@150@03 r) V@26@03))
      (<= 0 (inv@150@03 r)))
    (=
      ($FVF.lookup_int (as sm@160@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@160@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef45|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@160@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@160@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef46|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r)))
    (=
      ($FVF.lookup_int (as sm@160@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@160@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef47|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r)))
    (=
      ($FVF.lookup_int (as sm@160@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@160@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@157@03))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@160@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef49|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@159@03 r) V@26@03) (<= 0 (inv@159@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) r) r))
  :pattern ((inv@159@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@157@03))))
  $Snap.unit))
; [eval] exc == null ==> (forall i0: Int :: { aloc(opt_get1(res), i0).int } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0)
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@155@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26609
;  :arith-add-rows          19534
;  :arith-assert-diseq      1630
;  :arith-assert-lower      8116
;  :arith-assert-upper      5107
;  :arith-bound-prop        2408
;  :arith-conflicts         453
;  :arith-eq-adapter        5283
;  :arith-fixed-eqs         2823
;  :arith-offset-eqs        3114
;  :arith-pivots            3753
;  :conflicts               1094
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 695
;  :datatype-occurs-check   295
;  :datatype-splits         279
;  :decisions               2915
;  :del-clause              37256
;  :final-checks            171
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.19
;  :minimized-lits          127
;  :mk-bool-var             50416
;  :mk-clause               37269
;  :num-allocs              480293
;  :num-checks              268
;  :propagations            17779
;  :quant-instantiations    10719
;  :rlimit-count            1379052)
; [then-branch: 178 | exc@155@03 == Null | live]
; [else-branch: 178 | exc@155@03 != Null | dead]
(push) ; 13
; [then-branch: 178 | exc@155@03 == Null]
; [eval] (forall i0: Int :: { aloc(opt_get1(res), i0).int } 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0)
(declare-const i0@161@03 Int)
(push) ; 14
; [eval] 0 <= i0 && i0 < dim0 ==> aloc(opt_get1(res), i0).int == 0
; [eval] 0 <= i0 && i0 < dim0
; [eval] 0 <= i0
(push) ; 15
; [then-branch: 179 | 0 <= i0@161@03 | live]
; [else-branch: 179 | !(0 <= i0@161@03) | live]
(push) ; 16
; [then-branch: 179 | 0 <= i0@161@03]
(assert (<= 0 i0@161@03))
; [eval] i0 < dim0
(pop) ; 16
(push) ; 16
; [else-branch: 179 | !(0 <= i0@161@03)]
(assert (not (<= 0 i0@161@03)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 180 | i0@161@03 < V@26@03 && 0 <= i0@161@03 | live]
; [else-branch: 180 | !(i0@161@03 < V@26@03 && 0 <= i0@161@03) | live]
(push) ; 16
; [then-branch: 180 | i0@161@03 < V@26@03 && 0 <= i0@161@03]
(assert (and (< i0@161@03 V@26@03) (<= 0 i0@161@03)))
; [eval] aloc(opt_get1(res), i0).int == 0
; [eval] aloc(opt_get1(res), i0)
; [eval] opt_get1(res)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 18
(assert (not (not (= res@156@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26609
;  :arith-add-rows          19535
;  :arith-assert-diseq      1630
;  :arith-assert-lower      8118
;  :arith-assert-upper      5107
;  :arith-bound-prop        2408
;  :arith-conflicts         453
;  :arith-eq-adapter        5283
;  :arith-fixed-eqs         2823
;  :arith-offset-eqs        3114
;  :arith-pivots            3753
;  :conflicts               1094
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 695
;  :datatype-occurs-check   295
;  :datatype-splits         279
;  :decisions               2915
;  :del-clause              37256
;  :final-checks            171
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.20
;  :minimized-lits          127
;  :mk-bool-var             50418
;  :mk-clause               37269
;  :num-allocs              480392
;  :num-checks              269
;  :propagations            17779
;  :quant-instantiations    10719
;  :rlimit-count            1379234)
(assert (not (= res@156@03 (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not (= res@156@03 (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i0@161@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               26609
;  :arith-add-rows          19535
;  :arith-assert-diseq      1630
;  :arith-assert-lower      8118
;  :arith-assert-upper      5107
;  :arith-bound-prop        2408
;  :arith-conflicts         453
;  :arith-eq-adapter        5283
;  :arith-fixed-eqs         2823
;  :arith-offset-eqs        3114
;  :arith-pivots            3753
;  :conflicts               1094
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 695
;  :datatype-occurs-check   295
;  :datatype-splits         279
;  :decisions               2915
;  :del-clause              37256
;  :final-checks            171
;  :interface-eqs           7
;  :max-generation          6
;  :max-memory              10.37
;  :memory                  10.20
;  :minimized-lits          127
;  :mk-bool-var             50418
;  :mk-clause               37269
;  :num-allocs              480412
;  :num-checks              270
;  :propagations            17779
;  :quant-instantiations    10719
;  :rlimit-count            1379265)
(assert (< i0@161@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 17
; Joined path conditions
(assert (< i0@161@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (ite
            (and
              (<
                (inv@159@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                V@26@03)
              (<=
                0
                (inv@159@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
            $Perm.Write
            $Perm.No)
          (ite
            (and
              (and
                (and
                  (<
                    (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                    V@26@03)
                  (<=
                    0
                    (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
                (<
                  (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                  V@26@03))
              (<=
                0
                (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
            $Perm.Write
            $Perm.No))
        (ite
          (and
            (and
              (and
                (<
                  (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                  V@26@03)
                (<=
                  0
                  (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
              (<
                (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                V@26@03))
            (<=
              0
              (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
          $k@144@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (and
                (and
                  (<
                    (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                    V@26@03)
                  (<=
                    0
                    (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
                (<
                  (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                  V@26@03))
              (<=
                0
                (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)))
        (pTaken@122@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
    (-
      (-
        (ite
          (and
            (and
              (and
                (<
                  (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                  V@26@03)
                (<=
                  0
                  (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
              (<
                (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
                V@26@03))
            (<=
              0
              (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
          $Perm.Write
          $Perm.No)
        (pTaken@115@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)))
      (pTaken@121@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28754
;  :arith-add-rows          21254
;  :arith-assert-diseq      1793
;  :arith-assert-lower      8781
;  :arith-assert-upper      5575
;  :arith-bound-prop        2561
;  :arith-conflicts         480
;  :arith-eq-adapter        5770
;  :arith-fixed-eqs         3070
;  :arith-offset-eqs        3434
;  :arith-pivots            4017
;  :conflicts               1163
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 699
;  :datatype-occurs-check   295
;  :datatype-splits         279
;  :decisions               3147
;  :del-clause              41268
;  :final-checks            171
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.29
;  :minimized-lits          138
;  :mk-bool-var             56097
;  :mk-clause               41475
;  :num-allocs              499483
;  :num-checks              271
;  :propagations            19594
;  :quant-instantiations    11814
;  :rlimit-count            1452194
;  :time                    0.04)
(pop) ; 16
(push) ; 16
; [else-branch: 180 | !(i0@161@03 < V@26@03 && 0 <= i0@161@03)]
(assert (not (and (< i0@161@03 V@26@03) (<= 0 i0@161@03))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i0@161@03 V@26@03) (<= 0 i0@161@03))
  (and
    (< i0@161@03 V@26@03)
    (<= 0 i0@161@03)
    (not (= res@156@03 (as None<option<array>>  option<array>)))
    (< i0@161@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)))))
; Joined path conditions
; Definitional axioms for snapshot map values
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i0@161@03 Int)) (!
  (implies
    (and (< i0@161@03 V@26@03) (<= 0 i0@161@03))
    (and
      (< i0@161@03 V@26@03)
      (<= 0 i0@161@03)
      (not (= res@156@03 (as None<option<array>>  option<array>)))
      (< i0@161@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@155@03 $Ref.null)
  (forall ((i0@161@03 Int)) (!
    (implies
      (and (< i0@161@03 V@26@03) (<= 0 i0@161@03))
      (and
        (< i0@161@03 V@26@03)
        (<= 0 i0@161@03)
        (not (= res@156@03 (as None<option<array>>  option<array>)))
        (< i0@161@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@155@03 $Ref.null)
  (forall ((i0@161@03 Int)) (!
    (implies
      (and (< i0@161@03 V@26@03) (<= 0 i0@161@03))
      (=
        ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03))
        0))
    :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i0@161@03)))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 181 | exc@155@03 != Null | dead]
; [else-branch: 181 | exc@155@03 == Null | live]
(push) ; 12
; [else-branch: 181 | exc@155@03 == Null]
(pop) ; 12
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@155@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28866
;  :arith-add-rows          21271
;  :arith-assert-diseq      1793
;  :arith-assert-lower      8781
;  :arith-assert-upper      5575
;  :arith-bound-prop        2561
;  :arith-conflicts         480
;  :arith-eq-adapter        5770
;  :arith-fixed-eqs         3070
;  :arith-offset-eqs        3434
;  :arith-pivots            4048
;  :conflicts               1163
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 721
;  :datatype-occurs-check   305
;  :datatype-splits         293
;  :decisions               3169
;  :del-clause              41462
;  :final-checks            175
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.26
;  :minimized-lits          138
;  :mk-bool-var             56113
;  :mk-clause               41475
;  :num-allocs              501395
;  :num-checks              273
;  :propagations            19594
;  :quant-instantiations    11814
;  :rlimit-count            1455039)
; [then-branch: 182 | exc@155@03 == Null | live]
; [else-branch: 182 | exc@155@03 != Null | dead]
(push) ; 12
; [then-branch: 182 | exc@155@03 == Null]
; [exec]
; P := res3
; [exec]
; exc, res4 := initializeWithZeros(this, tid, P, V)
; [eval] this != null
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 13
(assert (not (not (= res@156@03 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28866
;  :arith-add-rows          21271
;  :arith-assert-diseq      1793
;  :arith-assert-lower      8781
;  :arith-assert-upper      5575
;  :arith-bound-prop        2561
;  :arith-conflicts         480
;  :arith-eq-adapter        5770
;  :arith-fixed-eqs         3070
;  :arith-offset-eqs        3434
;  :arith-pivots            4048
;  :conflicts               1163
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 721
;  :datatype-occurs-check   305
;  :datatype-splits         293
;  :decisions               3169
;  :del-clause              41462
;  :final-checks            175
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.26
;  :minimized-lits          138
;  :mk-bool-var             56113
;  :mk-clause               41475
;  :num-allocs              501419
;  :num-checks              274
;  :propagations            19594
;  :quant-instantiations    11814
;  :rlimit-count            1455055)
(assert (not (= res@156@03 (as None<option<array>>  option<array>))))
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
(assert (not (= (alen<Int> (opt_get1 $Snap.unit res@156@03)) V@26@03)))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28866
;  :arith-add-rows          21271
;  :arith-assert-diseq      1793
;  :arith-assert-lower      8781
;  :arith-assert-upper      5575
;  :arith-bound-prop        2561
;  :arith-conflicts         480
;  :arith-eq-adapter        5770
;  :arith-fixed-eqs         3070
;  :arith-offset-eqs        3434
;  :arith-pivots            4048
;  :conflicts               1163
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 721
;  :datatype-occurs-check   305
;  :datatype-splits         293
;  :decisions               3169
;  :del-clause              41462
;  :final-checks            175
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.26
;  :minimized-lits          138
;  :mk-bool-var             56113
;  :mk-clause               41475
;  :num-allocs              501435
;  :num-checks              275
;  :propagations            19594
;  :quant-instantiations    11814
;  :rlimit-count            1455074)
(assert (= (alen<Int> (opt_get1 $Snap.unit res@156@03)) V@26@03))
; [eval] |this.P_seq| == V
; [eval] |this.P_seq|
(declare-const k@162@03 Int)
(push) ; 13
; [eval] 0 <= k && k < V
; [eval] 0 <= k
(push) ; 14
; [then-branch: 183 | 0 <= k@162@03 | live]
; [else-branch: 183 | !(0 <= k@162@03) | live]
(push) ; 15
; [then-branch: 183 | 0 <= k@162@03]
(assert (<= 0 k@162@03))
; [eval] k < V
(pop) ; 15
(push) ; 15
; [else-branch: 183 | !(0 <= k@162@03)]
(assert (not (<= 0 k@162@03)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and (< k@162@03 V@26@03) (<= 0 k@162@03)))
; [eval] aloc(opt_get1(P), k)
; [eval] opt_get1(P)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (< k@162@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28866
;  :arith-add-rows          21272
;  :arith-assert-diseq      1793
;  :arith-assert-lower      8783
;  :arith-assert-upper      5575
;  :arith-bound-prop        2561
;  :arith-conflicts         480
;  :arith-eq-adapter        5770
;  :arith-fixed-eqs         3070
;  :arith-offset-eqs        3434
;  :arith-pivots            4048
;  :conflicts               1163
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 721
;  :datatype-occurs-check   305
;  :datatype-splits         293
;  :decisions               3169
;  :del-clause              41462
;  :final-checks            175
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.26
;  :minimized-lits          138
;  :mk-bool-var             56115
;  :mk-clause               41475
;  :num-allocs              501530
;  :num-checks              276
;  :propagations            19594
;  :quant-instantiations    11814
;  :rlimit-count            1455258)
(assert (< k@162@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 14
; Joined path conditions
(assert (< k@162@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 13
(declare-fun inv@163@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((k@162@03 Int)) (!
  (< k@162@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k@162@03))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((k1@162@03 Int) (k2@162@03 Int)) (!
  (implies
    (and
      (and
        (and (< k1@162@03 V@26@03) (<= 0 k1@162@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) k1@162@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) k1@162@03)))
      (and
        (and (< k2@162@03 V@26@03) (<= 0 k2@162@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) k2@162@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) k2@162@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k1@162@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k2@162@03)))
    (= k1@162@03 k2@162@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               28887
;  :arith-add-rows          21289
;  :arith-assert-diseq      1795
;  :arith-assert-lower      8787
;  :arith-assert-upper      5575
;  :arith-bound-prop        2561
;  :arith-conflicts         480
;  :arith-eq-adapter        5772
;  :arith-fixed-eqs         3070
;  :arith-offset-eqs        3434
;  :arith-pivots            4048
;  :conflicts               1164
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 721
;  :datatype-occurs-check   305
;  :datatype-splits         293
;  :decisions               3169
;  :del-clause              41544
;  :final-checks            175
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.25
;  :minimized-lits          138
;  :mk-bool-var             56236
;  :mk-clause               41557
;  :num-allocs              502474
;  :num-checks              277
;  :propagations            19601
;  :quant-instantiations    11856
;  :rlimit-count            1458504
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((k@162@03 Int)) (!
  (implies
    (and (< k@162@03 V@26@03) (<= 0 k@162@03))
    (=
      (inv@163@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k@162@03))
      k@162@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k@162@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@03 r) V@26@03) (<= 0 (inv@163@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@163@03 r))
      r))
  :pattern ((inv@163@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@03 r) V@26@03) (<= 0 (inv@163@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@160@03  $FVF<Int>) r) r))
  :pattern ((inv@163@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@164@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@163@03 r) V@26@03) (<= 0 (inv@163@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@159@03 r) V@26@03) (<= 0 (inv@159@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@165@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@163@03 r) V@26@03) (<= 0 (inv@163@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
            (< (inv@150@03 r) V@26@03))
          (<= 0 (inv@150@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@164@03 r)))
    $Perm.No))
(define-fun pTaken@166@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@163@03 r) V@26@03) (<= 0 (inv@163@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)
      (- (- $Perm.Write (pTaken@164@03 r)) (pTaken@165@03 r)))
    $Perm.No))
(define-fun pTaken@167@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@163@03 r) V@26@03) (<= 0 (inv@163@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r))
      (-
        (- (- $Perm.Write (pTaken@164@03 r)) (pTaken@165@03 r))
        (pTaken@166@03 r)))
    $Perm.No))
(define-fun pTaken@168@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@163@03 r) V@26@03) (<= 0 (inv@163@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r))
      (-
        (-
          (- (- $Perm.Write (pTaken@164@03 r)) (pTaken@165@03 r))
          (pTaken@166@03 r))
        (pTaken@167@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@159@03 r) V@26@03) (<= 0 (inv@159@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@164@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29029
;  :arith-add-rows          21328
;  :arith-assert-diseq      1799
;  :arith-assert-lower      8797
;  :arith-assert-upper      5580
;  :arith-bound-prop        2562
;  :arith-conflicts         481
;  :arith-eq-adapter        5786
;  :arith-fixed-eqs         3072
;  :arith-offset-eqs        3434
;  :arith-pivots            4057
;  :conflicts               1173
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 736
;  :datatype-occurs-check   310
;  :datatype-splits         300
;  :decisions               3189
;  :del-clause              41886
;  :final-checks            177
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.24
;  :minimized-lits          139
;  :mk-bool-var             56682
;  :mk-clause               41899
;  :num-allocs              505778
;  :num-checks              279
;  :propagations            19640
;  :quant-instantiations    11966
;  :rlimit-count            1465974
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@163@03 r) V@26@03) (<= 0 (inv@163@03 r)))
    (= (- $Perm.Write (pTaken@164@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29061
;  :arith-add-rows          21349
;  :arith-assert-diseq      1801
;  :arith-assert-lower      8801
;  :arith-assert-upper      5585
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5789
;  :arith-fixed-eqs         3073
;  :arith-offset-eqs        3434
;  :arith-pivots            4061
;  :conflicts               1174
;  :datatype-accessor-ax    87
;  :datatype-constructor-ax 736
;  :datatype-occurs-check   310
;  :datatype-splits         300
;  :decisions               3189
;  :del-clause              42047
;  :final-checks            177
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.23
;  :minimized-lits          139
;  :mk-bool-var             56900
;  :mk-clause               42060
;  :num-allocs              506691
;  :num-checks              280
;  :propagations            19651
;  :quant-instantiations    12021
;  :rlimit-count            1469960
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@169@03 $Ref)
(declare-const res@170@03 void)
(declare-const $t@171@03 $Snap)
(assert (= $t@171@03 ($Snap.combine ($Snap.first $t@171@03) ($Snap.second $t@171@03))))
(assert (= ($Snap.first $t@171@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@169@03 $Ref.null))
(assert (=
  ($Snap.second $t@171@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@171@03))
    ($Snap.second ($Snap.second $t@171@03)))))
(assert (= ($Snap.first ($Snap.second $t@171@03)) $Snap.unit))
; [eval] exc == null ==> P != (None(): option[array])
; [eval] exc == null
(push) ; 13
(set-option :timeout 10)
(push) ; 14
(assert (not (not (= exc@169@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29134
;  :arith-add-rows          21349
;  :arith-assert-diseq      1801
;  :arith-assert-lower      8801
;  :arith-assert-upper      5585
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5789
;  :arith-fixed-eqs         3073
;  :arith-offset-eqs        3434
;  :arith-pivots            4061
;  :conflicts               1174
;  :datatype-accessor-ax    89
;  :datatype-constructor-ax 748
;  :datatype-occurs-check   316
;  :datatype-splits         308
;  :decisions               3201
;  :del-clause              42047
;  :final-checks            179
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.24
;  :minimized-lits          139
;  :mk-bool-var             56913
;  :mk-clause               42060
;  :num-allocs              507630
;  :num-checks              281
;  :propagations            19651
;  :quant-instantiations    12021
;  :rlimit-count            1471160)
; [then-branch: 184 | exc@169@03 == Null | live]
; [else-branch: 184 | exc@169@03 != Null | dead]
(push) ; 14
; [then-branch: 184 | exc@169@03 == Null]
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (= exc@169@03 $Ref.null)
  (not (= res@156@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@171@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@171@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@171@03))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(P)) == V
; [eval] exc == null
(push) ; 13
(push) ; 14
(assert (not (not (= exc@169@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29201
;  :arith-add-rows          21349
;  :arith-assert-diseq      1801
;  :arith-assert-lower      8801
;  :arith-assert-upper      5585
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5789
;  :arith-fixed-eqs         3073
;  :arith-offset-eqs        3434
;  :arith-pivots            4061
;  :conflicts               1174
;  :datatype-accessor-ax    90
;  :datatype-constructor-ax 760
;  :datatype-occurs-check   322
;  :datatype-splits         316
;  :decisions               3213
;  :del-clause              42047
;  :final-checks            181
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.24
;  :minimized-lits          139
;  :mk-bool-var             56923
;  :mk-clause               42060
;  :num-allocs              508505
;  :num-checks              282
;  :propagations            19651
;  :quant-instantiations    12021
;  :rlimit-count            1472240)
; [then-branch: 185 | exc@169@03 == Null | live]
; [else-branch: 185 | exc@169@03 != Null | dead]
(push) ; 14
; [then-branch: 185 | exc@169@03 == Null]
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (= exc@169@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@156@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@171@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))))
; [eval] exc == null
(push) ; 13
(assert (not (not (= exc@169@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29270
;  :arith-add-rows          21349
;  :arith-assert-diseq      1801
;  :arith-assert-lower      8801
;  :arith-assert-upper      5585
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5789
;  :arith-fixed-eqs         3073
;  :arith-offset-eqs        3434
;  :arith-pivots            4061
;  :conflicts               1174
;  :datatype-accessor-ax    91
;  :datatype-constructor-ax 773
;  :datatype-occurs-check   328
;  :datatype-splits         325
;  :decisions               3226
;  :del-clause              42047
;  :final-checks            183
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.24
;  :minimized-lits          139
;  :mk-bool-var             56933
;  :mk-clause               42060
;  :num-allocs              509380
;  :num-checks              283
;  :propagations            19651
;  :quant-instantiations    12021
;  :rlimit-count            1473312)
; [then-branch: 186 | exc@169@03 == Null | live]
; [else-branch: 186 | exc@169@03 != Null | dead]
(push) ; 13
; [then-branch: 186 | exc@169@03 == Null]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
  $Snap.unit))
; [eval] exc == null ==> |this.P_seq| == V
; [eval] exc == null
(push) ; 14
(push) ; 15
(assert (not (not (= exc@169@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29341
;  :arith-add-rows          21349
;  :arith-assert-diseq      1801
;  :arith-assert-lower      8801
;  :arith-assert-upper      5585
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5789
;  :arith-fixed-eqs         3073
;  :arith-offset-eqs        3434
;  :arith-pivots            4061
;  :conflicts               1174
;  :datatype-accessor-ax    92
;  :datatype-constructor-ax 786
;  :datatype-occurs-check   334
;  :datatype-splits         334
;  :decisions               3239
;  :del-clause              42047
;  :final-checks            185
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.24
;  :minimized-lits          139
;  :mk-bool-var             56944
;  :mk-clause               42060
;  :num-allocs              510267
;  :num-checks              284
;  :propagations            19651
;  :quant-instantiations    12021
;  :rlimit-count            1474426)
; [then-branch: 187 | exc@169@03 == Null | live]
; [else-branch: 187 | exc@169@03 != Null | dead]
(push) ; 15
; [then-branch: 187 | exc@169@03 == Null]
; [eval] |this.P_seq| == V
; [eval] |this.P_seq|
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (= exc@169@03 $Ref.null)
  (=
    (Seq_length
      ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))
    V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))))))
; [eval] exc == null
(push) ; 14
(assert (not (not (= exc@169@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29419
;  :arith-add-rows          21350
;  :arith-assert-diseq      1801
;  :arith-assert-lower      8803
;  :arith-assert-upper      5586
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5790
;  :arith-fixed-eqs         3074
;  :arith-offset-eqs        3434
;  :arith-pivots            4062
;  :conflicts               1174
;  :datatype-accessor-ax    93
;  :datatype-constructor-ax 800
;  :datatype-occurs-check   340
;  :datatype-splits         344
;  :decisions               3253
;  :del-clause              42047
;  :final-checks            187
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.24
;  :minimized-lits          139
;  :mk-bool-var             56961
;  :mk-clause               42060
;  :num-allocs              511198
;  :num-checks              285
;  :propagations            19651
;  :quant-instantiations    12023
;  :rlimit-count            1475682)
; [then-branch: 188 | exc@169@03 == Null | live]
; [else-branch: 188 | exc@169@03 != Null | dead]
(push) ; 14
; [then-branch: 188 | exc@169@03 == Null]
(declare-const k@172@03 Int)
(push) ; 15
; [eval] 0 <= k && k < V
; [eval] 0 <= k
(push) ; 16
; [then-branch: 189 | 0 <= k@172@03 | live]
; [else-branch: 189 | !(0 <= k@172@03) | live]
(push) ; 17
; [then-branch: 189 | 0 <= k@172@03]
(assert (<= 0 k@172@03))
; [eval] k < V
(pop) ; 17
(push) ; 17
; [else-branch: 189 | !(0 <= k@172@03)]
(assert (not (<= 0 k@172@03)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(assert (and (< k@172@03 V@26@03) (<= 0 k@172@03)))
; [eval] aloc(opt_get1(P), k)
; [eval] opt_get1(P)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< k@172@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29419
;  :arith-add-rows          21351
;  :arith-assert-diseq      1801
;  :arith-assert-lower      8805
;  :arith-assert-upper      5586
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5790
;  :arith-fixed-eqs         3074
;  :arith-offset-eqs        3434
;  :arith-pivots            4062
;  :conflicts               1174
;  :datatype-accessor-ax    93
;  :datatype-constructor-ax 800
;  :datatype-occurs-check   340
;  :datatype-splits         344
;  :decisions               3253
;  :del-clause              42047
;  :final-checks            187
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.24
;  :minimized-lits          139
;  :mk-bool-var             56963
;  :mk-clause               42060
;  :num-allocs              511301
;  :num-checks              286
;  :propagations            19651
;  :quant-instantiations    12023
;  :rlimit-count            1475868)
(assert (< k@172@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 16
; Joined path conditions
(assert (< k@172@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 15
(declare-fun inv@173@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((k@172@03 Int)) (!
  (< k@172@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k@172@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 15
(assert (not (forall ((k1@172@03 Int) (k2@172@03 Int)) (!
  (implies
    (and
      (and (< k1@172@03 V@26@03) (<= 0 k1@172@03))
      (and (< k2@172@03 V@26@03) (<= 0 k2@172@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k1@172@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k2@172@03)))
    (= k1@172@03 k2@172@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29426
;  :arith-add-rows          21355
;  :arith-assert-diseq      1802
;  :arith-assert-lower      8809
;  :arith-assert-upper      5586
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5791
;  :arith-fixed-eqs         3074
;  :arith-offset-eqs        3434
;  :arith-pivots            4062
;  :conflicts               1175
;  :datatype-accessor-ax    93
;  :datatype-constructor-ax 800
;  :datatype-occurs-check   340
;  :datatype-splits         344
;  :decisions               3253
;  :del-clause              42053
;  :final-checks            187
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.24
;  :minimized-lits          139
;  :mk-bool-var             56980
;  :mk-clause               42066
;  :num-allocs              511778
;  :num-checks              287
;  :propagations            19651
;  :quant-instantiations    12033
;  :rlimit-count            1476699)
; Definitional axioms for inverse functions
(assert (forall ((k@172@03 Int)) (!
  (implies
    (and (< k@172@03 V@26@03) (<= 0 k@172@03))
    (=
      (inv@173@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k@172@03))
      k@172@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k@172@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@173@03 r))
      r))
  :pattern ((inv@173@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((k@172@03 Int)) (!
  (implies
    (and (< k@172@03 V@26@03) (<= 0 k@172@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k@172@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) k@172@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@174@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
    (=
      ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r)))
  :pattern (($FVF.lookup_int (as sm@174@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
        (< (inv@150@03 r) V@26@03))
      (<= 0 (inv@150@03 r)))
    (=
      ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@174@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef51|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@174@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef52|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r)))
    (=
      ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@174@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef53|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r)))
    (=
      ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@174@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef54|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@174@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef55|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r) r))
  :pattern ((inv@173@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(P), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(P), i1).int == 0)
; [eval] exc == null
(push) ; 15
(set-option :timeout 10)
(push) ; 16
(assert (not (not (= exc@169@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29503
;  :arith-add-rows          21355
;  :arith-assert-diseq      1802
;  :arith-assert-lower      8809
;  :arith-assert-upper      5586
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5791
;  :arith-fixed-eqs         3074
;  :arith-offset-eqs        3434
;  :arith-pivots            4062
;  :conflicts               1175
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 814
;  :datatype-occurs-check   346
;  :datatype-splits         354
;  :decisions               3267
;  :del-clause              42053
;  :final-checks            189
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          139
;  :mk-bool-var             57002
;  :mk-clause               42066
;  :num-allocs              514721
;  :num-checks              288
;  :propagations            19651
;  :quant-instantiations    12033
;  :rlimit-count            1486683
;  :time                    0.00)
; [then-branch: 190 | exc@169@03 == Null | live]
; [else-branch: 190 | exc@169@03 != Null | dead]
(push) ; 16
; [then-branch: 190 | exc@169@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(P), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(P), i1).int == 0)
(declare-const i1@175@03 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(P), i1).int == 0
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 191 | 0 <= i1@175@03 | live]
; [else-branch: 191 | !(0 <= i1@175@03) | live]
(push) ; 19
; [then-branch: 191 | 0 <= i1@175@03]
(assert (<= 0 i1@175@03))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 191 | !(0 <= i1@175@03)]
(assert (not (<= 0 i1@175@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(push) ; 18
; [then-branch: 192 | i1@175@03 < V@26@03 && 0 <= i1@175@03 | live]
; [else-branch: 192 | !(i1@175@03 < V@26@03 && 0 <= i1@175@03) | live]
(push) ; 19
; [then-branch: 192 | i1@175@03 < V@26@03 && 0 <= i1@175@03]
(assert (and (< i1@175@03 V@26@03) (<= 0 i1@175@03)))
; [eval] aloc(opt_get1(P), i1).int == 0
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(push) ; 20
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 21
(assert (not (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29503
;  :arith-add-rows          21356
;  :arith-assert-diseq      1802
;  :arith-assert-lower      8811
;  :arith-assert-upper      5586
;  :arith-bound-prop        2563
;  :arith-conflicts         482
;  :arith-eq-adapter        5791
;  :arith-fixed-eqs         3074
;  :arith-offset-eqs        3434
;  :arith-pivots            4062
;  :conflicts               1175
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 814
;  :datatype-occurs-check   346
;  :datatype-splits         354
;  :decisions               3267
;  :del-clause              42053
;  :final-checks            189
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          139
;  :mk-bool-var             57004
;  :mk-clause               42066
;  :num-allocs              514824
;  :num-checks              289
;  :propagations            19651
;  :quant-instantiations    12033
;  :rlimit-count            1486879)
(assert (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 20
; Joined path conditions
(assert (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)))
(push) ; 20
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (ite
            (and
              (<
                (inv@173@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                V@26@03)
              (<=
                0
                (inv@173@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
            $Perm.Write
            $Perm.No)
          (ite
            (and
              (and
                (and
                  (<
                    (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                    V@26@03)
                  (<=
                    0
                    (inv@151@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
                (<
                  (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                  V@26@03))
              (<=
                0
                (inv@150@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
            $Perm.Write
            $Perm.No))
        (ite
          (and
            (and
              (and
                (<
                  (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                  V@26@03)
                (<=
                  0
                  (inv@146@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
              (<
                (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                V@26@03))
            (<=
              0
              (inv@145@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
          $k@144@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (and
                (and
                  (<
                    (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                    V@26@03)
                  (<=
                    0
                    (inv@86@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
                (<
                  (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                  V@26@03))
              (<=
                0
                (inv@85@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)))
        (pTaken@122@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
    (-
      (-
        (ite
          (and
            (and
              (and
                (<
                  (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                  V@26@03)
                (<=
                  0
                  (inv@41@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
              (<
                (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
                V@26@03))
            (<=
              0
              (inv@40@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
          $Perm.Write
          $Perm.No)
        (pTaken@115@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)))
      (pTaken@121@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)))))))
(check-sat)
; unsat
(pop) ; 20
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29832
;  :arith-add-rows          21714
;  :arith-assert-diseq      1815
;  :arith-assert-lower      8906
;  :arith-assert-upper      5673
;  :arith-bound-prop        2610
;  :arith-conflicts         495
;  :arith-eq-adapter        5859
;  :arith-fixed-eqs         3114
;  :arith-offset-eqs        3464
;  :arith-pivots            4120
;  :conflicts               1199
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 818
;  :datatype-occurs-check   346
;  :datatype-splits         354
;  :decisions               3413
;  :del-clause              43180
;  :final-checks            189
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.30
;  :minimized-lits          158
;  :mk-bool-var             58418
;  :mk-clause               43389
;  :num-allocs              518410
;  :num-checks              290
;  :propagations            20068
;  :quant-instantiations    12230
;  :rlimit-count            1509777
;  :time                    0.01)
(pop) ; 19
(push) ; 19
; [else-branch: 192 | !(i1@175@03 < V@26@03 && 0 <= i1@175@03)]
(assert (not (and (< i1@175@03 V@26@03) (<= 0 i1@175@03))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (and (< i1@175@03 V@26@03) (<= 0 i1@175@03))
  (and
    (< i1@175@03 V@26@03)
    (<= 0 i1@175@03)
    (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)))))
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@175@03 Int)) (!
  (implies
    (and (< i1@175@03 V@26@03) (<= 0 i1@175@03))
    (and
      (< i1@175@03 V@26@03)
      (<= 0 i1@175@03)
      (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (= exc@169@03 $Ref.null)
  (forall ((i1@175@03 Int)) (!
    (implies
      (and (< i1@175@03 V@26@03) (<= 0 i1@175@03))
      (and
        (< i1@175@03 V@26@03)
        (<= 0 i1@175@03)
        (< i1@175@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@169@03 $Ref.null)
  (forall ((i1@175@03 Int)) (!
    (implies
      (and (< i1@175@03 V@26@03) (<= 0 i1@175@03))
      (=
        ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
        0))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@175@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { this.P_seq[i1] } 0 <= i1 && i1 < V ==> this.P_seq[i1] == 0)
; [eval] exc == null
(push) ; 15
(set-option :timeout 10)
(push) ; 16
(assert (not (not (= exc@169@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29902
;  :arith-add-rows          21727
;  :arith-assert-diseq      1815
;  :arith-assert-lower      8906
;  :arith-assert-upper      5673
;  :arith-bound-prop        2610
;  :arith-conflicts         495
;  :arith-eq-adapter        5859
;  :arith-fixed-eqs         3114
;  :arith-offset-eqs        3464
;  :arith-pivots            4138
;  :conflicts               1199
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 831
;  :datatype-occurs-check   352
;  :datatype-splits         363
;  :decisions               3426
;  :del-clause              43376
;  :final-checks            191
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          158
;  :mk-bool-var             58430
;  :mk-clause               43389
;  :num-allocs              519632
;  :num-checks              291
;  :propagations            20068
;  :quant-instantiations    12230
;  :rlimit-count            1511816
;  :time                    0.00)
; [then-branch: 193 | exc@169@03 == Null | live]
; [else-branch: 193 | exc@169@03 != Null | dead]
(push) ; 16
; [then-branch: 193 | exc@169@03 == Null]
; [eval] (forall i1: Int :: { this.P_seq[i1] } 0 <= i1 && i1 < V ==> this.P_seq[i1] == 0)
(declare-const i1@176@03 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V ==> this.P_seq[i1] == 0
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 194 | 0 <= i1@176@03 | live]
; [else-branch: 194 | !(0 <= i1@176@03) | live]
(push) ; 19
; [then-branch: 194 | 0 <= i1@176@03]
(assert (<= 0 i1@176@03))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 194 | !(0 <= i1@176@03)]
(assert (not (<= 0 i1@176@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(push) ; 18
; [then-branch: 195 | i1@176@03 < V@26@03 && 0 <= i1@176@03 | live]
; [else-branch: 195 | !(i1@176@03 < V@26@03 && 0 <= i1@176@03) | live]
(push) ; 19
; [then-branch: 195 | i1@176@03 < V@26@03 && 0 <= i1@176@03]
(assert (and (< i1@176@03 V@26@03) (<= 0 i1@176@03)))
; [eval] this.P_seq[i1] == 0
; [eval] this.P_seq[i1]
(set-option :timeout 0)
(push) ; 20
(assert (not (>= i1@176@03 0)))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29902
;  :arith-add-rows          21728
;  :arith-assert-diseq      1815
;  :arith-assert-lower      8908
;  :arith-assert-upper      5673
;  :arith-bound-prop        2610
;  :arith-conflicts         495
;  :arith-eq-adapter        5859
;  :arith-fixed-eqs         3114
;  :arith-offset-eqs        3464
;  :arith-pivots            4138
;  :conflicts               1199
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 831
;  :datatype-occurs-check   352
;  :datatype-splits         363
;  :decisions               3426
;  :del-clause              43376
;  :final-checks            191
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          158
;  :mk-bool-var             58432
;  :mk-clause               43389
;  :num-allocs              519730
;  :num-checks              292
;  :propagations            20068
;  :quant-instantiations    12230
;  :rlimit-count            1511991)
(push) ; 20
(assert (not (<
  i1@176@03
  (Seq_length
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29902
;  :arith-add-rows          21728
;  :arith-assert-diseq      1815
;  :arith-assert-lower      8908
;  :arith-assert-upper      5673
;  :arith-bound-prop        2610
;  :arith-conflicts         495
;  :arith-eq-adapter        5859
;  :arith-fixed-eqs         3114
;  :arith-offset-eqs        3464
;  :arith-pivots            4138
;  :conflicts               1199
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 831
;  :datatype-occurs-check   352
;  :datatype-splits         363
;  :decisions               3426
;  :del-clause              43376
;  :final-checks            191
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          158
;  :mk-bool-var             58432
;  :mk-clause               43389
;  :num-allocs              519750
;  :num-checks              293
;  :propagations            20068
;  :quant-instantiations    12230
;  :rlimit-count            1512011)
(pop) ; 19
(push) ; 19
; [else-branch: 195 | !(i1@176@03 < V@26@03 && 0 <= i1@176@03)]
(assert (not (and (< i1@176@03 V@26@03) (<= 0 i1@176@03))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (= exc@169@03 $Ref.null)
  (forall ((i1@176@03 Int)) (!
    (implies
      (and (< i1@176@03 V@26@03) (<= 0 i1@176@03))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
          i1@176@03)
        0))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
      i1@176@03))
    :qid |prog.l<no position>|))))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 196 | exc@169@03 != Null | dead]
; [else-branch: 196 | exc@169@03 == Null | live]
(push) ; 15
; [else-branch: 196 | exc@169@03 == Null]
(pop) ; 15
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 15
(assert (not (not (= exc@169@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30038
;  :arith-add-rows          21728
;  :arith-assert-diseq      1815
;  :arith-assert-lower      8908
;  :arith-assert-upper      5673
;  :arith-bound-prop        2610
;  :arith-conflicts         495
;  :arith-eq-adapter        5859
;  :arith-fixed-eqs         3114
;  :arith-offset-eqs        3464
;  :arith-pivots            4138
;  :conflicts               1199
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 857
;  :datatype-occurs-check   364
;  :datatype-splits         381
;  :decisions               3452
;  :del-clause              43376
;  :final-checks            195
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          158
;  :mk-bool-var             58451
;  :mk-clause               43389
;  :num-allocs              521528
;  :num-checks              295
;  :propagations            20068
;  :quant-instantiations    12230
;  :rlimit-count            1514249)
; [then-branch: 197 | exc@169@03 == Null | live]
; [else-branch: 197 | exc@169@03 != Null | dead]
(push) ; 15
; [then-branch: 197 | exc@169@03 == Null]
; [exec]
; evaluationDummy1 := res4
; [exec]
; exc, res5 := executeEdmondKarp(this, tid, G, Gf, s, t, P, V)
; [eval] this != null
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@177@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 198 | 0 <= i1@177@03 | live]
; [else-branch: 198 | !(0 <= i1@177@03) | live]
(push) ; 18
; [then-branch: 198 | 0 <= i1@177@03]
(assert (<= 0 i1@177@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 198 | !(0 <= i1@177@03)]
(assert (not (<= 0 i1@177@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@177@03 V@26@03) (<= 0 i1@177@03)))
(declare-const $k@178@03 $Perm)
(assert ($Perm.isReadVar $k@178@03 $Perm.Write))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30038
;  :arith-add-rows          21729
;  :arith-assert-diseq      1816
;  :arith-assert-lower      8912
;  :arith-assert-upper      5674
;  :arith-bound-prop        2610
;  :arith-conflicts         495
;  :arith-eq-adapter        5860
;  :arith-fixed-eqs         3114
;  :arith-offset-eqs        3464
;  :arith-pivots            4138
;  :conflicts               1199
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 857
;  :datatype-occurs-check   364
;  :datatype-splits         381
;  :decisions               3452
;  :del-clause              43376
;  :final-checks            195
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          158
;  :mk-bool-var             58457
;  :mk-clause               43391
;  :num-allocs              521698
;  :num-checks              296
;  :propagations            20069
;  :quant-instantiations    12230
;  :rlimit-count            1514580)
(assert (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 16
(declare-fun inv@179@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@178@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@177@03 Int)) (!
  (< i1@177@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@177@03))
  :qid |option$array$-aux|)))
(push) ; 16
(assert (not (forall ((i1@177@03 Int)) (!
  (implies
    (and (< i1@177@03 V@26@03) (<= 0 i1@177@03))
    (or (= $k@178@03 $Perm.No) (< $Perm.No $k@178@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30038
;  :arith-add-rows          21730
;  :arith-assert-diseq      1817
;  :arith-assert-lower      8914
;  :arith-assert-upper      5675
;  :arith-bound-prop        2610
;  :arith-conflicts         495
;  :arith-eq-adapter        5861
;  :arith-fixed-eqs         3114
;  :arith-offset-eqs        3464
;  :arith-pivots            4138
;  :conflicts               1200
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 857
;  :datatype-occurs-check   364
;  :datatype-splits         381
;  :decisions               3452
;  :del-clause              43378
;  :final-checks            195
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          158
;  :mk-bool-var             58464
;  :mk-clause               43393
;  :num-allocs              522128
;  :num-checks              297
;  :propagations            20070
;  :quant-instantiations    12230
;  :rlimit-count            1515127)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@177@03 Int) (i12@177@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@177@03 V@26@03) (<= 0 i11@177@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@177@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@177@03)))
        (< $Perm.No $k@178@03))
      (and
        (and
          (and (< i12@177@03 V@26@03) (<= 0 i12@177@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@177@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@177@03)))
        (< $Perm.No $k@178@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@177@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@177@03)))
    (= i11@177@03 i12@177@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30049
;  :arith-add-rows          21740
;  :arith-assert-diseq      1818
;  :arith-assert-lower      8918
;  :arith-assert-upper      5675
;  :arith-bound-prop        2610
;  :arith-conflicts         495
;  :arith-eq-adapter        5862
;  :arith-fixed-eqs         3114
;  :arith-offset-eqs        3464
;  :arith-pivots            4138
;  :conflicts               1201
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 857
;  :datatype-occurs-check   364
;  :datatype-splits         381
;  :decisions               3452
;  :del-clause              43425
;  :final-checks            195
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.26
;  :minimized-lits          158
;  :mk-bool-var             58536
;  :mk-clause               43440
;  :num-allocs              522737
;  :num-checks              298
;  :propagations            20074
;  :quant-instantiations    12250
;  :rlimit-count            1516509)
; Definitional axioms for inverse functions
(assert (forall ((i1@177@03 Int)) (!
  (implies
    (and (and (< i1@177@03 V@26@03) (<= 0 i1@177@03)) (< $Perm.No $k@178@03))
    (=
      (inv@179@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@177@03))
      i1@177@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@177@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
      (< $Perm.No $k@178@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@179@03 r))
      r))
  :pattern ((inv@179@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) r) r))
  :pattern ((inv@179@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@180@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
        $k@135@03
        $Perm.No)
      $k@178@03)
    $Perm.No))
(define-fun pTaken@181@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
        $k@127@03
        $Perm.No)
      (- $k@178@03 (pTaken@180@03 r)))
    $Perm.No))
(define-fun pTaken@182@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 r))
        (pTaken@104@03 r))
      (- (- $k@178@03 (pTaken@180@03 r)) (pTaken@181@03 r)))
    $Perm.No))
(define-fun pTaken@183@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
            $k@31@03
            $Perm.No)
          (pTaken@94@03 r))
        (pTaken@103@03 r))
      (- (- (- $k@178@03 (pTaken@180@03 r)) (pTaken@181@03 r)) (pTaken@182@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@178@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
          $k@135@03
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
      (<
        (ite
          (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
          $k@178@03
          $Perm.No)
        $k@135@03)
      (<
        (ite
          (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
          $k@178@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@136@03 r))
  :pattern ((inv@179@03 r))
  :qid |qp.srp56|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@179@03 r) V@26@03) (<= 0 (inv@179@03 r)))
    (= (- $k@178@03 (pTaken@180@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30236
;  :arith-add-rows          21795
;  :arith-assert-diseq      1828
;  :arith-assert-lower      8952
;  :arith-assert-upper      5686
;  :arith-bound-prop        2623
;  :arith-conflicts         497
;  :arith-eq-adapter        5892
;  :arith-fixed-eqs         3123
;  :arith-offset-eqs        3486
;  :arith-pivots            4162
;  :conflicts               1209
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 874
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3472
;  :del-clause              43636
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.26
;  :minimized-lits          159
;  :mk-bool-var             58835
;  :mk-clause               43649
;  :num-allocs              526031
;  :num-checks              300
;  :propagations            20166
;  :quant-instantiations    12318
;  :rlimit-count            1524799
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@184@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 199 | 0 <= i1@184@03 | live]
; [else-branch: 199 | !(0 <= i1@184@03) | live]
(push) ; 18
; [then-branch: 199 | 0 <= i1@184@03]
(assert (<= 0 i1@184@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 199 | !(0 <= i1@184@03)]
(assert (not (<= 0 i1@184@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 200 | i1@184@03 < V@26@03 && 0 <= i1@184@03 | live]
; [else-branch: 200 | !(i1@184@03 < V@26@03 && 0 <= i1@184@03) | live]
(push) ; 18
; [then-branch: 200 | i1@184@03 < V@26@03 && 0 <= i1@184@03]
(assert (and (< i1@184@03 V@26@03) (<= 0 i1@184@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@184@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30236
;  :arith-add-rows          21796
;  :arith-assert-diseq      1828
;  :arith-assert-lower      8954
;  :arith-assert-upper      5686
;  :arith-bound-prop        2623
;  :arith-conflicts         497
;  :arith-eq-adapter        5892
;  :arith-fixed-eqs         3123
;  :arith-offset-eqs        3486
;  :arith-pivots            4162
;  :conflicts               1209
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 874
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3472
;  :del-clause              43636
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.27
;  :minimized-lits          159
;  :mk-bool-var             58837
;  :mk-clause               43649
;  :num-allocs              526141
;  :num-checks              301
;  :propagations            20166
;  :quant-instantiations    12318
;  :rlimit-count            1524990)
(assert (< i1@184@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 19
; Joined path conditions
(assert (< i1@184@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30886
;  :arith-add-rows          22852
;  :arith-assert-diseq      1900
;  :arith-assert-lower      9203
;  :arith-assert-upper      5862
;  :arith-bound-prop        2699
;  :arith-conflicts         518
;  :arith-eq-adapter        6084
;  :arith-fixed-eqs         3224
;  :arith-offset-eqs        3578
;  :arith-pivots            4297
;  :conflicts               1246
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 878
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3516
;  :del-clause              44198
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.31
;  :minimized-lits          172
;  :mk-bool-var             59775
;  :mk-clause               44393
;  :num-allocs              530547
;  :num-checks              302
;  :propagations            20619
;  :quant-instantiations    12443
;  :rlimit-count            1564901
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 18
(push) ; 18
; [else-branch: 200 | !(i1@184@03 < V@26@03 && 0 <= i1@184@03)]
(assert (not (and (< i1@184@03 V@26@03) (<= 0 i1@184@03))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< i1@184@03 V@26@03) (<= 0 i1@184@03))
  (and
    (< i1@184@03 V@26@03)
    (<= 0 i1@184@03)
    (< i1@184@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@184@03 Int)) (!
  (implies
    (and (< i1@184@03 V@26@03) (<= 0 i1@184@03))
    (and
      (< i1@184@03 V@26@03)
      (<= 0 i1@184@03)
      (< i1@184@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@184@03 Int)) (!
  (implies
    (and (< i1@184@03 V@26@03) (<= 0 i1@184@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30894
;  :arith-add-rows          22882
;  :arith-assert-diseq      1900
;  :arith-assert-lower      9205
;  :arith-assert-upper      5862
;  :arith-bound-prop        2699
;  :arith-conflicts         518
;  :arith-eq-adapter        6089
;  :arith-fixed-eqs         3224
;  :arith-offset-eqs        3578
;  :arith-pivots            4314
;  :conflicts               1247
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 878
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3516
;  :del-clause              44512
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.28
;  :minimized-lits          172
;  :mk-bool-var             59937
;  :mk-clause               44525
;  :num-allocs              531778
;  :num-checks              303
;  :propagations            20623
;  :quant-instantiations    12488
;  :rlimit-count            1568405
;  :time                    0.00)
(assert (forall ((i1@184@03 Int)) (!
  (implies
    (and (< i1@184@03 V@26@03) (<= 0 i1@184@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@184@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@185@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 201 | 0 <= i1@185@03 | live]
; [else-branch: 201 | !(0 <= i1@185@03) | live]
(push) ; 18
; [then-branch: 201 | 0 <= i1@185@03]
(assert (<= 0 i1@185@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 201 | !(0 <= i1@185@03)]
(assert (not (<= 0 i1@185@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 202 | i1@185@03 < V@26@03 && 0 <= i1@185@03 | live]
; [else-branch: 202 | !(i1@185@03 < V@26@03 && 0 <= i1@185@03) | live]
(push) ; 18
; [then-branch: 202 | i1@185@03 < V@26@03 && 0 <= i1@185@03]
(assert (and (< i1@185@03 V@26@03) (<= 0 i1@185@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30894
;  :arith-add-rows          22883
;  :arith-assert-diseq      1900
;  :arith-assert-lower      9207
;  :arith-assert-upper      5862
;  :arith-bound-prop        2699
;  :arith-conflicts         518
;  :arith-eq-adapter        6089
;  :arith-fixed-eqs         3224
;  :arith-offset-eqs        3578
;  :arith-pivots            4314
;  :conflicts               1247
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 878
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3516
;  :del-clause              44512
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.37
;  :memory                  10.28
;  :minimized-lits          172
;  :mk-bool-var             59940
;  :mk-clause               44525
;  :num-allocs              532071
;  :num-checks              304
;  :propagations            20623
;  :quant-instantiations    12488
;  :rlimit-count            1568905)
(assert (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 19
; Joined path conditions
(assert (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31462
;  :arith-add-rows          23713
;  :arith-assert-diseq      1949
;  :arith-assert-lower      9419
;  :arith-assert-upper      5989
;  :arith-bound-prop        2768
;  :arith-conflicts         537
;  :arith-eq-adapter        6237
;  :arith-fixed-eqs         3306
;  :arith-offset-eqs        3660
;  :arith-pivots            4431
;  :conflicts               1278
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 882
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3589
;  :del-clause              45268
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.53
;  :memory                  10.51
;  :minimized-lits          175
;  :mk-bool-var             61280
;  :mk-clause               45464
;  :num-allocs              537611
;  :num-checks              305
;  :propagations            21058
;  :quant-instantiations    12677
;  :rlimit-count            1601680
;  :time                    0.01)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 20
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31462
;  :arith-add-rows          23713
;  :arith-assert-diseq      1949
;  :arith-assert-lower      9419
;  :arith-assert-upper      5989
;  :arith-bound-prop        2768
;  :arith-conflicts         537
;  :arith-eq-adapter        6237
;  :arith-fixed-eqs         3306
;  :arith-offset-eqs        3660
;  :arith-pivots            4431
;  :conflicts               1279
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 882
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3589
;  :del-clause              45268
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.53
;  :memory                  10.51
;  :minimized-lits          175
;  :mk-bool-var             61280
;  :mk-clause               45464
;  :num-allocs              537701
;  :num-checks              306
;  :propagations            21058
;  :quant-instantiations    12677
;  :rlimit-count            1601775)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
    (as None<option<array>>  option<array>))))
(pop) ; 19
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
    (as None<option<array>>  option<array>))))
(pop) ; 18
(push) ; 18
; [else-branch: 202 | !(i1@185@03 < V@26@03 && 0 <= i1@185@03)]
(assert (not (and (< i1@185@03 V@26@03) (<= 0 i1@185@03))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< i1@185@03 V@26@03) (<= 0 i1@185@03))
  (and
    (< i1@185@03 V@26@03)
    (<= 0 i1@185@03)
    (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@185@03 Int)) (!
  (implies
    (and (< i1@185@03 V@26@03) (<= 0 i1@185@03))
    (and
      (< i1@185@03 V@26@03)
      (<= 0 i1@185@03)
      (< i1@185@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@185@03 Int)) (!
  (implies
    (and (< i1@185@03 V@26@03) (<= 0 i1@185@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31462
;  :arith-add-rows          23745
;  :arith-assert-diseq      1949
;  :arith-assert-lower      9421
;  :arith-assert-upper      5989
;  :arith-bound-prop        2768
;  :arith-conflicts         537
;  :arith-eq-adapter        6239
;  :arith-fixed-eqs         3306
;  :arith-offset-eqs        3660
;  :arith-pivots            4461
;  :conflicts               1280
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 882
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3589
;  :del-clause              45505
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.53
;  :memory                  10.48
;  :minimized-lits          175
;  :mk-bool-var             61354
;  :mk-clause               45518
;  :num-allocs              538428
;  :num-checks              307
;  :propagations            21058
;  :quant-instantiations    12697
;  :rlimit-count            1603974)
(assert (forall ((i1@185@03 Int)) (!
  (implies
    (and (< i1@185@03 V@26@03) (<= 0 i1@185@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@185@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@186@03 Int)
(push) ; 16
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@187@03 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 203 | 0 <= i1@186@03 | live]
; [else-branch: 203 | !(0 <= i1@186@03) | live]
(push) ; 19
; [then-branch: 203 | 0 <= i1@186@03]
(assert (<= 0 i1@186@03))
; [eval] i1 < V
(push) ; 20
; [then-branch: 204 | i1@186@03 < V@26@03 | live]
; [else-branch: 204 | !(i1@186@03 < V@26@03) | live]
(push) ; 21
; [then-branch: 204 | i1@186@03 < V@26@03]
(assert (< i1@186@03 V@26@03))
; [eval] 0 <= i2
(push) ; 22
; [then-branch: 205 | 0 <= i2@187@03 | live]
; [else-branch: 205 | !(0 <= i2@187@03) | live]
(push) ; 23
; [then-branch: 205 | 0 <= i2@187@03]
(assert (<= 0 i2@187@03))
; [eval] i2 < V
(push) ; 24
; [then-branch: 206 | i2@187@03 < V@26@03 | live]
; [else-branch: 206 | !(i2@187@03 < V@26@03) | live]
(push) ; 25
; [then-branch: 206 | i2@187@03 < V@26@03]
(assert (< i2@187@03 V@26@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31462
;  :arith-add-rows          23747
;  :arith-assert-diseq      1949
;  :arith-assert-lower      9425
;  :arith-assert-upper      5989
;  :arith-bound-prop        2768
;  :arith-conflicts         537
;  :arith-eq-adapter        6239
;  :arith-fixed-eqs         3306
;  :arith-offset-eqs        3660
;  :arith-pivots            4461
;  :conflicts               1280
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 882
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3589
;  :del-clause              45505
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.53
;  :memory                  10.49
;  :minimized-lits          175
;  :mk-bool-var             61359
;  :mk-clause               45518
;  :num-allocs              538906
;  :num-checks              308
;  :propagations            21058
;  :quant-instantiations    12697
;  :rlimit-count            1604617)
(assert (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 26
; Joined path conditions
(assert (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)))
(push) ; 26
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)))))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31629
;  :arith-add-rows          23917
;  :arith-assert-diseq      1957
;  :arith-assert-lower      9474
;  :arith-assert-upper      6033
;  :arith-bound-prop        2796
;  :arith-conflicts         544
;  :arith-eq-adapter        6279
;  :arith-fixed-eqs         3334
;  :arith-offset-eqs        3683
;  :arith-pivots            4499
;  :conflicts               1294
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 886
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3608
;  :del-clause              45615
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.53
;  :memory                  10.52
;  :minimized-lits          175
;  :mk-bool-var             61795
;  :mk-clause               45810
;  :num-allocs              541432
;  :num-checks              309
;  :propagations            21141
;  :quant-instantiations    12785
;  :rlimit-count            1615077
;  :time                    0.00)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               31629
;  :arith-add-rows          23917
;  :arith-assert-diseq      1957
;  :arith-assert-lower      9474
;  :arith-assert-upper      6033
;  :arith-bound-prop        2796
;  :arith-conflicts         544
;  :arith-eq-adapter        6279
;  :arith-fixed-eqs         3334
;  :arith-offset-eqs        3683
;  :arith-pivots            4499
;  :conflicts               1294
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 886
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3608
;  :del-clause              45615
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.53
;  :memory                  10.52
;  :minimized-lits          175
;  :mk-bool-var             61795
;  :mk-clause               45810
;  :num-allocs              541458
;  :num-checks              310
;  :propagations            21141
;  :quant-instantiations    12785
;  :rlimit-count            1615107)
(assert (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 26
; Joined path conditions
(assert (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
(push) ; 26
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))))))
(check-sat)
; unsat
(pop) ; 26
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32924
;  :arith-add-rows          24939
;  :arith-assert-diseq      2049
;  :arith-assert-lower      9942
;  :arith-assert-upper      6324
;  :arith-bound-prop        2912
;  :arith-conflicts         563
;  :arith-eq-adapter        6535
;  :arith-fixed-eqs         3497
;  :arith-offset-eqs        3893
;  :arith-pivots            4651
;  :conflicts               1333
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 890
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3746
;  :del-clause              47026
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.65
;  :memory                  10.63
;  :minimized-lits          181
;  :mk-bool-var             63793
;  :mk-clause               47380
;  :num-allocs              550687
;  :num-checks              311
;  :propagations            22265
;  :quant-instantiations    13315
;  :rlimit-count            1670377
;  :time                    0.02)
(pop) ; 25
(push) ; 25
; [else-branch: 206 | !(i2@187@03 < V@26@03)]
(assert (not (< i2@187@03 V@26@03)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (implies
  (< i2@187@03 V@26@03)
  (and
    (< i2@187@03 V@26@03)
    (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
    (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))))
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 205 | !(0 <= i2@187@03)]
(assert (not (<= 0 i2@187@03)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (<= 0 i2@187@03)
  (and
    (<= 0 i2@187@03)
    (implies
      (< i2@187@03 V@26@03)
      (and
        (< i2@187@03 V@26@03)
        (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
        (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 204 | !(i1@186@03 < V@26@03)]
(assert (not (< i1@186@03 V@26@03)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (< i1@186@03 V@26@03)
  (and
    (< i1@186@03 V@26@03)
    (implies
      (<= 0 i2@187@03)
      (and
        (<= 0 i2@187@03)
        (implies
          (< i2@187@03 V@26@03)
          (and
            (< i2@187@03 V@26@03)
            (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
            (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 203 | !(0 <= i1@186@03)]
(assert (not (<= 0 i1@186@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (<= 0 i1@186@03)
  (and
    (<= 0 i1@186@03)
    (implies
      (< i1@186@03 V@26@03)
      (and
        (< i1@186@03 V@26@03)
        (implies
          (<= 0 i2@187@03)
          (and
            (<= 0 i2@187@03)
            (implies
              (< i2@187@03 V@26@03)
              (and
                (< i2@187@03 V@26@03)
                (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
                (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))))))))))
; Joined path conditions
(push) ; 18
; [then-branch: 207 | Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i1@186@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i2@187@03)) && i2@187@03 < V@26@03 && 0 <= i2@187@03 && i1@186@03 < V@26@03 && 0 <= i1@186@03 | live]
; [else-branch: 207 | !(Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i1@186@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i2@187@03)) && i2@187@03 < V@26@03 && 0 <= i2@187@03 && i1@186@03 < V@26@03 && 0 <= i1@186@03) | live]
(push) ; 19
; [then-branch: 207 | Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i1@186@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i2@187@03)) && i2@187@03 < V@26@03 && 0 <= i2@187@03 && i1@186@03 < V@26@03 && 0 <= i1@186@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
        (< i2@187@03 V@26@03))
      (<= 0 i2@187@03))
    (< i1@186@03 V@26@03))
  (<= 0 i1@186@03)))
; [eval] i1 == i2
(pop) ; 19
(push) ; 19
; [else-branch: 207 | !(Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i1@186@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, res@74@03), i2@187@03)) && i2@187@03 < V@26@03 && 0 <= i2@187@03 && i1@186@03 < V@26@03 && 0 <= i1@186@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
          (< i2@187@03 V@26@03))
        (<= 0 i2@187@03))
      (< i1@186@03 V@26@03))
    (<= 0 i1@186@03))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
          (< i2@187@03 V@26@03))
        (<= 0 i2@187@03))
      (< i1@186@03 V@26@03))
    (<= 0 i1@186@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
    (< i2@187@03 V@26@03)
    (<= 0 i2@187@03)
    (< i1@186@03 V@26@03)
    (<= 0 i1@186@03))))
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@187@03 Int)) (!
  (and
    (implies
      (<= 0 i1@186@03)
      (and
        (<= 0 i1@186@03)
        (implies
          (< i1@186@03 V@26@03)
          (and
            (< i1@186@03 V@26@03)
            (implies
              (<= 0 i2@187@03)
              (and
                (<= 0 i2@187@03)
                (implies
                  (< i2@187@03 V@26@03)
                  (and
                    (< i2@187@03 V@26@03)
                    (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
                    (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
              (< i2@187@03 V@26@03))
            (<= 0 i2@187@03))
          (< i1@186@03 V@26@03))
        (<= 0 i1@186@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
        (< i2@187@03 V@26@03)
        (<= 0 i2@187@03)
        (< i1@186@03 V@26@03)
        (<= 0 i1@186@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@186@03 Int)) (!
  (forall ((i2@187@03 Int)) (!
    (and
      (implies
        (<= 0 i1@186@03)
        (and
          (<= 0 i1@186@03)
          (implies
            (< i1@186@03 V@26@03)
            (and
              (< i1@186@03 V@26@03)
              (implies
                (<= 0 i2@187@03)
                (and
                  (<= 0 i2@187@03)
                  (implies
                    (< i2@187@03 V@26@03)
                    (and
                      (< i2@187@03 V@26@03)
                      (< i1@186@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
                      (< i2@187@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
                  ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
                (< i2@187@03 V@26@03))
              (<= 0 i2@187@03))
            (< i1@186@03 V@26@03))
          (<= 0 i1@186@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
          (< i2@187@03 V@26@03)
          (<= 0 i2@187@03)
          (< i1@186@03 V@26@03)
          (<= 0 i1@186@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@186@03 Int)) (!
  (forall ((i2@187@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
              (< i2@187@03 V@26@03))
            (<= 0 i2@187@03))
          (< i1@186@03 V@26@03))
        (<= 0 i1@186@03))
      (= i1@186@03 i2@187@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32977
;  :arith-add-rows          25013
;  :arith-assert-diseq      2051
;  :arith-assert-lower      9950
;  :arith-assert-upper      6328
;  :arith-bound-prop        2916
;  :arith-conflicts         563
;  :arith-eq-adapter        6560
;  :arith-fixed-eqs         3501
;  :arith-offset-eqs        3893
;  :arith-pivots            4695
;  :conflicts               1334
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 890
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3746
;  :del-clause              47741
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.65
;  :memory                  10.57
;  :minimized-lits          181
;  :mk-bool-var             64302
;  :mk-clause               47754
;  :num-allocs              553695
;  :num-checks              312
;  :propagations            22285
;  :quant-instantiations    13441
;  :rlimit-count            1681096
;  :time                    0.00)
(assert (forall ((i1@186@03 Int)) (!
  (forall ((i2@187@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03)))
              (< i2@187@03 V@26@03))
            (<= 0 i2@187@03))
          (< i1@186@03 V@26@03))
        (<= 0 i1@186@03))
      (= i1@186@03 i2@187@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@187@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@186@03))
  :qid |prog.l<no position>|)))
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(declare-const i1@188@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 208 | 0 <= i1@188@03 | live]
; [else-branch: 208 | !(0 <= i1@188@03) | live]
(push) ; 18
; [then-branch: 208 | 0 <= i1@188@03]
(assert (<= 0 i1@188@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 208 | !(0 <= i1@188@03)]
(assert (not (<= 0 i1@188@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@188@03 V@26@03) (<= 0 i1@188@03)))
(declare-const $k@189@03 $Perm)
(assert ($Perm.isReadVar $k@189@03 $Perm.Write))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@188@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32977
;  :arith-add-rows          25014
;  :arith-assert-diseq      2052
;  :arith-assert-lower      9954
;  :arith-assert-upper      6329
;  :arith-bound-prop        2916
;  :arith-conflicts         563
;  :arith-eq-adapter        6561
;  :arith-fixed-eqs         3501
;  :arith-offset-eqs        3893
;  :arith-pivots            4695
;  :conflicts               1334
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 890
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3746
;  :del-clause              47741
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.65
;  :memory                  10.57
;  :minimized-lits          181
;  :mk-bool-var             64309
;  :mk-clause               47756
;  :num-allocs              554187
;  :num-checks              313
;  :propagations            22286
;  :quant-instantiations    13441
;  :rlimit-count            1681952)
(assert (< i1@188@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@188@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 16
(declare-fun inv@190@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@189@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@188@03 Int)) (!
  (< i1@188@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@188@03))
  :qid |option$array$-aux|)))
(push) ; 16
(assert (not (forall ((i1@188@03 Int)) (!
  (implies
    (and (< i1@188@03 V@26@03) (<= 0 i1@188@03))
    (or (= $k@189@03 $Perm.No) (< $Perm.No $k@189@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32977
;  :arith-add-rows          25015
;  :arith-assert-diseq      2053
;  :arith-assert-lower      9956
;  :arith-assert-upper      6330
;  :arith-bound-prop        2916
;  :arith-conflicts         563
;  :arith-eq-adapter        6562
;  :arith-fixed-eqs         3501
;  :arith-offset-eqs        3893
;  :arith-pivots            4695
;  :conflicts               1335
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 890
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3746
;  :del-clause              47743
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.65
;  :memory                  10.57
;  :minimized-lits          181
;  :mk-bool-var             64316
;  :mk-clause               47758
;  :num-allocs              554616
;  :num-checks              314
;  :propagations            22287
;  :quant-instantiations    13441
;  :rlimit-count            1682499)
(declare-const sm@191@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
            $k@31@03
            $Perm.No)
          (pTaken@94@03 r))
        (pTaken@103@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r))
  :qid |qp.fvfValDef57|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 r))
        (pTaken@104@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
      (< $Perm.No $k@127@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
          $k@135@03
          $Perm.No)
        (pTaken@180@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef61|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@188@03 Int) (i12@188@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@188@03 V@26@03) (<= 0 i11@188@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@188@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@188@03)))
        (< $Perm.No $k@189@03))
      (and
        (and
          (and (< i12@188@03 V@26@03) (<= 0 i12@188@03))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@188@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@188@03)))
        (< $Perm.No $k@189@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@188@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@188@03)))
    (= i11@188@03 i12@188@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32991
;  :arith-add-rows          25026
;  :arith-assert-diseq      2054
;  :arith-assert-lower      9960
;  :arith-assert-upper      6330
;  :arith-bound-prop        2916
;  :arith-conflicts         563
;  :arith-eq-adapter        6563
;  :arith-fixed-eqs         3501
;  :arith-offset-eqs        3893
;  :arith-pivots            4695
;  :conflicts               1336
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 890
;  :datatype-occurs-check   370
;  :datatype-splits         390
;  :decisions               3746
;  :del-clause              47802
;  :final-checks            197
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.65
;  :memory                  10.58
;  :minimized-lits          181
;  :mk-bool-var             64408
;  :mk-clause               47817
;  :num-allocs              556574
;  :num-checks              315
;  :propagations            22291
;  :quant-instantiations    13465
;  :rlimit-count            1688659)
; Definitional axioms for inverse functions
(assert (forall ((i1@188@03 Int)) (!
  (implies
    (and (and (< i1@188@03 V@26@03) (<= 0 i1@188@03)) (< $Perm.No $k@189@03))
    (=
      (inv@190@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@188@03))
      i1@188@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@188@03))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@190@03 r) V@26@03) (<= 0 (inv@190@03 r)))
      (< $Perm.No $k@189@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@190@03 r))
      r))
  :pattern ((inv@190@03 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@190@03 r) V@26@03) (<= 0 (inv@190@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@191@03  $FVF<option<array>>) r) r))
  :pattern ((inv@190@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@192@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@190@03 r) V@26@03) (<= 0 (inv@190@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
            $k@31@03
            $Perm.No)
          (pTaken@94@03 r))
        (pTaken@103@03 r))
      $k@189@03)
    $Perm.No))
(define-fun pTaken@193@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@190@03 r) V@26@03) (<= 0 (inv@190@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 r))
        (pTaken@104@03 r))
      (- $k@189@03 (pTaken@192@03 r)))
    $Perm.No))
(define-fun pTaken@194@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@190@03 r) V@26@03) (<= 0 (inv@190@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
        $k@127@03
        $Perm.No)
      (- (- $k@189@03 (pTaken@192@03 r)) (pTaken@193@03 r)))
    $Perm.No))
(define-fun pTaken@195@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@190@03 r) V@26@03) (<= 0 (inv@190@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
          $k@135@03
          $Perm.No)
        (pTaken@180@03 r))
      (- (- (- $k@189@03 (pTaken@192@03 r)) (pTaken@193@03 r)) (pTaken@194@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@189@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
              $k@31@03
              $Perm.No)
            (pTaken@94@03 r))
          (pTaken@103@03 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@190@03 r) V@26@03) (<= 0 (inv@190@03 r)))
        $k@189@03
        $Perm.No)
      (-
        (-
          (ite
            (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
            $k@31@03
            $Perm.No)
          (pTaken@94@03 r))
        (pTaken@103@03 r))))
  :pattern ((inv@32@03 r))
  :pattern ((inv@190@03 r))
  :qid |qp.srp62|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@190@03 r) V@26@03) (<= 0 (inv@190@03 r)))
    (= (- $k@189@03 (pTaken@192@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33888
;  :arith-add-rows          25799
;  :arith-assert-diseq      2131
;  :arith-assert-lower      10243
;  :arith-assert-upper      6470
;  :arith-bound-prop        3019
;  :arith-conflicts         577
;  :arith-eq-adapter        6763
;  :arith-fixed-eqs         3593
;  :arith-offset-eqs        4019
;  :arith-pivots            4823
;  :conflicts               1366
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 907
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3837
;  :del-clause              49181
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.69
;  :memory                  10.64
;  :minimized-lits          186
;  :mk-bool-var             66037
;  :mk-clause               49194
;  :num-allocs              565695
;  :num-checks              317
;  :propagations            23022
;  :quant-instantiations    13781
;  :rlimit-count            1731039
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@196@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 209 | 0 <= i1@196@03 | live]
; [else-branch: 209 | !(0 <= i1@196@03) | live]
(push) ; 18
; [then-branch: 209 | 0 <= i1@196@03]
(assert (<= 0 i1@196@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 209 | !(0 <= i1@196@03)]
(assert (not (<= 0 i1@196@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 210 | i1@196@03 < V@26@03 && 0 <= i1@196@03 | live]
; [else-branch: 210 | !(i1@196@03 < V@26@03 && 0 <= i1@196@03) | live]
(push) ; 18
; [then-branch: 210 | i1@196@03 < V@26@03 && 0 <= i1@196@03]
(assert (and (< i1@196@03 V@26@03) (<= 0 i1@196@03)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@196@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33888
;  :arith-add-rows          25800
;  :arith-assert-diseq      2131
;  :arith-assert-lower      10245
;  :arith-assert-upper      6470
;  :arith-bound-prop        3019
;  :arith-conflicts         577
;  :arith-eq-adapter        6763
;  :arith-fixed-eqs         3593
;  :arith-offset-eqs        4019
;  :arith-pivots            4823
;  :conflicts               1366
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 907
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3837
;  :del-clause              49181
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.69
;  :memory                  10.64
;  :minimized-lits          186
;  :mk-bool-var             66039
;  :mk-clause               49194
;  :num-allocs              565804
;  :num-checks              318
;  :propagations            23022
;  :quant-instantiations    13781
;  :rlimit-count            1731230)
(assert (< i1@196@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 19
; Joined path conditions
(assert (< i1@196@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               34605
;  :arith-add-rows          26587
;  :arith-assert-diseq      2169
;  :arith-assert-lower      10496
;  :arith-assert-upper      6620
;  :arith-bound-prop        3094
;  :arith-conflicts         591
;  :arith-eq-adapter        6924
;  :arith-fixed-eqs         3680
;  :arith-offset-eqs        4107
;  :arith-pivots            4928
;  :conflicts               1392
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 911
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3879
;  :del-clause              49915
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.69
;  :memory                  10.68
;  :minimized-lits          186
;  :mk-bool-var             67304
;  :mk-clause               50125
;  :num-allocs              572046
;  :num-checks              319
;  :propagations            23615
;  :quant-instantiations    14147
;  :rlimit-count            1770480
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 18
(push) ; 18
; [else-branch: 210 | !(i1@196@03 < V@26@03 && 0 <= i1@196@03)]
(assert (not (and (< i1@196@03 V@26@03) (<= 0 i1@196@03))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< i1@196@03 V@26@03) (<= 0 i1@196@03))
  (and
    (< i1@196@03 V@26@03)
    (<= 0 i1@196@03)
    (< i1@196@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@196@03 Int)) (!
  (implies
    (and (< i1@196@03 V@26@03) (<= 0 i1@196@03))
    (and
      (< i1@196@03 V@26@03)
      (<= 0 i1@196@03)
      (< i1@196@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@196@03 Int)) (!
  (implies
    (and (< i1@196@03 V@26@03) (<= 0 i1@196@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               34701
;  :arith-add-rows          26664
;  :arith-assert-diseq      2169
;  :arith-assert-lower      10506
;  :arith-assert-upper      6629
;  :arith-bound-prop        3108
;  :arith-conflicts         592
;  :arith-eq-adapter        6937
;  :arith-fixed-eqs         3687
;  :arith-offset-eqs        4122
;  :arith-pivots            4962
;  :conflicts               1398
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 915
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3884
;  :del-clause              50338
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.69
;  :memory                  10.64
;  :minimized-lits          186
;  :mk-bool-var             67596
;  :mk-clause               50351
;  :num-allocs              573647
;  :num-checks              320
;  :propagations            23657
;  :quant-instantiations    14217
;  :rlimit-count            1776971
;  :time                    0.00)
(assert (forall ((i1@196@03 Int)) (!
  (implies
    (and (< i1@196@03 V@26@03) (<= 0 i1@196@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@196@03))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@197@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 211 | 0 <= i1@197@03 | live]
; [else-branch: 211 | !(0 <= i1@197@03) | live]
(push) ; 18
; [then-branch: 211 | 0 <= i1@197@03]
(assert (<= 0 i1@197@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 211 | !(0 <= i1@197@03)]
(assert (not (<= 0 i1@197@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 212 | i1@197@03 < V@26@03 && 0 <= i1@197@03 | live]
; [else-branch: 212 | !(i1@197@03 < V@26@03 && 0 <= i1@197@03) | live]
(push) ; 18
; [then-branch: 212 | i1@197@03 < V@26@03 && 0 <= i1@197@03]
(assert (and (< i1@197@03 V@26@03) (<= 0 i1@197@03)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i1@197@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               34701
;  :arith-add-rows          26665
;  :arith-assert-diseq      2169
;  :arith-assert-lower      10508
;  :arith-assert-upper      6629
;  :arith-bound-prop        3108
;  :arith-conflicts         592
;  :arith-eq-adapter        6937
;  :arith-fixed-eqs         3687
;  :arith-offset-eqs        4122
;  :arith-pivots            4962
;  :conflicts               1398
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 915
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3884
;  :del-clause              50338
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.69
;  :memory                  10.64
;  :minimized-lits          186
;  :mk-bool-var             67599
;  :mk-clause               50351
;  :num-allocs              573938
;  :num-checks              321
;  :propagations            23657
;  :quant-instantiations    14217
;  :rlimit-count            1777469)
(assert (< i1@197@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 19
; Joined path conditions
(assert (< i1@197@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36604
;  :arith-add-rows          28118
;  :arith-assert-diseq      2314
;  :arith-assert-lower      11161
;  :arith-assert-upper      7012
;  :arith-bound-prop        3252
;  :arith-conflicts         614
;  :arith-eq-adapter        7370
;  :arith-fixed-eqs         3903
;  :arith-offset-eqs        4444
;  :arith-pivots            5170
;  :conflicts               1443
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 919
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3977
;  :del-clause              52110
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.74
;  :memory                  10.71
;  :minimized-lits          186
;  :mk-bool-var             70274
;  :mk-clause               52320
;  :num-allocs              585644
;  :num-checks              322
;  :propagations            25197
;  :quant-instantiations    14856
;  :rlimit-count            1845944
;  :time                    0.07)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 20
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36604
;  :arith-add-rows          28118
;  :arith-assert-diseq      2314
;  :arith-assert-lower      11161
;  :arith-assert-upper      7012
;  :arith-bound-prop        3252
;  :arith-conflicts         614
;  :arith-eq-adapter        7370
;  :arith-fixed-eqs         3903
;  :arith-offset-eqs        4444
;  :arith-pivots            5170
;  :conflicts               1444
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 919
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3977
;  :del-clause              52110
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.74
;  :memory                  10.71
;  :minimized-lits          186
;  :mk-bool-var             70274
;  :mk-clause               52320
;  :num-allocs              585733
;  :num-checks              323
;  :propagations            25197
;  :quant-instantiations    14856
;  :rlimit-count            1846039)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
    (as None<option<array>>  option<array>))))
(pop) ; 19
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
    (as None<option<array>>  option<array>))))
(pop) ; 18
(push) ; 18
; [else-branch: 212 | !(i1@197@03 < V@26@03 && 0 <= i1@197@03)]
(assert (not (and (< i1@197@03 V@26@03) (<= 0 i1@197@03))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< i1@197@03 V@26@03) (<= 0 i1@197@03))
  (and
    (< i1@197@03 V@26@03)
    (<= 0 i1@197@03)
    (< i1@197@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@197@03 Int)) (!
  (implies
    (and (< i1@197@03 V@26@03) (<= 0 i1@197@03))
    (and
      (< i1@197@03 V@26@03)
      (<= 0 i1@197@03)
      (< i1@197@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@197@03 Int)) (!
  (implies
    (and (< i1@197@03 V@26@03) (<= 0 i1@197@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)))))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36754
;  :arith-add-rows          28193
;  :arith-assert-diseq      2316
;  :arith-assert-lower      11177
;  :arith-assert-upper      7020
;  :arith-bound-prop        3266
;  :arith-conflicts         615
;  :arith-eq-adapter        7384
;  :arith-fixed-eqs         3910
;  :arith-offset-eqs        4463
;  :arith-pivots            5208
;  :conflicts               1452
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 923
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3985
;  :del-clause              52546
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.74
;  :memory                  10.68
;  :minimized-lits          186
;  :mk-bool-var             70591
;  :mk-clause               52559
;  :num-allocs              587698
;  :num-checks              324
;  :propagations            25280
;  :quant-instantiations    14944
;  :rlimit-count            1853962
;  :time                    0.01)
(assert (forall ((i1@197@03 Int)) (!
  (implies
    (and (< i1@197@03 V@26@03) (<= 0 i1@197@03))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03))))
      V@26@03))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@197@03)))))
  :qid |prog.l<no position>|)))
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@198@03 Int)
(push) ; 16
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@199@03 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 213 | 0 <= i1@198@03 | live]
; [else-branch: 213 | !(0 <= i1@198@03) | live]
(push) ; 19
; [then-branch: 213 | 0 <= i1@198@03]
(assert (<= 0 i1@198@03))
; [eval] i1 < V
(push) ; 20
; [then-branch: 214 | i1@198@03 < V@26@03 | live]
; [else-branch: 214 | !(i1@198@03 < V@26@03) | live]
(push) ; 21
; [then-branch: 214 | i1@198@03 < V@26@03]
(assert (< i1@198@03 V@26@03))
; [eval] 0 <= i2
(push) ; 22
; [then-branch: 215 | 0 <= i2@199@03 | live]
; [else-branch: 215 | !(0 <= i2@199@03) | live]
(push) ; 23
; [then-branch: 215 | 0 <= i2@199@03]
(assert (<= 0 i2@199@03))
; [eval] i2 < V
(push) ; 24
; [then-branch: 216 | i2@199@03 < V@26@03 | live]
; [else-branch: 216 | !(i2@199@03 < V@26@03) | live]
(push) ; 25
; [then-branch: 216 | i2@199@03 < V@26@03]
(assert (< i2@199@03 V@26@03))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               36754
;  :arith-add-rows          28195
;  :arith-assert-diseq      2316
;  :arith-assert-lower      11181
;  :arith-assert-upper      7020
;  :arith-bound-prop        3266
;  :arith-conflicts         615
;  :arith-eq-adapter        7384
;  :arith-fixed-eqs         3910
;  :arith-offset-eqs        4463
;  :arith-pivots            5208
;  :conflicts               1452
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 923
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               3985
;  :del-clause              52546
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.74
;  :memory                  10.68
;  :minimized-lits          186
;  :mk-bool-var             70596
;  :mk-clause               52559
;  :num-allocs              588175
;  :num-checks              325
;  :propagations            25280
;  :quant-instantiations    14944
;  :rlimit-count            1854605)
(assert (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 26
; Joined path conditions
(assert (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)))
(push) ; 26
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)))))))
(check-sat)
; unsat
(pop) ; 26
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37788
;  :arith-add-rows          29249
;  :arith-assert-diseq      2415
;  :arith-assert-lower      11561
;  :arith-assert-upper      7290
;  :arith-bound-prop        3382
;  :arith-conflicts         635
;  :arith-eq-adapter        7677
;  :arith-fixed-eqs         4042
;  :arith-offset-eqs        4581
;  :arith-pivots            5358
;  :conflicts               1495
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 927
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4095
;  :del-clause              53732
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.76
;  :memory                  10.74
;  :minimized-lits          191
;  :mk-bool-var             72329
;  :mk-clause               53942
;  :num-allocs              595590
;  :num-checks              326
;  :propagations            26088
;  :quant-instantiations    15300
;  :rlimit-count            1902930
;  :time                    0.02)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(push) ; 26
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 27
(assert (not (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 27
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37788
;  :arith-add-rows          29249
;  :arith-assert-diseq      2415
;  :arith-assert-lower      11561
;  :arith-assert-upper      7290
;  :arith-bound-prop        3382
;  :arith-conflicts         635
;  :arith-eq-adapter        7677
;  :arith-fixed-eqs         4042
;  :arith-offset-eqs        4581
;  :arith-pivots            5358
;  :conflicts               1495
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 927
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4095
;  :del-clause              53732
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              10.76
;  :memory                  10.74
;  :minimized-lits          191
;  :mk-bool-var             72329
;  :mk-clause               53942
;  :num-allocs              595616
;  :num-checks              327
;  :propagations            26088
;  :quant-instantiations    15300
;  :rlimit-count            1902960)
(assert (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 26
; Joined path conditions
(assert (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
(push) ; 26
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))))))
(check-sat)
; unsat
(pop) ; 26
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40491
;  :arith-add-rows          31169
;  :arith-assert-diseq      2696
;  :arith-assert-lower      12602
;  :arith-assert-upper      7875
;  :arith-bound-prop        3607
;  :arith-conflicts         661
;  :arith-eq-adapter        8301
;  :arith-fixed-eqs         4351
;  :arith-offset-eqs        4843
;  :arith-pivots            5610
;  :conflicts               1553
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 931
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4365
;  :del-clause              57674
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              11.04
;  :memory                  11.01
;  :minimized-lits          212
;  :mk-bool-var             76712
;  :mk-clause               58085
;  :num-allocs              613371
;  :num-checks              328
;  :propagations            28601
;  :quant-instantiations    16597
;  :rlimit-count            2029892
;  :time                    0.05)
(pop) ; 25
(push) ; 25
; [else-branch: 216 | !(i2@199@03 < V@26@03)]
(assert (not (< i2@199@03 V@26@03)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (implies
  (< i2@199@03 V@26@03)
  (and
    (< i2@199@03 V@26@03)
    (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
    (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))))
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 215 | !(0 <= i2@199@03)]
(assert (not (<= 0 i2@199@03)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (<= 0 i2@199@03)
  (and
    (<= 0 i2@199@03)
    (implies
      (< i2@199@03 V@26@03)
      (and
        (< i2@199@03 V@26@03)
        (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
        (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 214 | !(i1@198@03 < V@26@03)]
(assert (not (< i1@198@03 V@26@03)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (< i1@198@03 V@26@03)
  (and
    (< i1@198@03 V@26@03)
    (implies
      (<= 0 i2@199@03)
      (and
        (<= 0 i2@199@03)
        (implies
          (< i2@199@03 V@26@03)
          (and
            (< i2@199@03 V@26@03)
            (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
            (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 213 | !(0 <= i1@198@03)]
(assert (not (<= 0 i1@198@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (<= 0 i1@198@03)
  (and
    (<= 0 i1@198@03)
    (implies
      (< i1@198@03 V@26@03)
      (and
        (< i1@198@03 V@26@03)
        (implies
          (<= 0 i2@199@03)
          (and
            (<= 0 i2@199@03)
            (implies
              (< i2@199@03 V@26@03)
              (and
                (< i2@199@03 V@26@03)
                (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
                (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))))))))))
; Joined path conditions
(push) ; 18
; [then-branch: 217 | Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, G@23@03), i1@198@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, G@23@03), i2@199@03)) && i2@199@03 < V@26@03 && 0 <= i2@199@03 && i1@198@03 < V@26@03 && 0 <= i1@198@03 | live]
; [else-branch: 217 | !(Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, G@23@03), i1@198@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, G@23@03), i2@199@03)) && i2@199@03 < V@26@03 && 0 <= i2@199@03 && i1@198@03 < V@26@03 && 0 <= i1@198@03) | live]
(push) ; 19
; [then-branch: 217 | Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, G@23@03), i1@198@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, G@23@03), i2@199@03)) && i2@199@03 < V@26@03 && 0 <= i2@199@03 && i1@198@03 < V@26@03 && 0 <= i1@198@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
        (< i2@199@03 V@26@03))
      (<= 0 i2@199@03))
    (< i1@198@03 V@26@03))
  (<= 0 i1@198@03)))
; [eval] i1 == i2
(pop) ; 19
(push) ; 19
; [else-branch: 217 | !(Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, G@23@03), i1@198@03)) == Lookup(option$array$,sm@137@03,aloc((_, _), opt_get1(_, G@23@03), i2@199@03)) && i2@199@03 < V@26@03 && 0 <= i2@199@03 && i1@198@03 < V@26@03 && 0 <= i1@198@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
          (< i2@199@03 V@26@03))
        (<= 0 i2@199@03))
      (< i1@198@03 V@26@03))
    (<= 0 i1@198@03))))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
          (< i2@199@03 V@26@03))
        (<= 0 i2@199@03))
      (< i1@198@03 V@26@03))
    (<= 0 i1@198@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
      ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
    (< i2@199@03 V@26@03)
    (<= 0 i2@199@03)
    (< i1@198@03 V@26@03)
    (<= 0 i1@198@03))))
; Joined path conditions
(pop) ; 17
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@199@03 Int)) (!
  (and
    (implies
      (<= 0 i1@198@03)
      (and
        (<= 0 i1@198@03)
        (implies
          (< i1@198@03 V@26@03)
          (and
            (< i1@198@03 V@26@03)
            (implies
              (<= 0 i2@199@03)
              (and
                (<= 0 i2@199@03)
                (implies
                  (< i2@199@03 V@26@03)
                  (and
                    (< i2@199@03 V@26@03)
                    (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
                    (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
              (< i2@199@03 V@26@03))
            (<= 0 i2@199@03))
          (< i1@198@03 V@26@03))
        (<= 0 i1@198@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
          ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
        (< i2@199@03 V@26@03)
        (<= 0 i2@199@03)
        (< i1@198@03 V@26@03)
        (<= 0 i1@198@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@198@03 Int)) (!
  (forall ((i2@199@03 Int)) (!
    (and
      (implies
        (<= 0 i1@198@03)
        (and
          (<= 0 i1@198@03)
          (implies
            (< i1@198@03 V@26@03)
            (and
              (< i1@198@03 V@26@03)
              (implies
                (<= 0 i2@199@03)
                (and
                  (<= 0 i2@199@03)
                  (implies
                    (< i2@199@03 V@26@03)
                    (and
                      (< i2@199@03 V@26@03)
                      (< i1@198@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
                      (< i2@199@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
                  ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
                (< i2@199@03 V@26@03))
              (<= 0 i2@199@03))
            (< i1@198@03 V@26@03))
          (<= 0 i1@198@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
            ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
          (< i2@199@03 V@26@03)
          (<= 0 i2@199@03)
          (< i1@198@03 V@26@03)
          (<= 0 i1@198@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@198@03 Int)) (!
  (forall ((i2@199@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
              (< i2@199@03 V@26@03))
            (<= 0 i2@199@03))
          (< i1@198@03 V@26@03))
        (<= 0 i1@198@03))
      (= i1@198@03 i2@199@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40691
;  :arith-add-rows          31392
;  :arith-assert-diseq      2699
;  :arith-assert-lower      12631
;  :arith-assert-upper      7898
;  :arith-bound-prop        3641
;  :arith-conflicts         664
;  :arith-eq-adapter        8328
;  :arith-fixed-eqs         4366
;  :arith-offset-eqs        4875
;  :arith-pivots            5690
;  :conflicts               1562
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 935
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4382
;  :del-clause              58526
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              11.04
;  :memory                  10.94
;  :minimized-lits          212
;  :mk-bool-var             77345
;  :mk-clause               58539
;  :num-allocs              616876
;  :num-checks              329
;  :propagations            28693
;  :quant-instantiations    16739
;  :rlimit-count            2045812
;  :time                    0.01)
(assert (forall ((i1@198@03 Int)) (!
  (forall ((i2@199@03 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
                ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03)))
              (< i2@199@03 V@26@03))
            (<= 0 i2@199@03))
          (< i1@198@03 V@26@03))
        (<= 0 i1@198@03))
      (= i1@198@03 i2@199@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@199@03))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@198@03))
  :qid |prog.l<no position>|)))
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
; [eval] |this.Gf_seq| == V
; [eval] |this.Gf_seq|
; [eval] |this.P_seq| == V
; [eval] |this.P_seq|
(push) ; 16
(assert (not (=
  (Seq_length
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))
  V@26@03)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40691
;  :arith-add-rows          31392
;  :arith-assert-diseq      2699
;  :arith-assert-lower      12631
;  :arith-assert-upper      7898
;  :arith-bound-prop        3641
;  :arith-conflicts         664
;  :arith-eq-adapter        8328
;  :arith-fixed-eqs         4366
;  :arith-offset-eqs        4875
;  :arith-pivots            5690
;  :conflicts               1562
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 935
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4382
;  :del-clause              58526
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              11.04
;  :memory                  10.94
;  :minimized-lits          212
;  :mk-bool-var             77346
;  :mk-clause               58539
;  :num-allocs              617213
;  :num-checks              330
;  :propagations            28693
;  :quant-instantiations    16739
;  :rlimit-count            2046357)
(assert (=
  (Seq_length
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))
  V@26@03))
; [eval] SquareIntMatrix(this, this.Gf_seq, V)
(push) ; 16
; [eval] this != null
(pop) ; 16
; Joined path conditions
; [eval] 0 <= s
; [eval] s < V
; [eval] 0 <= t
; [eval] t < V
(declare-const i1@200@03 Int)
(declare-const j1@201@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 218 | 0 <= i1@200@03 | live]
; [else-branch: 218 | !(0 <= i1@200@03) | live]
(push) ; 18
; [then-branch: 218 | 0 <= i1@200@03]
(assert (<= 0 i1@200@03))
; [eval] i1 < V
(push) ; 19
; [then-branch: 219 | i1@200@03 < V@26@03 | live]
; [else-branch: 219 | !(i1@200@03 < V@26@03) | live]
(push) ; 20
; [then-branch: 219 | i1@200@03 < V@26@03]
(assert (< i1@200@03 V@26@03))
; [eval] 0 <= j1
(push) ; 21
; [then-branch: 220 | 0 <= j1@201@03 | live]
; [else-branch: 220 | !(0 <= j1@201@03) | live]
(push) ; 22
; [then-branch: 220 | 0 <= j1@201@03]
(assert (<= 0 j1@201@03))
; [eval] j1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 220 | !(0 <= j1@201@03)]
(assert (not (<= 0 j1@201@03)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 219 | !(i1@200@03 < V@26@03)]
(assert (not (< i1@200@03 V@26@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 218 | !(0 <= i1@200@03)]
(assert (not (<= 0 i1@200@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@201@03 V@26@03) (<= 0 j1@201@03)) (< i1@200@03 V@26@03))
  (<= 0 i1@200@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40691
;  :arith-add-rows          31395
;  :arith-assert-diseq      2699
;  :arith-assert-lower      12637
;  :arith-assert-upper      7898
;  :arith-bound-prop        3641
;  :arith-conflicts         664
;  :arith-eq-adapter        8328
;  :arith-fixed-eqs         4366
;  :arith-offset-eqs        4875
;  :arith-pivots            5690
;  :conflicts               1562
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 935
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4382
;  :del-clause              58526
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              11.04
;  :memory                  10.94
;  :minimized-lits          212
;  :mk-bool-var             77352
;  :mk-clause               58539
;  :num-allocs              617484
;  :num-checks              331
;  :propagations            28693
;  :quant-instantiations    16739
;  :rlimit-count            2046832)
(assert (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41169
;  :arith-add-rows          31915
;  :arith-assert-diseq      2724
;  :arith-assert-lower      12808
;  :arith-assert-upper      8021
;  :arith-bound-prop        3705
;  :arith-conflicts         676
;  :arith-eq-adapter        8451
;  :arith-fixed-eqs         4441
;  :arith-offset-eqs        4970
;  :arith-pivots            5762
;  :conflicts               1586
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 939
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4419
;  :del-clause              58910
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              11.04
;  :memory                  10.97
;  :minimized-lits          212
;  :mk-bool-var             78194
;  :mk-clause               59114
;  :num-allocs              621231
;  :num-checks              332
;  :propagations            29023
;  :quant-instantiations    16831
;  :rlimit-count            2066252
;  :time                    0.00)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41169
;  :arith-add-rows          31915
;  :arith-assert-diseq      2724
;  :arith-assert-lower      12808
;  :arith-assert-upper      8021
;  :arith-bound-prop        3705
;  :arith-conflicts         676
;  :arith-eq-adapter        8451
;  :arith-fixed-eqs         4441
;  :arith-offset-eqs        4970
;  :arith-pivots            5762
;  :conflicts               1587
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 939
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4419
;  :del-clause              58910
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              11.04
;  :memory                  10.97
;  :minimized-lits          212
;  :mk-bool-var             78194
;  :mk-clause               59114
;  :num-allocs              621320
;  :num-checks              333
;  :propagations            29023
;  :quant-instantiations    16831
;  :rlimit-count            2066347)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  j1@201@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41175
;  :arith-add-rows          31921
;  :arith-assert-diseq      2724
;  :arith-assert-lower      12811
;  :arith-assert-upper      8022
;  :arith-bound-prop        3705
;  :arith-conflicts         677
;  :arith-eq-adapter        8452
;  :arith-fixed-eqs         4442
;  :arith-offset-eqs        4970
;  :arith-pivots            5766
;  :conflicts               1588
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 939
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4419
;  :del-clause              58917
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              11.04
;  :memory                  10.96
;  :minimized-lits          212
;  :mk-bool-var             78209
;  :mk-clause               59121
;  :num-allocs              621633
;  :num-checks              334
;  :propagations            29027
;  :quant-instantiations    16842
;  :rlimit-count            2067383)
(assert (<
  j1@201@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))))))
(pop) ; 17
; Joined path conditions
(assert (<
  j1@201@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))))))
(pop) ; 16
(declare-fun inv@202@03 ($Ref) Int)
(declare-fun inv@203@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@200@03 Int) (j1@201@03 Int)) (!
  (and
    (< i1@200@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@201@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))) j1@201@03))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@200@03 Int) (j11@201@03 Int) (i12@200@03 Int) (j12@201@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@201@03 V@26@03) (<= 0 j11@201@03))
            (< i11@200@03 V@26@03))
          (<= 0 i11@200@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@200@03))) j11@201@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@200@03))) j11@201@03)))
      (and
        (and
          (and
            (and (< j12@201@03 V@26@03) (<= 0 j12@201@03))
            (< i12@200@03 V@26@03))
          (<= 0 i12@200@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@200@03))) j12@201@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@200@03))) j12@201@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@200@03))) j11@201@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@200@03))) j12@201@03)))
    (and (= i11@200@03 i12@200@03) (= j11@201@03 j12@201@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41233
;  :arith-add-rows          31994
;  :arith-assert-diseq      2724
;  :arith-assert-lower      12820
;  :arith-assert-upper      8023
;  :arith-bound-prop        3705
;  :arith-conflicts         677
;  :arith-eq-adapter        8471
;  :arith-fixed-eqs         4442
;  :arith-offset-eqs        4970
;  :arith-pivots            5786
;  :conflicts               1589
;  :datatype-accessor-ax    94
;  :datatype-constructor-ax 939
;  :datatype-occurs-check   376
;  :datatype-splits         399
;  :decisions               4419
;  :del-clause              59440
;  :final-checks            199
;  :interface-eqs           7
;  :max-generation          7
;  :max-memory              11.04
;  :memory                  10.93
;  :minimized-lits          212
;  :mk-bool-var             78668
;  :mk-clause               59453
;  :num-allocs              624446
;  :num-checks              335
;  :propagations            29056
;  :quant-instantiations    16959
;  :rlimit-count            2076973
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@200@03 Int) (j1@201@03 Int)) (!
  (implies
    (and
      (and (and (< j1@201@03 V@26@03) (<= 0 j1@201@03)) (< i1@200@03 V@26@03))
      (<= 0 i1@200@03))
    (and
      (=
        (inv@202@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))) j1@201@03))
        i1@200@03)
      (=
        (inv@203@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))) j1@201@03))
        j1@201@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@200@03))) j1@201@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@202@03 r)))) (inv@203@03 r))
      r))
  :pattern ((inv@202@03 r))
  :pattern ((inv@203@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r) r))
  :pattern ((inv@202@03 r) (inv@203@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@204@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@205@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
            (< (inv@150@03 r) V@26@03))
          (<= 0 (inv@150@03 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@204@03 r)))
    $Perm.No))
(define-fun pTaken@206@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)
      (- (- $Perm.Write (pTaken@204@03 r)) (pTaken@205@03 r)))
    $Perm.No))
(define-fun pTaken@207@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r))
      (-
        (- (- $Perm.Write (pTaken@204@03 r)) (pTaken@205@03 r))
        (pTaken@206@03 r)))
    $Perm.No))
(define-fun pTaken@208@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r))
      (-
        (-
          (- (- $Perm.Write (pTaken@204@03 r)) (pTaken@205@03 r))
          (pTaken@206@03 r))
        (pTaken@207@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@204@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44265
;  :arith-add-rows          32949
;  :arith-assert-diseq      2844
;  :arith-assert-lower      13468
;  :arith-assert-upper      8431
;  :arith-bound-prop        3853
;  :arith-conflicts         689
;  :arith-eq-adapter        8884
;  :arith-fixed-eqs         4722
;  :arith-offset-eqs        5209
;  :arith-pivots            6060
;  :conflicts               1632
;  :datatype-accessor-ax    117
;  :datatype-constructor-ax 1032
;  :datatype-occurs-check   442
;  :datatype-splits         495
;  :decisions               5364
;  :del-clause              65499
;  :final-checks            213
;  :interface-eqs           7
;  :max-generation          8
;  :max-memory              11.29
;  :memory                  11.17
;  :minimized-lits          235
;  :mk-bool-var             85349
;  :mk-clause               65512
;  :num-allocs              646380
;  :num-checks              337
;  :propagations            31650
;  :quant-instantiations    18570
;  :rlimit-count            2173411
;  :time                    0.06)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    (= (- $Perm.Write (pTaken@204@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.11s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               50526
;  :arith-add-rows          35200
;  :arith-assert-diseq      3276
;  :arith-assert-lower      15314
;  :arith-assert-upper      9861
;  :arith-bound-prop        4104
;  :arith-conflicts         716
;  :arith-eq-adapter        9942
;  :arith-fixed-eqs         5346
;  :arith-offset-eqs        6011
;  :arith-pivots            6522
;  :conflicts               1700
;  :datatype-accessor-ax    158
;  :datatype-constructor-ax 1129
;  :datatype-occurs-check   517
;  :datatype-splits         630
;  :decisions               6945
;  :del-clause              73571
;  :final-checks            237
;  :interface-eqs           16
;  :max-generation          9
;  :max-memory              12.08
;  :memory                  11.81
;  :minimized-lits          250
;  :mk-bool-var             94825
;  :mk-clause               73584
;  :num-allocs              677471
;  :num-checks              338
;  :propagations            36422
;  :quant-instantiations    20685
;  :rlimit-count            2344420
;  :time                    0.10)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
            (< (inv@150@03 r) V@26@03))
          (<= 0 (inv@150@03 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@205@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.23s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               61252
;  :arith-add-rows          39136
;  :arith-assert-diseq      3847
;  :arith-assert-lower      17959
;  :arith-assert-upper      11868
;  :arith-bound-prop        4423
;  :arith-conflicts         753
;  :arith-eq-adapter        11712
;  :arith-fixed-eqs         6448
;  :arith-offset-eqs        7740
;  :arith-pivots            7456
;  :conflicts               1780
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 1220
;  :datatype-occurs-check   592
;  :datatype-splits         769
;  :decisions               8886
;  :del-clause              89827
;  :final-checks            253
;  :interface-eqs           17
;  :max-generation          14
;  :max-memory              16.41
;  :memory                  15.07
;  :minimized-lits          271
;  :mk-bool-var             114021
;  :mk-clause               89840
;  :num-allocs              742412
;  :num-checks              339
;  :propagations            44292
;  :quant-instantiations    26082
;  :rlimit-count            2669709
;  :time                    0.23)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@203@03 r) V@26@03) (<= 0 (inv@203@03 r)))
        (< (inv@202@03 r) V@26@03))
      (<= 0 (inv@202@03 r)))
    (= (- (- $Perm.Write (pTaken@204@03 r)) (pTaken@205@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               61629
;  :arith-add-rows          39395
;  :arith-assert-diseq      3866
;  :arith-assert-lower      18022
;  :arith-assert-upper      11932
;  :arith-bound-prop        4475
;  :arith-conflicts         759
;  :arith-eq-adapter        11802
;  :arith-fixed-eqs         6483
;  :arith-offset-eqs        7798
;  :arith-pivots            7531
;  :conflicts               1792
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 1224
;  :datatype-occurs-check   592
;  :datatype-splits         769
;  :decisions               8897
;  :del-clause              90700
;  :final-checks            253
;  :interface-eqs           17
;  :max-generation          14
;  :max-memory              16.41
;  :memory                  15.02
;  :minimized-lits          274
;  :mk-bool-var             115220
;  :mk-clause               90713
;  :num-allocs              747669
;  :num-checks              340
;  :propagations            44449
;  :quant-instantiations    26333
;  :rlimit-count            2692093
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@209@03 Int)
(declare-const j1@210@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 221 | 0 <= i1@209@03 | live]
; [else-branch: 221 | !(0 <= i1@209@03) | live]
(push) ; 18
; [then-branch: 221 | 0 <= i1@209@03]
(assert (<= 0 i1@209@03))
; [eval] i1 < V
(push) ; 19
; [then-branch: 222 | i1@209@03 < V@26@03 | live]
; [else-branch: 222 | !(i1@209@03 < V@26@03) | live]
(push) ; 20
; [then-branch: 222 | i1@209@03 < V@26@03]
(assert (< i1@209@03 V@26@03))
; [eval] 0 <= j1
(push) ; 21
; [then-branch: 223 | 0 <= j1@210@03 | live]
; [else-branch: 223 | !(0 <= j1@210@03) | live]
(push) ; 22
; [then-branch: 223 | 0 <= j1@210@03]
(assert (<= 0 j1@210@03))
; [eval] j1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 223 | !(0 <= j1@210@03)]
(assert (not (<= 0 j1@210@03)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 222 | !(i1@209@03 < V@26@03)]
(assert (not (< i1@209@03 V@26@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 221 | !(0 <= i1@209@03)]
(assert (not (<= 0 i1@209@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@210@03 V@26@03) (<= 0 j1@210@03)) (< i1@209@03 V@26@03))
  (<= 0 i1@209@03)))
(declare-const $k@211@03 $Perm)
(assert ($Perm.isReadVar $k@211@03 $Perm.Write))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@209@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               61629
;  :arith-add-rows          39398
;  :arith-assert-diseq      3867
;  :arith-assert-lower      18030
;  :arith-assert-upper      11933
;  :arith-bound-prop        4475
;  :arith-conflicts         759
;  :arith-eq-adapter        11803
;  :arith-fixed-eqs         6483
;  :arith-offset-eqs        7798
;  :arith-pivots            7531
;  :conflicts               1792
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 1224
;  :datatype-occurs-check   592
;  :datatype-splits         769
;  :decisions               8897
;  :del-clause              90700
;  :final-checks            253
;  :interface-eqs           17
;  :max-generation          14
;  :max-memory              16.41
;  :memory                  15.03
;  :minimized-lits          274
;  :mk-bool-var             115230
;  :mk-clause               90715
;  :num-allocs              748009
;  :num-checks              341
;  :propagations            44450
;  :quant-instantiations    26333
;  :rlimit-count            2692701)
(assert (< i1@209@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@209@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
              V@26@03)
            (<=
              0
              (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))))
          $k@135@03
          $Perm.No)
        (ite
          (and
            (<
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
              V@26@03)
            (<=
              0
              (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))))
          $k@127@03
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
                V@26@03)
              (<=
                0
                (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03)))
        (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))))
    (-
      (-
        (ite
          (and
            (<
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
              V@26@03)
            (<=
              0
              (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))))
          $k@31@03
          $Perm.No)
        (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03)))
      (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               63299
;  :arith-add-rows          41138
;  :arith-assert-diseq      4007
;  :arith-assert-lower      18667
;  :arith-assert-upper      12225
;  :arith-bound-prop        4635
;  :arith-conflicts         781
;  :arith-eq-adapter        12179
;  :arith-fixed-eqs         6660
;  :arith-offset-eqs        8103
;  :arith-pivots            7763
;  :conflicts               1836
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 1228
;  :datatype-occurs-check   592
;  :datatype-splits         769
;  :decisions               8988
;  :del-clause              92184
;  :final-checks            253
;  :interface-eqs           17
;  :max-generation          14
;  :max-memory              16.41
;  :memory                  15.06
;  :minimized-lits          285
;  :mk-bool-var             117503
;  :mk-clause               92396
;  :num-allocs              758380
;  :num-checks              342
;  :propagations            45716
;  :quant-instantiations    26839
;  :rlimit-count            2765650
;  :time                    0.03)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               63299
;  :arith-add-rows          41138
;  :arith-assert-diseq      4007
;  :arith-assert-lower      18667
;  :arith-assert-upper      12225
;  :arith-bound-prop        4635
;  :arith-conflicts         781
;  :arith-eq-adapter        12179
;  :arith-fixed-eqs         6660
;  :arith-offset-eqs        8103
;  :arith-pivots            7763
;  :conflicts               1837
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 1228
;  :datatype-occurs-check   592
;  :datatype-splits         769
;  :decisions               8988
;  :del-clause              92184
;  :final-checks            253
;  :interface-eqs           17
;  :max-generation          14
;  :max-memory              16.41
;  :memory                  15.06
;  :minimized-lits          285
;  :mk-bool-var             117503
;  :mk-clause               92396
;  :num-allocs              758469
;  :num-checks              343
;  :propagations            45716
;  :quant-instantiations    26839
;  :rlimit-count            2765745)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
    (as None<option<array>>  option<array>))))
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (<
  j1@210@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               63305
;  :arith-add-rows          41144
;  :arith-assert-diseq      4007
;  :arith-assert-lower      18670
;  :arith-assert-upper      12226
;  :arith-bound-prop        4635
;  :arith-conflicts         782
;  :arith-eq-adapter        12180
;  :arith-fixed-eqs         6661
;  :arith-offset-eqs        8103
;  :arith-pivots            7767
;  :conflicts               1838
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 1228
;  :datatype-occurs-check   592
;  :datatype-splits         769
;  :decisions               8988
;  :del-clause              92191
;  :final-checks            253
;  :interface-eqs           17
;  :max-generation          14
;  :max-memory              16.41
;  :memory                  15.04
;  :minimized-lits          285
;  :mk-bool-var             117518
;  :mk-clause               92403
;  :num-allocs              758771
;  :num-checks              344
;  :propagations            45720
;  :quant-instantiations    26848
;  :rlimit-count            2766727)
(assert (<
  j1@210@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))))))
(pop) ; 17
; Joined path conditions
(assert (<
  j1@210@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))))))
(pop) ; 16
(declare-fun inv@212@03 ($Ref) Int)
(declare-fun inv@213@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@211@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@209@03 Int) (j1@210@03 Int)) (!
  (and
    (< i1@209@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@210@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))) j1@210@03))
  :qid |int-aux|)))
(push) ; 16
(assert (not (forall ((i1@209@03 Int) (j1@210@03 Int)) (!
  (implies
    (and
      (and (and (< j1@210@03 V@26@03) (<= 0 j1@210@03)) (< i1@209@03 V@26@03))
      (<= 0 i1@209@03))
    (or (= $k@211@03 $Perm.No) (< $Perm.No $k@211@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               63305
;  :arith-add-rows          41174
;  :arith-assert-diseq      4008
;  :arith-assert-lower      18672
;  :arith-assert-upper      12227
;  :arith-bound-prop        4635
;  :arith-conflicts         782
;  :arith-eq-adapter        12181
;  :arith-fixed-eqs         6661
;  :arith-offset-eqs        8103
;  :arith-pivots            7790
;  :conflicts               1839
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 1228
;  :datatype-occurs-check   592
;  :datatype-splits         769
;  :decisions               8988
;  :del-clause              92390
;  :final-checks            253
;  :interface-eqs           17
;  :max-generation          14
;  :max-memory              16.41
;  :memory                  15.01
;  :minimized-lits          285
;  :mk-bool-var             117527
;  :mk-clause               92405
;  :num-allocs              759286
;  :num-checks              345
;  :propagations            45721
;  :quant-instantiations    26848
;  :rlimit-count            2768160)
(declare-const sm@214@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r)))
    (=
      ($FVF.lookup_int (as sm@214@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@214@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef63|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r)))
    (=
      ($FVF.lookup_int (as sm@214@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@214@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef64|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@214@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@214@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef65|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
              (< (inv@150@03 r) V@26@03))
            (<= 0 (inv@150@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@205@03 r)))
    (=
      ($FVF.lookup_int (as sm@214@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@214@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@204@03 r)))
    (=
      ($FVF.lookup_int (as sm@214@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r)))
  :pattern (($FVF.lookup_int (as sm@214@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r))
  :qid |qp.fvfValDef67|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@214@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef68|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@209@03 Int) (j11@210@03 Int) (i12@209@03 Int) (j12@210@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and
              (and (< j11@210@03 V@26@03) (<= 0 j11@210@03))
              (< i11@209@03 V@26@03))
            (<= 0 i11@209@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@214@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@209@03))) j11@210@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@209@03))) j11@210@03)))
        (< $Perm.No $k@211@03))
      (and
        (and
          (and
            (and
              (and (< j12@210@03 V@26@03) (<= 0 j12@210@03))
              (< i12@209@03 V@26@03))
            (<= 0 i12@209@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@214@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@209@03))) j12@210@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@209@03))) j12@210@03)))
        (< $Perm.No $k@211@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@209@03))) j11@210@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@209@03))) j12@210@03)))
    (and (= i11@209@03 i12@209@03) (= j11@210@03 j12@210@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               63363
;  :arith-add-rows          41229
;  :arith-assert-diseq      4008
;  :arith-assert-lower      18680
;  :arith-assert-upper      12229
;  :arith-bound-prop        4635
;  :arith-conflicts         782
;  :arith-eq-adapter        12200
;  :arith-fixed-eqs         6661
;  :arith-offset-eqs        8103
;  :arith-pivots            7790
;  :conflicts               1840
;  :datatype-accessor-ax    193
;  :datatype-constructor-ax 1228
;  :datatype-occurs-check   592
;  :datatype-splits         769
;  :decisions               8988
;  :del-clause              92767
;  :final-checks            253
;  :interface-eqs           17
;  :max-generation          14
;  :max-memory              16.41
;  :memory                  15.00
;  :minimized-lits          285
;  :mk-bool-var             118041
;  :mk-clause               92782
;  :num-allocs              763760
;  :num-checks              346
;  :propagations            45750
;  :quant-instantiations    26979
;  :rlimit-count            2786012
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@209@03 Int) (j1@210@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@210@03 V@26@03) (<= 0 j1@210@03)) (< i1@209@03 V@26@03))
        (<= 0 i1@209@03))
      (< $Perm.No $k@211@03))
    (and
      (=
        (inv@212@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))) j1@210@03))
        i1@209@03)
      (=
        (inv@213@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))) j1@210@03))
        j1@210@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@209@03))) j1@210@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
          (< (inv@212@03 r) V@26@03))
        (<= 0 (inv@212@03 r)))
      (< $Perm.No $k@211@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@137@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@212@03 r)))) (inv@213@03 r))
      r))
  :pattern ((inv@212@03 r))
  :pattern ((inv@213@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
        (< (inv@212@03 r) V@26@03))
      (<= 0 (inv@212@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@214@03  $FVF<Int>) r) r))
  :pattern ((inv@212@03 r) (inv@213@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@215@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
        (< (inv@212@03 r) V@26@03))
      (<= 0 (inv@212@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r))
      $k@211@03)
    $Perm.No))
(define-fun pTaken@216@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
        (< (inv@212@03 r) V@26@03))
      (<= 0 (inv@212@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r))
      (- $k@211@03 (pTaken@215@03 r)))
    $Perm.No))
(define-fun pTaken@217@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
        (< (inv@212@03 r) V@26@03))
      (<= 0 (inv@212@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)
      (- (- $k@211@03 (pTaken@215@03 r)) (pTaken@216@03 r)))
    $Perm.No))
(define-fun pTaken@218@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
        (< (inv@212@03 r) V@26@03))
      (<= 0 (inv@212@03 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
              (< (inv@150@03 r) V@26@03))
            (<= 0 (inv@150@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@205@03 r))
      (- (- (- $k@211@03 (pTaken@215@03 r)) (pTaken@216@03 r)) (pTaken@217@03 r)))
    $Perm.No))
(define-fun pTaken@219@03 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
        (< (inv@212@03 r) V@26@03))
      (<= 0 (inv@212@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@204@03 r))
      (-
        (-
          (- (- $k@211@03 (pTaken@215@03 r)) (pTaken@216@03 r))
          (pTaken@217@03 r))
        (pTaken@218@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@211@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        $Perm.No))
    (<
      (ite
        (and
          (and
            (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
            (< (inv@212@03 r) V@26@03))
          (<= 0 (inv@212@03 r)))
        $k@211@03
        $Perm.No)
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r))))
  :pattern ((inv@41@03 r))
  :pattern ((inv@40@03 r))
  :pattern ((inv@213@03 r))
  :pattern ((inv@212@03 r))
  :qid |qp.srp69|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
        (< (inv@212@03 r) V@26@03))
      (<= 0 (inv@212@03 r)))
    (= (- $k@211@03 (pTaken@215@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.36s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               87142
;  :arith-add-rows          51745
;  :arith-assert-diseq      6020
;  :arith-assert-lower      26474
;  :arith-assert-upper      17623
;  :arith-bound-prop        5470
;  :arith-conflicts         867
;  :arith-eq-adapter        15876
;  :arith-fixed-eqs         9209
;  :arith-offset-eqs        11549
;  :arith-pivots            9391
;  :conflicts               2015
;  :datatype-accessor-ax    233
;  :datatype-constructor-ax 1401
;  :datatype-occurs-check   673
;  :datatype-splits         914
;  :decisions               14155
;  :del-clause              124321
;  :final-checks            280
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.55
;  :memory                  16.99
;  :minimized-lits          353
;  :mk-bool-var             153306
;  :mk-clause               124334
;  :num-allocs              863550
;  :num-checks              348
;  :propagations            66592
;  :quant-instantiations    35107
;  :restarts                1
;  :rlimit-count            3479845
;  :time                    0.36)
; Constrain original permissions $k@211@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        $Perm.No))
    (<
      (ite
        (and
          (and
            (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
            (< (inv@212@03 r) V@26@03))
          (<= 0 (inv@212@03 r)))
        $k@211@03
        $Perm.No)
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r))))
  :pattern ((inv@86@03 r))
  :pattern ((inv@85@03 r))
  :pattern ((inv@213@03 r))
  :pattern ((inv@212@03 r))
  :qid |qp.srp70|)))
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@213@03 r) V@26@03) (<= 0 (inv@213@03 r)))
        (< (inv@212@03 r) V@26@03))
      (<= 0 (inv@212@03 r)))
    (= (- (- $k@211@03 (pTaken@215@03 r)) (pTaken@216@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.11s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               94410
;  :arith-add-rows          55266
;  :arith-assert-diseq      6475
;  :arith-assert-lower      28570
;  :arith-assert-upper      19155
;  :arith-bound-prop        5779
;  :arith-conflicts         907
;  :arith-eq-adapter        17048
;  :arith-fixed-eqs         9977
;  :arith-offset-eqs        12798
;  :arith-pivots            9996
;  :conflicts               2096
;  :datatype-accessor-ax    233
;  :datatype-constructor-ax 1405
;  :datatype-occurs-check   673
;  :datatype-splits         914
;  :decisions               15342
;  :del-clause              134634
;  :final-checks            280
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.55
;  :memory                  16.97
;  :minimized-lits          381
;  :mk-bool-var             165248
;  :mk-clause               134647
;  :num-allocs              896610
;  :num-checks              349
;  :propagations            71603
;  :quant-instantiations    37722
;  :restarts                1
;  :rlimit-count            3685731
;  :time                    0.11)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const i1@220@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 224 | 0 <= i1@220@03 | live]
; [else-branch: 224 | !(0 <= i1@220@03) | live]
(push) ; 18
; [then-branch: 224 | 0 <= i1@220@03]
(assert (<= 0 i1@220@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 224 | !(0 <= i1@220@03)]
(assert (not (<= 0 i1@220@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(assert (and (< i1@220@03 V@26@03) (<= 0 i1@220@03)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@220@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               94410
;  :arith-add-rows          55267
;  :arith-assert-diseq      6475
;  :arith-assert-lower      28572
;  :arith-assert-upper      19155
;  :arith-bound-prop        5779
;  :arith-conflicts         907
;  :arith-eq-adapter        17048
;  :arith-fixed-eqs         9977
;  :arith-offset-eqs        12798
;  :arith-pivots            9996
;  :conflicts               2096
;  :datatype-accessor-ax    233
;  :datatype-constructor-ax 1405
;  :datatype-occurs-check   673
;  :datatype-splits         914
;  :decisions               15342
;  :del-clause              134634
;  :final-checks            280
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.55
;  :memory                  16.97
;  :minimized-lits          381
;  :mk-bool-var             165250
;  :mk-clause               134647
;  :num-allocs              896720
;  :num-checks              350
;  :propagations            71603
;  :quant-instantiations    37722
;  :restarts                1
;  :rlimit-count            3685910)
(assert (< i1@220@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 17
; Joined path conditions
(assert (< i1@220@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 16
(declare-fun inv@221@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@220@03 Int)) (!
  (< i1@220@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@220@03))
  :qid |int-aux|)))
(declare-const sm@222@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@204@03 r)))
    (=
      ($FVF.lookup_int (as sm@222@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r)))
  :pattern (($FVF.lookup_int (as sm@222@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and
            (and
              (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
              (< (inv@150@03 r) V@26@03))
            (<= 0 (inv@150@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@205@03 r)))
    (=
      ($FVF.lookup_int (as sm@222@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@222@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@222@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@222@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r)))
    (=
      ($FVF.lookup_int (as sm@222@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@222@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef74|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r)))
    (=
      ($FVF.lookup_int (as sm@222@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@222@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef75|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@222@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef76|)))
; Check receiver injectivity
(push) ; 16
(assert (not (forall ((i11@220@03 Int) (i12@220@03 Int)) (!
  (implies
    (and
      (and
        (and (< i11@220@03 V@26@03) (<= 0 i11@220@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@222@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@220@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@220@03)))
      (and
        (and (< i12@220@03 V@26@03) (<= 0 i12@220@03))
        ($FVF.loc_int ($FVF.lookup_int (as sm@222@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@220@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@220@03)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@220@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@220@03)))
    (= i11@220@03 i12@220@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               94422
;  :arith-add-rows          55288
;  :arith-assert-diseq      6476
;  :arith-assert-lower      28576
;  :arith-assert-upper      19155
;  :arith-bound-prop        5779
;  :arith-conflicts         907
;  :arith-eq-adapter        17049
;  :arith-fixed-eqs         9977
;  :arith-offset-eqs        12798
;  :arith-pivots            9996
;  :conflicts               2097
;  :datatype-accessor-ax    233
;  :datatype-constructor-ax 1405
;  :datatype-occurs-check   673
;  :datatype-splits         914
;  :decisions               15342
;  :del-clause              134729
;  :final-checks            280
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.55
;  :memory                  16.92
;  :minimized-lits          381
;  :mk-bool-var             165384
;  :mk-clause               134742
;  :num-allocs              899350
;  :num-checks              351
;  :propagations            71608
;  :quant-instantiations    37743
;  :restarts                1
;  :rlimit-count            3697185
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@220@03 Int)) (!
  (implies
    (and (< i1@220@03 V@26@03) (<= 0 i1@220@03))
    (=
      (inv@221@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@220@03))
      i1@220@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@220@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@221@03 r))
      r))
  :pattern ((inv@221@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@222@03  $FVF<Int>) r) r))
  :pattern ((inv@221@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@223@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@204@03 r))
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@224@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    ($Perm.min
      (-
        (ite
          (and
            (and
              (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
              (< (inv@150@03 r) V@26@03))
            (<= 0 (inv@150@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@205@03 r))
      (- $Perm.Write (pTaken@223@03 r)))
    $Perm.No))
(define-fun pTaken@225@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)
      (- (- $Perm.Write (pTaken@223@03 r)) (pTaken@224@03 r)))
    $Perm.No))
(define-fun pTaken@226@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r))
      (-
        (- (- $Perm.Write (pTaken@223@03 r)) (pTaken@224@03 r))
        (pTaken@225@03 r)))
    $Perm.No))
(define-fun pTaken@227@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r))
      (-
        (-
          (- (- $Perm.Write (pTaken@223@03 r)) (pTaken@224@03 r))
          (pTaken@225@03 r))
        (pTaken@226@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@204@03 r))
      (pTaken@223@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               95462
;  :arith-add-rows          55849
;  :arith-assert-diseq      6491
;  :arith-assert-lower      28818
;  :arith-assert-upper      19351
;  :arith-bound-prop        5831
;  :arith-conflicts         913
;  :arith-eq-adapter        17287
;  :arith-fixed-eqs         10160
;  :arith-offset-eqs        12816
;  :arith-pivots            10238
;  :conflicts               2115
;  :datatype-accessor-ax    233
;  :datatype-constructor-ax 1422
;  :datatype-occurs-check   679
;  :datatype-splits         923
;  :decisions               15379
;  :del-clause              138621
;  :final-checks            282
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.55
;  :memory                  16.85
;  :minimized-lits          388
;  :mk-bool-var             170706
;  :mk-clause               138634
;  :num-allocs              920821
;  :num-checks              353
;  :propagations            72203
;  :quant-instantiations    39146
;  :restarts                1
;  :rlimit-count            3752306
;  :time                    0.05)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    (= (- $Perm.Write (pTaken@223@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 16
; 0.32s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               112858
;  :arith-add-rows          63370
;  :arith-assert-diseq      7712
;  :arith-assert-lower      34483
;  :arith-assert-upper      22953
;  :arith-bound-prop        6442
;  :arith-conflicts         986
;  :arith-eq-adapter        20422
;  :arith-fixed-eqs         12317
;  :arith-offset-eqs        15089
;  :arith-pivots            11634
;  :conflicts               2266
;  :datatype-accessor-ax    284
;  :datatype-constructor-ax 1544
;  :datatype-occurs-check   767
;  :datatype-splits         1072
;  :decisions               19514
;  :del-clause              168451
;  :final-checks            298
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.57
;  :minimized-lits          518
;  :mk-bool-var             200654
;  :mk-clause               168464
;  :num-allocs              1005267
;  :num-checks              354
;  :propagations            88414
;  :quant-instantiations    46864
;  :restarts                2
;  :rlimit-count            4256541
;  :time                    0.32)
; Chunk depleted?
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (-
        (ite
          (and
            (and
              (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
              (< (inv@150@03 r) V@26@03))
            (<= 0 (inv@150@03 r)))
          $Perm.Write
          $Perm.No)
        (pTaken@205@03 r))
      (pTaken@224@03 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               113899
;  :arith-add-rows          64038
;  :arith-assert-diseq      7739
;  :arith-assert-lower      34755
;  :arith-assert-upper      23130
;  :arith-bound-prop        6518
;  :arith-conflicts         995
;  :arith-eq-adapter        20666
;  :arith-fixed-eqs         12472
;  :arith-offset-eqs        15131
;  :arith-pivots            11835
;  :conflicts               2287
;  :datatype-accessor-ax    284
;  :datatype-constructor-ax 1548
;  :datatype-occurs-check   767
;  :datatype-splits         1072
;  :decisions               19546
;  :del-clause              171504
;  :final-checks            298
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.54
;  :minimized-lits          529
;  :mk-bool-var             204974
;  :mk-clause               171517
;  :num-allocs              1021306
;  :num-checks              355
;  :propagations            88962
;  :quant-instantiations    47901
;  :restarts                2
;  :rlimit-count            4306454
;  :time                    0.04)
; Intermediate check if already taken enough permissions
(push) ; 16
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@221@03 r) V@26@03) (<= 0 (inv@221@03 r)))
    (= (- (- $Perm.Write (pTaken@223@03 r)) (pTaken@224@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 16
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115099
;  :arith-add-rows          64976
;  :arith-assert-diseq      7759
;  :arith-assert-lower      34999
;  :arith-assert-upper      23324
;  :arith-bound-prop        6629
;  :arith-conflicts         1005
;  :arith-eq-adapter        20912
;  :arith-fixed-eqs         12668
;  :arith-offset-eqs        15211
;  :arith-pivots            12094
;  :conflicts               2307
;  :datatype-accessor-ax    284
;  :datatype-constructor-ax 1552
;  :datatype-occurs-check   767
;  :datatype-splits         1072
;  :decisions               19570
;  :del-clause              174345
;  :final-checks            298
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.55
;  :minimized-lits          538
;  :mk-bool-var             209169
;  :mk-clause               174358
;  :num-allocs              1038722
;  :num-checks              356
;  :propagations            89423
;  :quant-instantiations    48915
;  :restarts                2
;  :rlimit-count            4367550
;  :time                    0.04)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] valid_graph_vertices(this, P, V)
(push) ; 16
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(declare-const i1@228@03 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 225 | 0 <= i1@228@03 | live]
; [else-branch: 225 | !(0 <= i1@228@03) | live]
(push) ; 19
; [then-branch: 225 | 0 <= i1@228@03]
(assert (<= 0 i1@228@03))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 225 | !(0 <= i1@228@03)]
(assert (not (<= 0 i1@228@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and (< i1@228@03 V@26@03) (<= 0 i1@228@03)))
(declare-const $k@229@03 $Perm)
(assert ($Perm.isReadVar $k@229@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@228@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115099
;  :arith-add-rows          64977
;  :arith-assert-diseq      7760
;  :arith-assert-lower      35003
;  :arith-assert-upper      23325
;  :arith-bound-prop        6629
;  :arith-conflicts         1005
;  :arith-eq-adapter        20913
;  :arith-fixed-eqs         12668
;  :arith-offset-eqs        15211
;  :arith-pivots            12094
;  :conflicts               2307
;  :datatype-accessor-ax    284
;  :datatype-constructor-ax 1552
;  :datatype-occurs-check   767
;  :datatype-splits         1072
;  :decisions               19570
;  :del-clause              174345
;  :final-checks            298
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.55
;  :minimized-lits          538
;  :mk-bool-var             209175
;  :mk-clause               174360
;  :num-allocs              1038900
;  :num-checks              357
;  :propagations            89424
;  :quant-instantiations    48915
;  :restarts                2
;  :rlimit-count            4367883)
(assert (< i1@228@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 18
; Joined path conditions
(assert (< i1@228@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 17
(declare-fun inv@230@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@229@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@228@03 Int)) (!
  (< i1@228@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@228@03))
  :qid |int-aux|)))
(push) ; 17
(assert (not (forall ((i1@228@03 Int)) (!
  (implies
    (and (< i1@228@03 V@26@03) (<= 0 i1@228@03))
    (or (= $k@229@03 $Perm.No) (< $Perm.No $k@229@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115099
;  :arith-add-rows          64978
;  :arith-assert-diseq      7761
;  :arith-assert-lower      35005
;  :arith-assert-upper      23326
;  :arith-bound-prop        6629
;  :arith-conflicts         1005
;  :arith-eq-adapter        20914
;  :arith-fixed-eqs         12668
;  :arith-offset-eqs        15211
;  :arith-pivots            12094
;  :conflicts               2308
;  :datatype-accessor-ax    284
;  :datatype-constructor-ax 1552
;  :datatype-occurs-check   767
;  :datatype-splits         1072
;  :decisions               19570
;  :del-clause              174347
;  :final-checks            298
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.55
;  :minimized-lits          538
;  :mk-bool-var             209182
;  :mk-clause               174362
;  :num-allocs              1039320
;  :num-checks              358
;  :propagations            89425
;  :quant-instantiations    48915
;  :restarts                2
;  :rlimit-count            4368430)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@228@03 Int) (i12@228@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@228@03 V@26@03) (<= 0 i11@228@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@228@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@228@03)))
        (< $Perm.No $k@229@03))
      (and
        (and
          (and (< i12@228@03 V@26@03) (<= 0 i12@228@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@228@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@228@03)))
        (< $Perm.No $k@229@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@228@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@228@03)))
    (= i11@228@03 i12@228@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115112
;  :arith-add-rows          64995
;  :arith-assert-diseq      7762
;  :arith-assert-lower      35009
;  :arith-assert-upper      23326
;  :arith-bound-prop        6629
;  :arith-conflicts         1005
;  :arith-eq-adapter        20915
;  :arith-fixed-eqs         12668
;  :arith-offset-eqs        15211
;  :arith-pivots            12094
;  :conflicts               2309
;  :datatype-accessor-ax    284
;  :datatype-constructor-ax 1552
;  :datatype-occurs-check   767
;  :datatype-splits         1072
;  :decisions               19570
;  :del-clause              174404
;  :final-checks            298
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.55
;  :minimized-lits          538
;  :mk-bool-var             209272
;  :mk-clause               174419
;  :num-allocs              1039998
;  :num-checks              359
;  :propagations            89430
;  :quant-instantiations    48940
;  :restarts                2
;  :rlimit-count            4370145
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@228@03 Int)) (!
  (implies
    (and (and (< i1@228@03 V@26@03) (<= 0 i1@228@03)) (< $Perm.No $k@229@03))
    (=
      (inv@230@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@228@03))
      i1@228@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@228@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
      (< $Perm.No $k@229@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@230@03 r))
      r))
  :pattern ((inv@230@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r) r))
  :pattern ((inv@230@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@231@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
        $Perm.Write
        $Perm.No)
      $k@229@03)
    $Perm.No))
(define-fun pTaken@232@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
            (< (inv@150@03 r) V@26@03))
          (<= 0 (inv@150@03 r)))
        $Perm.Write
        $Perm.No)
      (- $k@229@03 (pTaken@231@03 r)))
    $Perm.No))
(define-fun pTaken@233@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)
      (- (- $k@229@03 (pTaken@231@03 r)) (pTaken@232@03 r)))
    $Perm.No))
(define-fun pTaken@234@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r))
      (- (- (- $k@229@03 (pTaken@231@03 r)) (pTaken@232@03 r)) (pTaken@233@03 r)))
    $Perm.No))
(define-fun pTaken@235@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r))
      (-
        (-
          (- (- $k@229@03 (pTaken@231@03 r)) (pTaken@232@03 r))
          (pTaken@233@03 r))
        (pTaken@234@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@229@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
      (<
        (ite
          (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
          $k@229@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
          $k@229@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@173@03 r))
  :pattern ((inv@230@03 r))
  :qid |qp.srp77|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 17
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
    (= (- $k@229@03 (pTaken@231@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115253
;  :arith-add-rows          65036
;  :arith-assert-diseq      7766
;  :arith-assert-lower      35023
;  :arith-assert-upper      23334
;  :arith-bound-prop        6635
;  :arith-conflicts         1007
;  :arith-eq-adapter        20933
;  :arith-fixed-eqs         12672
;  :arith-offset-eqs        15218
;  :arith-pivots            12108
;  :conflicts               2318
;  :datatype-accessor-ax    284
;  :datatype-constructor-ax 1569
;  :datatype-occurs-check   773
;  :datatype-splits         1081
;  :decisions               19591
;  :del-clause              174660
;  :final-checks            300
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.50
;  :minimized-lits          538
;  :mk-bool-var             209601
;  :mk-clause               174673
;  :num-allocs              1043506
;  :num-checks              361
;  :propagations            89486
;  :quant-instantiations    49016
;  :restarts                2
;  :rlimit-count            4379968
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@236@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@236@03  $FVF<Int>)))
    (and
      (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
      (< $Perm.No $k@229@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@236@03  $FVF<Int>))))
  :qid |qp.fvfDomDef84|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r))))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (and
        (and
          (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
          (< (inv@150@03 r) V@26@03))
        (<= 0 (inv@150@03 r))))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        (< $Perm.No $k@144@03)
        false))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef83|)))
(pop) ; 16
; Joined path conditions
(assert ($Perm.isReadVar $k@229@03 $Perm.Write))
(assert (forall ((i1@228@03 Int)) (!
  (implies
    (and (and (< i1@228@03 V@26@03) (<= 0 i1@228@03)) (< $Perm.No $k@229@03))
    (=
      (inv@230@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@228@03))
      i1@228@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@228@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
      (< $Perm.No $k@229@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@230@03 r))
      r))
  :pattern ((inv@230@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@236@03  $FVF<Int>)))
    (and
      (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
      (< $Perm.No $k@229@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@236@03  $FVF<Int>))))
  :qid |qp.fvfDomDef84|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r))))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r))
  :qid |qp.fvfValDef78|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (and
        (and
          (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
          (< (inv@150@03 r) V@26@03))
        (<= 0 (inv@150@03 r))))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef79|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        (< $Perm.No $k@144@03)
        false))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
        (< $Perm.No $k@229@03))
      (<
        $Perm.No
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))))
    (=
      ($FVF.lookup_int (as sm@236@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@236@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef83|)))
(assert (and
  (forall ((i1@228@03 Int)) (!
    (< i1@228@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@228@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@174@03  $FVF<Int>) r) r))
    :pattern ((inv@230@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
        (<
          (ite
            (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
            $k@229@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@230@03 r) V@26@03) (<= 0 (inv@230@03 r)))
            $k@229@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@173@03 r))
    :pattern ((inv@230@03 r))
    :qid |qp.srp77|))))
(set-option :timeout 0)
(push) ; 16
(assert (not (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@236@03  $FVF<Int>))))) this@21@03 res@156@03 V@26@03)))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115425
;  :arith-add-rows          65244
;  :arith-assert-diseq      7768
;  :arith-assert-lower      35046
;  :arith-assert-upper      23352
;  :arith-bound-prop        6653
;  :arith-conflicts         1010
;  :arith-eq-adapter        20947
;  :arith-fixed-eqs         12682
;  :arith-offset-eqs        15240
;  :arith-pivots            12137
;  :conflicts               2326
;  :datatype-accessor-ax    287
;  :datatype-constructor-ax 1573
;  :datatype-occurs-check   773
;  :datatype-splits         1081
;  :decisions               19600
;  :del-clause              175314
;  :final-checks            300
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.50
;  :minimized-lits          538
;  :mk-bool-var             210533
;  :mk-clause               175329
;  :num-allocs              1050039
;  :num-checks              362
;  :propagations            89554
;  :quant-instantiations    49216
;  :restarts                2
;  :rlimit-count            4406069
;  :time                    0.01)
(assert (valid_graph_vertices ($Snap.combine
  $Snap.unit
  ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($SortWrappers.$FVF<Int>To$Snap (as sm@236@03  $FVF<Int>))))) this@21@03 res@156@03 V@26@03))
; [eval] (forall i1: Int :: { this.P_seq[i1] } { aloc(opt_get1(P), i1) } 0 <= i1 && i1 < V ==> this.P_seq[i1] == aloc(opt_get1(P), i1).int)
(declare-const i1@237@03 Int)
(push) ; 16
; [eval] 0 <= i1 && i1 < V ==> this.P_seq[i1] == aloc(opt_get1(P), i1).int
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 17
; [then-branch: 226 | 0 <= i1@237@03 | live]
; [else-branch: 226 | !(0 <= i1@237@03) | live]
(push) ; 18
; [then-branch: 226 | 0 <= i1@237@03]
(assert (<= 0 i1@237@03))
; [eval] i1 < V
(pop) ; 18
(push) ; 18
; [else-branch: 226 | !(0 <= i1@237@03)]
(assert (not (<= 0 i1@237@03)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 227 | i1@237@03 < V@26@03 && 0 <= i1@237@03 | live]
; [else-branch: 227 | !(i1@237@03 < V@26@03 && 0 <= i1@237@03) | live]
(push) ; 18
; [then-branch: 227 | i1@237@03 < V@26@03 && 0 <= i1@237@03]
(assert (and (< i1@237@03 V@26@03) (<= 0 i1@237@03)))
; [eval] this.P_seq[i1] == aloc(opt_get1(P), i1).int
; [eval] this.P_seq[i1]
(push) ; 19
(assert (not (>= i1@237@03 0)))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115432
;  :arith-add-rows          65248
;  :arith-assert-diseq      7769
;  :arith-assert-lower      35050
;  :arith-assert-upper      23353
;  :arith-bound-prop        6653
;  :arith-conflicts         1010
;  :arith-eq-adapter        20948
;  :arith-fixed-eqs         12682
;  :arith-offset-eqs        15240
;  :arith-pivots            12137
;  :conflicts               2326
;  :datatype-accessor-ax    290
;  :datatype-constructor-ax 1573
;  :datatype-occurs-check   773
;  :datatype-splits         1081
;  :decisions               19600
;  :del-clause              175314
;  :final-checks            300
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.50
;  :minimized-lits          538
;  :mk-bool-var             210564
;  :mk-clause               175361
;  :num-allocs              1050395
;  :num-checks              363
;  :propagations            89569
;  :quant-instantiations    49220
;  :restarts                2
;  :rlimit-count            4406676)
(push) ; 19
(assert (not (<
  i1@237@03
  (Seq_length
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115432
;  :arith-add-rows          65248
;  :arith-assert-diseq      7769
;  :arith-assert-lower      35050
;  :arith-assert-upper      23353
;  :arith-bound-prop        6653
;  :arith-conflicts         1010
;  :arith-eq-adapter        20948
;  :arith-fixed-eqs         12682
;  :arith-offset-eqs        15240
;  :arith-pivots            12137
;  :conflicts               2326
;  :datatype-accessor-ax    290
;  :datatype-constructor-ax 1573
;  :datatype-occurs-check   773
;  :datatype-splits         1081
;  :decisions               19600
;  :del-clause              175314
;  :final-checks            300
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.50
;  :minimized-lits          538
;  :mk-bool-var             210564
;  :mk-clause               175361
;  :num-allocs              1050415
;  :num-checks              364
;  :propagations            89569
;  :quant-instantiations    49220
;  :restarts                2
;  :rlimit-count            4406696)
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115432
;  :arith-add-rows          65248
;  :arith-assert-diseq      7769
;  :arith-assert-lower      35050
;  :arith-assert-upper      23353
;  :arith-bound-prop        6653
;  :arith-conflicts         1010
;  :arith-eq-adapter        20948
;  :arith-fixed-eqs         12682
;  :arith-offset-eqs        15240
;  :arith-pivots            12137
;  :conflicts               2326
;  :datatype-accessor-ax    290
;  :datatype-constructor-ax 1573
;  :datatype-occurs-check   773
;  :datatype-splits         1081
;  :decisions               19600
;  :del-clause              175314
;  :final-checks            300
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              17.97
;  :memory                  17.50
;  :minimized-lits          538
;  :mk-bool-var             210564
;  :mk-clause               175361
;  :num-allocs              1050435
;  :num-checks              365
;  :propagations            89569
;  :quant-instantiations    49220
;  :restarts                2
;  :rlimit-count            4406726)
(assert (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 19
; Joined path conditions
(assert (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(declare-const sm@238@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
        (< (inv@150@03 r) V@26@03))
      (<= 0 (inv@150@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef86|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef90|)))
(declare-const pm@239@03 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@239@03  $FPM) r)
    (+
      (+
        (+
          (+
            (ite
              (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
              $Perm.Write
              $Perm.No)
            (ite
              (and
                (and
                  (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
                  (< (inv@150@03 r) V@26@03))
                (<= 0 (inv@150@03 r)))
              $Perm.Write
              $Perm.No))
          (ite
            (and
              (and
                (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
                (< (inv@145@03 r) V@26@03))
              (<= 0 (inv@145@03 r)))
            $k@144@03
            $Perm.No))
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r)))
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r))))
  :pattern (($FVF.perm_int (as pm@239@03  $FPM) r))
  :qid |qp.resPrmSumDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@239@03  $FPM) r))
  :qid |qp.resTrgDef92|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@238@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03)))
(push) ; 19
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@239@03  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.08s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               118752
;  :arith-add-rows          67311
;  :arith-assert-diseq      7858
;  :arith-assert-lower      35781
;  :arith-assert-upper      23877
;  :arith-bound-prop        6881
;  :arith-conflicts         1030
;  :arith-eq-adapter        21579
;  :arith-fixed-eqs         13086
;  :arith-offset-eqs        15546
;  :arith-pivots            12618
;  :conflicts               2358
;  :datatype-accessor-ax    290
;  :datatype-constructor-ax 1585
;  :datatype-occurs-check   773
;  :datatype-splits         1081
;  :decisions               19716
;  :del-clause              181537
;  :final-checks            300
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  18.01
;  :minimized-lits          554
;  :mk-bool-var             218874
;  :mk-clause               181899
;  :num-allocs              1083706
;  :num-checks              366
;  :propagations            91642
;  :quant-instantiations    51527
;  :restarts                2
;  :rlimit-count            4568052
;  :time                    0.08)
(pop) ; 18
(push) ; 18
; [else-branch: 227 | !(i1@237@03 < V@26@03 && 0 <= i1@237@03)]
(assert (not (and (< i1@237@03 V@26@03) (<= 0 i1@237@03))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
        (< (inv@150@03 r) V@26@03))
      (<= 0 (inv@150@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef86|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef90|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@239@03  $FPM) r)
    (+
      (+
        (+
          (+
            (ite
              (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
              $Perm.Write
              $Perm.No)
            (ite
              (and
                (and
                  (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
                  (< (inv@150@03 r) V@26@03))
                (<= 0 (inv@150@03 r)))
              $Perm.Write
              $Perm.No))
          (ite
            (and
              (and
                (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
                (< (inv@145@03 r) V@26@03))
              (<= 0 (inv@145@03 r)))
            $k@144@03
            $Perm.No))
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r)))
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r))))
  :pattern (($FVF.perm_int (as pm@239@03  $FPM) r))
  :qid |qp.resPrmSumDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@239@03  $FPM) r))
  :qid |qp.resTrgDef92|)))
(assert (implies
  (and (< i1@237@03 V@26@03) (<= 0 i1@237@03))
  (and
    (< i1@237@03 V@26@03)
    (<= 0 i1@237@03)
    (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@238@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r))
  :qid |qp.fvfValDef85|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
        (< (inv@150@03 r) V@26@03))
      (<= 0 (inv@150@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r))
  :qid |qp.fvfValDef86|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                (< (inv@85@03 r) V@26@03))
              (<= 0 (inv@85@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@114@03 r))
        (pTaken@122@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r)))
    (=
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@238@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef90|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@239@03  $FPM) r)
    (+
      (+
        (+
          (+
            (ite
              (and (< (inv@173@03 r) V@26@03) (<= 0 (inv@173@03 r)))
              $Perm.Write
              $Perm.No)
            (ite
              (and
                (and
                  (and (< (inv@151@03 r) V@26@03) (<= 0 (inv@151@03 r)))
                  (< (inv@150@03 r) V@26@03))
                (<= 0 (inv@150@03 r)))
              $Perm.Write
              $Perm.No))
          (ite
            (and
              (and
                (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
                (< (inv@145@03 r) V@26@03))
              (<= 0 (inv@145@03 r)))
            $k@144@03
            $Perm.No))
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r)))
      (-
        (-
          (ite
            (and
              (and
                (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                (< (inv@40@03 r) V@26@03))
              (<= 0 (inv@40@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@115@03 r))
        (pTaken@121@03 r))))
  :pattern (($FVF.perm_int (as pm@239@03  $FPM) r))
  :qid |qp.resPrmSumDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@238@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@171@03))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@239@03  $FPM) r))
  :qid |qp.resTrgDef92|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@237@03 Int)) (!
  (implies
    (and (< i1@237@03 V@26@03) (<= 0 i1@237@03))
    (and
      (< i1@237@03 V@26@03)
      (<= 0 i1@237@03)
      (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@238@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
    i1@237@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@237@03 Int)) (!
  (implies
    (and (< i1@237@03 V@26@03) (<= 0 i1@237@03))
    (and
      (< i1@237@03 V@26@03)
      (<= 0 i1@237@03)
      (< i1@237@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@238@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(push) ; 16
(assert (not (forall ((i1@237@03 Int)) (!
  (implies
    (and (< i1@237@03 V@26@03) (<= 0 i1@237@03))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
        i1@237@03)
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
    i1@237@03))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03))
  :qid |prog.l<no position>|))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               118854
;  :arith-add-rows          67407
;  :arith-assert-diseq      7858
;  :arith-assert-lower      35791
;  :arith-assert-upper      23887
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21596
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2366
;  :datatype-accessor-ax    290
;  :datatype-constructor-ax 1589
;  :datatype-occurs-check   773
;  :datatype-splits         1081
;  :decisions               19724
;  :del-clause              182199
;  :final-checks            300
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.94
;  :minimized-lits          555
;  :mk-bool-var             219331
;  :mk-clause               182246
;  :num-allocs              1088901
;  :num-checks              367
;  :propagations            91676
;  :quant-instantiations    51631
;  :restarts                2
;  :rlimit-count            4590599
;  :time                    0.00)
(assert (forall ((i1@237@03 Int)) (!
  (implies
    (and (< i1@237@03 V@26@03) (<= 0 i1@237@03))
    (=
      (Seq_index
        ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
        i1@237@03)
      ($FVF.lookup_int (as sm@238@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@171@03)))))
    i1@237@03))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@237@03))
  :qid |prog.l<no position>|)))
(declare-const exc@240@03 $Ref)
(declare-const res@241@03 Int)
(declare-const $t@242@03 $Snap)
(assert (= $t@242@03 ($Snap.combine ($Snap.first $t@242@03) ($Snap.second $t@242@03))))
(assert (= ($Snap.first $t@242@03) $Snap.unit))
; [eval] exc == null
(assert (= exc@240@03 $Ref.null))
(assert (=
  ($Snap.second $t@242@03)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@242@03))
    ($Snap.second ($Snap.second $t@242@03)))))
(assert (= ($Snap.first ($Snap.second $t@242@03)) $Snap.unit))
; [eval] exc == null ==> Gf != (None(): option[array])
; [eval] exc == null
(push) ; 16
(set-option :timeout 10)
(push) ; 17
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               118945
;  :arith-add-rows          67407
;  :arith-assert-diseq      7858
;  :arith-assert-lower      35791
;  :arith-assert-upper      23887
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21596
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2366
;  :datatype-accessor-ax    292
;  :datatype-constructor-ax 1604
;  :datatype-occurs-check   784
;  :datatype-splits         1092
;  :decisions               19739
;  :del-clause              182199
;  :final-checks            302
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.92
;  :minimized-lits          555
;  :mk-bool-var             219348
;  :mk-clause               182246
;  :num-allocs              1090115
;  :num-checks              368
;  :propagations            91676
;  :quant-instantiations    51631
;  :restarts                2
;  :rlimit-count            4592428
;  :time                    0.00)
; [then-branch: 228 | exc@240@03 == Null | live]
; [else-branch: 228 | exc@240@03 != Null | dead]
(push) ; 17
; [then-branch: 228 | exc@240@03 == Null]
; [eval] Gf != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (not (= res@74@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@242@03))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@242@03)))
    ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@242@03))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(Gf)) == V
; [eval] exc == null
(push) ; 16
(push) ; 17
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119030
;  :arith-add-rows          67407
;  :arith-assert-diseq      7858
;  :arith-assert-lower      35791
;  :arith-assert-upper      23887
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21596
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2366
;  :datatype-accessor-ax    293
;  :datatype-constructor-ax 1619
;  :datatype-occurs-check   795
;  :datatype-splits         1103
;  :decisions               19754
;  :del-clause              182199
;  :final-checks            304
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.91
;  :minimized-lits          555
;  :mk-bool-var             219361
;  :mk-clause               182246
;  :num-allocs              1091096
;  :num-checks              369
;  :propagations            91676
;  :quant-instantiations    51631
;  :restarts                2
;  :rlimit-count            4593679)
; [then-branch: 229 | exc@240@03 == Null | live]
; [else-branch: 229 | exc@240@03 != Null | dead]
(push) ; 17
; [then-branch: 229 | exc@240@03 == Null]
; [eval] alen(opt_get1(Gf)) == V
; [eval] alen(opt_get1(Gf))
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@74@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@242@03)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@242@03))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))
; [eval] exc == null
(push) ; 16
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119117
;  :arith-add-rows          67407
;  :arith-assert-diseq      7858
;  :arith-assert-lower      35791
;  :arith-assert-upper      23887
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21596
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2366
;  :datatype-accessor-ax    294
;  :datatype-constructor-ax 1635
;  :datatype-occurs-check   806
;  :datatype-splits         1115
;  :decisions               19770
;  :del-clause              182199
;  :final-checks            306
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.91
;  :minimized-lits          555
;  :mk-bool-var             219374
;  :mk-clause               182246
;  :num-allocs              1092072
;  :num-checks              370
;  :propagations            91676
;  :quant-instantiations    51631
;  :restarts                2
;  :rlimit-count            4594922)
; [then-branch: 230 | exc@240@03 == Null | live]
; [else-branch: 230 | exc@240@03 != Null | dead]
(push) ; 16
; [then-branch: 230 | exc@240@03 == Null]
(declare-const i1@243@03 Int)
(push) ; 17
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 18
; [then-branch: 231 | 0 <= i1@243@03 | live]
; [else-branch: 231 | !(0 <= i1@243@03) | live]
(push) ; 19
; [then-branch: 231 | 0 <= i1@243@03]
(assert (<= 0 i1@243@03))
; [eval] i1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 231 | !(0 <= i1@243@03)]
(assert (not (<= 0 i1@243@03)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(assert (and (< i1@243@03 V@26@03) (<= 0 i1@243@03)))
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@243@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119117
;  :arith-add-rows          67408
;  :arith-assert-diseq      7858
;  :arith-assert-lower      35793
;  :arith-assert-upper      23887
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21596
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2366
;  :datatype-accessor-ax    294
;  :datatype-constructor-ax 1635
;  :datatype-occurs-check   806
;  :datatype-splits         1115
;  :decisions               19770
;  :del-clause              182199
;  :final-checks            306
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.91
;  :minimized-lits          555
;  :mk-bool-var             219376
;  :mk-clause               182246
;  :num-allocs              1092175
;  :num-checks              371
;  :propagations            91676
;  :quant-instantiations    51631
;  :restarts                2
;  :rlimit-count            4595106)
(assert (< i1@243@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 18
; Joined path conditions
(assert (< i1@243@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(declare-const $k@244@03 $Perm)
(assert ($Perm.isReadVar $k@244@03 $Perm.Write))
(pop) ; 17
(declare-fun inv@245@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@244@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@243@03 Int)) (!
  (< i1@243@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@243@03))
  :qid |option$array$-aux|)))
(push) ; 17
(assert (not (forall ((i1@243@03 Int)) (!
  (implies
    (and (< i1@243@03 V@26@03) (<= 0 i1@243@03))
    (or (= $k@244@03 $Perm.No) (< $Perm.No $k@244@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119117
;  :arith-add-rows          67409
;  :arith-assert-diseq      7859
;  :arith-assert-lower      35795
;  :arith-assert-upper      23888
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21597
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2367
;  :datatype-accessor-ax    294
;  :datatype-constructor-ax 1635
;  :datatype-occurs-check   806
;  :datatype-splits         1115
;  :decisions               19770
;  :del-clause              182199
;  :final-checks            306
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.91
;  :minimized-lits          555
;  :mk-bool-var             219383
;  :mk-clause               182248
;  :num-allocs              1092640
;  :num-checks              372
;  :propagations            91677
;  :quant-instantiations    51631
;  :restarts                2
;  :rlimit-count            4595677)
; Check receiver injectivity
(push) ; 17
(assert (not (forall ((i11@243@03 Int) (i12@243@03 Int)) (!
  (implies
    (and
      (and (and (< i11@243@03 V@26@03) (<= 0 i11@243@03)) (< $Perm.No $k@244@03))
      (and (and (< i12@243@03 V@26@03) (<= 0 i12@243@03)) (< $Perm.No $k@244@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@243@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@243@03)))
    (= i11@243@03 i12@243@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119128
;  :arith-add-rows          67413
;  :arith-assert-diseq      7860
;  :arith-assert-lower      35799
;  :arith-assert-upper      23888
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21598
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2368
;  :datatype-accessor-ax    294
;  :datatype-constructor-ax 1635
;  :datatype-occurs-check   806
;  :datatype-splits         1115
;  :decisions               19770
;  :del-clause              182205
;  :final-checks            306
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.90
;  :minimized-lits          555
;  :mk-bool-var             219404
;  :mk-clause               182254
;  :num-allocs              1093027
;  :num-checks              373
;  :propagations            91677
;  :quant-instantiations    51650
;  :restarts                2
;  :rlimit-count            4596517)
; Definitional axioms for inverse functions
(assert (forall ((i1@243@03 Int)) (!
  (implies
    (and (and (< i1@243@03 V@26@03) (<= 0 i1@243@03)) (< $Perm.No $k@244@03))
    (=
      (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@243@03))
      i1@243@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@243@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@245@03 r) V@26@03) (<= 0 (inv@245@03 r)))
      (< $Perm.No $k@244@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@245@03 r))
      r))
  :pattern ((inv@245@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@243@03 Int)) (!
  (<= $Perm.No $k@244@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@243@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@243@03 Int)) (!
  (<= $k@244@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@243@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@243@03 Int)) (!
  (implies
    (and (and (< i1@243@03 V@26@03) (<= 0 i1@243@03)) (< $Perm.No $k@244@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@243@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@243@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@246@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@245@03 r) V@26@03) (<= 0 (inv@245@03 r)))
      (< $Perm.No $k@244@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@242@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@242@03))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
              $k@31@03
              $Perm.No)
            (pTaken@94@03 r))
          (pTaken@103@03 r))
        (pTaken@192@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 r))
        (pTaken@104@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
      (< $Perm.No $k@127@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r))
  :qid |qp.fvfValDef96|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
          $k@135@03
          $Perm.No)
        (pTaken@180@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r))
  :qid |qp.fvfValDef97|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@242@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef98|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@245@03 r) V@26@03) (<= 0 (inv@245@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) r) r))
  :pattern ((inv@245@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 17
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119218
;  :arith-add-rows          67413
;  :arith-assert-diseq      7860
;  :arith-assert-lower      35799
;  :arith-assert-upper      23889
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21598
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2368
;  :datatype-accessor-ax    295
;  :datatype-constructor-ax 1651
;  :datatype-occurs-check   817
;  :datatype-splits         1127
;  :decisions               19786
;  :del-clause              182205
;  :final-checks            308
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.90
;  :minimized-lits          555
;  :mk-bool-var             219429
;  :mk-clause               182254
;  :num-allocs              1096317
;  :num-checks              374
;  :propagations            91677
;  :quant-instantiations    51650
;  :restarts                2
;  :rlimit-count            4605185)
; [then-branch: 232 | exc@240@03 == Null | live]
; [else-branch: 232 | exc@240@03 != Null | dead]
(push) ; 18
; [then-branch: 232 | exc@240@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array]))
(declare-const i1@247@03 Int)
(push) ; 19
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 20
; [then-branch: 233 | 0 <= i1@247@03 | live]
; [else-branch: 233 | !(0 <= i1@247@03) | live]
(push) ; 21
; [then-branch: 233 | 0 <= i1@247@03]
(assert (<= 0 i1@247@03))
; [eval] i1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 233 | !(0 <= i1@247@03)]
(assert (not (<= 0 i1@247@03)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 234 | i1@247@03 < V@26@03 && 0 <= i1@247@03 | live]
; [else-branch: 234 | !(i1@247@03 < V@26@03 && 0 <= i1@247@03) | live]
(push) ; 21
; [then-branch: 234 | i1@247@03 < V@26@03 && 0 <= i1@247@03]
(assert (and (< i1@247@03 V@26@03) (<= 0 i1@247@03)))
; [eval] aloc(opt_get1(Gf), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< i1@247@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               119218
;  :arith-add-rows          67414
;  :arith-assert-diseq      7860
;  :arith-assert-lower      35801
;  :arith-assert-upper      23889
;  :arith-bound-prop        6895
;  :arith-conflicts         1031
;  :arith-eq-adapter        21598
;  :arith-fixed-eqs         13092
;  :arith-offset-eqs        15558
;  :arith-pivots            12663
;  :conflicts               2368
;  :datatype-accessor-ax    295
;  :datatype-constructor-ax 1651
;  :datatype-occurs-check   817
;  :datatype-splits         1127
;  :decisions               19786
;  :del-clause              182205
;  :final-checks            308
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.90
;  :minimized-lits          555
;  :mk-bool-var             219431
;  :mk-clause               182254
;  :num-allocs              1096420
;  :num-checks              375
;  :propagations            91677
;  :quant-instantiations    51650
;  :restarts                2
;  :rlimit-count            4605379)
(assert (< i1@247@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 22
; Joined path conditions
(assert (< i1@247@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (ite
            (and
              (<
                (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
                V@26@03)
              (<=
                0
                (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
            $k@244@03
            $Perm.No)
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               120517
;  :arith-add-rows          68415
;  :arith-assert-diseq      7961
;  :arith-assert-lower      36219
;  :arith-assert-upper      24183
;  :arith-bound-prop        7015
;  :arith-conflicts         1048
;  :arith-eq-adapter        21867
;  :arith-fixed-eqs         13255
;  :arith-offset-eqs        15745
;  :arith-pivots            12837
;  :conflicts               2401
;  :datatype-accessor-ax    295
;  :datatype-constructor-ax 1655
;  :datatype-occurs-check   817
;  :datatype-splits         1127
;  :decisions               19932
;  :del-clause              183747
;  :final-checks            308
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.93
;  :minimized-lits          565
;  :mk-bool-var             221722
;  :mk-clause               184050
;  :num-allocs              1106777
;  :num-checks              376
;  :propagations            92648
;  :quant-instantiations    52170
;  :restarts                2
;  :rlimit-count            4665662
;  :time                    0.02)
; [eval] (None(): option[array])
(pop) ; 21
(push) ; 21
; [else-branch: 234 | !(i1@247@03 < V@26@03 && 0 <= i1@247@03)]
(assert (not (and (< i1@247@03 V@26@03) (<= 0 i1@247@03))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< i1@247@03 V@26@03) (<= 0 i1@247@03))
  (and
    (< i1@247@03 V@26@03)
    (<= 0 i1@247@03)
    (< i1@247@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@247@03 Int)) (!
  (implies
    (and (< i1@247@03 V@26@03) (<= 0 i1@247@03))
    (and
      (< i1@247@03 V@26@03)
      (<= 0 i1@247@03)
      (< i1@247@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@247@03 Int)) (!
    (implies
      (and (< i1@247@03 V@26@03) (<= 0 i1@247@03))
      (and
        (< i1@247@03 V@26@03)
        (<= 0 i1@247@03)
        (< i1@247@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@247@03 Int)) (!
    (implies
      (and (< i1@247@03 V@26@03) (<= 0 i1@247@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@247@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 17
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               120608
;  :arith-add-rows          68431
;  :arith-assert-diseq      7961
;  :arith-assert-lower      36219
;  :arith-assert-upper      24183
;  :arith-bound-prop        7015
;  :arith-conflicts         1048
;  :arith-eq-adapter        21867
;  :arith-fixed-eqs         13255
;  :arith-offset-eqs        15745
;  :arith-pivots            12856
;  :conflicts               2401
;  :datatype-accessor-ax    296
;  :datatype-constructor-ax 1671
;  :datatype-occurs-check   828
;  :datatype-splits         1139
;  :decisions               19948
;  :del-clause              184001
;  :final-checks            310
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.90
;  :minimized-lits          565
;  :mk-bool-var             221738
;  :mk-clause               184050
;  :num-allocs              1108144
;  :num-checks              377
;  :propagations            92648
;  :quant-instantiations    52170
;  :restarts                2
;  :rlimit-count            4668133)
; [then-branch: 235 | exc@240@03 == Null | live]
; [else-branch: 235 | exc@240@03 != Null | dead]
(push) ; 18
; [then-branch: 235 | exc@240@03 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V)
(declare-const i1@248@03 Int)
(push) ; 19
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 20
; [then-branch: 236 | 0 <= i1@248@03 | live]
; [else-branch: 236 | !(0 <= i1@248@03) | live]
(push) ; 21
; [then-branch: 236 | 0 <= i1@248@03]
(assert (<= 0 i1@248@03))
; [eval] i1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 236 | !(0 <= i1@248@03)]
(assert (not (<= 0 i1@248@03)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 237 | i1@248@03 < V@26@03 && 0 <= i1@248@03 | live]
; [else-branch: 237 | !(i1@248@03 < V@26@03 && 0 <= i1@248@03) | live]
(push) ; 21
; [then-branch: 237 | i1@248@03 < V@26@03 && 0 <= i1@248@03]
(assert (and (< i1@248@03 V@26@03) (<= 0 i1@248@03)))
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(Gf), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< i1@248@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               120608
;  :arith-add-rows          68432
;  :arith-assert-diseq      7961
;  :arith-assert-lower      36221
;  :arith-assert-upper      24183
;  :arith-bound-prop        7015
;  :arith-conflicts         1048
;  :arith-eq-adapter        21867
;  :arith-fixed-eqs         13255
;  :arith-offset-eqs        15745
;  :arith-pivots            12856
;  :conflicts               2401
;  :datatype-accessor-ax    296
;  :datatype-constructor-ax 1671
;  :datatype-occurs-check   828
;  :datatype-splits         1139
;  :decisions               19948
;  :del-clause              184001
;  :final-checks            310
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.90
;  :minimized-lits          565
;  :mk-bool-var             221740
;  :mk-clause               184050
;  :num-allocs              1108247
;  :num-checks              378
;  :propagations            92648
;  :quant-instantiations    52170
;  :restarts                2
;  :rlimit-count            4668329)
(assert (< i1@248@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 22
; Joined path conditions
(assert (< i1@248@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (ite
            (and
              (<
                (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
                V@26@03)
              (<=
                0
                (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))))
            $k@244@03
            $Perm.No)
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               121416
;  :arith-add-rows          69114
;  :arith-assert-diseq      8025
;  :arith-assert-lower      36517
;  :arith-assert-upper      24386
;  :arith-bound-prop        7102
;  :arith-conflicts         1064
;  :arith-eq-adapter        22065
;  :arith-fixed-eqs         13362
;  :arith-offset-eqs        15855
;  :arith-pivots            12982
;  :conflicts               2435
;  :datatype-accessor-ax    296
;  :datatype-constructor-ax 1675
;  :datatype-occurs-check   828
;  :datatype-splits         1139
;  :decisions               20037
;  :del-clause              184855
;  :final-checks            310
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.93
;  :minimized-lits          568
;  :mk-bool-var             223354
;  :mk-clause               185158
;  :num-allocs              1115848
;  :num-checks              379
;  :propagations            93236
;  :quant-instantiations    52481
;  :restarts                2
;  :rlimit-count            4705439
;  :time                    0.02)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               121416
;  :arith-add-rows          69114
;  :arith-assert-diseq      8025
;  :arith-assert-lower      36517
;  :arith-assert-upper      24386
;  :arith-bound-prop        7102
;  :arith-conflicts         1064
;  :arith-eq-adapter        22065
;  :arith-fixed-eqs         13362
;  :arith-offset-eqs        15855
;  :arith-pivots            12982
;  :conflicts               2436
;  :datatype-accessor-ax    296
;  :datatype-constructor-ax 1675
;  :datatype-occurs-check   828
;  :datatype-splits         1139
;  :decisions               20037
;  :del-clause              184855
;  :final-checks            310
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.93
;  :minimized-lits          568
;  :mk-bool-var             223354
;  :mk-clause               185158
;  :num-allocs              1115939
;  :num-checks              380
;  :propagations            93236
;  :quant-instantiations    52481
;  :restarts                2
;  :rlimit-count            4705534)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
    (as None<option<array>>  option<array>))))
(pop) ; 21
(push) ; 21
; [else-branch: 237 | !(i1@248@03 < V@26@03 && 0 <= i1@248@03)]
(assert (not (and (< i1@248@03 V@26@03) (<= 0 i1@248@03))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< i1@248@03 V@26@03) (<= 0 i1@248@03))
  (and
    (< i1@248@03 V@26@03)
    (<= 0 i1@248@03)
    (< i1@248@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@248@03 Int)) (!
  (implies
    (and (< i1@248@03 V@26@03) (<= 0 i1@248@03))
    (and
      (< i1@248@03 V@26@03)
      (<= 0 i1@248@03)
      (< i1@248@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@248@03 Int)) (!
    (implies
      (and (< i1@248@03 V@26@03) (<= 0 i1@248@03))
      (and
        (< i1@248@03 V@26@03)
        (<= 0 i1@248@03)
        (< i1@248@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@248@03 Int)) (!
    (implies
      (and (< i1@248@03 V@26@03) (<= 0 i1@248@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03))))
        V@26@03))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@248@03)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 17
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               121508
;  :arith-add-rows          69144
;  :arith-assert-diseq      8025
;  :arith-assert-lower      36517
;  :arith-assert-upper      24386
;  :arith-bound-prop        7102
;  :arith-conflicts         1064
;  :arith-eq-adapter        22065
;  :arith-fixed-eqs         13362
;  :arith-offset-eqs        15855
;  :arith-pivots            13003
;  :conflicts               2436
;  :datatype-accessor-ax    297
;  :datatype-constructor-ax 1691
;  :datatype-occurs-check   839
;  :datatype-splits         1151
;  :decisions               20053
;  :del-clause              185109
;  :final-checks            312
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.90
;  :minimized-lits          568
;  :mk-bool-var             223370
;  :mk-clause               185158
;  :num-allocs              1117333
;  :num-checks              381
;  :propagations            93236
;  :quant-instantiations    52481
;  :restarts                2
;  :rlimit-count            4708380
;  :time                    0.00)
; [then-branch: 238 | exc@240@03 == Null | live]
; [else-branch: 238 | exc@240@03 != Null | dead]
(push) ; 18
; [then-branch: 238 | exc@240@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(Gf), i1) } (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2))
(declare-const i1@249@03 Int)
(push) ; 19
; [eval] (forall i2: Int :: { aloc(opt_get1(Gf), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2)
(declare-const i2@250@03 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 239 | 0 <= i1@249@03 | live]
; [else-branch: 239 | !(0 <= i1@249@03) | live]
(push) ; 22
; [then-branch: 239 | 0 <= i1@249@03]
(assert (<= 0 i1@249@03))
; [eval] i1 < V
(push) ; 23
; [then-branch: 240 | i1@249@03 < V@26@03 | live]
; [else-branch: 240 | !(i1@249@03 < V@26@03) | live]
(push) ; 24
; [then-branch: 240 | i1@249@03 < V@26@03]
(assert (< i1@249@03 V@26@03))
; [eval] 0 <= i2
(push) ; 25
; [then-branch: 241 | 0 <= i2@250@03 | live]
; [else-branch: 241 | !(0 <= i2@250@03) | live]
(push) ; 26
; [then-branch: 241 | 0 <= i2@250@03]
(assert (<= 0 i2@250@03))
; [eval] i2 < V
(push) ; 27
; [then-branch: 242 | i2@250@03 < V@26@03 | live]
; [else-branch: 242 | !(i2@250@03 < V@26@03) | live]
(push) ; 28
; [then-branch: 242 | i2@250@03 < V@26@03]
(assert (< i2@250@03 V@26@03))
; [eval] aloc(opt_get1(Gf), i1).option$array$ == aloc(opt_get1(Gf), i2).option$array$
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 29
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 29
; Joined path conditions
(push) ; 29
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 30
(assert (not (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               121508
;  :arith-add-rows          69146
;  :arith-assert-diseq      8025
;  :arith-assert-lower      36521
;  :arith-assert-upper      24386
;  :arith-bound-prop        7102
;  :arith-conflicts         1064
;  :arith-eq-adapter        22065
;  :arith-fixed-eqs         13362
;  :arith-offset-eqs        15855
;  :arith-pivots            13003
;  :conflicts               2436
;  :datatype-accessor-ax    297
;  :datatype-constructor-ax 1691
;  :datatype-occurs-check   839
;  :datatype-splits         1151
;  :decisions               20053
;  :del-clause              185109
;  :final-checks            312
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.90
;  :minimized-lits          568
;  :mk-bool-var             223374
;  :mk-clause               185158
;  :num-allocs              1117619
;  :num-checks              382
;  :propagations            93236
;  :quant-instantiations    52481
;  :restarts                2
;  :rlimit-count            4708720)
(assert (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 29
; Joined path conditions
(assert (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)))
(push) ; 29
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (ite
            (and
              (<
                (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                V@26@03)
              (<=
                0
                (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))))
            $k@244@03
            $Perm.No)
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)))))))
(check-sat)
; unsat
(pop) ; 29
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               122683
;  :arith-add-rows          70231
;  :arith-assert-diseq      8136
;  :arith-assert-lower      37018
;  :arith-assert-upper      24661
;  :arith-bound-prop        7223
;  :arith-conflicts         1085
;  :arith-eq-adapter        22354
;  :arith-fixed-eqs         13520
;  :arith-offset-eqs        16044
;  :arith-pivots            13161
;  :conflicts               2471
;  :datatype-accessor-ax    297
;  :datatype-constructor-ax 1695
;  :datatype-occurs-check   839
;  :datatype-splits         1151
;  :decisions               20245
;  :del-clause              186975
;  :final-checks            312
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.94
;  :minimized-lits          572
;  :mk-bool-var             225928
;  :mk-clause               187277
;  :num-allocs              1127345
;  :num-checks              383
;  :propagations            94253
;  :quant-instantiations    52926
;  :restarts                2
;  :rlimit-count            4767143
;  :time                    0.03)
; [eval] aloc(opt_get1(Gf), i2)
; [eval] opt_get1(Gf)
(push) ; 29
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 29
; Joined path conditions
(push) ; 29
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 30
(assert (not (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 30
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               122683
;  :arith-add-rows          70231
;  :arith-assert-diseq      8136
;  :arith-assert-lower      37018
;  :arith-assert-upper      24661
;  :arith-bound-prop        7223
;  :arith-conflicts         1085
;  :arith-eq-adapter        22354
;  :arith-fixed-eqs         13520
;  :arith-offset-eqs        16044
;  :arith-pivots            13161
;  :conflicts               2471
;  :datatype-accessor-ax    297
;  :datatype-constructor-ax 1695
;  :datatype-occurs-check   839
;  :datatype-splits         1151
;  :decisions               20245
;  :del-clause              186975
;  :final-checks            312
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.94
;  :minimized-lits          572
;  :mk-bool-var             225928
;  :mk-clause               187277
;  :num-allocs              1127372
;  :num-checks              384
;  :propagations            94253
;  :quant-instantiations    52926
;  :restarts                2
;  :rlimit-count            4767173)
(assert (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 29
; Joined path conditions
(assert (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
(push) ; 29
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (ite
            (and
              (<
                (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
                V@26@03)
              (<=
                0
                (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))
            $k@244@03
            $Perm.No)
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))))))
(check-sat)
; unsat
(pop) ; 29
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124442
;  :arith-add-rows          71500
;  :arith-assert-diseq      8268
;  :arith-assert-lower      37559
;  :arith-assert-upper      25009
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22698
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13338
;  :conflicts               2516
;  :datatype-accessor-ax    297
;  :datatype-constructor-ax 1699
;  :datatype-occurs-check   839
;  :datatype-splits         1151
;  :decisions               20381
;  :del-clause              190150
;  :final-checks            312
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  18.04
;  :minimized-lits          577
;  :mk-bool-var             229449
;  :mk-clause               190666
;  :num-allocs              1143028
;  :num-checks              385
;  :propagations            95620
;  :quant-instantiations    53843
;  :restarts                2
;  :rlimit-count            4858196
;  :time                    0.04)
(pop) ; 28
(push) ; 28
; [else-branch: 242 | !(i2@250@03 < V@26@03)]
(assert (not (< i2@250@03 V@26@03)))
(pop) ; 28
(pop) ; 27
; Joined path conditions
(assert (implies
  (< i2@250@03 V@26@03)
  (and
    (< i2@250@03 V@26@03)
    (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
    (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))))
; Joined path conditions
(pop) ; 26
(push) ; 26
; [else-branch: 241 | !(0 <= i2@250@03)]
(assert (not (<= 0 i2@250@03)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
(assert (implies
  (<= 0 i2@250@03)
  (and
    (<= 0 i2@250@03)
    (implies
      (< i2@250@03 V@26@03)
      (and
        (< i2@250@03 V@26@03)
        (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
        (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))))))
; Joined path conditions
(pop) ; 24
(push) ; 24
; [else-branch: 240 | !(i1@249@03 < V@26@03)]
(assert (not (< i1@249@03 V@26@03)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (implies
  (< i1@249@03 V@26@03)
  (and
    (< i1@249@03 V@26@03)
    (implies
      (<= 0 i2@250@03)
      (and
        (<= 0 i2@250@03)
        (implies
          (< i2@250@03 V@26@03)
          (and
            (< i2@250@03 V@26@03)
            (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
            (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))))))))
; Joined path conditions
(pop) ; 22
(push) ; 22
; [else-branch: 239 | !(0 <= i1@249@03)]
(assert (not (<= 0 i1@249@03)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (<= 0 i1@249@03)
  (and
    (<= 0 i1@249@03)
    (implies
      (< i1@249@03 V@26@03)
      (and
        (< i1@249@03 V@26@03)
        (implies
          (<= 0 i2@250@03)
          (and
            (<= 0 i2@250@03)
            (implies
              (< i2@250@03 V@26@03)
              (and
                (< i2@250@03 V@26@03)
                (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))))))))))
; Joined path conditions
(push) ; 21
; [then-branch: 243 | Lookup(option$array$,sm@246@03,aloc((_, _), opt_get1(_, res@74@03), i1@249@03)) == Lookup(option$array$,sm@246@03,aloc((_, _), opt_get1(_, res@74@03), i2@250@03)) && i2@250@03 < V@26@03 && 0 <= i2@250@03 && i1@249@03 < V@26@03 && 0 <= i1@249@03 | live]
; [else-branch: 243 | !(Lookup(option$array$,sm@246@03,aloc((_, _), opt_get1(_, res@74@03), i1@249@03)) == Lookup(option$array$,sm@246@03,aloc((_, _), opt_get1(_, res@74@03), i2@250@03)) && i2@250@03 < V@26@03 && 0 <= i2@250@03 && i1@249@03 < V@26@03 && 0 <= i1@249@03) | live]
(push) ; 22
; [then-branch: 243 | Lookup(option$array$,sm@246@03,aloc((_, _), opt_get1(_, res@74@03), i1@249@03)) == Lookup(option$array$,sm@246@03,aloc((_, _), opt_get1(_, res@74@03), i2@250@03)) && i2@250@03 < V@26@03 && 0 <= i2@250@03 && i1@249@03 < V@26@03 && 0 <= i1@249@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
          ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
        (< i2@250@03 V@26@03))
      (<= 0 i2@250@03))
    (< i1@249@03 V@26@03))
  (<= 0 i1@249@03)))
; [eval] i1 == i2
(pop) ; 22
(push) ; 22
; [else-branch: 243 | !(Lookup(option$array$,sm@246@03,aloc((_, _), opt_get1(_, res@74@03), i1@249@03)) == Lookup(option$array$,sm@246@03,aloc((_, _), opt_get1(_, res@74@03), i2@250@03)) && i2@250@03 < V@26@03 && 0 <= i2@250@03 && i1@249@03 < V@26@03 && 0 <= i1@249@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
            ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
          (< i2@250@03 V@26@03))
        (<= 0 i2@250@03))
      (< i1@249@03 V@26@03))
    (<= 0 i1@249@03))))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
            ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
          (< i2@250@03 V@26@03))
        (<= 0 i2@250@03))
      (< i1@249@03 V@26@03))
    (<= 0 i1@249@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
      ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
    (< i2@250@03 V@26@03)
    (<= 0 i2@250@03)
    (< i1@249@03 V@26@03)
    (<= 0 i1@249@03))))
; Joined path conditions
(pop) ; 20
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@250@03 Int)) (!
  (and
    (implies
      (<= 0 i1@249@03)
      (and
        (<= 0 i1@249@03)
        (implies
          (< i1@249@03 V@26@03)
          (and
            (< i1@249@03 V@26@03)
            (implies
              (<= 0 i2@250@03)
              (and
                (<= 0 i2@250@03)
                (implies
                  (< i2@250@03 V@26@03)
                  (and
                    (< i2@250@03 V@26@03)
                    (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                    (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
              (< i2@250@03 V@26@03))
            (<= 0 i2@250@03))
          (< i1@249@03 V@26@03))
        (<= 0 i1@249@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
          ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
        (< i2@250@03 V@26@03)
        (<= 0 i2@250@03)
        (< i1@249@03 V@26@03)
        (<= 0 i1@249@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@249@03 Int)) (!
  (forall ((i2@250@03 Int)) (!
    (and
      (implies
        (<= 0 i1@249@03)
        (and
          (<= 0 i1@249@03)
          (implies
            (< i1@249@03 V@26@03)
            (and
              (< i1@249@03 V@26@03)
              (implies
                (<= 0 i2@250@03)
                (and
                  (<= 0 i2@250@03)
                  (implies
                    (< i2@250@03 V@26@03)
                    (and
                      (< i2@250@03 V@26@03)
                      (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                      (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                  ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
                (< i2@250@03 V@26@03))
              (<= 0 i2@250@03))
            (< i1@249@03 V@26@03))
          (<= 0 i1@249@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
            ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
          (< i2@250@03 V@26@03)
          (<= 0 i2@250@03)
          (< i1@249@03 V@26@03)
          (<= 0 i1@249@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@249@03 Int)) (!
    (forall ((i2@250@03 Int)) (!
      (and
        (implies
          (<= 0 i1@249@03)
          (and
            (<= 0 i1@249@03)
            (implies
              (< i1@249@03 V@26@03)
              (and
                (< i1@249@03 V@26@03)
                (implies
                  (<= 0 i2@250@03)
                  (and
                    (<= 0 i2@250@03)
                    (implies
                      (< i2@250@03 V@26@03)
                      (and
                        (< i2@250@03 V@26@03)
                        (< i1@249@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                        (< i2@250@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                    ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
                  (< i2@250@03 V@26@03))
                (<= 0 i2@250@03))
              (< i1@249@03 V@26@03))
            (<= 0 i1@249@03))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
              ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
            (< i2@250@03 V@26@03)
            (<= 0 i2@250@03)
            (< i1@249@03 V@26@03)
            (<= 0 i1@249@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@249@03 Int)) (!
    (forall ((i2@250@03 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
                  ($FVF.lookup_option$array$ (as sm@246@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03)))
                (< i2@250@03 V@26@03))
              (<= 0 i2@250@03))
            (< i1@249@03 V@26@03))
          (<= 0 i1@249@03))
        (= i1@249@03 i2@250@03))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i2@250@03))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@249@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))
  $Snap.unit))
; [eval] exc == null ==> G != (None(): option[array])
; [eval] exc == null
(push) ; 17
(set-option :timeout 10)
(push) ; 18
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124535
;  :arith-add-rows          71560
;  :arith-assert-diseq      8268
;  :arith-assert-lower      37559
;  :arith-assert-upper      25009
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22698
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13385
;  :conflicts               2516
;  :datatype-accessor-ax    298
;  :datatype-constructor-ax 1715
;  :datatype-occurs-check   850
;  :datatype-splits         1163
;  :decisions               20397
;  :del-clause              190641
;  :final-checks            314
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.97
;  :minimized-lits          577
;  :mk-bool-var             229478
;  :mk-clause               190690
;  :num-allocs              1144984
;  :num-checks              386
;  :propagations            95620
;  :quant-instantiations    53843
;  :restarts                2
;  :rlimit-count            4863092
;  :time                    0.00)
; [then-branch: 244 | exc@240@03 == Null | live]
; [else-branch: 244 | exc@240@03 != Null | dead]
(push) ; 18
; [then-branch: 244 | exc@240@03 == Null]
; [eval] G != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (not (= G@23@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(G)) == V
; [eval] exc == null
(push) ; 17
(push) ; 18
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124629
;  :arith-add-rows          71560
;  :arith-assert-diseq      8268
;  :arith-assert-lower      37559
;  :arith-assert-upper      25009
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22698
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13385
;  :conflicts               2516
;  :datatype-accessor-ax    299
;  :datatype-constructor-ax 1731
;  :datatype-occurs-check   861
;  :datatype-splits         1175
;  :decisions               20413
;  :del-clause              190641
;  :final-checks            316
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.97
;  :minimized-lits          577
;  :mk-bool-var             229492
;  :mk-clause               190690
;  :num-allocs              1145996
;  :num-checks              387
;  :propagations            95620
;  :quant-instantiations    53843
;  :restarts                2
;  :rlimit-count            4864454
;  :time                    0.00)
; [then-branch: 245 | exc@240@03 == Null | live]
; [else-branch: 245 | exc@240@03 != Null | dead]
(push) ; 18
; [then-branch: 245 | exc@240@03 == Null]
; [eval] alen(opt_get1(G)) == V
; [eval] alen(opt_get1(G))
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit G@23@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))
; [eval] exc == null
(push) ; 17
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124725
;  :arith-add-rows          71560
;  :arith-assert-diseq      8268
;  :arith-assert-lower      37559
;  :arith-assert-upper      25009
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22698
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13385
;  :conflicts               2516
;  :datatype-accessor-ax    300
;  :datatype-constructor-ax 1748
;  :datatype-occurs-check   872
;  :datatype-splits         1188
;  :decisions               20430
;  :del-clause              190641
;  :final-checks            318
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.97
;  :minimized-lits          577
;  :mk-bool-var             229506
;  :mk-clause               190690
;  :num-allocs              1147003
;  :num-checks              388
;  :propagations            95620
;  :quant-instantiations    53843
;  :restarts                2
;  :rlimit-count            4865808)
; [then-branch: 246 | exc@240@03 == Null | live]
; [else-branch: 246 | exc@240@03 != Null | dead]
(push) ; 17
; [then-branch: 246 | exc@240@03 == Null]
(declare-const i1@251@03 Int)
(push) ; 18
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 19
; [then-branch: 247 | 0 <= i1@251@03 | live]
; [else-branch: 247 | !(0 <= i1@251@03) | live]
(push) ; 20
; [then-branch: 247 | 0 <= i1@251@03]
(assert (<= 0 i1@251@03))
; [eval] i1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 247 | !(0 <= i1@251@03)]
(assert (not (<= 0 i1@251@03)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(assert (and (< i1@251@03 V@26@03) (<= 0 i1@251@03)))
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@251@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124725
;  :arith-add-rows          71561
;  :arith-assert-diseq      8268
;  :arith-assert-lower      37561
;  :arith-assert-upper      25009
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22698
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13385
;  :conflicts               2516
;  :datatype-accessor-ax    300
;  :datatype-constructor-ax 1748
;  :datatype-occurs-check   872
;  :datatype-splits         1188
;  :decisions               20430
;  :del-clause              190641
;  :final-checks            318
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.97
;  :minimized-lits          577
;  :mk-bool-var             229508
;  :mk-clause               190690
;  :num-allocs              1147106
;  :num-checks              389
;  :propagations            95620
;  :quant-instantiations    53843
;  :restarts                2
;  :rlimit-count            4865994)
(assert (< i1@251@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 19
; Joined path conditions
(assert (< i1@251@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(declare-const $k@252@03 $Perm)
(assert ($Perm.isReadVar $k@252@03 $Perm.Write))
(pop) ; 18
(declare-fun inv@253@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@252@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@251@03 Int)) (!
  (< i1@251@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@251@03))
  :qid |option$array$-aux|)))
(push) ; 18
(assert (not (forall ((i1@251@03 Int)) (!
  (implies
    (and (< i1@251@03 V@26@03) (<= 0 i1@251@03))
    (or (= $k@252@03 $Perm.No) (< $Perm.No $k@252@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124725
;  :arith-add-rows          71562
;  :arith-assert-diseq      8269
;  :arith-assert-lower      37563
;  :arith-assert-upper      25010
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22699
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13385
;  :conflicts               2517
;  :datatype-accessor-ax    300
;  :datatype-constructor-ax 1748
;  :datatype-occurs-check   872
;  :datatype-splits         1188
;  :decisions               20430
;  :del-clause              190641
;  :final-checks            318
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.97
;  :minimized-lits          577
;  :mk-bool-var             229515
;  :mk-clause               190692
;  :num-allocs              1147574
;  :num-checks              390
;  :propagations            95621
;  :quant-instantiations    53843
;  :restarts                2
;  :rlimit-count            4866565)
; Check receiver injectivity
(push) ; 18
(assert (not (forall ((i11@251@03 Int) (i12@251@03 Int)) (!
  (implies
    (and
      (and (and (< i11@251@03 V@26@03) (<= 0 i11@251@03)) (< $Perm.No $k@252@03))
      (and (and (< i12@251@03 V@26@03) (<= 0 i12@251@03)) (< $Perm.No $k@252@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@251@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@251@03)))
    (= i11@251@03 i12@251@03))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124738
;  :arith-add-rows          71566
;  :arith-assert-diseq      8270
;  :arith-assert-lower      37567
;  :arith-assert-upper      25010
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22700
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13385
;  :conflicts               2518
;  :datatype-accessor-ax    300
;  :datatype-constructor-ax 1748
;  :datatype-occurs-check   872
;  :datatype-splits         1188
;  :decisions               20430
;  :del-clause              190647
;  :final-checks            318
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.96
;  :minimized-lits          577
;  :mk-bool-var             229538
;  :mk-clause               190698
;  :num-allocs              1147974
;  :num-checks              391
;  :propagations            95621
;  :quant-instantiations    53866
;  :restarts                2
;  :rlimit-count            4867472)
; Definitional axioms for inverse functions
(assert (forall ((i1@251@03 Int)) (!
  (implies
    (and (and (< i1@251@03 V@26@03) (<= 0 i1@251@03)) (< $Perm.No $k@252@03))
    (=
      (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@251@03))
      i1@251@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@251@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@253@03 r) V@26@03) (<= 0 (inv@253@03 r)))
      (< $Perm.No $k@252@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@253@03 r))
      r))
  :pattern ((inv@253@03 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@251@03 Int)) (!
  (<= $Perm.No $k@252@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@251@03))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@251@03 Int)) (!
  (<= $k@252@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@251@03))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@251@03 Int)) (!
  (implies
    (and (and (< i1@251@03 V@26@03) (<= 0 i1@251@03)) (< $Perm.No $k@252@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@251@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@251@03))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@254@03 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@253@03 r) V@26@03) (<= 0 (inv@253@03 r)))
      (< $Perm.No $k@252@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))) r))
  :qid |qp.fvfValDef99|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@245@03 r) V@26@03) (<= 0 (inv@245@03 r)))
      (< $Perm.No $k@244@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@242@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@242@03))))) r))
  :qid |qp.fvfValDef100|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and (< (inv@32@03 r) V@26@03) (<= 0 (inv@32@03 r)))
              $k@31@03
              $Perm.No)
            (pTaken@94@03 r))
          (pTaken@103@03 r))
        (pTaken@192@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@77@03 r) V@26@03) (<= 0 (inv@77@03 r)))
            $Perm.Write
            $Perm.No)
          (pTaken@93@03 r))
        (pTaken@104@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r))
  :qid |qp.fvfValDef102|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@128@03 r) V@26@03) (<= 0 (inv@128@03 r)))
      (< $Perm.No $k@127@03)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r))
  :qid |qp.fvfValDef103|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@136@03 r) V@26@03) (<= 0 (inv@136@03 r)))
          $k@135@03
          $Perm.No)
        (pTaken@180@03 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r))
  :qid |qp.fvfValDef104|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@242@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@75@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@125@03))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef105|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@253@03 r) V@26@03) (<= 0 (inv@253@03 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) r) r))
  :pattern ((inv@253@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 18
(set-option :timeout 10)
(push) ; 19
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124837
;  :arith-add-rows          71566
;  :arith-assert-diseq      8270
;  :arith-assert-lower      37567
;  :arith-assert-upper      25011
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22700
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13385
;  :conflicts               2518
;  :datatype-accessor-ax    301
;  :datatype-constructor-ax 1765
;  :datatype-occurs-check   883
;  :datatype-splits         1201
;  :decisions               20447
;  :del-clause              190647
;  :final-checks            320
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.97
;  :minimized-lits          577
;  :mk-bool-var             229565
;  :mk-clause               190698
;  :num-allocs              1151453
;  :num-checks              392
;  :propagations            95621
;  :quant-instantiations    53866
;  :restarts                2
;  :rlimit-count            4877026)
; [then-branch: 248 | exc@240@03 == Null | live]
; [else-branch: 248 | exc@240@03 != Null | dead]
(push) ; 19
; [then-branch: 248 | exc@240@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array]))
(declare-const i1@255@03 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 249 | 0 <= i1@255@03 | live]
; [else-branch: 249 | !(0 <= i1@255@03) | live]
(push) ; 22
; [then-branch: 249 | 0 <= i1@255@03]
(assert (<= 0 i1@255@03))
; [eval] i1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 249 | !(0 <= i1@255@03)]
(assert (not (<= 0 i1@255@03)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(push) ; 21
; [then-branch: 250 | i1@255@03 < V@26@03 && 0 <= i1@255@03 | live]
; [else-branch: 250 | !(i1@255@03 < V@26@03 && 0 <= i1@255@03) | live]
(push) ; 22
; [then-branch: 250 | i1@255@03 < V@26@03 && 0 <= i1@255@03]
(assert (and (< i1@255@03 V@26@03) (<= 0 i1@255@03)))
; [eval] aloc(opt_get1(G), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               124837
;  :arith-add-rows          71567
;  :arith-assert-diseq      8270
;  :arith-assert-lower      37569
;  :arith-assert-upper      25011
;  :arith-bound-prop        7356
;  :arith-conflicts         1111
;  :arith-eq-adapter        22700
;  :arith-fixed-eqs         13708
;  :arith-offset-eqs        16270
;  :arith-pivots            13385
;  :conflicts               2518
;  :datatype-accessor-ax    301
;  :datatype-constructor-ax 1765
;  :datatype-occurs-check   883
;  :datatype-splits         1201
;  :decisions               20447
;  :del-clause              190647
;  :final-checks            320
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              18.16
;  :memory                  17.97
;  :minimized-lits          577
;  :mk-bool-var             229567
;  :mk-clause               190698
;  :num-allocs              1151556
;  :num-checks              393
;  :propagations            95621
;  :quant-instantiations    53866
;  :restarts                2
;  :rlimit-count            4877222)
(assert (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 23
; Joined path conditions
(assert (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (+
            (ite
              (and
                (<
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
                  V@26@03)
                (<=
                  0
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
              $k@252@03
              $Perm.No)
            (ite
              (and
                (<
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
                  V@26@03)
                (<=
                  0
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
              $k@244@03
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               126310
;  :arith-add-rows          73043
;  :arith-assert-diseq      8403
;  :arith-assert-lower      38107
;  :arith-assert-upper      25325
;  :arith-bound-prop        7538
;  :arith-conflicts         1128
;  :arith-eq-adapter        23064
;  :arith-fixed-eqs         13882
;  :arith-offset-eqs        16518
;  :arith-pivots            13593
;  :conflicts               2566
;  :datatype-accessor-ax    301
;  :datatype-constructor-ax 1769
;  :datatype-occurs-check   883
;  :datatype-splits         1201
;  :decisions               20666
;  :del-clause              193191
;  :final-checks            320
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.33
;  :minimized-lits          586
;  :mk-bool-var             233039
;  :mk-clause               193551
;  :num-allocs              1162713
;  :num-checks              394
;  :propagations            96967
;  :quant-instantiations    54355
;  :restarts                2
;  :rlimit-count            4946270
;  :time                    0.02)
; [eval] (None(): option[array])
(pop) ; 22
(push) ; 22
; [else-branch: 250 | !(i1@255@03 < V@26@03 && 0 <= i1@255@03)]
(assert (not (and (< i1@255@03 V@26@03) (<= 0 i1@255@03))))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (and (< i1@255@03 V@26@03) (<= 0 i1@255@03))
  (and
    (< i1@255@03 V@26@03)
    (<= 0 i1@255@03)
    (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)))))
; Joined path conditions
(pop) ; 20
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@255@03 Int)) (!
  (implies
    (and (< i1@255@03 V@26@03) (<= 0 i1@255@03))
    (and
      (< i1@255@03 V@26@03)
      (<= 0 i1@255@03)
      (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@255@03 Int)) (!
    (implies
      (and (< i1@255@03 V@26@03) (<= 0 i1@255@03))
      (and
        (< i1@255@03 V@26@03)
        (<= 0 i1@255@03)
        (< i1@255@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@255@03 Int)) (!
    (implies
      (and (< i1@255@03 V@26@03) (<= 0 i1@255@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@255@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 18
(set-option :timeout 10)
(push) ; 19
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               126410
;  :arith-add-rows          73067
;  :arith-assert-diseq      8403
;  :arith-assert-lower      38107
;  :arith-assert-upper      25325
;  :arith-bound-prop        7538
;  :arith-conflicts         1128
;  :arith-eq-adapter        23064
;  :arith-fixed-eqs         13882
;  :arith-offset-eqs        16518
;  :arith-pivots            13621
;  :conflicts               2566
;  :datatype-accessor-ax    302
;  :datatype-constructor-ax 1786
;  :datatype-occurs-check   894
;  :datatype-splits         1214
;  :decisions               20683
;  :del-clause              193500
;  :final-checks            322
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.30
;  :minimized-lits          586
;  :mk-bool-var             233056
;  :mk-clause               193551
;  :num-allocs              1164089
;  :num-checks              395
;  :propagations            96967
;  :quant-instantiations    54355
;  :restarts                2
;  :rlimit-count            4949060
;  :time                    0.00)
; [then-branch: 251 | exc@240@03 == Null | live]
; [else-branch: 251 | exc@240@03 != Null | dead]
(push) ; 19
; [then-branch: 251 | exc@240@03 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V)
(declare-const i1@256@03 Int)
(push) ; 20
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 21
; [then-branch: 252 | 0 <= i1@256@03 | live]
; [else-branch: 252 | !(0 <= i1@256@03) | live]
(push) ; 22
; [then-branch: 252 | 0 <= i1@256@03]
(assert (<= 0 i1@256@03))
; [eval] i1 < V
(pop) ; 22
(push) ; 22
; [else-branch: 252 | !(0 <= i1@256@03)]
(assert (not (<= 0 i1@256@03)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
; Joined path conditions
(push) ; 21
; [then-branch: 253 | i1@256@03 < V@26@03 && 0 <= i1@256@03 | live]
; [else-branch: 253 | !(i1@256@03 < V@26@03 && 0 <= i1@256@03) | live]
(push) ; 22
; [then-branch: 253 | i1@256@03 < V@26@03 && 0 <= i1@256@03]
(assert (and (< i1@256@03 V@26@03) (<= 0 i1@256@03)))
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(G), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@256@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               126410
;  :arith-add-rows          73068
;  :arith-assert-diseq      8403
;  :arith-assert-lower      38109
;  :arith-assert-upper      25325
;  :arith-bound-prop        7538
;  :arith-conflicts         1128
;  :arith-eq-adapter        23064
;  :arith-fixed-eqs         13882
;  :arith-offset-eqs        16518
;  :arith-pivots            13621
;  :conflicts               2566
;  :datatype-accessor-ax    302
;  :datatype-constructor-ax 1786
;  :datatype-occurs-check   894
;  :datatype-splits         1214
;  :decisions               20683
;  :del-clause              193500
;  :final-checks            322
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.30
;  :minimized-lits          586
;  :mk-bool-var             233058
;  :mk-clause               193551
;  :num-allocs              1164193
;  :num-checks              396
;  :propagations            96967
;  :quant-instantiations    54355
;  :restarts                2
;  :rlimit-count            4949254)
(assert (< i1@256@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 23
; Joined path conditions
(assert (< i1@256@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (+
            (ite
              (and
                (<
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
                  V@26@03)
                (<=
                  0
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
              $k@252@03
              $Perm.No)
            (ite
              (and
                (<
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
                  V@26@03)
                (<=
                  0
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
              $k@244@03
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128328
;  :arith-add-rows          74981
;  :arith-assert-diseq      8575
;  :arith-assert-lower      38779
;  :arith-assert-upper      25764
;  :arith-bound-prop        7695
;  :arith-conflicts         1154
;  :arith-eq-adapter        23495
;  :arith-fixed-eqs         14141
;  :arith-offset-eqs        16804
;  :arith-pivots            13843
;  :conflicts               2615
;  :datatype-accessor-ax    302
;  :datatype-constructor-ax 1790
;  :datatype-occurs-check   894
;  :datatype-splits         1214
;  :decisions               20929
;  :del-clause              196027
;  :final-checks            322
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.35
;  :minimized-lits          594
;  :mk-bool-var             236414
;  :mk-clause               196387
;  :num-allocs              1175868
;  :num-checks              397
;  :propagations            98568
;  :quant-instantiations    55091
;  :restarts                2
;  :rlimit-count            5042300
;  :time                    0.03)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 24
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128328
;  :arith-add-rows          74981
;  :arith-assert-diseq      8575
;  :arith-assert-lower      38779
;  :arith-assert-upper      25764
;  :arith-bound-prop        7695
;  :arith-conflicts         1154
;  :arith-eq-adapter        23495
;  :arith-fixed-eqs         14141
;  :arith-offset-eqs        16804
;  :arith-pivots            13843
;  :conflicts               2616
;  :datatype-accessor-ax    302
;  :datatype-constructor-ax 1790
;  :datatype-occurs-check   894
;  :datatype-splits         1214
;  :decisions               20929
;  :del-clause              196027
;  :final-checks            322
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.35
;  :minimized-lits          594
;  :mk-bool-var             236414
;  :mk-clause               196387
;  :num-allocs              1175959
;  :num-checks              398
;  :propagations            98568
;  :quant-instantiations    55091
;  :restarts                2
;  :rlimit-count            5042395)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
    (as None<option<array>>  option<array>))))
(pop) ; 23
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
    (as None<option<array>>  option<array>))))
(pop) ; 22
(push) ; 22
; [else-branch: 253 | !(i1@256@03 < V@26@03 && 0 <= i1@256@03)]
(assert (not (and (< i1@256@03 V@26@03) (<= 0 i1@256@03))))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (and (< i1@256@03 V@26@03) (<= 0 i1@256@03))
  (and
    (< i1@256@03 V@26@03)
    (<= 0 i1@256@03)
    (< i1@256@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 20
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@256@03 Int)) (!
  (implies
    (and (< i1@256@03 V@26@03) (<= 0 i1@256@03))
    (and
      (< i1@256@03 V@26@03)
      (<= 0 i1@256@03)
      (< i1@256@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@256@03 Int)) (!
    (implies
      (and (< i1@256@03 V@26@03) (<= 0 i1@256@03))
      (and
        (< i1@256@03 V@26@03)
        (<= 0 i1@256@03)
        (< i1@256@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@256@03 Int)) (!
    (implies
      (and (< i1@256@03 V@26@03) (<= 0 i1@256@03))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03))))
        V@26@03))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@256@03)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 18
(set-option :timeout 10)
(push) ; 19
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128429
;  :arith-add-rows          75022
;  :arith-assert-diseq      8575
;  :arith-assert-lower      38779
;  :arith-assert-upper      25764
;  :arith-bound-prop        7695
;  :arith-conflicts         1154
;  :arith-eq-adapter        23495
;  :arith-fixed-eqs         14141
;  :arith-offset-eqs        16804
;  :arith-pivots            13874
;  :conflicts               2616
;  :datatype-accessor-ax    303
;  :datatype-constructor-ax 1807
;  :datatype-occurs-check   905
;  :datatype-splits         1227
;  :decisions               20946
;  :del-clause              196336
;  :final-checks            324
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.32
;  :minimized-lits          594
;  :mk-bool-var             236431
;  :mk-clause               196387
;  :num-allocs              1177342
;  :num-checks              399
;  :propagations            98568
;  :quant-instantiations    55091
;  :restarts                2
;  :rlimit-count            5045577
;  :time                    0.00)
; [then-branch: 254 | exc@240@03 == Null | live]
; [else-branch: 254 | exc@240@03 != Null | dead]
(push) ; 19
; [then-branch: 254 | exc@240@03 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(G), i1) } (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2))
(declare-const i1@257@03 Int)
(push) ; 20
; [eval] (forall i2: Int :: { aloc(opt_get1(G), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2)
(declare-const i2@258@03 Int)
(push) ; 21
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] 0 <= i1
(push) ; 22
; [then-branch: 255 | 0 <= i1@257@03 | live]
; [else-branch: 255 | !(0 <= i1@257@03) | live]
(push) ; 23
; [then-branch: 255 | 0 <= i1@257@03]
(assert (<= 0 i1@257@03))
; [eval] i1 < V
(push) ; 24
; [then-branch: 256 | i1@257@03 < V@26@03 | live]
; [else-branch: 256 | !(i1@257@03 < V@26@03) | live]
(push) ; 25
; [then-branch: 256 | i1@257@03 < V@26@03]
(assert (< i1@257@03 V@26@03))
; [eval] 0 <= i2
(push) ; 26
; [then-branch: 257 | 0 <= i2@258@03 | live]
; [else-branch: 257 | !(0 <= i2@258@03) | live]
(push) ; 27
; [then-branch: 257 | 0 <= i2@258@03]
(assert (<= 0 i2@258@03))
; [eval] i2 < V
(push) ; 28
; [then-branch: 258 | i2@258@03 < V@26@03 | live]
; [else-branch: 258 | !(i2@258@03 < V@26@03) | live]
(push) ; 29
; [then-branch: 258 | i2@258@03 < V@26@03]
(assert (< i2@258@03 V@26@03))
; [eval] aloc(opt_get1(G), i1).option$array$ == aloc(opt_get1(G), i2).option$array$
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 30
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 30
; Joined path conditions
(push) ; 30
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 31
(assert (not (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               128429
;  :arith-add-rows          75024
;  :arith-assert-diseq      8575
;  :arith-assert-lower      38783
;  :arith-assert-upper      25764
;  :arith-bound-prop        7695
;  :arith-conflicts         1154
;  :arith-eq-adapter        23495
;  :arith-fixed-eqs         14141
;  :arith-offset-eqs        16804
;  :arith-pivots            13874
;  :conflicts               2616
;  :datatype-accessor-ax    303
;  :datatype-constructor-ax 1807
;  :datatype-occurs-check   905
;  :datatype-splits         1227
;  :decisions               20946
;  :del-clause              196336
;  :final-checks            324
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.32
;  :minimized-lits          594
;  :mk-bool-var             236435
;  :mk-clause               196387
;  :num-allocs              1177623
;  :num-checks              400
;  :propagations            98568
;  :quant-instantiations    55091
;  :restarts                2
;  :rlimit-count            5045918)
(assert (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 30
; Joined path conditions
(assert (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)))
(push) ; 30
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (+
            (ite
              (and
                (<
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                  V@26@03)
                (<=
                  0
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))))
              $k@252@03
              $Perm.No)
            (ite
              (and
                (<
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                  V@26@03)
                (<=
                  0
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))))
              $k@244@03
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)))))))
(check-sat)
; unsat
(pop) ; 30
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               130342
;  :arith-add-rows          76293
;  :arith-assert-diseq      8703
;  :arith-assert-lower      39342
;  :arith-assert-upper      26095
;  :arith-bound-prop        7835
;  :arith-conflicts         1174
;  :arith-eq-adapter        23858
;  :arith-fixed-eqs         14321
;  :arith-offset-eqs        16979
;  :arith-pivots            14069
;  :conflicts               2661
;  :datatype-accessor-ax    303
;  :datatype-constructor-ax 1811
;  :datatype-occurs-check   905
;  :datatype-splits         1227
;  :decisions               21176
;  :del-clause              200410
;  :final-checks            324
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.40
;  :minimized-lits          597
;  :mk-bool-var             240533
;  :mk-clause               200770
;  :num-allocs              1191477
;  :num-checks              401
;  :propagations            100536
;  :quant-instantiations    56208
;  :restarts                2
;  :rlimit-count            5151944
;  :time                    0.04)
; [eval] aloc(opt_get1(G), i2)
; [eval] opt_get1(G)
(push) ; 30
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 30
; Joined path conditions
(push) ; 30
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 31
(assert (not (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 31
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               130342
;  :arith-add-rows          76293
;  :arith-assert-diseq      8703
;  :arith-assert-lower      39342
;  :arith-assert-upper      26095
;  :arith-bound-prop        7835
;  :arith-conflicts         1174
;  :arith-eq-adapter        23858
;  :arith-fixed-eqs         14321
;  :arith-offset-eqs        16979
;  :arith-pivots            14069
;  :conflicts               2661
;  :datatype-accessor-ax    303
;  :datatype-constructor-ax 1811
;  :datatype-occurs-check   905
;  :datatype-splits         1227
;  :decisions               21176
;  :del-clause              200410
;  :final-checks            324
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.40
;  :minimized-lits          597
;  :mk-bool-var             240533
;  :mk-clause               200770
;  :num-allocs              1191504
;  :num-checks              402
;  :propagations            100536
;  :quant-instantiations    56208
;  :restarts                2
;  :rlimit-count            5151974)
(assert (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 30
; Joined path conditions
(assert (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
(push) ; 30
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (+
            (ite
              (and
                (<
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
                  V@26@03)
                (<=
                  0
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))
              $k@252@03
              $Perm.No)
            (ite
              (and
                (<
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
                  V@26@03)
                (<=
                  0
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))
              $k@244@03
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))))))
(check-sat)
; unsat
(pop) ; 30
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               135802
;  :arith-add-rows          80124
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41287
;  :arith-assert-upper      27224
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24972
;  :arith-fixed-eqs         14968
;  :arith-offset-eqs        17892
;  :arith-pivots            14466
;  :conflicts               2746
;  :datatype-accessor-ax    303
;  :datatype-constructor-ax 1815
;  :datatype-occurs-check   905
;  :datatype-splits         1227
;  :decisions               21685
;  :del-clause              207434
;  :final-checks            324
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.67
;  :minimized-lits          622
;  :mk-bool-var             248842
;  :mk-clause               208051
;  :num-allocs              1219532
;  :num-checks              403
;  :propagations            105909
;  :quant-instantiations    58566
;  :restarts                2
;  :rlimit-count            5374943
;  :time                    0.09)
(pop) ; 29
(push) ; 29
; [else-branch: 258 | !(i2@258@03 < V@26@03)]
(assert (not (< i2@258@03 V@26@03)))
(pop) ; 29
(pop) ; 28
; Joined path conditions
(assert (implies
  (< i2@258@03 V@26@03)
  (and
    (< i2@258@03 V@26@03)
    (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
    (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))))
; Joined path conditions
(pop) ; 27
(push) ; 27
; [else-branch: 257 | !(0 <= i2@258@03)]
(assert (not (<= 0 i2@258@03)))
(pop) ; 27
(pop) ; 26
; Joined path conditions
(assert (implies
  (<= 0 i2@258@03)
  (and
    (<= 0 i2@258@03)
    (implies
      (< i2@258@03 V@26@03)
      (and
        (< i2@258@03 V@26@03)
        (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
        (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))))))
; Joined path conditions
(pop) ; 25
(push) ; 25
; [else-branch: 256 | !(i1@257@03 < V@26@03)]
(assert (not (< i1@257@03 V@26@03)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
(assert (implies
  (< i1@257@03 V@26@03)
  (and
    (< i1@257@03 V@26@03)
    (implies
      (<= 0 i2@258@03)
      (and
        (<= 0 i2@258@03)
        (implies
          (< i2@258@03 V@26@03)
          (and
            (< i2@258@03 V@26@03)
            (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
            (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))))))))
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 255 | !(0 <= i1@257@03)]
(assert (not (<= 0 i1@257@03)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (<= 0 i1@257@03)
  (and
    (<= 0 i1@257@03)
    (implies
      (< i1@257@03 V@26@03)
      (and
        (< i1@257@03 V@26@03)
        (implies
          (<= 0 i2@258@03)
          (and
            (<= 0 i2@258@03)
            (implies
              (< i2@258@03 V@26@03)
              (and
                (< i2@258@03 V@26@03)
                (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))))))))))
; Joined path conditions
(push) ; 22
; [then-branch: 259 | Lookup(option$array$,sm@254@03,aloc((_, _), opt_get1(_, G@23@03), i1@257@03)) == Lookup(option$array$,sm@254@03,aloc((_, _), opt_get1(_, G@23@03), i2@258@03)) && i2@258@03 < V@26@03 && 0 <= i2@258@03 && i1@257@03 < V@26@03 && 0 <= i1@257@03 | live]
; [else-branch: 259 | !(Lookup(option$array$,sm@254@03,aloc((_, _), opt_get1(_, G@23@03), i1@257@03)) == Lookup(option$array$,sm@254@03,aloc((_, _), opt_get1(_, G@23@03), i2@258@03)) && i2@258@03 < V@26@03 && 0 <= i2@258@03 && i1@257@03 < V@26@03 && 0 <= i1@257@03) | live]
(push) ; 23
; [then-branch: 259 | Lookup(option$array$,sm@254@03,aloc((_, _), opt_get1(_, G@23@03), i1@257@03)) == Lookup(option$array$,sm@254@03,aloc((_, _), opt_get1(_, G@23@03), i2@258@03)) && i2@258@03 < V@26@03 && 0 <= i2@258@03 && i1@257@03 < V@26@03 && 0 <= i1@257@03]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
          ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
        (< i2@258@03 V@26@03))
      (<= 0 i2@258@03))
    (< i1@257@03 V@26@03))
  (<= 0 i1@257@03)))
; [eval] i1 == i2
(pop) ; 23
(push) ; 23
; [else-branch: 259 | !(Lookup(option$array$,sm@254@03,aloc((_, _), opt_get1(_, G@23@03), i1@257@03)) == Lookup(option$array$,sm@254@03,aloc((_, _), opt_get1(_, G@23@03), i2@258@03)) && i2@258@03 < V@26@03 && 0 <= i2@258@03 && i1@257@03 < V@26@03 && 0 <= i1@257@03)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
            ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
          (< i2@258@03 V@26@03))
        (<= 0 i2@258@03))
      (< i1@257@03 V@26@03))
    (<= 0 i1@257@03))))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
            ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
          (< i2@258@03 V@26@03))
        (<= 0 i2@258@03))
      (< i1@257@03 V@26@03))
    (<= 0 i1@257@03))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
      ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
    (< i2@258@03 V@26@03)
    (<= 0 i2@258@03)
    (< i1@257@03 V@26@03)
    (<= 0 i1@257@03))))
; Joined path conditions
(pop) ; 21
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@258@03 Int)) (!
  (and
    (implies
      (<= 0 i1@257@03)
      (and
        (<= 0 i1@257@03)
        (implies
          (< i1@257@03 V@26@03)
          (and
            (< i1@257@03 V@26@03)
            (implies
              (<= 0 i2@258@03)
              (and
                (<= 0 i2@258@03)
                (implies
                  (< i2@258@03 V@26@03)
                  (and
                    (< i2@258@03 V@26@03)
                    (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                    (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
              (< i2@258@03 V@26@03))
            (<= 0 i2@258@03))
          (< i1@257@03 V@26@03))
        (<= 0 i1@257@03))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
          ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
        (< i2@258@03 V@26@03)
        (<= 0 i2@258@03)
        (< i1@257@03 V@26@03)
        (<= 0 i1@257@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 20
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@257@03 Int)) (!
  (forall ((i2@258@03 Int)) (!
    (and
      (implies
        (<= 0 i1@257@03)
        (and
          (<= 0 i1@257@03)
          (implies
            (< i1@257@03 V@26@03)
            (and
              (< i1@257@03 V@26@03)
              (implies
                (<= 0 i2@258@03)
                (and
                  (<= 0 i2@258@03)
                  (implies
                    (< i2@258@03 V@26@03)
                    (and
                      (< i2@258@03 V@26@03)
                      (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                      (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                  ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
                (< i2@258@03 V@26@03))
              (<= 0 i2@258@03))
            (< i1@257@03 V@26@03))
          (<= 0 i1@257@03))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
            ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
          (< i2@258@03 V@26@03)
          (<= 0 i2@258@03)
          (< i1@257@03 V@26@03)
          (<= 0 i1@257@03))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@257@03 Int)) (!
    (forall ((i2@258@03 Int)) (!
      (and
        (implies
          (<= 0 i1@257@03)
          (and
            (<= 0 i1@257@03)
            (implies
              (< i1@257@03 V@26@03)
              (and
                (< i1@257@03 V@26@03)
                (implies
                  (<= 0 i2@258@03)
                  (and
                    (<= 0 i2@258@03)
                    (implies
                      (< i2@258@03 V@26@03)
                      (and
                        (< i2@258@03 V@26@03)
                        (< i1@257@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                        (< i2@258@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
                  (< i2@258@03 V@26@03))
                (<= 0 i2@258@03))
              (< i1@257@03 V@26@03))
            (<= 0 i1@257@03))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
              ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
            (< i2@258@03 V@26@03)
            (<= 0 i2@258@03)
            (< i1@257@03 V@26@03)
            (<= 0 i1@257@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@257@03 Int)) (!
    (forall ((i2@258@03 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
                  ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03)))
                (< i2@258@03 V@26@03))
              (<= 0 i2@258@03))
            (< i1@257@03 V@26@03))
          (<= 0 i1@257@03))
        (= i1@257@03 i2@258@03))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i2@258@03))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@257@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> P != (None(): option[array])
; [eval] exc == null
(push) ; 18
(set-option :timeout 10)
(push) ; 19
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               135904
;  :arith-add-rows          80355
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41287
;  :arith-assert-upper      27224
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24972
;  :arith-fixed-eqs         14968
;  :arith-offset-eqs        17892
;  :arith-pivots            14529
;  :conflicts               2746
;  :datatype-accessor-ax    304
;  :datatype-constructor-ax 1832
;  :datatype-occurs-check   916
;  :datatype-splits         1240
;  :decisions               21702
;  :del-clause              208024
;  :final-checks            326
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.59
;  :minimized-lits          622
;  :mk-bool-var             248872
;  :mk-clause               208075
;  :num-allocs              1221506
;  :num-checks              404
;  :propagations            105909
;  :quant-instantiations    58566
;  :restarts                2
;  :rlimit-count            5383394
;  :time                    0.00)
; [then-branch: 260 | exc@240@03 == Null | live]
; [else-branch: 260 | exc@240@03 != Null | dead]
(push) ; 19
; [then-branch: 260 | exc@240@03 == Null]
; [eval] P != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (not (= res@156@03 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(P)) == V
; [eval] exc == null
(push) ; 18
(push) ; 19
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136007
;  :arith-add-rows          80355
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41287
;  :arith-assert-upper      27224
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24972
;  :arith-fixed-eqs         14968
;  :arith-offset-eqs        17892
;  :arith-pivots            14529
;  :conflicts               2746
;  :datatype-accessor-ax    305
;  :datatype-constructor-ax 1849
;  :datatype-occurs-check   927
;  :datatype-splits         1253
;  :decisions               21719
;  :del-clause              208024
;  :final-checks            328
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.59
;  :minimized-lits          622
;  :mk-bool-var             248887
;  :mk-clause               208075
;  :num-allocs              1222515
;  :num-checks              405
;  :propagations            105909
;  :quant-instantiations    58566
;  :restarts                2
;  :rlimit-count            5384868)
; [then-branch: 261 | exc@240@03 == Null | live]
; [else-branch: 261 | exc@240@03 != Null | dead]
(push) ; 19
; [then-branch: 261 | exc@240@03 == Null]
; [eval] alen(opt_get1(P)) == V
; [eval] alen(opt_get1(P))
; [eval] opt_get1(P)
(push) ; 20
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 20
; Joined path conditions
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit res@156@03)) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))
; [eval] exc == null
(push) ; 18
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136112
;  :arith-add-rows          80355
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41287
;  :arith-assert-upper      27224
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24972
;  :arith-fixed-eqs         14968
;  :arith-offset-eqs        17892
;  :arith-pivots            14529
;  :conflicts               2746
;  :datatype-accessor-ax    306
;  :datatype-constructor-ax 1867
;  :datatype-occurs-check   938
;  :datatype-splits         1267
;  :decisions               21737
;  :del-clause              208024
;  :final-checks            330
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.59
;  :minimized-lits          622
;  :mk-bool-var             248902
;  :mk-clause               208075
;  :num-allocs              1223521
;  :num-checks              406
;  :propagations            105909
;  :quant-instantiations    58566
;  :restarts                2
;  :rlimit-count            5386334)
; [then-branch: 262 | exc@240@03 == Null | live]
; [else-branch: 262 | exc@240@03 != Null | dead]
(push) ; 18
; [then-branch: 262 | exc@240@03 == Null]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))
; [eval] exc == null
(push) ; 19
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136220
;  :arith-add-rows          80355
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41287
;  :arith-assert-upper      27224
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24972
;  :arith-fixed-eqs         14968
;  :arith-offset-eqs        17892
;  :arith-pivots            14529
;  :conflicts               2746
;  :datatype-accessor-ax    307
;  :datatype-constructor-ax 1886
;  :datatype-occurs-check   949
;  :datatype-splits         1282
;  :decisions               21756
;  :del-clause              208024
;  :final-checks            332
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.60
;  :minimized-lits          622
;  :mk-bool-var             248918
;  :mk-clause               208075
;  :num-allocs              1224532
;  :num-checks              407
;  :propagations            105909
;  :quant-instantiations    58566
;  :restarts                2
;  :rlimit-count            5387816)
; [then-branch: 263 | exc@240@03 == Null | live]
; [else-branch: 263 | exc@240@03 != Null | dead]
(push) ; 19
; [then-branch: 263 | exc@240@03 == Null]
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> |this.Gf_seq| == V
; [eval] exc == null
(push) ; 20
(push) ; 21
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136330
;  :arith-add-rows          80355
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41287
;  :arith-assert-upper      27224
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24972
;  :arith-fixed-eqs         14968
;  :arith-offset-eqs        17892
;  :arith-pivots            14529
;  :conflicts               2746
;  :datatype-accessor-ax    308
;  :datatype-constructor-ax 1905
;  :datatype-occurs-check   962
;  :datatype-splits         1297
;  :decisions               21775
;  :del-clause              208024
;  :final-checks            334
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.60
;  :minimized-lits          622
;  :mk-bool-var             248935
;  :mk-clause               208075
;  :num-allocs              1225550
;  :num-checks              408
;  :propagations            105909
;  :quant-instantiations    58566
;  :restarts                2
;  :rlimit-count            5389348)
; [then-branch: 264 | exc@240@03 == Null | live]
; [else-branch: 264 | exc@240@03 != Null | dead]
(push) ; 21
; [then-branch: 264 | exc@240@03 == Null]
; [eval] |this.Gf_seq| == V
; [eval] |this.Gf_seq|
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (=
    (Seq_length
      ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
    V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> |this.P_seq| == V
; [eval] exc == null
(push) ; 20
(push) ; 21
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136445
;  :arith-add-rows          80356
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41289
;  :arith-assert-upper      27225
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24973
;  :arith-fixed-eqs         14969
;  :arith-offset-eqs        17892
;  :arith-pivots            14530
;  :conflicts               2746
;  :datatype-accessor-ax    309
;  :datatype-constructor-ax 1924
;  :datatype-occurs-check   975
;  :datatype-splits         1312
;  :decisions               21794
;  :del-clause              208024
;  :final-checks            336
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.59
;  :minimized-lits          622
;  :mk-bool-var             248958
;  :mk-clause               208075
;  :num-allocs              1226628
;  :num-checks              409
;  :propagations            105909
;  :quant-instantiations    58568
;  :restarts                2
;  :rlimit-count            5391060)
; [then-branch: 265 | exc@240@03 == Null | live]
; [else-branch: 265 | exc@240@03 != Null | dead]
(push) ; 21
; [then-branch: 265 | exc@240@03 == Null]
; [eval] |this.P_seq| == V
; [eval] |this.P_seq|
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (=
    (Seq_length
      ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))
    V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> SquareIntMatrix(this, this.Gf_seq, V)
; [eval] exc == null
(push) ; 20
(push) ; 21
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136561
;  :arith-add-rows          80357
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41291
;  :arith-assert-upper      27226
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24974
;  :arith-fixed-eqs         14970
;  :arith-offset-eqs        17892
;  :arith-pivots            14531
;  :conflicts               2746
;  :datatype-accessor-ax    310
;  :datatype-constructor-ax 1943
;  :datatype-occurs-check   988
;  :datatype-splits         1327
;  :decisions               21813
;  :del-clause              208024
;  :final-checks            338
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.58
;  :minimized-lits          622
;  :mk-bool-var             248981
;  :mk-clause               208075
;  :num-allocs              1227717
;  :num-checks              410
;  :propagations            105909
;  :quant-instantiations    58570
;  :restarts                2
;  :rlimit-count            5392777)
; [then-branch: 266 | exc@240@03 == Null | live]
; [else-branch: 266 | exc@240@03 != Null | dead]
(push) ; 21
; [then-branch: 266 | exc@240@03 == Null]
; [eval] SquareIntMatrix(this, this.Gf_seq, V)
(push) ; 22
; [eval] this != null
(pop) ; 22
; Joined path conditions
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))) V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= s
; [eval] exc == null
(push) ; 20
(push) ; 21
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136684
;  :arith-add-rows          80358
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41291
;  :arith-assert-upper      27226
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24975
;  :arith-fixed-eqs         14970
;  :arith-offset-eqs        17892
;  :arith-pivots            14531
;  :conflicts               2746
;  :datatype-accessor-ax    311
;  :datatype-constructor-ax 1962
;  :datatype-occurs-check   1001
;  :datatype-splits         1342
;  :decisions               21832
;  :del-clause              208025
;  :final-checks            340
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.58
;  :minimized-lits          622
;  :mk-bool-var             249022
;  :mk-clause               208095
;  :num-allocs              1228874
;  :num-checks              411
;  :propagations            105915
;  :quant-instantiations    58575
;  :restarts                2
;  :rlimit-count            5394828
;  :time                    0.00)
; [then-branch: 267 | exc@240@03 == Null | live]
; [else-branch: 267 | exc@240@03 != Null | dead]
(push) ; 21
; [then-branch: 267 | exc@240@03 == Null]
; [eval] 0 <= s
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies (= exc@240@03 $Ref.null) (<= 0 s@24@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> s < V
; [eval] exc == null
(push) ; 20
(push) ; 21
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136807
;  :arith-add-rows          80358
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41291
;  :arith-assert-upper      27226
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24976
;  :arith-fixed-eqs         14970
;  :arith-offset-eqs        17892
;  :arith-pivots            14531
;  :conflicts               2746
;  :datatype-accessor-ax    312
;  :datatype-constructor-ax 1981
;  :datatype-occurs-check   1014
;  :datatype-splits         1357
;  :decisions               21851
;  :del-clause              208026
;  :final-checks            342
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.58
;  :minimized-lits          622
;  :mk-bool-var             249042
;  :mk-clause               208096
;  :num-allocs              1229938
;  :num-checks              412
;  :propagations            105915
;  :quant-instantiations    58575
;  :restarts                2
;  :rlimit-count            5396452)
; [then-branch: 268 | exc@240@03 == Null | live]
; [else-branch: 268 | exc@240@03 != Null | dead]
(push) ; 21
; [then-branch: 268 | exc@240@03 == Null]
; [eval] s < V
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies (= exc@240@03 $Ref.null) (< s@24@03 V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> 0 <= t
; [eval] exc == null
(push) ; 20
(push) ; 21
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               136930
;  :arith-add-rows          80358
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41291
;  :arith-assert-upper      27226
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24977
;  :arith-fixed-eqs         14970
;  :arith-offset-eqs        17892
;  :arith-pivots            14531
;  :conflicts               2746
;  :datatype-accessor-ax    313
;  :datatype-constructor-ax 2000
;  :datatype-occurs-check   1027
;  :datatype-splits         1372
;  :decisions               21870
;  :del-clause              208027
;  :final-checks            344
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.58
;  :minimized-lits          622
;  :mk-bool-var             249062
;  :mk-clause               208097
;  :num-allocs              1231005
;  :num-checks              413
;  :propagations            105915
;  :quant-instantiations    58575
;  :restarts                2
;  :rlimit-count            5398093)
; [then-branch: 269 | exc@240@03 == Null | live]
; [else-branch: 269 | exc@240@03 != Null | dead]
(push) ; 21
; [then-branch: 269 | exc@240@03 == Null]
; [eval] 0 <= t
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies (= exc@240@03 $Ref.null) (<= 0 t@25@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> t < V
; [eval] exc == null
(push) ; 20
(push) ; 21
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               137053
;  :arith-add-rows          80358
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41291
;  :arith-assert-upper      27226
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24978
;  :arith-fixed-eqs         14970
;  :arith-offset-eqs        17892
;  :arith-pivots            14531
;  :conflicts               2746
;  :datatype-accessor-ax    314
;  :datatype-constructor-ax 2019
;  :datatype-occurs-check   1040
;  :datatype-splits         1387
;  :decisions               21889
;  :del-clause              208028
;  :final-checks            346
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.58
;  :minimized-lits          622
;  :mk-bool-var             249082
;  :mk-clause               208098
;  :num-allocs              1232077
;  :num-checks              414
;  :propagations            105915
;  :quant-instantiations    58575
;  :restarts                2
;  :rlimit-count            5399741)
; [then-branch: 270 | exc@240@03 == Null | live]
; [else-branch: 270 | exc@240@03 != Null | dead]
(push) ; 21
; [then-branch: 270 | exc@240@03 == Null]
; [eval] t < V
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies (= exc@240@03 $Ref.null) (< t@25@03 V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))))
; [eval] exc == null
(push) ; 20
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               137177
;  :arith-add-rows          80358
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41291
;  :arith-assert-upper      27226
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24979
;  :arith-fixed-eqs         14970
;  :arith-offset-eqs        17892
;  :arith-pivots            14531
;  :conflicts               2746
;  :datatype-accessor-ax    315
;  :datatype-constructor-ax 2039
;  :datatype-occurs-check   1053
;  :datatype-splits         1403
;  :decisions               21909
;  :del-clause              208029
;  :final-checks            348
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.58
;  :minimized-lits          622
;  :mk-bool-var             249102
;  :mk-clause               208099
;  :num-allocs              1233149
;  :num-checks              415
;  :propagations            105915
;  :quant-instantiations    58575
;  :restarts                2
;  :rlimit-count            5401389)
; [then-branch: 271 | exc@240@03 == Null | live]
; [else-branch: 271 | exc@240@03 != Null | dead]
(push) ; 20
; [then-branch: 271 | exc@240@03 == Null]
(declare-const i1@259@03 Int)
(declare-const j1@260@03 Int)
(push) ; 21
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 22
; [then-branch: 272 | 0 <= i1@259@03 | live]
; [else-branch: 272 | !(0 <= i1@259@03) | live]
(push) ; 23
; [then-branch: 272 | 0 <= i1@259@03]
(assert (<= 0 i1@259@03))
; [eval] i1 < V
(push) ; 24
; [then-branch: 273 | i1@259@03 < V@26@03 | live]
; [else-branch: 273 | !(i1@259@03 < V@26@03) | live]
(push) ; 25
; [then-branch: 273 | i1@259@03 < V@26@03]
(assert (< i1@259@03 V@26@03))
; [eval] 0 <= j1
(push) ; 26
; [then-branch: 274 | 0 <= j1@260@03 | live]
; [else-branch: 274 | !(0 <= j1@260@03) | live]
(push) ; 27
; [then-branch: 274 | 0 <= j1@260@03]
(assert (<= 0 j1@260@03))
; [eval] j1 < V
(pop) ; 27
(push) ; 27
; [else-branch: 274 | !(0 <= j1@260@03)]
(assert (not (<= 0 j1@260@03)))
(pop) ; 27
(pop) ; 26
; Joined path conditions
; Joined path conditions
(pop) ; 25
(push) ; 25
; [else-branch: 273 | !(i1@259@03 < V@26@03)]
(assert (not (< i1@259@03 V@26@03)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
; Joined path conditions
(pop) ; 23
(push) ; 23
; [else-branch: 272 | !(0 <= i1@259@03)]
(assert (not (<= 0 i1@259@03)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@260@03 V@26@03) (<= 0 j1@260@03)) (< i1@259@03 V@26@03))
  (<= 0 i1@259@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(Gf), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(Gf), i1).option$array$)
; [eval] aloc(opt_get1(Gf), i1)
; [eval] opt_get1(Gf)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< i1@259@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               137177
;  :arith-add-rows          80361
;  :arith-assert-diseq      9127
;  :arith-assert-lower      41297
;  :arith-assert-upper      27226
;  :arith-bound-prop        8146
;  :arith-conflicts         1218
;  :arith-eq-adapter        24979
;  :arith-fixed-eqs         14970
;  :arith-offset-eqs        17892
;  :arith-pivots            14534
;  :conflicts               2746
;  :datatype-accessor-ax    315
;  :datatype-constructor-ax 2039
;  :datatype-occurs-check   1053
;  :datatype-splits         1403
;  :decisions               21909
;  :del-clause              208029
;  :final-checks            348
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.58
;  :minimized-lits          622
;  :mk-bool-var             249108
;  :mk-clause               208099
;  :num-allocs              1233422
;  :num-checks              416
;  :propagations            105915
;  :quant-instantiations    58575
;  :restarts                2
;  :rlimit-count            5401879)
(assert (< i1@259@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(pop) ; 22
; Joined path conditions
(assert (< i1@259@03 (alen<Int> (opt_get1 $Snap.unit res@74@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (+
            (ite
              (and
                (<
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
                  V@26@03)
                (<=
                  0
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))
              $k@252@03
              $Perm.No)
            (ite
              (and
                (<
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
                  V@26@03)
                (<=
                  0
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))
              $k@244@03
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               139368
;  :arith-add-rows          81836
;  :arith-assert-diseq      9309
;  :arith-assert-lower      42113
;  :arith-assert-upper      27679
;  :arith-bound-prop        8306
;  :arith-conflicts         1242
;  :arith-eq-adapter        25455
;  :arith-fixed-eqs         15226
;  :arith-offset-eqs        18164
;  :arith-pivots            14719
;  :conflicts               2799
;  :datatype-accessor-ax    315
;  :datatype-constructor-ax 2043
;  :datatype-occurs-check   1053
;  :datatype-splits         1403
;  :decisions               22319
;  :del-clause              212179
;  :final-checks            348
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.63
;  :minimized-lits          627
;  :mk-bool-var             254127
;  :mk-clause               212560
;  :num-allocs              1249618
;  :num-checks              417
;  :propagations            108133
;  :quant-instantiations    59730
;  :restarts                2
;  :rlimit-count            5506812
;  :time                    0.04)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               139392
;  :arith-add-rows          81857
;  :arith-assert-diseq      9309
;  :arith-assert-lower      42114
;  :arith-assert-upper      27681
;  :arith-bound-prop        8315
;  :arith-conflicts         1243
;  :arith-eq-adapter        25456
;  :arith-fixed-eqs         15226
;  :arith-offset-eqs        18164
;  :arith-pivots            14720
;  :conflicts               2805
;  :datatype-accessor-ax    315
;  :datatype-constructor-ax 2047
;  :datatype-occurs-check   1053
;  :datatype-splits         1403
;  :decisions               22324
;  :del-clause              212189
;  :final-checks            348
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.63
;  :minimized-lits          627
;  :mk-bool-var             254130
;  :mk-clause               212570
;  :num-allocs              1249725
;  :num-checks              418
;  :propagations            108163
;  :quant-instantiations    59730
;  :restarts                2
;  :rlimit-count            5507561)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  j1@260@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               139735
;  :arith-add-rows          82024
;  :arith-assert-diseq      9337
;  :arith-assert-lower      42250
;  :arith-assert-upper      27741
;  :arith-bound-prop        8344
;  :arith-conflicts         1252
;  :arith-eq-adapter        25534
;  :arith-fixed-eqs         15262
;  :arith-offset-eqs        18189
;  :arith-pivots            14752
;  :conflicts               2829
;  :datatype-accessor-ax    315
;  :datatype-constructor-ax 2051
;  :datatype-occurs-check   1053
;  :datatype-splits         1403
;  :decisions               22370
;  :del-clause              212445
;  :final-checks            348
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.63
;  :minimized-lits          627
;  :mk-bool-var             254468
;  :mk-clause               212826
;  :num-allocs              1251295
;  :num-checks              419
;  :propagations            108403
;  :quant-instantiations    59803
;  :restarts                2
;  :rlimit-count            5515339
;  :time                    0.00)
(assert (<
  j1@260@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))))
(pop) ; 22
; Joined path conditions
(assert (<
  j1@260@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))))
(pop) ; 21
(declare-fun inv@261@03 ($Ref) Int)
(declare-fun inv@262@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@259@03 Int) (j1@260@03 Int)) (!
  (and
    (< i1@259@03 (alen<Int> (opt_get1 $Snap.unit res@74@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@260@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))) j1@260@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 21
(assert (not (forall ((i11@259@03 Int) (j11@260@03 Int) (i12@259@03 Int) (j12@260@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< j11@260@03 V@26@03) (<= 0 j11@260@03))
          (< i11@259@03 V@26@03))
        (<= 0 i11@259@03))
      (and
        (and
          (and (< j12@260@03 V@26@03) (<= 0 j12@260@03))
          (< i12@259@03 V@26@03))
        (<= 0 i12@259@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i11@259@03))) j11@260@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i12@259@03))) j12@260@03)))
    (and (= i11@259@03 i12@259@03) (= j11@260@03 j12@260@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 21
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               140028
;  :arith-add-rows          82311
;  :arith-assert-diseq      9341
;  :arith-assert-lower      42314
;  :arith-assert-upper      27781
;  :arith-bound-prop        8391
;  :arith-conflicts         1254
;  :arith-eq-adapter        25580
;  :arith-fixed-eqs         15291
;  :arith-offset-eqs        18232
;  :arith-pivots            14848
;  :conflicts               2844
;  :datatype-accessor-ax    315
;  :datatype-constructor-ax 2055
;  :datatype-occurs-check   1053
;  :datatype-splits         1403
;  :decisions               22388
;  :del-clause              213383
;  :final-checks            348
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.59
;  :minimized-lits          627
;  :mk-bool-var             255387
;  :mk-clause               213453
;  :num-allocs              1255623
;  :num-checks              420
;  :propagations            108543
;  :quant-instantiations    60052
;  :restarts                2
;  :rlimit-count            5536498
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@259@03 Int) (j1@260@03 Int)) (!
  (implies
    (and
      (and (and (< j1@260@03 V@26@03) (<= 0 j1@260@03)) (< i1@259@03 V@26@03))
      (<= 0 i1@259@03))
    (and
      (=
        (inv@261@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))) j1@260@03))
        i1@259@03)
      (=
        (inv@262@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))) j1@260@03))
        j1@260@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))) j1@260@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@74@03) (inv@261@03 r)))) (inv@262@03 r))
      r))
  :pattern ((inv@261@03 r))
  :pattern ((inv@262@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@259@03 Int) (j1@260@03 Int)) (!
  (implies
    (and
      (and (and (< j1@260@03 V@26@03) (<= 0 j1@260@03)) (< i1@259@03 V@26@03))
      (<= 0 i1@259@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))) j1@260@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit res@74@03) i1@259@03))) j1@260@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@263@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    (=
      ($FVF.lookup_int (as sm@263@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@263@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef106|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r)))
    (=
      ($FVF.lookup_int (as sm@263@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@263@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef107|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r)))
    (=
      ($FVF.lookup_int (as sm@263@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@263@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef108|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@263@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@263@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@263@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef110|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@263@03  $FVF<Int>) r) r))
  :pattern ((inv@261@03 r) (inv@262@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 21
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 21
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               140155
;  :arith-add-rows          82311
;  :arith-assert-diseq      9341
;  :arith-assert-lower      42314
;  :arith-assert-upper      27781
;  :arith-bound-prop        8391
;  :arith-conflicts         1254
;  :arith-eq-adapter        25581
;  :arith-fixed-eqs         15291
;  :arith-offset-eqs        18232
;  :arith-pivots            14848
;  :conflicts               2844
;  :datatype-accessor-ax    316
;  :datatype-constructor-ax 2076
;  :datatype-occurs-check   1066
;  :datatype-splits         1420
;  :decisions               22409
;  :del-clause              213384
;  :final-checks            350
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.60
;  :minimized-lits          627
;  :mk-bool-var             255417
;  :mk-clause               213454
;  :num-allocs              1258738
;  :num-checks              421
;  :propagations            108543
;  :quant-instantiations    60052
;  :restarts                2
;  :rlimit-count            5547896)
; [then-branch: 275 | exc@240@03 == Null | live]
; [else-branch: 275 | exc@240@03 != Null | dead]
(push) ; 21
; [then-branch: 275 | exc@240@03 == Null]
(declare-const i1@264@03 Int)
(declare-const j1@265@03 Int)
(push) ; 22
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 23
; [then-branch: 276 | 0 <= i1@264@03 | live]
; [else-branch: 276 | !(0 <= i1@264@03) | live]
(push) ; 24
; [then-branch: 276 | 0 <= i1@264@03]
(assert (<= 0 i1@264@03))
; [eval] i1 < V
(push) ; 25
; [then-branch: 277 | i1@264@03 < V@26@03 | live]
; [else-branch: 277 | !(i1@264@03 < V@26@03) | live]
(push) ; 26
; [then-branch: 277 | i1@264@03 < V@26@03]
(assert (< i1@264@03 V@26@03))
; [eval] 0 <= j1
(push) ; 27
; [then-branch: 278 | 0 <= j1@265@03 | live]
; [else-branch: 278 | !(0 <= j1@265@03) | live]
(push) ; 28
; [then-branch: 278 | 0 <= j1@265@03]
(assert (<= 0 j1@265@03))
; [eval] j1 < V
(pop) ; 28
(push) ; 28
; [else-branch: 278 | !(0 <= j1@265@03)]
(assert (not (<= 0 j1@265@03)))
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(pop) ; 26
(push) ; 26
; [else-branch: 277 | !(i1@264@03 < V@26@03)]
(assert (not (< i1@264@03 V@26@03)))
(pop) ; 26
(pop) ; 25
; Joined path conditions
; Joined path conditions
(pop) ; 24
(push) ; 24
; [else-branch: 276 | !(0 <= i1@264@03)]
(assert (not (<= 0 i1@264@03)))
(pop) ; 24
(pop) ; 23
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@265@03 V@26@03) (<= 0 j1@265@03)) (< i1@264@03 V@26@03))
  (<= 0 i1@264@03)))
; [eval] aloc(opt_get1(aloc(opt_get1(G), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(G), i1).option$array$)
; [eval] aloc(opt_get1(G), i1)
; [eval] opt_get1(G)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@264@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               140155
;  :arith-add-rows          82314
;  :arith-assert-diseq      9341
;  :arith-assert-lower      42320
;  :arith-assert-upper      27781
;  :arith-bound-prop        8391
;  :arith-conflicts         1254
;  :arith-eq-adapter        25581
;  :arith-fixed-eqs         15291
;  :arith-offset-eqs        18232
;  :arith-pivots            14849
;  :conflicts               2844
;  :datatype-accessor-ax    316
;  :datatype-constructor-ax 2076
;  :datatype-occurs-check   1066
;  :datatype-splits         1420
;  :decisions               22409
;  :del-clause              213384
;  :final-checks            350
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.60
;  :minimized-lits          627
;  :mk-bool-var             255423
;  :mk-clause               213454
;  :num-allocs              1259011
;  :num-checks              422
;  :propagations            108543
;  :quant-instantiations    60052
;  :restarts                2
;  :rlimit-count            5548376)
(assert (< i1@264@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(pop) ; 23
; Joined path conditions
(assert (< i1@264@03 (alen<Int> (opt_get1 $Snap.unit G@23@03))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (+
          (+
            (ite
              (and
                (<
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
                  V@26@03)
                (<=
                  0
                  (inv@253@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))
              $k@252@03
              $Perm.No)
            (ite
              (and
                (<
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
                  V@26@03)
                (<=
                  0
                  (inv@245@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))
              $k@244@03
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (<
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
                      V@26@03)
                    (<=
                      0
                      (inv@32@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))
                  $k@31@03
                  $Perm.No)
                (pTaken@94@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03)))
              (pTaken@103@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03)))
            (pTaken@192@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))
        (-
          (-
            (ite
              (and
                (<
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
                  V@26@03)
                (<=
                  0
                  (inv@77@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))
              $Perm.Write
              $Perm.No)
            (pTaken@93@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03)))
          (pTaken@104@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))
      (ite
        (and
          (<
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
            V@26@03)
          (<=
            0
            (inv@128@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))
        $k@127@03
        $Perm.No))
    (-
      (ite
        (and
          (<
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
            V@26@03)
          (<=
            0
            (inv@136@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))
        $k@135@03
        $Perm.No)
      (pTaken@180@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               141796
;  :arith-add-rows          84050
;  :arith-assert-diseq      9481
;  :arith-assert-lower      42912
;  :arith-assert-upper      28122
;  :arith-bound-prop        8589
;  :arith-conflicts         1272
;  :arith-eq-adapter        25954
;  :arith-fixed-eqs         15494
;  :arith-offset-eqs        18454
;  :arith-pivots            15043
;  :conflicts               2890
;  :datatype-accessor-ax    316
;  :datatype-constructor-ax 2080
;  :datatype-occurs-check   1066
;  :datatype-splits         1420
;  :decisions               22609
;  :del-clause              215603
;  :final-checks            350
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.64
;  :minimized-lits          635
;  :mk-bool-var             258476
;  :mk-clause               215982
;  :num-allocs              1270755
;  :num-checks              423
;  :propagations            109866
;  :quant-instantiations    60717
;  :restarts                2
;  :rlimit-count            5632362
;  :time                    0.02)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 24
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               141796
;  :arith-add-rows          84050
;  :arith-assert-diseq      9481
;  :arith-assert-lower      42912
;  :arith-assert-upper      28122
;  :arith-bound-prop        8589
;  :arith-conflicts         1272
;  :arith-eq-adapter        25954
;  :arith-fixed-eqs         15494
;  :arith-offset-eqs        18454
;  :arith-pivots            15043
;  :conflicts               2891
;  :datatype-accessor-ax    316
;  :datatype-constructor-ax 2080
;  :datatype-occurs-check   1066
;  :datatype-splits         1420
;  :decisions               22609
;  :del-clause              215603
;  :final-checks            350
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.64
;  :minimized-lits          635
;  :mk-bool-var             258476
;  :mk-clause               215982
;  :num-allocs              1270846
;  :num-checks              424
;  :propagations            109866
;  :quant-instantiations    60717
;  :restarts                2
;  :rlimit-count            5632457)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
    (as None<option<array>>  option<array>))))
(pop) ; 23
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
    (as None<option<array>>  option<array>))))
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (<
  j1@265@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03)))))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               141800
;  :arith-add-rows          84053
;  :arith-assert-diseq      9481
;  :arith-assert-lower      42914
;  :arith-assert-upper      28122
;  :arith-bound-prop        8591
;  :arith-conflicts         1272
;  :arith-eq-adapter        25955
;  :arith-fixed-eqs         15494
;  :arith-offset-eqs        18454
;  :arith-pivots            15045
;  :conflicts               2892
;  :datatype-accessor-ax    316
;  :datatype-constructor-ax 2080
;  :datatype-occurs-check   1066
;  :datatype-splits         1420
;  :decisions               22609
;  :del-clause              215609
;  :final-checks            350
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.64
;  :minimized-lits          635
;  :mk-bool-var             258487
;  :mk-clause               215988
;  :num-allocs              1271038
;  :num-checks              425
;  :propagations            109866
;  :quant-instantiations    60724
;  :restarts                2
;  :rlimit-count            5632875)
(assert (<
  j1@265@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))))
(pop) ; 23
; Joined path conditions
(assert (<
  j1@265@03
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))))
(declare-const $k@266@03 $Perm)
(assert ($Perm.isReadVar $k@266@03 $Perm.Write))
(pop) ; 22
(declare-fun inv@267@03 ($Ref) Int)
(declare-fun inv@268@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@266@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@264@03 Int) (j1@265@03 Int)) (!
  (and
    (< i1@264@03 (alen<Int> (opt_get1 $Snap.unit G@23@03)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))
        (as None<option<array>>  option<array>)))
    (<
      j1@265@03
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))) j1@265@03))
  :qid |int-aux|)))
(push) ; 22
(assert (not (forall ((i1@264@03 Int) (j1@265@03 Int)) (!
  (implies
    (and
      (and (and (< j1@265@03 V@26@03) (<= 0 j1@265@03)) (< i1@264@03 V@26@03))
      (<= 0 i1@264@03))
    (or (= $k@266@03 $Perm.No) (< $Perm.No $k@266@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               141800
;  :arith-add-rows          84079
;  :arith-assert-diseq      9482
;  :arith-assert-lower      42916
;  :arith-assert-upper      28123
;  :arith-bound-prop        8591
;  :arith-conflicts         1272
;  :arith-eq-adapter        25956
;  :arith-fixed-eqs         15494
;  :arith-offset-eqs        18454
;  :arith-pivots            15076
;  :conflicts               2893
;  :datatype-accessor-ax    316
;  :datatype-constructor-ax 2080
;  :datatype-occurs-check   1066
;  :datatype-splits         1420
;  :decisions               22609
;  :del-clause              215918
;  :final-checks            350
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.60
;  :minimized-lits          635
;  :mk-bool-var             258496
;  :mk-clause               215990
;  :num-allocs              1271594
;  :num-checks              426
;  :propagations            109867
;  :quant-instantiations    60724
;  :restarts                2
;  :rlimit-count            5634345)
; Check receiver injectivity
(push) ; 22
(assert (not (forall ((i11@264@03 Int) (j11@265@03 Int) (i12@264@03 Int) (j12@265@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@265@03 V@26@03) (<= 0 j11@265@03))
            (< i11@264@03 V@26@03))
          (<= 0 i11@264@03))
        (< $Perm.No $k@266@03))
      (and
        (and
          (and
            (and (< j12@265@03 V@26@03) (<= 0 j12@265@03))
            (< i12@264@03 V@26@03))
          (<= 0 i12@264@03))
        (< $Perm.No $k@266@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i11@264@03))) j11@265@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i12@264@03))) j12@265@03)))
    (and (= i11@264@03 i12@264@03) (= j11@265@03 j12@265@03)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               141911
;  :arith-add-rows          84166
;  :arith-assert-diseq      9482
;  :arith-assert-lower      42938
;  :arith-assert-upper      28133
;  :arith-bound-prop        8602
;  :arith-conflicts         1272
;  :arith-eq-adapter        25992
;  :arith-fixed-eqs         15504
;  :arith-offset-eqs        18465
;  :arith-pivots            15104
;  :conflicts               2894
;  :datatype-accessor-ax    316
;  :datatype-constructor-ax 2080
;  :datatype-occurs-check   1066
;  :datatype-splits         1420
;  :decisions               22609
;  :del-clause              216487
;  :final-checks            350
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.61
;  :minimized-lits          635
;  :mk-bool-var             259393
;  :mk-clause               216559
;  :num-allocs              1275521
;  :num-checks              427
;  :propagations            109912
;  :quant-instantiations    60957
;  :restarts                2
;  :rlimit-count            5649727
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((i1@264@03 Int) (j1@265@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@265@03 V@26@03) (<= 0 j1@265@03)) (< i1@264@03 V@26@03))
        (<= 0 i1@264@03))
      (< $Perm.No $k@266@03))
    (and
      (=
        (inv@267@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))) j1@265@03))
        i1@264@03)
      (=
        (inv@268@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))) j1@265@03))
        j1@265@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))) j1@265@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and
          (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
          (< (inv@267@03 r) V@26@03))
        (<= 0 (inv@267@03 r)))
      (< $Perm.No $k@266@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit G@23@03) (inv@267@03 r)))) (inv@268@03 r))
      r))
  :pattern ((inv@267@03 r))
  :pattern ((inv@268@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@264@03 Int) (j1@265@03 Int)) (!
  (<= $Perm.No $k@266@03)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))) j1@265@03))
  :qid |int-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@264@03 Int) (j1@265@03 Int)) (!
  (<= $k@266@03 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))) j1@265@03))
  :qid |int-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@264@03 Int) (j1@265@03 Int)) (!
  (implies
    (and
      (and
        (and (and (< j1@265@03 V@26@03) (<= 0 j1@265@03)) (< i1@264@03 V@26@03))
        (<= 0 i1@264@03))
      (< $Perm.No $k@266@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))) j1@265@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@254@03  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit G@23@03) i1@264@03))) j1@265@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@269@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
          (< (inv@267@03 r) V@26@03))
        (<= 0 (inv@267@03 r)))
      (< $Perm.No $k@266@03)
      false)
    (=
      ($FVF.lookup_int (as sm@269@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@269@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    (=
      ($FVF.lookup_int (as sm@269@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@269@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r)))
    (=
      ($FVF.lookup_int (as sm@269@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@269@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef113|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r)))
    (=
      ($FVF.lookup_int (as sm@269@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@269@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef114|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@269@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@269@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef115|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@269@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef116|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
        (< (inv@267@03 r) V@26@03))
      (<= 0 (inv@267@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@269@03  $FVF<Int>) r) r))
  :pattern ((inv@267@03 r) (inv@268@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 22
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142041
;  :arith-add-rows          84166
;  :arith-assert-diseq      9482
;  :arith-assert-lower      42938
;  :arith-assert-upper      28134
;  :arith-bound-prop        8602
;  :arith-conflicts         1272
;  :arith-eq-adapter        25993
;  :arith-fixed-eqs         15504
;  :arith-offset-eqs        18465
;  :arith-pivots            15104
;  :conflicts               2894
;  :datatype-accessor-ax    317
;  :datatype-constructor-ax 2102
;  :datatype-occurs-check   1079
;  :datatype-splits         1438
;  :decisions               22631
;  :del-clause              216488
;  :final-checks            352
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.62
;  :minimized-lits          635
;  :mk-bool-var             259426
;  :mk-clause               216560
;  :num-allocs              1279090
;  :num-checks              428
;  :propagations            109912
;  :quant-instantiations    60957
;  :restarts                2
;  :rlimit-count            5663467
;  :time                    0.00)
; [then-branch: 279 | exc@240@03 == Null | live]
; [else-branch: 279 | exc@240@03 != Null | dead]
(push) ; 22
; [then-branch: 279 | exc@240@03 == Null]
(declare-const i1@270@03 Int)
(push) ; 23
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 24
; [then-branch: 280 | 0 <= i1@270@03 | live]
; [else-branch: 280 | !(0 <= i1@270@03) | live]
(push) ; 25
; [then-branch: 280 | 0 <= i1@270@03]
(assert (<= 0 i1@270@03))
; [eval] i1 < V
(pop) ; 25
(push) ; 25
; [else-branch: 280 | !(0 <= i1@270@03)]
(assert (not (<= 0 i1@270@03)))
(pop) ; 25
(pop) ; 24
; Joined path conditions
; Joined path conditions
(assert (and (< i1@270@03 V@26@03) (<= 0 i1@270@03)))
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 25
(assert (not (< i1@270@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142041
;  :arith-add-rows          84167
;  :arith-assert-diseq      9482
;  :arith-assert-lower      42940
;  :arith-assert-upper      28134
;  :arith-bound-prop        8602
;  :arith-conflicts         1272
;  :arith-eq-adapter        25993
;  :arith-fixed-eqs         15504
;  :arith-offset-eqs        18465
;  :arith-pivots            15105
;  :conflicts               2894
;  :datatype-accessor-ax    317
;  :datatype-constructor-ax 2102
;  :datatype-occurs-check   1079
;  :datatype-splits         1438
;  :decisions               22631
;  :del-clause              216488
;  :final-checks            352
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.63
;  :minimized-lits          635
;  :mk-bool-var             259428
;  :mk-clause               216560
;  :num-allocs              1279194
;  :num-checks              429
;  :propagations            109912
;  :quant-instantiations    60957
;  :restarts                2
;  :rlimit-count            5663658)
(assert (< i1@270@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 24
; Joined path conditions
(assert (< i1@270@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 23
(declare-fun inv@271@03 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@270@03 Int)) (!
  (< i1@270@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@270@03))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 23
(assert (not (forall ((i11@270@03 Int) (i12@270@03 Int)) (!
  (implies
    (and
      (and (< i11@270@03 V@26@03) (<= 0 i11@270@03))
      (and (< i12@270@03 V@26@03) (<= 0 i12@270@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@270@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@270@03)))
    (= i11@270@03 i12@270@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142056
;  :arith-add-rows          84171
;  :arith-assert-diseq      9483
;  :arith-assert-lower      42944
;  :arith-assert-upper      28134
;  :arith-bound-prop        8602
;  :arith-conflicts         1272
;  :arith-eq-adapter        25994
;  :arith-fixed-eqs         15504
;  :arith-offset-eqs        18465
;  :arith-pivots            15106
;  :conflicts               2895
;  :datatype-accessor-ax    317
;  :datatype-constructor-ax 2102
;  :datatype-occurs-check   1079
;  :datatype-splits         1438
;  :decisions               22631
;  :del-clause              216494
;  :final-checks            352
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.61
;  :minimized-lits          635
;  :mk-bool-var             259454
;  :mk-clause               216566
;  :num-allocs              1279740
;  :num-checks              430
;  :propagations            109912
;  :quant-instantiations    60982
;  :restarts                2
;  :rlimit-count            5664774)
; Definitional axioms for inverse functions
(assert (forall ((i1@270@03 Int)) (!
  (implies
    (and (< i1@270@03 V@26@03) (<= 0 i1@270@03))
    (=
      (inv@271@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@270@03))
      i1@270@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@270@03))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@271@03 r))
      r))
  :pattern ((inv@271@03 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@270@03 Int)) (!
  (implies
    (and (< i1@270@03 V@26@03) (<= 0 i1@270@03))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@270@03)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@270@03))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@272@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
    (=
      ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
          (< (inv@267@03 r) V@26@03))
        (<= 0 (inv@267@03 r)))
      (< $Perm.No $k@266@03)
      false)
    (=
      ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef118|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    (=
      ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef119|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r)))
    (=
      ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef120|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r)))
    (=
      ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef121|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@272@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef122|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@272@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef123|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r) r))
  :pattern ((inv@271@03 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> valid_graph_vertices(this, P, V)
; [eval] exc == null
(push) ; 23
(set-option :timeout 10)
(push) ; 24
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142188
;  :arith-add-rows          84171
;  :arith-assert-diseq      9483
;  :arith-assert-lower      42944
;  :arith-assert-upper      28134
;  :arith-bound-prop        8602
;  :arith-conflicts         1272
;  :arith-eq-adapter        25995
;  :arith-fixed-eqs         15504
;  :arith-offset-eqs        18465
;  :arith-pivots            15106
;  :conflicts               2895
;  :datatype-accessor-ax    318
;  :datatype-constructor-ax 2124
;  :datatype-occurs-check   1092
;  :datatype-splits         1456
;  :decisions               22653
;  :del-clause              216495
;  :final-checks            354
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.62
;  :minimized-lits          635
;  :mk-bool-var             259488
;  :mk-clause               216567
;  :num-allocs              1283318
;  :num-checks              431
;  :propagations            109912
;  :quant-instantiations    60982
;  :restarts                2
;  :rlimit-count            5678655)
; [then-branch: 281 | exc@240@03 == Null | live]
; [else-branch: 281 | exc@240@03 != Null | dead]
(push) ; 24
; [then-branch: 281 | exc@240@03 == Null]
; [eval] valid_graph_vertices(this, P, V)
(push) ; 25
; [eval] this != null
; [eval] p != (None(): option[array])
; [eval] (None(): option[array])
; [eval] alen(opt_get1(p)) == V
; [eval] alen(opt_get1(p))
; [eval] opt_get1(p)
(push) ; 26
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 26
; Joined path conditions
(declare-const i1@273@03 Int)
(push) ; 26
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 27
; [then-branch: 282 | 0 <= i1@273@03 | live]
; [else-branch: 282 | !(0 <= i1@273@03) | live]
(push) ; 28
; [then-branch: 282 | 0 <= i1@273@03]
(assert (<= 0 i1@273@03))
; [eval] i1 < V
(pop) ; 28
(push) ; 28
; [else-branch: 282 | !(0 <= i1@273@03)]
(assert (not (<= 0 i1@273@03)))
(pop) ; 28
(pop) ; 27
; Joined path conditions
; Joined path conditions
(assert (and (< i1@273@03 V@26@03) (<= 0 i1@273@03)))
(declare-const $k@274@03 $Perm)
(assert ($Perm.isReadVar $k@274@03 $Perm.Write))
; [eval] aloc(opt_get1(p), i1)
; [eval] opt_get1(p)
(push) ; 27
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 27
; Joined path conditions
(push) ; 27
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 28
(assert (not (< i1@273@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142188
;  :arith-add-rows          84172
;  :arith-assert-diseq      9484
;  :arith-assert-lower      42948
;  :arith-assert-upper      28135
;  :arith-bound-prop        8602
;  :arith-conflicts         1272
;  :arith-eq-adapter        25996
;  :arith-fixed-eqs         15504
;  :arith-offset-eqs        18465
;  :arith-pivots            15106
;  :conflicts               2895
;  :datatype-accessor-ax    318
;  :datatype-constructor-ax 2124
;  :datatype-occurs-check   1092
;  :datatype-splits         1456
;  :decisions               22653
;  :del-clause              216495
;  :final-checks            354
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.62
;  :minimized-lits          635
;  :mk-bool-var             259494
;  :mk-clause               216569
;  :num-allocs              1283488
;  :num-checks              432
;  :propagations            109913
;  :quant-instantiations    60982
;  :restarts                2
;  :rlimit-count            5678992)
(assert (< i1@273@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 27
; Joined path conditions
(assert (< i1@273@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 26
(declare-fun inv@275@03 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@274@03 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@273@03 Int)) (!
  (< i1@273@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
  :qid |int-aux|)))
(push) ; 26
(assert (not (forall ((i1@273@03 Int)) (!
  (implies
    (and (< i1@273@03 V@26@03) (<= 0 i1@273@03))
    (or (= $k@274@03 $Perm.No) (< $Perm.No $k@274@03)))
  
  ))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142188
;  :arith-add-rows          84173
;  :arith-assert-diseq      9485
;  :arith-assert-lower      42950
;  :arith-assert-upper      28136
;  :arith-bound-prop        8602
;  :arith-conflicts         1272
;  :arith-eq-adapter        25997
;  :arith-fixed-eqs         15504
;  :arith-offset-eqs        18465
;  :arith-pivots            15106
;  :conflicts               2896
;  :datatype-accessor-ax    318
;  :datatype-constructor-ax 2124
;  :datatype-occurs-check   1092
;  :datatype-splits         1456
;  :decisions               22653
;  :del-clause              216497
;  :final-checks            354
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.62
;  :minimized-lits          635
;  :mk-bool-var             259501
;  :mk-clause               216571
;  :num-allocs              1283913
;  :num-checks              433
;  :propagations            109914
;  :quant-instantiations    60982
;  :restarts                2
;  :rlimit-count            5679538)
; Definitional axioms for snapshot map domain
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 26
(assert (not (forall ((i11@273@03 Int) (i12@273@03 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@273@03 V@26@03) (<= 0 i11@273@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@272@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@273@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@273@03)))
        (< $Perm.No $k@274@03))
      (and
        (and
          (and (< i12@273@03 V@26@03) (<= 0 i12@273@03))
          ($FVF.loc_int ($FVF.lookup_int (as sm@272@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@273@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@273@03)))
        (< $Perm.No $k@274@03))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i11@273@03)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i12@273@03)))
    (= i11@273@03 i12@273@03))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142208
;  :arith-add-rows          84196
;  :arith-assert-diseq      9486
;  :arith-assert-lower      42954
;  :arith-assert-upper      28136
;  :arith-bound-prop        8602
;  :arith-conflicts         1272
;  :arith-eq-adapter        25998
;  :arith-fixed-eqs         15504
;  :arith-offset-eqs        18465
;  :arith-pivots            15108
;  :conflicts               2897
;  :datatype-accessor-ax    318
;  :datatype-constructor-ax 2124
;  :datatype-occurs-check   1092
;  :datatype-splits         1456
;  :decisions               22653
;  :del-clause              216569
;  :final-checks            354
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.61
;  :minimized-lits          635
;  :mk-bool-var             259619
;  :mk-clause               216643
;  :num-allocs              1284718
;  :num-checks              434
;  :propagations            109920
;  :quant-instantiations    61018
;  :restarts                2
;  :rlimit-count            5681726
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@273@03 Int)) (!
  (implies
    (and (and (< i1@273@03 V@26@03) (<= 0 i1@273@03)) (< $Perm.No $k@274@03))
    (=
      (inv@275@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
      i1@273@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
      (< $Perm.No $k@274@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@275@03 r))
      r))
  :pattern ((inv@275@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r) r))
  :pattern ((inv@275@03 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@276@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
    ($Perm.min
      (ite
        (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
        $Perm.Write
        $Perm.No)
      $k@274@03)
    $Perm.No))
(define-fun pTaken@277@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
            (< (inv@267@03 r) V@26@03))
          (<= 0 (inv@267@03 r)))
        $k@266@03
        $Perm.No)
      (- $k@274@03 (pTaken@276@03 r)))
    $Perm.No))
(define-fun pTaken@278@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
            (< (inv@261@03 r) V@26@03))
          (<= 0 (inv@261@03 r)))
        $Perm.Write
        $Perm.No)
      (- (- $k@274@03 (pTaken@276@03 r)) (pTaken@277@03 r)))
    $Perm.No))
(define-fun pTaken@279@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r))
      (- (- (- $k@274@03 (pTaken@276@03 r)) (pTaken@277@03 r)) (pTaken@278@03 r)))
    $Perm.No))
(define-fun pTaken@280@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
    ($Perm.min
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r))
      (-
        (-
          (- (- $k@274@03 (pTaken@276@03 r)) (pTaken@277@03 r))
          (pTaken@278@03 r))
        (pTaken@279@03 r)))
    $Perm.No))
(define-fun pTaken@281@03 ((r $Ref)) $Perm
  (ite
    (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)
      (-
        (-
          (-
            (- (- $k@274@03 (pTaken@276@03 r)) (pTaken@277@03 r))
            (pTaken@278@03 r))
          (pTaken@279@03 r))
        (pTaken@280@03 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@274@03
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
          $Perm.Write
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
      (<
        (ite
          (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
          $k@274@03
          $Perm.No)
        $Perm.Write)
      (<
        (ite
          (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
          $k@274@03
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@271@03 r))
  :pattern ((inv@275@03 r))
  :qid |qp.srp124|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 26
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
    (= (- $k@274@03 (pTaken@276@03 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142491
;  :arith-add-rows          84257
;  :arith-assert-diseq      9490
;  :arith-assert-lower      42973
;  :arith-assert-upper      28147
;  :arith-bound-prop        8613
;  :arith-conflicts         1274
;  :arith-eq-adapter        26019
;  :arith-fixed-eqs         15510
;  :arith-offset-eqs        18477
;  :arith-pivots            15126
;  :conflicts               2906
;  :datatype-accessor-ax    318
;  :datatype-constructor-ax 2150
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               22683
;  :del-clause              217092
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.62
;  :minimized-lits          635
;  :mk-bool-var             260304
;  :mk-clause               217164
;  :num-allocs              1289556
;  :num-checks              436
;  :propagations            109993
;  :quant-instantiations    61198
;  :restarts                2
;  :rlimit-count            5699304
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
(declare-const sm@282@03 $FVF<Int>)
; Definitional axioms for snapshot map domain
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@282@03  $FVF<Int>)))
    (and
      (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
      (< $Perm.No $k@274@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@282@03  $FVF<Int>))))
  :qid |qp.fvfDomDef132|)))
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (ite
        (and
          (and
            (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
            (< (inv@267@03 r) V@26@03))
          (<= 0 (inv@267@03 r)))
        (< $Perm.No $k@266@03)
        false))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (and
        (and
          (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
          (< (inv@261@03 r) V@26@03))
        (<= 0 (inv@261@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                    (< (inv@40@03 r) V@26@03))
                  (<= 0 (inv@40@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@115@03 r))
            (pTaken@121@03 r))
          (pTaken@215@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                    (< (inv@85@03 r) V@26@03))
                  (<= 0 (inv@85@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@114@03 r))
            (pTaken@122@03 r))
          (pTaken@216@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        (< $Perm.No $k@144@03)
        false))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef131|)))
(pop) ; 25
; Joined path conditions
(assert ($Perm.isReadVar $k@274@03 $Perm.Write))
(assert (forall ((i1@273@03 Int)) (!
  (implies
    (and (and (< i1@273@03 V@26@03) (<= 0 i1@273@03)) (< $Perm.No $k@274@03))
    (=
      (inv@275@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
      i1@273@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
      (< $Perm.No $k@274@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@275@03 r))
      r))
  :pattern ((inv@275@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@282@03  $FVF<Int>)))
    (and
      (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
      (< $Perm.No $k@274@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@282@03  $FVF<Int>))))
  :qid |qp.fvfDomDef132|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (ite
        (and
          (and
            (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
            (< (inv@267@03 r) V@26@03))
          (<= 0 (inv@267@03 r)))
        (< $Perm.No $k@266@03)
        false))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (and
        (and
          (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
          (< (inv@261@03 r) V@26@03))
        (<= 0 (inv@261@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                    (< (inv@40@03 r) V@26@03))
                  (<= 0 (inv@40@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@115@03 r))
            (pTaken@121@03 r))
          (pTaken@215@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                    (< (inv@85@03 r) V@26@03))
                  (<= 0 (inv@85@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@114@03 r))
            (pTaken@122@03 r))
          (pTaken@216@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        (< $Perm.No $k@144@03)
        false))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef131|)))
(assert (and
  (forall ((i1@273@03 Int)) (!
    (< i1@273@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
    :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
    :qid |int-aux|))
  (forall ((r $Ref)) (!
    (implies
      (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r) r))
    :pattern ((inv@275@03 r))
    ))
  (forall ((r $Ref)) (!
    (implies
      (not
        (=
          (ite
            (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
            $Perm.Write
            $Perm.No)
          $Perm.No))
      (ite
        (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
        (<
          (ite
            (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
            $k@274@03
            $Perm.No)
          $Perm.Write)
        (<
          (ite
            (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
            $k@274@03
            $Perm.No)
          $Perm.No)))
    :pattern ((inv@271@03 r))
    :pattern ((inv@275@03 r))
    :qid |qp.srp124|))))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert ($Perm.isReadVar $k@274@03 $Perm.Write))
(assert (forall ((i1@273@03 Int)) (!
  (implies
    (and (and (< i1@273@03 V@26@03) (<= 0 i1@273@03)) (< $Perm.No $k@274@03))
    (=
      (inv@275@03 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
      i1@273@03))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
      (< $Perm.No $k@274@03))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) (inv@275@03 r))
      r))
  :pattern ((inv@275@03 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (iff
    (Set_in r ($FVF.domain_int (as sm@282@03  $FVF<Int>)))
    (and
      (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
      (< $Perm.No $k@274@03)))
  :pattern ((Set_in r ($FVF.domain_int (as sm@282@03  $FVF<Int>))))
  :qid |qp.fvfDomDef132|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef125|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (ite
        (and
          (and
            (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
            (< (inv@267@03 r) V@26@03))
          (<= 0 (inv@267@03 r)))
        (< $Perm.No $k@266@03)
        false))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef126|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (and
        (and
          (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
          (< (inv@261@03 r) V@26@03))
        (<= 0 (inv@261@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef127|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                    (< (inv@40@03 r) V@26@03))
                  (<= 0 (inv@40@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@115@03 r))
            (pTaken@121@03 r))
          (pTaken@215@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef128|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (<
        $Perm.No
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                    (< (inv@85@03 r) V@26@03))
                  (<= 0 (inv@85@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@114@03 r))
            (pTaken@122@03 r))
          (pTaken@216@03 r))))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef129|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        (< $Perm.No $k@274@03))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        (< $Perm.No $k@144@03)
        false))
    (=
      ($FVF.lookup_int (as sm@282@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef130|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@282@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef131|)))
(assert (implies
  (= exc@240@03 $Ref.null)
  (and
    (forall ((i1@273@03 Int)) (!
      (< i1@273@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@273@03))
      :qid |int-aux|))
    (forall ((r $Ref)) (!
      (implies
        (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
        ($FVF.loc_int ($FVF.lookup_int (as sm@272@03  $FVF<Int>) r) r))
      :pattern ((inv@275@03 r))
      ))
    (forall ((r $Ref)) (!
      (implies
        (not
          (=
            (ite
              (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
              $Perm.Write
              $Perm.No)
            $Perm.No))
        (ite
          (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
          (<
            (ite
              (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
              $k@274@03
              $Perm.No)
            $Perm.Write)
          (<
            (ite
              (and (< (inv@275@03 r) V@26@03) (<= 0 (inv@275@03 r)))
              $k@274@03
              $Perm.No)
            $Perm.No)))
      :pattern ((inv@271@03 r))
      :pattern ((inv@275@03 r))
      :qid |qp.srp124|)))))
(assert (implies
  (= exc@240@03 $Ref.null)
  (valid_graph_vertices ($Snap.combine
    $Snap.unit
    ($Snap.combine
      $Snap.unit
      ($Snap.combine
        $Snap.unit
        ($SortWrappers.$FVF<Int>To$Snap (as sm@282@03  $FVF<Int>))))) this@21@03 res@156@03 V@26@03)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { this.P_seq[i1] } { aloc(opt_get1(P), i1) } 0 <= i1 && i1 < V ==> this.P_seq[i1] == aloc(opt_get1(P), i1).int)
; [eval] exc == null
(push) ; 23
(set-option :timeout 10)
(push) ; 24
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142765
;  :arith-add-rows          84413
;  :arith-assert-diseq      9491
;  :arith-assert-lower      42998
;  :arith-assert-upper      28161
;  :arith-bound-prop        8620
;  :arith-conflicts         1277
;  :arith-eq-adapter        26032
;  :arith-fixed-eqs         15520
;  :arith-offset-eqs        18483
;  :arith-pivots            15147
;  :conflicts               2910
;  :datatype-accessor-ax    322
;  :datatype-constructor-ax 2154
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               22694
;  :del-clause              218654
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.68
;  :minimized-lits          637
;  :mk-bool-var             262265
;  :mk-clause               218761
;  :num-allocs              1300318
;  :num-checks              437
;  :propagations            110078
;  :quant-instantiations    61730
;  :restarts                2
;  :rlimit-count            5744509
;  :time                    0.01)
; [then-branch: 283 | exc@240@03 == Null | live]
; [else-branch: 283 | exc@240@03 != Null | dead]
(push) ; 24
; [then-branch: 283 | exc@240@03 == Null]
; [eval] (forall i1: Int :: { this.P_seq[i1] } { aloc(opt_get1(P), i1) } 0 <= i1 && i1 < V ==> this.P_seq[i1] == aloc(opt_get1(P), i1).int)
(declare-const i1@283@03 Int)
(push) ; 25
; [eval] 0 <= i1 && i1 < V ==> this.P_seq[i1] == aloc(opt_get1(P), i1).int
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 26
; [then-branch: 284 | 0 <= i1@283@03 | live]
; [else-branch: 284 | !(0 <= i1@283@03) | live]
(push) ; 27
; [then-branch: 284 | 0 <= i1@283@03]
(assert (<= 0 i1@283@03))
; [eval] i1 < V
(pop) ; 27
(push) ; 27
; [else-branch: 284 | !(0 <= i1@283@03)]
(assert (not (<= 0 i1@283@03)))
(pop) ; 27
(pop) ; 26
; Joined path conditions
; Joined path conditions
(push) ; 26
; [then-branch: 285 | i1@283@03 < V@26@03 && 0 <= i1@283@03 | live]
; [else-branch: 285 | !(i1@283@03 < V@26@03 && 0 <= i1@283@03) | live]
(push) ; 27
; [then-branch: 285 | i1@283@03 < V@26@03 && 0 <= i1@283@03]
(assert (and (< i1@283@03 V@26@03) (<= 0 i1@283@03)))
; [eval] this.P_seq[i1] == aloc(opt_get1(P), i1).int
; [eval] this.P_seq[i1]
(set-option :timeout 0)
(push) ; 28
(assert (not (>= i1@283@03 0)))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142765
;  :arith-add-rows          84414
;  :arith-assert-diseq      9491
;  :arith-assert-lower      43000
;  :arith-assert-upper      28161
;  :arith-bound-prop        8620
;  :arith-conflicts         1277
;  :arith-eq-adapter        26032
;  :arith-fixed-eqs         15520
;  :arith-offset-eqs        18483
;  :arith-pivots            15148
;  :conflicts               2910
;  :datatype-accessor-ax    322
;  :datatype-constructor-ax 2154
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               22694
;  :del-clause              218654
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.68
;  :minimized-lits          637
;  :mk-bool-var             262267
;  :mk-clause               218761
;  :num-allocs              1300417
;  :num-checks              438
;  :propagations            110078
;  :quant-instantiations    61730
;  :restarts                2
;  :rlimit-count            5744689)
(push) ; 28
(assert (not (<
  i1@283@03
  (Seq_length
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))
(check-sat)
; unsat
(pop) ; 28
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142765
;  :arith-add-rows          84414
;  :arith-assert-diseq      9491
;  :arith-assert-lower      43000
;  :arith-assert-upper      28161
;  :arith-bound-prop        8620
;  :arith-conflicts         1277
;  :arith-eq-adapter        26032
;  :arith-fixed-eqs         15520
;  :arith-offset-eqs        18483
;  :arith-pivots            15148
;  :conflicts               2910
;  :datatype-accessor-ax    322
;  :datatype-constructor-ax 2154
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               22694
;  :del-clause              218654
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.68
;  :minimized-lits          637
;  :mk-bool-var             262267
;  :mk-clause               218761
;  :num-allocs              1300437
;  :num-checks              439
;  :propagations            110078
;  :quant-instantiations    61730
;  :restarts                2
;  :rlimit-count            5744709)
; [eval] aloc(opt_get1(P), i1)
; [eval] opt_get1(P)
(push) ; 28
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 28
; Joined path conditions
(push) ; 28
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 29
(assert (not (< i1@283@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))))
(check-sat)
; unsat
(pop) ; 29
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142765
;  :arith-add-rows          84414
;  :arith-assert-diseq      9491
;  :arith-assert-lower      43000
;  :arith-assert-upper      28161
;  :arith-bound-prop        8620
;  :arith-conflicts         1277
;  :arith-eq-adapter        26032
;  :arith-fixed-eqs         15520
;  :arith-offset-eqs        18483
;  :arith-pivots            15148
;  :conflicts               2910
;  :datatype-accessor-ax    322
;  :datatype-constructor-ax 2154
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               22694
;  :del-clause              218654
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  19.68
;  :minimized-lits          637
;  :mk-bool-var             262267
;  :mk-clause               218761
;  :num-allocs              1300457
;  :num-checks              440
;  :propagations            110078
;  :quant-instantiations    61730
;  :restarts                2
;  :rlimit-count            5744739)
(assert (< i1@283@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(pop) ; 28
; Joined path conditions
(assert (< i1@283@03 (alen<Int> (opt_get1 $Snap.unit res@156@03))))
(declare-const sm@284@03 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef133|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
          (< (inv@267@03 r) V@26@03))
        (<= 0 (inv@267@03 r)))
      (< $Perm.No $k@266@03)
      false)
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef139|)))
(declare-const pm@285@03 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@285@03  $FPM) r)
    (+
      (+
        (+
          (+
            (+
              (ite
                (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
                $Perm.Write
                $Perm.No)
              (ite
                (and
                  (and
                    (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
                    (< (inv@267@03 r) V@26@03))
                  (<= 0 (inv@267@03 r)))
                $k@266@03
                $Perm.No))
            (ite
              (and
                (and
                  (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
                  (< (inv@261@03 r) V@26@03))
                (<= 0 (inv@261@03 r)))
              $Perm.Write
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (and
                      (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                      (< (inv@40@03 r) V@26@03))
                    (<= 0 (inv@40@03 r)))
                  $Perm.Write
                  $Perm.No)
                (pTaken@115@03 r))
              (pTaken@121@03 r))
            (pTaken@215@03 r)))
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                    (< (inv@85@03 r) V@26@03))
                  (<= 0 (inv@85@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@114@03 r))
            (pTaken@122@03 r))
          (pTaken@216@03 r)))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@285@03  $FPM) r))
  :qid |qp.resPrmSumDef140|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@285@03  $FPM) r))
  :qid |qp.resTrgDef141|)))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)))
(push) ; 28
(assert (not (<
  $Perm.No
  ($FVF.perm_int (as pm@285@03  $FPM) (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)))))
(check-sat)
; unsat
(pop) ; 28
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               145718
;  :arith-add-rows          86374
;  :arith-assert-diseq      9588
;  :arith-assert-lower      43569
;  :arith-assert-upper      28584
;  :arith-bound-prop        8805
;  :arith-conflicts         1296
;  :arith-eq-adapter        26402
;  :arith-fixed-eqs         15767
;  :arith-offset-eqs        18782
;  :arith-pivots            15348
;  :conflicts               2951
;  :datatype-accessor-ax    322
;  :datatype-constructor-ax 2154
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               24054
;  :del-clause              240361
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  20.19
;  :minimized-lits          665
;  :mk-bool-var             280365
;  :mk-clause               241086
;  :num-allocs              1334954
;  :num-checks              441
;  :propagations            114546
;  :quant-instantiations    65639
;  :restarts                2
;  :rlimit-count            5946721
;  :time                    0.09)
(pop) ; 27
(push) ; 27
; [else-branch: 285 | !(i1@283@03 < V@26@03 && 0 <= i1@283@03)]
(assert (not (and (< i1@283@03 V@26@03) (<= 0 i1@283@03))))
(pop) ; 27
(pop) ; 26
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef133|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
          (< (inv@267@03 r) V@26@03))
        (<= 0 (inv@267@03 r)))
      (< $Perm.No $k@266@03)
      false)
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@285@03  $FPM) r)
    (+
      (+
        (+
          (+
            (+
              (ite
                (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
                $Perm.Write
                $Perm.No)
              (ite
                (and
                  (and
                    (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
                    (< (inv@267@03 r) V@26@03))
                  (<= 0 (inv@267@03 r)))
                $k@266@03
                $Perm.No))
            (ite
              (and
                (and
                  (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
                  (< (inv@261@03 r) V@26@03))
                (<= 0 (inv@261@03 r)))
              $Perm.Write
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (and
                      (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                      (< (inv@40@03 r) V@26@03))
                    (<= 0 (inv@40@03 r)))
                  $Perm.Write
                  $Perm.No)
                (pTaken@115@03 r))
              (pTaken@121@03 r))
            (pTaken@215@03 r)))
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                    (< (inv@85@03 r) V@26@03))
                  (<= 0 (inv@85@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@114@03 r))
            (pTaken@122@03 r))
          (pTaken@216@03 r)))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@285@03  $FPM) r))
  :qid |qp.resPrmSumDef140|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@285@03  $FPM) r))
  :qid |qp.resTrgDef141|)))
(assert (implies
  (and (< i1@283@03 V@26@03) (<= 0 i1@283@03))
  (and
    (< i1@283@03 V@26@03)
    (<= 0 i1@283@03)
    (< i1@283@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)))))
; Joined path conditions
(pop) ; 25
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef133|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
          (< (inv@267@03 r) V@26@03))
        (<= 0 (inv@267@03 r)))
      (< $Perm.No $k@266@03)
      false)
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@285@03  $FPM) r)
    (+
      (+
        (+
          (+
            (+
              (ite
                (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
                $Perm.Write
                $Perm.No)
              (ite
                (and
                  (and
                    (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
                    (< (inv@267@03 r) V@26@03))
                  (<= 0 (inv@267@03 r)))
                $k@266@03
                $Perm.No))
            (ite
              (and
                (and
                  (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
                  (< (inv@261@03 r) V@26@03))
                (<= 0 (inv@261@03 r)))
              $Perm.Write
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (and
                      (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                      (< (inv@40@03 r) V@26@03))
                    (<= 0 (inv@40@03 r)))
                  $Perm.Write
                  $Perm.No)
                (pTaken@115@03 r))
              (pTaken@121@03 r))
            (pTaken@215@03 r)))
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                    (< (inv@85@03 r) V@26@03))
                  (<= 0 (inv@85@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@114@03 r))
            (pTaken@122@03 r))
          (pTaken@216@03 r)))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@285@03  $FPM) r))
  :qid |qp.resPrmSumDef140|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@285@03  $FPM) r))
  :qid |qp.resTrgDef141|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@283@03 Int)) (!
  (implies
    (and (< i1@283@03 V@26@03) (<= 0 i1@283@03))
    (and
      (< i1@283@03 V@26@03)
      (<= 0 i1@283@03)
      (< i1@283@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03))))
  :pattern ((Seq_index
    ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
    i1@283@03))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((i1@283@03 Int)) (!
  (implies
    (and (< i1@283@03 V@26@03) (<= 0 i1@283@03))
    (and
      (< i1@283@03 V@26@03)
      (<= 0 i1@283@03)
      (< i1@283@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
      ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef133|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
          (< (inv@267@03 r) V@26@03))
        (<= 0 (inv@267@03 r)))
      (< $Perm.No $k@266@03)
      false)
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef134|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
        (< (inv@261@03 r) V@26@03))
      (<= 0 (inv@261@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r))
  :qid |qp.fvfValDef135|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                  (< (inv@40@03 r) V@26@03))
                (<= 0 (inv@40@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@115@03 r))
          (pTaken@121@03 r))
        (pTaken@215@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r))
  :qid |qp.fvfValDef136|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and
                (and
                  (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                  (< (inv@85@03 r) V@26@03))
                (<= 0 (inv@85@03 r)))
              $Perm.Write
              $Perm.No)
            (pTaken@114@03 r))
          (pTaken@122@03 r))
        (pTaken@216@03 r)))
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r))
  :qid |qp.fvfValDef137|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and
        (and
          (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
          (< (inv@145@03 r) V@26@03))
        (<= 0 (inv@145@03 r)))
      (< $Perm.No $k@144@03)
      false)
    (=
      ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r))
  :qid |qp.fvfValDef138|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@284@03  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef139|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@285@03  $FPM) r)
    (+
      (+
        (+
          (+
            (+
              (ite
                (and (< (inv@271@03 r) V@26@03) (<= 0 (inv@271@03 r)))
                $Perm.Write
                $Perm.No)
              (ite
                (and
                  (and
                    (and (< (inv@268@03 r) V@26@03) (<= 0 (inv@268@03 r)))
                    (< (inv@267@03 r) V@26@03))
                  (<= 0 (inv@267@03 r)))
                $k@266@03
                $Perm.No))
            (ite
              (and
                (and
                  (and (< (inv@262@03 r) V@26@03) (<= 0 (inv@262@03 r)))
                  (< (inv@261@03 r) V@26@03))
                (<= 0 (inv@261@03 r)))
              $Perm.Write
              $Perm.No))
          (-
            (-
              (-
                (ite
                  (and
                    (and
                      (and (< (inv@41@03 r) V@26@03) (<= 0 (inv@41@03 r)))
                      (< (inv@40@03 r) V@26@03))
                    (<= 0 (inv@40@03 r)))
                  $Perm.Write
                  $Perm.No)
                (pTaken@115@03 r))
              (pTaken@121@03 r))
            (pTaken@215@03 r)))
        (-
          (-
            (-
              (ite
                (and
                  (and
                    (and (< (inv@86@03 r) V@26@03) (<= 0 (inv@86@03 r)))
                    (< (inv@85@03 r) V@26@03))
                  (<= 0 (inv@85@03 r)))
                $Perm.Write
                $Perm.No)
              (pTaken@114@03 r))
            (pTaken@122@03 r))
          (pTaken@216@03 r)))
      (ite
        (and
          (and
            (and (< (inv@146@03 r) V@26@03) (<= 0 (inv@146@03 r)))
            (< (inv@145@03 r) V@26@03))
          (<= 0 (inv@145@03 r)))
        $k@144@03
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@285@03  $FPM) r))
  :qid |qp.resPrmSumDef140|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@29@03)))))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@75@03))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@125@03))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@285@03  $FPM) r))
  :qid |qp.resTrgDef141|)))
(assert (implies
  (= exc@240@03 $Ref.null)
  (and
    (forall ((i1@283@03 Int)) (!
      (implies
        (and (< i1@283@03 V@26@03) (<= 0 i1@283@03))
        (and
          (< i1@283@03 V@26@03)
          (<= 0 i1@283@03)
          (< i1@283@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
          ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03))))
      :pattern ((Seq_index
        ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
        i1@283@03))
      :qid |prog.l<no position>-aux|))
    (forall ((i1@283@03 Int)) (!
      (implies
        (and (< i1@283@03 V@26@03) (<= 0 i1@283@03))
        (and
          (< i1@283@03 V@26@03)
          (<= 0 i1@283@03)
          (< i1@283@03 (alen<Int> (opt_get1 $Snap.unit res@156@03)))
          ($FVF.loc_int ($FVF.lookup_int (as sm@284@03  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (= exc@240@03 $Ref.null)
  (forall ((i1@283@03 Int)) (!
    (implies
      (and (< i1@283@03 V@26@03) (<= 0 i1@283@03))
      (=
        (Seq_index
          ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
          i1@283@03)
        ($FVF.lookup_int (as sm@284@03  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03))))
    :pattern ((Seq_index
      ($SortWrappers.$SnapToSeq<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))))
      i1@283@03))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit res@156@03) i1@283@03))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03)))))))))))))))))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> ExAugPath(this, this.Gf_seq, V, s, t) == false
; [eval] exc == null
(push) ; 23
(set-option :timeout 10)
(push) ; 24
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unknown
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146052
;  :arith-add-rows          86604
;  :arith-assert-diseq      9588
;  :arith-assert-lower      43601
;  :arith-assert-upper      28604
;  :arith-bound-prop        8818
;  :arith-conflicts         1299
;  :arith-eq-adapter        26421
;  :arith-fixed-eqs         15784
;  :arith-offset-eqs        18788
;  :arith-pivots            15414
;  :conflicts               2955
;  :datatype-accessor-ax    322
;  :datatype-constructor-ax 2158
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               24066
;  :del-clause              242746
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  20.11
;  :minimized-lits          667
;  :mk-bool-var             282571
;  :mk-clause               242853
;  :num-allocs              1347389
;  :num-checks              442
;  :propagations            114640
;  :quant-instantiations    66281
;  :restarts                2
;  :rlimit-count            6002122
;  :time                    0.01)
; [then-branch: 286 | exc@240@03 == Null | live]
; [else-branch: 286 | exc@240@03 != Null | dead]
(push) ; 24
; [then-branch: 286 | exc@240@03 == Null]
; [eval] ExAugPath(this, this.Gf_seq, V, s, t) == false
; [eval] ExAugPath(this, this.Gf_seq, V, s, t)
(push) ; 25
; [eval] this != null
; [eval] SquareIntMatrix(this, G, V)
(push) ; 26
; [eval] this != null
(pop) ; 26
; Joined path conditions
(set-option :timeout 0)
(push) ; 26
(assert (not (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))) V@26@03)))
(check-sat)
; unsat
(pop) ; 26
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146052
;  :arith-add-rows          86604
;  :arith-assert-diseq      9588
;  :arith-assert-lower      43601
;  :arith-assert-upper      28604
;  :arith-bound-prop        8818
;  :arith-conflicts         1299
;  :arith-eq-adapter        26421
;  :arith-fixed-eqs         15784
;  :arith-offset-eqs        18788
;  :arith-pivots            15414
;  :conflicts               2955
;  :datatype-accessor-ax    322
;  :datatype-constructor-ax 2158
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               24066
;  :del-clause              242746
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  20.11
;  :minimized-lits          667
;  :mk-bool-var             282571
;  :mk-clause               242853
;  :num-allocs              1347413
;  :num-checks              443
;  :propagations            114640
;  :quant-instantiations    66281
;  :restarts                2
;  :rlimit-count            6002146)
(assert (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))) V@26@03))
(pop) ; 25
; Joined path conditions
(assert (SquareIntMatrix $Snap.unit this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))) V@26@03))
(pop) ; 24
(pop) ; 23
; Joined path conditions
(assert (implies
  (= exc@240@03 $Ref.null)
  (=
    (ExAugPath ($Snap.combine $Snap.unit $Snap.unit) this@21@03 ($SortWrappers.$SnapToSeq<Seq<Int>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@242@03))))))))))))))))) V@26@03 s@24@03 t@25@03)
    false)))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unsat
; [eval] exc != null
; [then-branch: 287 | exc@240@03 != Null | dead]
; [else-branch: 287 | exc@240@03 == Null | live]
(push) ; 23
; [else-branch: 287 | exc@240@03 == Null]
(pop) ; 23
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 23
(assert (not (not (= exc@240@03 $Ref.null))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               146055
;  :arith-add-rows          86618
;  :arith-assert-diseq      9588
;  :arith-assert-lower      43601
;  :arith-assert-upper      28604
;  :arith-bound-prop        8819
;  :arith-conflicts         1299
;  :arith-eq-adapter        26421
;  :arith-fixed-eqs         15785
;  :arith-offset-eqs        18788
;  :arith-pivots            15414
;  :conflicts               2957
;  :datatype-accessor-ax    322
;  :datatype-constructor-ax 2158
;  :datatype-occurs-check   1105
;  :datatype-splits         1474
;  :decisions               24066
;  :del-clause              242746
;  :final-checks            356
;  :interface-eqs           27
;  :max-generation          14
;  :max-memory              20.49
;  :memory                  20.12
;  :minimized-lits          667
;  :mk-bool-var             282678
;  :mk-clause               242989
;  :num-allocs              1348105
;  :num-checks              445
;  :propagations            114652
;  :quant-instantiations    66294
;  :restarts                2
;  :rlimit-count            6004414)
; [then-branch: 288 | exc@240@03 == Null | dead]
; [else-branch: 288 | exc@240@03 != Null | live]
(push) ; 23
; [else-branch: 288 | exc@240@03 != Null]
(assert (not (= exc@240@03 $Ref.null)))
(pop) ; 23
(pop) ; 22
(pop) ; 21
(pop) ; 20
(pop) ; 19
(pop) ; 18
(pop) ; 17
(pop) ; 16
(pop) ; 15
(pop) ; 14
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
