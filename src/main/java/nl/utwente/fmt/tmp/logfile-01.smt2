(get-info :version)
; (:version "4.8.6")
; Started: 2022-06-09 19:28:09
; Silicon.version: 1.1-SNAPSHOT (cd20cf02@(detached))
; Input file: -
; Verifier id: 00
; ------------------------------------------------------------
; Begin preamble
; ////////// Static preamble
; 
; ; /z3config.smt2
(set-option :print-success true) ; Boogie: false
(set-option :global-decls true) ; Boogie: default
(set-option :auto_config false) ; Usually a good idea
(set-option :smt.restart_strategy 0)
(set-option :smt.restart_factor |1.5|)
(set-option :smt.case_split 3)
(set-option :smt.delay_units true)
(set-option :smt.delay_units_threshold 16)
(set-option :nnf.sk_hack true)
(set-option :type_check true)
(set-option :smt.bv.reflect true)
(set-option :smt.mbqi false)
(set-option :smt.qi.eager_threshold 100)
(set-option :smt.qi.cost "(+ weight generation)")
(set-option :smt.qi.max_multi_patterns 1000)
(set-option :smt.phase_selection 0) ; default: 3, Boogie: 0
(set-option :sat.phase caching)
(set-option :sat.random_seed 0)
(set-option :nlsat.randomize true)
(set-option :nlsat.seed 0)
(set-option :nlsat.shuffle_vars false)
(set-option :fp.spacer.order_children 0) ; Not available with Z3 4.5
(set-option :fp.spacer.random_seed 0) ; Not available with Z3 4.5
(set-option :smt.arith.random_initial_value true) ; Boogie: true
(set-option :smt.random_seed 0)
(set-option :sls.random_offset true)
(set-option :sls.random_seed 0)
(set-option :sls.restart_init false)
(set-option :sls.walksat_ucb true)
(set-option :model.v2 true)
; 
; ; /preamble.smt2
(declare-datatypes () ((
    $Snap ($Snap.unit)
    ($Snap.combine ($Snap.first $Snap) ($Snap.second $Snap)))))
(declare-sort $Ref 0)
(declare-const $Ref.null $Ref)
(declare-sort $FPM)
(declare-sort $PPM)
(define-sort $Perm () Real)
(define-const $Perm.Write $Perm 1.0)
(define-const $Perm.No $Perm 0.0)
(define-fun $Perm.isValidVar ((p $Perm)) Bool
	(<= $Perm.No p))
(define-fun $Perm.isReadVar ((p $Perm) (ub $Perm)) Bool
    (and ($Perm.isValidVar p)
         (not (= p $Perm.No))
         (< p $Perm.Write)))
(define-fun $Perm.min ((p1 $Perm) (p2 $Perm)) Real
    (ite (<= p1 p2) p1 p2))
(define-fun $Math.min ((a Int) (b Int)) Int
    (ite (<= a b) a b))
(define-fun $Math.clip ((a Int)) Int
    (ite (< a 0) 0 a))
; ////////// Sorts
(declare-sort Seq<Int>)
(declare-sort Set<option<array>>)
(declare-sort Set<Bool>)
(declare-sort Set<Int>)
(declare-sort Set<$Ref>)
(declare-sort Set<$Snap>)
(declare-sort t_null)
(declare-sort any)
(declare-sort void)
(declare-sort option<any>)
(declare-sort option<array>)
(declare-sort array)
(declare-sort $FVF<Int>)
(declare-sort $FVF<option<array>>)
(declare-sort $FVF<Bool>)
(declare-sort $FVF<$Ref>)
; ////////// Sort wrappers
; Declaring additional sort wrappers
(declare-fun $SortWrappers.IntTo$Snap (Int) $Snap)
(declare-fun $SortWrappers.$SnapToInt ($Snap) Int)
(assert (forall ((x Int)) (!
    (= x ($SortWrappers.$SnapToInt($SortWrappers.IntTo$Snap x)))
    :pattern (($SortWrappers.IntTo$Snap x))
    :qid |$Snap.$SnapToIntTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.IntTo$Snap($SortWrappers.$SnapToInt x)))
    :pattern (($SortWrappers.$SnapToInt x))
    :qid |$Snap.IntTo$SnapToInt|
    )))
(declare-fun $SortWrappers.BoolTo$Snap (Bool) $Snap)
(declare-fun $SortWrappers.$SnapToBool ($Snap) Bool)
(assert (forall ((x Bool)) (!
    (= x ($SortWrappers.$SnapToBool($SortWrappers.BoolTo$Snap x)))
    :pattern (($SortWrappers.BoolTo$Snap x))
    :qid |$Snap.$SnapToBoolTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.BoolTo$Snap($SortWrappers.$SnapToBool x)))
    :pattern (($SortWrappers.$SnapToBool x))
    :qid |$Snap.BoolTo$SnapToBool|
    )))
(declare-fun $SortWrappers.$RefTo$Snap ($Ref) $Snap)
(declare-fun $SortWrappers.$SnapTo$Ref ($Snap) $Ref)
(assert (forall ((x $Ref)) (!
    (= x ($SortWrappers.$SnapTo$Ref($SortWrappers.$RefTo$Snap x)))
    :pattern (($SortWrappers.$RefTo$Snap x))
    :qid |$Snap.$SnapTo$RefTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$RefTo$Snap($SortWrappers.$SnapTo$Ref x)))
    :pattern (($SortWrappers.$SnapTo$Ref x))
    :qid |$Snap.$RefTo$SnapTo$Ref|
    )))
(declare-fun $SortWrappers.$PermTo$Snap ($Perm) $Snap)
(declare-fun $SortWrappers.$SnapTo$Perm ($Snap) $Perm)
(assert (forall ((x $Perm)) (!
    (= x ($SortWrappers.$SnapTo$Perm($SortWrappers.$PermTo$Snap x)))
    :pattern (($SortWrappers.$PermTo$Snap x))
    :qid |$Snap.$SnapTo$PermTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$PermTo$Snap($SortWrappers.$SnapTo$Perm x)))
    :pattern (($SortWrappers.$SnapTo$Perm x))
    :qid |$Snap.$PermTo$SnapTo$Perm|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Seq<Int>To$Snap (Seq<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSeq<Int> ($Snap) Seq<Int>)
(assert (forall ((x Seq<Int>)) (!
    (= x ($SortWrappers.$SnapToSeq<Int>($SortWrappers.Seq<Int>To$Snap x)))
    :pattern (($SortWrappers.Seq<Int>To$Snap x))
    :qid |$Snap.$SnapToSeq<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Seq<Int>To$Snap($SortWrappers.$SnapToSeq<Int> x)))
    :pattern (($SortWrappers.$SnapToSeq<Int> x))
    :qid |$Snap.Seq<Int>To$SnapToSeq<Int>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.Set<option<array>>To$Snap (Set<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<option<array>> ($Snap) Set<option<array>>)
(assert (forall ((x Set<option<array>>)) (!
    (= x ($SortWrappers.$SnapToSet<option<array>>($SortWrappers.Set<option<array>>To$Snap x)))
    :pattern (($SortWrappers.Set<option<array>>To$Snap x))
    :qid |$Snap.$SnapToSet<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<option<array>>To$Snap($SortWrappers.$SnapToSet<option<array>> x)))
    :pattern (($SortWrappers.$SnapToSet<option<array>> x))
    :qid |$Snap.Set<option<array>>To$SnapToSet<option<array>>|
    )))
(declare-fun $SortWrappers.Set<Bool>To$Snap (Set<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Bool> ($Snap) Set<Bool>)
(assert (forall ((x Set<Bool>)) (!
    (= x ($SortWrappers.$SnapToSet<Bool>($SortWrappers.Set<Bool>To$Snap x)))
    :pattern (($SortWrappers.Set<Bool>To$Snap x))
    :qid |$Snap.$SnapToSet<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Bool>To$Snap($SortWrappers.$SnapToSet<Bool> x)))
    :pattern (($SortWrappers.$SnapToSet<Bool> x))
    :qid |$Snap.Set<Bool>To$SnapToSet<Bool>|
    )))
(declare-fun $SortWrappers.Set<Int>To$Snap (Set<Int>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<Int> ($Snap) Set<Int>)
(assert (forall ((x Set<Int>)) (!
    (= x ($SortWrappers.$SnapToSet<Int>($SortWrappers.Set<Int>To$Snap x)))
    :pattern (($SortWrappers.Set<Int>To$Snap x))
    :qid |$Snap.$SnapToSet<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<Int>To$Snap($SortWrappers.$SnapToSet<Int> x)))
    :pattern (($SortWrappers.$SnapToSet<Int> x))
    :qid |$Snap.Set<Int>To$SnapToSet<Int>|
    )))
(declare-fun $SortWrappers.Set<$Ref>To$Snap (Set<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Ref> ($Snap) Set<$Ref>)
(assert (forall ((x Set<$Ref>)) (!
    (= x ($SortWrappers.$SnapToSet<$Ref>($SortWrappers.Set<$Ref>To$Snap x)))
    :pattern (($SortWrappers.Set<$Ref>To$Snap x))
    :qid |$Snap.$SnapToSet<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Ref>To$Snap($SortWrappers.$SnapToSet<$Ref> x)))
    :pattern (($SortWrappers.$SnapToSet<$Ref> x))
    :qid |$Snap.Set<$Ref>To$SnapToSet<$Ref>|
    )))
(declare-fun $SortWrappers.Set<$Snap>To$Snap (Set<$Snap>) $Snap)
(declare-fun $SortWrappers.$SnapToSet<$Snap> ($Snap) Set<$Snap>)
(assert (forall ((x Set<$Snap>)) (!
    (= x ($SortWrappers.$SnapToSet<$Snap>($SortWrappers.Set<$Snap>To$Snap x)))
    :pattern (($SortWrappers.Set<$Snap>To$Snap x))
    :qid |$Snap.$SnapToSet<$Snap>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.Set<$Snap>To$Snap($SortWrappers.$SnapToSet<$Snap> x)))
    :pattern (($SortWrappers.$SnapToSet<$Snap> x))
    :qid |$Snap.Set<$Snap>To$SnapToSet<$Snap>|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.t_nullTo$Snap (t_null) $Snap)
(declare-fun $SortWrappers.$SnapTot_null ($Snap) t_null)
(assert (forall ((x t_null)) (!
    (= x ($SortWrappers.$SnapTot_null($SortWrappers.t_nullTo$Snap x)))
    :pattern (($SortWrappers.t_nullTo$Snap x))
    :qid |$Snap.$SnapTot_nullTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.t_nullTo$Snap($SortWrappers.$SnapTot_null x)))
    :pattern (($SortWrappers.$SnapTot_null x))
    :qid |$Snap.t_nullTo$SnapTot_null|
    )))
(declare-fun $SortWrappers.anyTo$Snap (any) $Snap)
(declare-fun $SortWrappers.$SnapToany ($Snap) any)
(assert (forall ((x any)) (!
    (= x ($SortWrappers.$SnapToany($SortWrappers.anyTo$Snap x)))
    :pattern (($SortWrappers.anyTo$Snap x))
    :qid |$Snap.$SnapToanyTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.anyTo$Snap($SortWrappers.$SnapToany x)))
    :pattern (($SortWrappers.$SnapToany x))
    :qid |$Snap.anyTo$SnapToany|
    )))
(declare-fun $SortWrappers.voidTo$Snap (void) $Snap)
(declare-fun $SortWrappers.$SnapTovoid ($Snap) void)
(assert (forall ((x void)) (!
    (= x ($SortWrappers.$SnapTovoid($SortWrappers.voidTo$Snap x)))
    :pattern (($SortWrappers.voidTo$Snap x))
    :qid |$Snap.$SnapTovoidTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.voidTo$Snap($SortWrappers.$SnapTovoid x)))
    :pattern (($SortWrappers.$SnapTovoid x))
    :qid |$Snap.voidTo$SnapTovoid|
    )))
(declare-fun $SortWrappers.option<any>To$Snap (option<any>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<any> ($Snap) option<any>)
(assert (forall ((x option<any>)) (!
    (= x ($SortWrappers.$SnapTooption<any>($SortWrappers.option<any>To$Snap x)))
    :pattern (($SortWrappers.option<any>To$Snap x))
    :qid |$Snap.$SnapTooption<any>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<any>To$Snap($SortWrappers.$SnapTooption<any> x)))
    :pattern (($SortWrappers.$SnapTooption<any> x))
    :qid |$Snap.option<any>To$SnapTooption<any>|
    )))
(declare-fun $SortWrappers.option<array>To$Snap (option<array>) $Snap)
(declare-fun $SortWrappers.$SnapTooption<array> ($Snap) option<array>)
(assert (forall ((x option<array>)) (!
    (= x ($SortWrappers.$SnapTooption<array>($SortWrappers.option<array>To$Snap x)))
    :pattern (($SortWrappers.option<array>To$Snap x))
    :qid |$Snap.$SnapTooption<array>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.option<array>To$Snap($SortWrappers.$SnapTooption<array> x)))
    :pattern (($SortWrappers.$SnapTooption<array> x))
    :qid |$Snap.option<array>To$SnapTooption<array>|
    )))
(declare-fun $SortWrappers.arrayTo$Snap (array) $Snap)
(declare-fun $SortWrappers.$SnapToarray ($Snap) array)
(assert (forall ((x array)) (!
    (= x ($SortWrappers.$SnapToarray($SortWrappers.arrayTo$Snap x)))
    :pattern (($SortWrappers.arrayTo$Snap x))
    :qid |$Snap.$SnapToarrayTo$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.arrayTo$Snap($SortWrappers.$SnapToarray x)))
    :pattern (($SortWrappers.$SnapToarray x))
    :qid |$Snap.arrayTo$SnapToarray|
    )))
; Declaring additional sort wrappers
(declare-fun $SortWrappers.$FVF<Int>To$Snap ($FVF<Int>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Int> ($Snap) $FVF<Int>)
(assert (forall ((x $FVF<Int>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Int>($SortWrappers.$FVF<Int>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Int>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Int>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Int>To$Snap($SortWrappers.$SnapTo$FVF<Int> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Int> x))
    :qid |$Snap.$FVF<Int>To$SnapTo$FVF<Int>|
    )))
(declare-fun $SortWrappers.$FVF<option<array>>To$Snap ($FVF<option<array>>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<option<array>> ($Snap) $FVF<option<array>>)
(assert (forall ((x $FVF<option<array>>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<option<array>>($SortWrappers.$FVF<option<array>>To$Snap x)))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<option<array>>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<option<array>>To$Snap($SortWrappers.$SnapTo$FVF<option<array>> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<option<array>> x))
    :qid |$Snap.$FVF<option<array>>To$SnapTo$FVF<option<array>>|
    )))
(declare-fun $SortWrappers.$FVF<Bool>To$Snap ($FVF<Bool>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<Bool> ($Snap) $FVF<Bool>)
(assert (forall ((x $FVF<Bool>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<Bool>($SortWrappers.$FVF<Bool>To$Snap x)))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<Bool>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<Bool>To$Snap($SortWrappers.$SnapTo$FVF<Bool> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<Bool> x))
    :qid |$Snap.$FVF<Bool>To$SnapTo$FVF<Bool>|
    )))
(declare-fun $SortWrappers.$FVF<$Ref>To$Snap ($FVF<$Ref>) $Snap)
(declare-fun $SortWrappers.$SnapTo$FVF<$Ref> ($Snap) $FVF<$Ref>)
(assert (forall ((x $FVF<$Ref>)) (!
    (= x ($SortWrappers.$SnapTo$FVF<$Ref>($SortWrappers.$FVF<$Ref>To$Snap x)))
    :pattern (($SortWrappers.$FVF<$Ref>To$Snap x))
    :qid |$Snap.$SnapTo$FVF<$Ref>To$Snap|
    )))
(assert (forall ((x $Snap)) (!
    (= x ($SortWrappers.$FVF<$Ref>To$Snap($SortWrappers.$SnapTo$FVF<$Ref> x)))
    :pattern (($SortWrappers.$SnapTo$FVF<$Ref> x))
    :qid |$Snap.$FVF<$Ref>To$SnapTo$FVF<$Ref>|
    )))
; ////////// Symbols
(declare-fun Set_in (option<array> Set<option<array>>) Bool)
(declare-fun Set_card (Set<option<array>>) Int)
(declare-const Set_empty Set<option<array>>)
(declare-fun Set_singleton (option<array>) Set<option<array>>)
(declare-fun Set_unionone (Set<option<array>> option<array>) Set<option<array>>)
(declare-fun Set_union (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_disjoint (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_difference (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_intersection (Set<option<array>> Set<option<array>>) Set<option<array>>)
(declare-fun Set_subset (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_equal (Set<option<array>> Set<option<array>>) Bool)
(declare-fun Set_in (Bool Set<Bool>) Bool)
(declare-fun Set_card (Set<Bool>) Int)
(declare-const Set_empty Set<Bool>)
(declare-fun Set_singleton (Bool) Set<Bool>)
(declare-fun Set_unionone (Set<Bool> Bool) Set<Bool>)
(declare-fun Set_union (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_disjoint (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_difference (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_intersection (Set<Bool> Set<Bool>) Set<Bool>)
(declare-fun Set_subset (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_equal (Set<Bool> Set<Bool>) Bool)
(declare-fun Set_in (Int Set<Int>) Bool)
(declare-fun Set_card (Set<Int>) Int)
(declare-const Set_empty Set<Int>)
(declare-fun Set_singleton (Int) Set<Int>)
(declare-fun Set_unionone (Set<Int> Int) Set<Int>)
(declare-fun Set_union (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_disjoint (Set<Int> Set<Int>) Bool)
(declare-fun Set_difference (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_intersection (Set<Int> Set<Int>) Set<Int>)
(declare-fun Set_subset (Set<Int> Set<Int>) Bool)
(declare-fun Set_equal (Set<Int> Set<Int>) Bool)
(declare-fun Set_in ($Ref Set<$Ref>) Bool)
(declare-fun Set_card (Set<$Ref>) Int)
(declare-const Set_empty Set<$Ref>)
(declare-fun Set_singleton ($Ref) Set<$Ref>)
(declare-fun Set_unionone (Set<$Ref> $Ref) Set<$Ref>)
(declare-fun Set_union (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_disjoint (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_difference (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_intersection (Set<$Ref> Set<$Ref>) Set<$Ref>)
(declare-fun Set_subset (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_equal (Set<$Ref> Set<$Ref>) Bool)
(declare-fun Set_in ($Snap Set<$Snap>) Bool)
(declare-fun Set_card (Set<$Snap>) Int)
(declare-const Set_empty Set<$Snap>)
(declare-fun Set_singleton ($Snap) Set<$Snap>)
(declare-fun Set_unionone (Set<$Snap> $Snap) Set<$Snap>)
(declare-fun Set_union (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_disjoint (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_difference (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_intersection (Set<$Snap> Set<$Snap>) Set<$Snap>)
(declare-fun Set_subset (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Set_equal (Set<$Snap> Set<$Snap>) Bool)
(declare-fun Seq_length (Seq<Int>) Int)
(declare-const Seq_empty Seq<Int>)
(declare-fun Seq_singleton (Int) Seq<Int>)
(declare-fun Seq_build (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_index (Seq<Int> Int) Int)
(declare-fun Seq_append (Seq<Int> Seq<Int>) Seq<Int>)
(declare-fun Seq_update (Seq<Int> Int Int) Seq<Int>)
(declare-fun Seq_contains (Seq<Int> Int) Bool)
(declare-fun Seq_take (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_drop (Seq<Int> Int) Seq<Int>)
(declare-fun Seq_equal (Seq<Int> Seq<Int>) Bool)
(declare-fun Seq_sameuntil (Seq<Int> Seq<Int> Int) Bool)
(declare-fun Seq_range (Int Int) Seq<Int>)
(declare-fun array_loc<Ref> (array Int) $Ref)
(declare-fun alen<Int> (array) Int)
(declare-fun loc_inv_1<array> ($Ref) array)
(declare-fun loc_inv_2<Int> ($Ref) Int)
(declare-const None<option<array>> option<array>)
(declare-fun some<option<array>> (array) option<array>)
(declare-fun option_get<array> (option<array>) array)
(declare-const v_null<t_null> t_null)
(declare-const None<option<any>> option<any>)
(declare-fun some<option<any>> (any) option<any>)
(declare-fun option_get<any> (option<any>) any)
(declare-const unit<void> void)
; /field_value_functions_declarations.smt2 [int: Int]
(declare-fun $FVF.domain_int ($FVF<Int>) Set<$Ref>)
(declare-fun $FVF.lookup_int ($FVF<Int> $Ref) Int)
(declare-fun $FVF.after_int ($FVF<Int> $FVF<Int>) Bool)
(declare-fun $FVF.loc_int (Int $Ref) Bool)
(declare-fun $FVF.perm_int ($FPM $Ref) $Perm)
(declare-const $fvfTOP_int $FVF<Int>)
; /field_value_functions_declarations.smt2 [option$array$: option[array]]
(declare-fun $FVF.domain_option$array$ ($FVF<option<array>>) Set<$Ref>)
(declare-fun $FVF.lookup_option$array$ ($FVF<option<array>> $Ref) option<array>)
(declare-fun $FVF.after_option$array$ ($FVF<option<array>> $FVF<option<array>>) Bool)
(declare-fun $FVF.loc_option$array$ (option<array> $Ref) Bool)
(declare-fun $FVF.perm_option$array$ ($FPM $Ref) $Perm)
(declare-const $fvfTOP_option$array$ $FVF<option<array>>)
; /field_value_functions_declarations.smt2 [bool: Bool]
(declare-fun $FVF.domain_bool ($FVF<Bool>) Set<$Ref>)
(declare-fun $FVF.lookup_bool ($FVF<Bool> $Ref) Bool)
(declare-fun $FVF.after_bool ($FVF<Bool> $FVF<Bool>) Bool)
(declare-fun $FVF.loc_bool (Bool $Ref) Bool)
(declare-fun $FVF.perm_bool ($FPM $Ref) $Perm)
(declare-const $fvfTOP_bool $FVF<Bool>)
; Declaring symbols related to program functions (from program analysis)
(declare-fun aloc ($Snap array Int) $Ref)
(declare-fun aloc%limited ($Snap array Int) $Ref)
(declare-fun aloc%stateless (array Int) Bool)
(declare-fun opt_get1 ($Snap option<array>) array)
(declare-fun opt_get1%limited ($Snap option<array>) array)
(declare-fun opt_get1%stateless (option<array>) Bool)
(declare-fun any_as ($Snap any) any)
(declare-fun any_as%limited ($Snap any) any)
(declare-fun any_as%stateless (any) Bool)
(declare-fun opt_get ($Snap option<any>) any)
(declare-fun opt_get%limited ($Snap option<any>) any)
(declare-fun opt_get%stateless (option<any>) Bool)
(declare-fun lemma_skew_symetry ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_skew_symetry%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_skew_symetry%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun FlowNetwork%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun ExPath ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun ExPath%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun ExPath%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun value ($Snap $Ref option<array> Int Int Int) Int)
(declare-fun value%limited ($Snap $Ref option<array> Int Int Int) Int)
(declare-fun value%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun valid_graph_vertices ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun valid_graph_vertices%stateless ($Ref option<array> Int) Bool)
(declare-fun scale ($Snap $Perm) $Perm)
(declare-fun scale%limited ($Snap $Perm) $Perm)
(declare-fun scale%stateless ($Perm) Bool)
(declare-fun as_any ($Snap any) any)
(declare-fun as_any%limited ($Snap any) any)
(declare-fun as_any%stateless (any) Bool)
(declare-fun ResidualNetwork ($Snap $Ref option<array> Int) Bool)
(declare-fun ResidualNetwork%limited ($Snap $Ref option<array> Int) Bool)
(declare-fun ResidualNetwork%stateless ($Ref option<array> Int) Bool)
(declare-fun type ($Snap $Ref) Int)
(declare-fun type%limited ($Snap $Ref) Int)
(declare-fun type%stateless ($Ref) Bool)
(declare-fun lemma_max_flow_min_cut ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_max_flow_min_cut%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_max_flow_min_cut%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun lemma_capacity_constrain ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_capacity_constrain%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_capacity_constrain%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun opt_or_else ($Snap option<any> any) any)
(declare-fun opt_or_else%limited ($Snap option<any> any) any)
(declare-fun opt_or_else%stateless (option<any> any) Bool)
(declare-fun valid_graph_vertices1 ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%limited ($Snap $Ref Seq<Int> Int) Bool)
(declare-fun valid_graph_vertices1%stateless ($Ref Seq<Int> Int) Bool)
(declare-fun flow ($Snap $Ref option<array> Int Int Int) Int)
(declare-fun flow%limited ($Snap $Ref option<array> Int Int Int) Int)
(declare-fun flow%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun lemma_flow_conservation ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_flow_conservation%limited ($Snap $Ref option<array> Int Int Int) Bool)
(declare-fun lemma_flow_conservation%stateless ($Ref option<array> Int Int Int) Bool)
(declare-fun subtype ($Snap Int Int) Bool)
(declare-fun subtype%limited ($Snap Int Int) Bool)
(declare-fun subtype%stateless (Int Int) Bool)
; Snapshot variable to be used during function verification
(declare-fun s@$ () $Snap)
; Declaring predicate trigger functions
(declare-fun lock_inv_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_FordFulkerson%trigger ($Snap $Ref) Bool)
(declare-fun lock_inv_Object%trigger ($Snap $Ref) Bool)
(declare-fun lock_held_Object%trigger ($Snap $Ref) Bool)
; ////////// Uniqueness assumptions from domains
; ////////// Axioms
(assert (forall ((s Seq<Int>)) (!
  (<= 0 (Seq_length s))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.seq_length_non_negative|)))
(assert (= (Seq_length (as Seq_empty  Seq<Int>)) 0))
(assert (forall ((s Seq<Int>)) (!
  (implies (= (Seq_length s) 0) (= s (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_length s))
  :qid |$Seq[Int]_prog.only_empty_seq_length_zero|)))
(assert (forall ((e Int)) (!
  (= (Seq_length (Seq_singleton e)) 1)
  :pattern ((Seq_length (Seq_singleton e)))
  :qid |$Seq[Int]_prog.length_singleton_seq|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (= (Seq_length (Seq_build s e)) (+ 1 (Seq_length s)))
  :pattern ((Seq_length (Seq_build s e)))
  :qid |$Seq[Int]_prog.length_seq_build_inc_by_one|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (ite
    (= i (Seq_length s))
    (= (Seq_index (Seq_build s e) i) e)
    (= (Seq_index (Seq_build s e) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_build s e) i))
  :qid |$Seq[Int]_prog.seq_index_over_build|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (= (Seq_length (Seq_append s1 s2)) (+ (Seq_length s1) (Seq_length s2))))
  :pattern ((Seq_length (Seq_append s1 s2)))
  :qid |$Seq[Int]_prog.seq_length_over_append|)))
(assert (forall ((e Int)) (!
  (= (Seq_index (Seq_singleton e) 0) e)
  :pattern ((Seq_index (Seq_singleton e) 0))
  :qid |$Seq[Int]_prog.seq_index_over_singleton|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_singleton e1) e2) (= e1 e2))
  :pattern ((Seq_contains (Seq_singleton e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_singleton|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append (as Seq_empty  Seq<Int>) s) s)
  :pattern ((Seq_append (as Seq_empty  Seq<Int>) s))
  :qid |$Seq[Int]_prog.seq_append_empty_left|)))
(assert (forall ((s Seq<Int>)) (!
  (= (Seq_append s (as Seq_empty  Seq<Int>)) s)
  :pattern ((Seq_append s (as Seq_empty  Seq<Int>)))
  :qid |$Seq[Int]_prog.seq_append_empty_right|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (i Int)) (!
  (implies
    (and
      (not (= s1 (as Seq_empty  Seq<Int>)))
      (not (= s2 (as Seq_empty  Seq<Int>))))
    (ite
      (< i (Seq_length s1))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s1 i))
      (= (Seq_index (Seq_append s1 s2) i) (Seq_index s2 (- i (Seq_length s1))))))
  :pattern ((Seq_index (Seq_append s1 s2) i))
  :pattern ((Seq_index s1 i) (Seq_append s1 s2))
  :qid |$Seq[Int]_prog.seq_index_over_append|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int)) (!
  (implies
    (and (<= 0 i) (< i (Seq_length s)))
    (= (Seq_length (Seq_update s i e)) (Seq_length s)))
  :pattern ((Seq_length (Seq_update s i e)))
  :qid |$Seq[Int]_prog.seq_length_invariant_over_update|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (j Int)) (!
  (ite
    (implies (and (<= 0 i) (< i (Seq_length s))) (= i j))
    (= (Seq_index (Seq_update s i e) j) e)
    (= (Seq_index (Seq_update s i e) j) (Seq_index s j)))
  :pattern ((Seq_index (Seq_update s i e) j))
  :qid |$Seq[Int]_prog.seq_index_over_update|)))
(assert (forall ((s Seq<Int>) (e Int)) (!
  (=
    (Seq_contains s e)
    (exists ((i Int)) (!
      (and (<= 0 i) (and (< i (Seq_length s)) (= (Seq_index s i) e)))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains s e))
  :qid |$Seq[Int]_prog.seq_element_contains_index_exists|)))
(assert (forall ((e Int)) (!
  (not (Seq_contains (as Seq_empty  Seq<Int>) e))
  :pattern ((Seq_contains (as Seq_empty  Seq<Int>) e))
  :qid |$Seq[Int]_prog.empty_seq_contains_nothing|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (e Int)) (!
  (=
    (Seq_contains (Seq_append s1 s2) e)
    (or (Seq_contains s1 e) (Seq_contains s2 e)))
  :pattern ((Seq_contains (Seq_append s1 s2) e))
  :qid |$Seq[Int]_prog.seq_contains_over_append|)))
(assert (forall ((s Seq<Int>) (e1 Int) (e2 Int)) (!
  (= (Seq_contains (Seq_build s e1) e2) (or (= e1 e2) (Seq_contains s e2)))
  :pattern ((Seq_contains (Seq_build s e1) e2))
  :qid |$Seq[Int]_prog.seq_contains_over_build|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_take s n) (as Seq_empty  Seq<Int>)))
  :pattern ((Seq_take s n))
  :qid |$Seq[Int]_prog.seq_take_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_take s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (< i n) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_take s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_take_index_exists|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies (<= n 0) (= (Seq_drop s n) s))
  :pattern ((Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_drop_negative_length|)))
(assert (forall ((s Seq<Int>) (n Int) (e Int)) (!
  (=
    (Seq_contains (Seq_drop s n) e)
    (exists ((i Int)) (!
      (and
        (<= 0 i)
        (and (<= n i) (and (< i (Seq_length s)) (= (Seq_index s i) e))))
      :pattern ((Seq_index s i))
      )))
  :pattern ((Seq_contains (Seq_drop s n) e))
  :qid |$Seq[Int]_prog.seq_contains_over_drop_index_exists|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (=
    (Seq_equal s1 s2)
    (and
      (= (Seq_length s1) (Seq_length s2))
      (forall ((i Int)) (!
        (implies
          (and (<= 0 i) (< i (Seq_length s1)))
          (= (Seq_index s1 i) (Seq_index s2 i)))
        :pattern ((Seq_index s1 i))
        :pattern ((Seq_index s2 i))
        ))))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.extensional_seq_equality|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>)) (!
  (implies (Seq_equal s1 s2) (= s1 s2))
  :pattern ((Seq_equal s1 s2))
  :qid |$Seq[Int]_prog.seq_equality_identity|)))
(assert (forall ((s1 Seq<Int>) (s2 Seq<Int>) (n Int)) (!
  (=
    (Seq_sameuntil s1 s2 n)
    (forall ((i Int)) (!
      (implies (and (<= 0 i) (< i n)) (= (Seq_index s1 i) (Seq_index s2 i)))
      :pattern ((Seq_index s1 i))
      :pattern ((Seq_index s2 i))
      )))
  :pattern ((Seq_sameuntil s1 s2 n))
  :qid |$Seq[Int]_prog.extensional_seq_equality_prefix|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_take s n)) n)
      (= (Seq_length (Seq_take s n)) (Seq_length s))))
  :pattern ((Seq_length (Seq_take s n)))
  :qid |$Seq[Int]_prog.seq_length_over_take|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< i (Seq_length s))))
    (= (Seq_index (Seq_take s n) i) (Seq_index s i)))
  :pattern ((Seq_index (Seq_take s n) i))
  :pattern ((Seq_index s i) (Seq_take s n))
  :qid |$Seq[Int]_prog.seq_index_over_take|)))
(assert (forall ((s Seq<Int>) (n Int)) (!
  (implies
    (<= 0 n)
    (ite
      (<= n (Seq_length s))
      (= (Seq_length (Seq_drop s n)) (- (Seq_length s) n))
      (= (Seq_length (Seq_drop s n)) 0)))
  :pattern ((Seq_length (Seq_drop s n)))
  :qid |$Seq[Int]_prog.seq_length_over_drop|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= 0 i) (< i (- (Seq_length s) n))))
    (= (Seq_index (Seq_drop s n) i) (Seq_index s (+ i n))))
  :pattern ((Seq_index (Seq_drop s n) i))
  :qid |$Seq[Int]_prog.seq_index_over_drop_1|)))
(assert (forall ((s Seq<Int>) (n Int) (i Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_index (Seq_drop s n) (- i n)) (Seq_index s i)))
  :pattern ((Seq_index s i) (Seq_drop s n))
  :qid |$Seq[Int]_prog.seq_index_over_drop_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_take (Seq_update s i e) n) (Seq_update (Seq_take s n) i e)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= n i) (< i (Seq_length s)))
    (= (Seq_take (Seq_update s i e) n) (Seq_take s n)))
  :pattern ((Seq_take (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_take_over_update_2|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (and (<= n i) (< i (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_update (Seq_drop s n) (- i n) e)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_1|)))
(assert (forall ((s Seq<Int>) (i Int) (e Int) (n Int)) (!
  (implies
    (and (<= 0 i) (and (< i n) (< n (Seq_length s))))
    (= (Seq_drop (Seq_update s i e) n) (Seq_drop s n)))
  :pattern ((Seq_drop (Seq_update s i e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_update_2|)))
(assert (forall ((s Seq<Int>) (e Int) (n Int)) (!
  (implies
    (and (<= 0 n) (<= n (Seq_length s)))
    (= (Seq_drop (Seq_build s e) n) (Seq_build (Seq_drop s n) e)))
  :pattern ((Seq_drop (Seq_build s e) n))
  :qid |$Seq[Int]_prog.seq_drop_over_build|)))
(assert (forall ((min_ Int) (max Int)) (!
  (ite
    (< min_ max)
    (= (Seq_length (Seq_range min_ max)) (- max min_))
    (= (Seq_length (Seq_range min_ max)) 0))
  :pattern ((Seq_length (Seq_range min_ max)))
  :qid |$Seq[Int]_prog.ranged_seq_length|)))
(assert (forall ((min_ Int) (max Int) (i Int)) (!
  (implies
    (and (<= 0 i) (< i (- max min_)))
    (= (Seq_index (Seq_range min_ max) i) (+ min_ i)))
  :pattern ((Seq_index (Seq_range min_ max) i))
  :qid |$Seq[Int]_prog.ranged_seq_index|)))
(assert (forall ((min_ Int) (max Int) (e Int)) (!
  (= (Seq_contains (Seq_range min_ max) e) (and (<= min_ e) (< e max)))
  :pattern ((Seq_contains (Seq_range min_ max) e))
  :qid |$Seq[Int]_prog.ranged_seq_contains|)))
(assert (forall ((s Set<option<array>>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.card_non_negative|)))
(assert (forall ((e option<array>)) (!
  (not (Set_in e (as Set_empty  Set<option<array>>)))
  :pattern ((Set_in e (as Set_empty  Set<option<array>>)))
  :qid |$Set[option[array]]_prog.in_empty_set|)))
(assert (forall ((s Set<option<array>>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<option<array>>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e option<array>)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[option[array]]_prog.empty_set_cardinality|)))
(assert (forall ((e option<array>)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[option[array]]_prog.in_singleton_set|)))
(assert (forall ((e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[option[array]]_prog.in_singleton_set_equality|)))
(assert (forall ((e option<array>)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[option[array]]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[option[array]]_prog.in_unionone_same|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[option[array]]_prog.in_unionone_other|)))
(assert (forall ((s Set<option<array>>) (e1 option<array>) (e2 option<array>)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[option[array]]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<option<array>>) (e option<array>)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[option[array]]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[option[array]]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[option[array]]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[option[array]]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[option[array]]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>) (e option<array>)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[option[array]]_prog.not_in_difference|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e option<array>)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[option[array]]_prog.subset_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e option<array>)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.equality_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[option[array]]_prog.native_equality|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e option<array>)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[option[array]]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<option<array>>) (s2 Set<option<array>>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[option[array]]_prog.cardinality_difference|)))
(assert (forall ((s Set<Bool>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.card_non_negative|)))
(assert (forall ((e Bool)) (!
  (not (Set_in e (as Set_empty  Set<Bool>)))
  :pattern ((Set_in e (as Set_empty  Set<Bool>)))
  :qid |$Set[Bool]_prog.in_empty_set|)))
(assert (forall ((s Set<Bool>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Bool>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Bool)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Bool]_prog.empty_set_cardinality|)))
(assert (forall ((e Bool)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Bool]_prog.in_singleton_set|)))
(assert (forall ((e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Bool]_prog.in_singleton_set_equality|)))
(assert (forall ((e Bool)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Bool]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Bool]_prog.in_unionone_same|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Bool]_prog.in_unionone_other|)))
(assert (forall ((s Set<Bool>) (e1 Bool) (e2 Bool)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Bool]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Bool>) (e Bool)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Bool]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Bool]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Bool]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Bool]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Bool]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>) (e Bool)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Bool]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Bool)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Bool]_prog.subset_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Bool)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.equality_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Bool]_prog.native_equality|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Bool)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Bool]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Bool>) (s2 Set<Bool>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Bool]_prog.cardinality_difference|)))
(assert (forall ((s Set<Int>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.card_non_negative|)))
(assert (forall ((e Int)) (!
  (not (Set_in e (as Set_empty  Set<Int>)))
  :pattern ((Set_in e (as Set_empty  Set<Int>)))
  :qid |$Set[Int]_prog.in_empty_set|)))
(assert (forall ((s Set<Int>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<Int>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e Int)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Int]_prog.empty_set_cardinality|)))
(assert (forall ((e Int)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Int]_prog.in_singleton_set|)))
(assert (forall ((e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Int]_prog.in_singleton_set_equality|)))
(assert (forall ((e Int)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Int]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Int]_prog.in_unionone_same|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Int]_prog.in_unionone_other|)))
(assert (forall ((s Set<Int>) (e1 Int) (e2 Int)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Int]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<Int>) (e Int)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Int]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Int]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Int]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Int]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Int]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Int]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Int]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>) (e Int)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Int]_prog.not_in_difference|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e Int)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Int]_prog.subset_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e Int)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.equality_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Int]_prog.native_equality|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e Int)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Int]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<Int>) (s2 Set<Int>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Int]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Ref>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.card_non_negative|)))
(assert (forall ((e $Ref)) (!
  (not (Set_in e (as Set_empty  Set<$Ref>)))
  :pattern ((Set_in e (as Set_empty  Set<$Ref>)))
  :qid |$Set[Ref]_prog.in_empty_set|)))
(assert (forall ((s Set<$Ref>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Ref>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Ref)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Ref]_prog.empty_set_cardinality|)))
(assert (forall ((e $Ref)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Ref]_prog.in_singleton_set|)))
(assert (forall ((e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Ref]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Ref)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Ref]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Ref]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Ref]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Ref>) (e1 $Ref) (e2 $Ref)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Ref]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Ref>) (e $Ref)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Ref]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Ref]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Ref]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Ref]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Ref]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>) (e $Ref)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Ref]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Ref)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Ref]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Ref)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Ref]_prog.native_equality|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Ref)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Ref]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Ref>) (s2 Set<$Ref>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Ref]_prog.cardinality_difference|)))
(assert (forall ((s Set<$Snap>)) (!
  (<= 0 (Set_card s))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.card_non_negative|)))
(assert (forall ((e $Snap)) (!
  (not (Set_in e (as Set_empty  Set<$Snap>)))
  :pattern ((Set_in e (as Set_empty  Set<$Snap>)))
  :qid |$Set[Snap]_prog.in_empty_set|)))
(assert (forall ((s Set<$Snap>)) (!
  (and
    (= (= (Set_card s) 0) (= s (as Set_empty  Set<$Snap>)))
    (implies
      (not (= (Set_card s) 0))
      (exists ((e $Snap)) (!
        (Set_in e s)
        :pattern ((Set_in e s))
        ))))
  :pattern ((Set_card s))
  :qid |$Set[Snap]_prog.empty_set_cardinality|)))
(assert (forall ((e $Snap)) (!
  (Set_in e (Set_singleton e))
  :pattern ((Set_singleton e))
  :qid |$Set[Snap]_prog.in_singleton_set|)))
(assert (forall ((e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_singleton e2)) (= e1 e2))
  :pattern ((Set_in e1 (Set_singleton e2)))
  :qid |$Set[Snap]_prog.in_singleton_set_equality|)))
(assert (forall ((e $Snap)) (!
  (= (Set_card (Set_singleton e)) 1)
  :pattern ((Set_card (Set_singleton e)))
  :qid |$Set[Snap]_prog.singleton_set_cardinality|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (Set_in e (Set_unionone s e))
  :pattern ((Set_unionone s e))
  :qid |$Set[Snap]_prog.in_unionone_same|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (= (Set_in e1 (Set_unionone s e2)) (or (= e1 e2) (Set_in e1 s)))
  :pattern ((Set_in e1 (Set_unionone s e2)))
  :qid |$Set[Snap]_prog.in_unionone_other|)))
(assert (forall ((s Set<$Snap>) (e1 $Snap) (e2 $Snap)) (!
  (implies (Set_in e1 s) (Set_in e1 (Set_unionone s e2)))
  :pattern ((Set_in e1 s) (Set_unionone s e2))
  :qid |$Set[Snap]_prog.invariance_in_unionone|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s) (= (Set_card (Set_unionone s e)) (Set_card s)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_invariant|)))
(assert (forall ((s Set<$Snap>) (e $Snap)) (!
  (implies
    (not (Set_in e s))
    (= (Set_card (Set_unionone s e)) (+ (Set_card s) 1)))
  :pattern ((Set_card (Set_unionone s e)))
  :qid |$Set[Snap]_prog.unionone_cardinality_changed|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_union s1 s2)) (or (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.in_union_in_one|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s1) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s1) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_left_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (Set_in e (Set_union s1 s2)))
  :pattern ((Set_in e s2) (Set_union s1 s2))
  :qid |$Set[Snap]_prog.in_right_in_union|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_intersection s1 s2)) (and (Set_in e s1) (Set_in e s2)))
  :pattern ((Set_in e (Set_intersection s1 s2)))
  :pattern ((Set_intersection s1 s2) (Set_in e s1))
  :pattern ((Set_intersection s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.in_intersection_in_both|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union s1 (Set_union s1 s2)) (Set_union s1 s2))
  :pattern ((Set_union s1 (Set_union s1 s2)))
  :qid |$Set[Snap]_prog.union_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_union (Set_union s1 s2) s2) (Set_union s1 s2))
  :pattern ((Set_union (Set_union s1 s2) s2))
  :qid |$Set[Snap]_prog.union_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection s1 (Set_intersection s1 s2)) (Set_intersection s1 s2))
  :pattern ((Set_intersection s1 (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.intersection_left_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (= (Set_intersection (Set_intersection s1 s2) s2) (Set_intersection s1 s2))
  :pattern ((Set_intersection (Set_intersection s1 s2) s2))
  :qid |$Set[Snap]_prog.intersection_right_idempotency|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (+ (Set_card (Set_union s1 s2)) (Set_card (Set_intersection s1 s2)))
    (+ (Set_card s1) (Set_card s2)))
  :pattern ((Set_card (Set_union s1 s2)))
  :pattern ((Set_card (Set_intersection s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_sums|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (= (Set_in e (Set_difference s1 s2)) (and (Set_in e s1) (not (Set_in e s2))))
  :pattern ((Set_in e (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>) (e $Snap)) (!
  (implies (Set_in e s2) (not (Set_in e (Set_difference s1 s2))))
  :pattern ((Set_difference s1 s2) (Set_in e s2))
  :qid |$Set[Snap]_prog.not_in_difference|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_subset s1 s2)
    (forall ((e $Snap)) (!
      (implies (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_subset s1 s2))
  :qid |$Set[Snap]_prog.subset_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_equal s1 s2)
    (forall ((e $Snap)) (!
      (= (Set_in e s1) (Set_in e s2))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.equality_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (implies (Set_equal s1 s2) (= s1 s2))
  :pattern ((Set_equal s1 s2))
  :qid |$Set[Snap]_prog.native_equality|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (=
    (Set_disjoint s1 s2)
    (forall ((e $Snap)) (!
      (or (not (Set_in e s1)) (not (Set_in e s2)))
      :pattern ((Set_in e s1))
      :pattern ((Set_in e s2))
      )))
  :pattern ((Set_disjoint s1 s2))
  :qid |$Set[Snap]_prog.disjointness_definition|)))
(assert (forall ((s1 Set<$Snap>) (s2 Set<$Snap>)) (!
  (and
    (=
      (+
        (+ (Set_card (Set_difference s1 s2)) (Set_card (Set_difference s2 s1)))
        (Set_card (Set_intersection s1 s2)))
      (Set_card (Set_union s1 s2)))
    (=
      (Set_card (Set_difference s1 s2))
      (- (Set_card s1) (Set_card (Set_intersection s1 s2)))))
  :pattern ((Set_card (Set_difference s1 s2)))
  :qid |$Set[Snap]_prog.cardinality_difference|)))
(assert (forall ((a2 array)) (!
  (forall ((i1 Int)) (!
    (and
      (= (loc_inv_1<array> (array_loc<Ref> a2 i1)) a2)
      (= (loc_inv_2<Int> (array_loc<Ref> a2 i1)) i1))
    :pattern ((loc_inv_1<array> (array_loc<Ref> a2 i1)))
    :pattern ((loc_inv_2<Int> (array_loc<Ref> a2 i1)))
    ))
  
  )))
(assert (forall ((a2 array)) (!
  (>= (alen<Int> a2) 0)
  :pattern ((alen<Int> a2))
  )))
(assert (forall ((x1 array)) (!
  (not (= (as None<option<array>>  option<array>) (some<option<array>> x1)))
  :pattern ((some<option<array>> x1))
  )))
(assert (forall ((x1 array)) (!
  (= (option_get<array> (some<option<array>> x1)) x1)
  :pattern ((option_get<array> (some<option<array>> x1)))
  )))
(assert (forall ((opt1 option<array>)) (!
  (= (some<option<array>> (option_get<array> opt1)) opt1)
  :pattern ((some<option<array>> (option_get<array> opt1)))
  )))
(assert (forall ((v t_null)) (!
  (= (as v_null<t_null>  t_null) v)
  
  )))
(assert (forall ((x1 any)) (!
  (not (= (as None<option<any>>  option<any>) (some<option<any>> x1)))
  :pattern ((some<option<any>> x1))
  )))
(assert (forall ((x1 any)) (!
  (= (option_get<any> (some<option<any>> x1)) x1)
  :pattern ((option_get<any> (some<option<any>> x1)))
  )))
(assert (forall ((opt1 option<any>)) (!
  (= (some<option<any>> (option_get<any> opt1)) opt1)
  :pattern ((some<option<any>> (option_get<any> opt1)))
  )))
(assert (forall ((v void)) (!
  (= (as unit<void>  void) v)
  
  )))
; /field_value_functions_axioms.smt2 [int: Int]
(assert (forall ((vs $FVF<Int>) (ws $FVF<Int>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_int vs) ($FVF.domain_int ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_int vs))
            (= ($FVF.lookup_int vs x) ($FVF.lookup_int ws x)))
          :pattern (($FVF.lookup_int vs x) ($FVF.lookup_int ws x))
          :qid |qp.$FVF<Int>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Int>To$Snap vs)
              ($SortWrappers.$FVF<Int>To$Snap ws)
              )
    :qid |qp.$FVF<Int>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_int pm r))
    :pattern ($FVF.perm_int pm r))))
(assert (forall ((r $Ref) (f Int)) (!
    (= ($FVF.loc_int f r) true)
    :pattern ($FVF.loc_int f r))))
; /field_value_functions_axioms.smt2 [option$array$: option[array]]
(assert (forall ((vs $FVF<option<array>>) (ws $FVF<option<array>>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_option$array$ vs) ($FVF.domain_option$array$ ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_option$array$ vs))
            (= ($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x)))
          :pattern (($FVF.lookup_option$array$ vs x) ($FVF.lookup_option$array$ ws x))
          :qid |qp.$FVF<option<array>>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<option<array>>To$Snap vs)
              ($SortWrappers.$FVF<option<array>>To$Snap ws)
              )
    :qid |qp.$FVF<option<array>>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_option$array$ pm r))
    :pattern ($FVF.perm_option$array$ pm r))))
(assert (forall ((r $Ref) (f option<array>)) (!
    (= ($FVF.loc_option$array$ f r) true)
    :pattern ($FVF.loc_option$array$ f r))))
; /field_value_functions_axioms.smt2 [bool: Bool]
(assert (forall ((vs $FVF<Bool>) (ws $FVF<Bool>)) (!
    (implies
      (and
        (Set_equal ($FVF.domain_bool vs) ($FVF.domain_bool ws))
        (forall ((x $Ref)) (!
          (implies
            (Set_in x ($FVF.domain_bool vs))
            (= ($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x)))
          :pattern (($FVF.lookup_bool vs x) ($FVF.lookup_bool ws x))
          :qid |qp.$FVF<Bool>-eq-inner|
          )))
      (= vs ws))
    :pattern (($SortWrappers.$FVF<Bool>To$Snap vs)
              ($SortWrappers.$FVF<Bool>To$Snap ws)
              )
    :qid |qp.$FVF<Bool>-eq-outer|
    )))
(assert (forall ((r $Ref) (pm $FPM)) (!
    ($Perm.isValidVar ($FVF.perm_bool pm r))
    :pattern ($FVF.perm_bool pm r))))
(assert (forall ((r $Ref) (f Bool)) (!
    (= ($FVF.loc_bool f r) true)
    :pattern ($FVF.loc_bool f r))))
; End preamble
; ------------------------------------------------------------
; State saturation: after preamble
(set-option :timeout 100)
(check-sat)
; unknown
; ------------------------------------------------------------
; Begin function- and predicate-related preamble
; Declaring symbols related to program functions (from verification)
(declare-fun $k@85@00 () $Perm)
(declare-fun inv@86@00 ($Snap $Ref option<array> Int $Ref) Int)
(declare-fun sm@87@00 ($Snap $Ref option<array> Int) $FVF<Int>)
(assert (forall ((s@$ $Snap) (a2@0@00 array) (i1@1@00 Int)) (!
  (= (aloc%limited s@$ a2@0@00 i1@1@00) (aloc s@$ a2@0@00 i1@1@00))
  :pattern ((aloc s@$ a2@0@00 i1@1@00))
  )))
(assert (forall ((s@$ $Snap) (a2@0@00 array) (i1@1@00 Int)) (!
  (aloc%stateless a2@0@00 i1@1@00)
  :pattern ((aloc%limited s@$ a2@0@00 i1@1@00))
  )))
(assert (forall ((s@$ $Snap) (a2@0@00 array) (i1@1@00 Int)) (!
  (let ((result@2@00 (aloc%limited s@$ a2@0@00 i1@1@00))) (implies
    (and (<= 0 i1@1@00) (< i1@1@00 (alen<Int> a2@0@00)))
    (and
      (= (loc_inv_1<array> result@2@00) a2@0@00)
      (= (loc_inv_2<Int> result@2@00) i1@1@00))))
  :pattern ((aloc%limited s@$ a2@0@00 i1@1@00))
  )))
(assert (forall ((s@$ $Snap) (a2@0@00 array) (i1@1@00 Int)) (!
  (implies
    (and (<= 0 i1@1@00) (< i1@1@00 (alen<Int> a2@0@00)))
    (= (aloc s@$ a2@0@00 i1@1@00) (array_loc<Ref> a2@0@00 i1@1@00)))
  :pattern ((aloc s@$ a2@0@00 i1@1@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@3@00 option<array>)) (!
  (= (opt_get1%limited s@$ opt1@3@00) (opt_get1 s@$ opt1@3@00))
  :pattern ((opt_get1 s@$ opt1@3@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@3@00 option<array>)) (!
  (opt_get1%stateless opt1@3@00)
  :pattern ((opt_get1%limited s@$ opt1@3@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@3@00 option<array>)) (!
  (let ((result@4@00 (opt_get1%limited s@$ opt1@3@00))) (implies
    (not (= opt1@3@00 (as None<option<array>>  option<array>)))
    (= (some<option<array>> result@4@00) opt1@3@00)))
  :pattern ((opt_get1%limited s@$ opt1@3@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@3@00 option<array>)) (!
  (implies
    (not (= opt1@3@00 (as None<option<array>>  option<array>)))
    (= (opt_get1 s@$ opt1@3@00) (option_get<array> opt1@3@00)))
  :pattern ((opt_get1 s@$ opt1@3@00))
  )))
(assert (forall ((s@$ $Snap) (t@5@00 any)) (!
  (= (any_as%limited s@$ t@5@00) (any_as s@$ t@5@00))
  :pattern ((any_as s@$ t@5@00))
  )))
(assert (forall ((s@$ $Snap) (t@5@00 any)) (!
  (any_as%stateless t@5@00)
  :pattern ((any_as%limited s@$ t@5@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@7@00 option<any>)) (!
  (= (opt_get%limited s@$ opt1@7@00) (opt_get s@$ opt1@7@00))
  :pattern ((opt_get s@$ opt1@7@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@7@00 option<any>)) (!
  (opt_get%stateless opt1@7@00)
  :pattern ((opt_get%limited s@$ opt1@7@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@7@00 option<any>)) (!
  (let ((result@8@00 (opt_get%limited s@$ opt1@7@00))) (implies
    (not (= opt1@7@00 (as None<option<any>>  option<any>)))
    (= (some<option<any>> result@8@00) opt1@7@00)))
  :pattern ((opt_get%limited s@$ opt1@7@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@7@00 option<any>)) (!
  (implies
    (not (= opt1@7@00 (as None<option<any>>  option<any>)))
    (= (opt_get s@$ opt1@7@00) (option_get<any> opt1@7@00)))
  :pattern ((opt_get s@$ opt1@7@00))
  )))
(assert (forall ((s@$ $Snap) (this@9@00 $Ref) (G@10@00 option<array>) (V@11@00 Int) (s@12@00 Int) (t@13@00 Int)) (!
  (=
    (lemma_skew_symetry%limited s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00)
    (lemma_skew_symetry s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00))
  :pattern ((lemma_skew_symetry s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00))
  )))
(assert (forall ((s@$ $Snap) (this@9@00 $Ref) (G@10@00 option<array>) (V@11@00 Int) (s@12@00 Int) (t@13@00 Int)) (!
  (lemma_skew_symetry%stateless this@9@00 G@10@00 V@11@00 s@12@00 t@13@00)
  :pattern ((lemma_skew_symetry%limited s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00))
  )))
(assert (forall ((s@$ $Snap) (this@9@00 $Ref) (G@10@00 option<array>) (V@11@00 Int) (s@12@00 Int) (t@13@00 Int)) (!
  (implies
    (not (= this@9@00 $Ref.null))
    (= (lemma_skew_symetry s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00) false))
  :pattern ((lemma_skew_symetry s@$ this@9@00 G@10@00 V@11@00 s@12@00 t@13@00))
  )))
(assert (forall ((s@$ $Snap) (this@15@00 $Ref) (G@16@00 option<array>) (V@17@00 Int) (s@18@00 Int) (t@19@00 Int)) (!
  (=
    (FlowNetwork%limited s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00)
    (FlowNetwork s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00))
  :pattern ((FlowNetwork s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00))
  )))
(assert (forall ((s@$ $Snap) (this@15@00 $Ref) (G@16@00 option<array>) (V@17@00 Int) (s@18@00 Int) (t@19@00 Int)) (!
  (FlowNetwork%stateless this@15@00 G@16@00 V@17@00 s@18@00 t@19@00)
  :pattern ((FlowNetwork%limited s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00))
  )))
(assert (forall ((s@$ $Snap) (this@15@00 $Ref) (G@16@00 option<array>) (V@17@00 Int) (s@18@00 Int) (t@19@00 Int)) (!
  (implies
    (not (= this@15@00 $Ref.null))
    (=
      (FlowNetwork s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00)
      (and (and (< 0 V@17@00) (= s@18@00 0)) (not (= s@18@00 t@19@00)))))
  :pattern ((FlowNetwork s@$ this@15@00 G@16@00 V@17@00 s@18@00 t@19@00))
  )))
(assert (forall ((s@$ $Snap) (this@21@00 $Ref) (G@22@00 option<array>) (V@23@00 Int) (s@24@00 Int) (t@25@00 Int)) (!
  (=
    (ExPath%limited s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00)
    (ExPath s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00))
  :pattern ((ExPath s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00))
  )))
(assert (forall ((s@$ $Snap) (this@21@00 $Ref) (G@22@00 option<array>) (V@23@00 Int) (s@24@00 Int) (t@25@00 Int)) (!
  (ExPath%stateless this@21@00 G@22@00 V@23@00 s@24@00 t@25@00)
  :pattern ((ExPath%limited s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00))
  )))
(assert (forall ((s@$ $Snap) (this@21@00 $Ref) (G@22@00 option<array>) (V@23@00 Int) (s@24@00 Int) (t@25@00 Int)) (!
  (implies
    (not (= this@21@00 $Ref.null))
    (= (ExPath s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00) false))
  :pattern ((ExPath s@$ this@21@00 G@22@00 V@23@00 s@24@00 t@25@00))
  )))
(assert (forall ((s@$ $Snap) (this@27@00 $Ref) (G@28@00 option<array>) (V@29@00 Int) (s@30@00 Int) (t@31@00 Int)) (!
  (=
    (value%limited s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00)
    (value s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00))
  :pattern ((value s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00))
  )))
(assert (forall ((s@$ $Snap) (this@27@00 $Ref) (G@28@00 option<array>) (V@29@00 Int) (s@30@00 Int) (t@31@00 Int)) (!
  (value%stateless this@27@00 G@28@00 V@29@00 s@30@00 t@31@00)
  :pattern ((value%limited s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00))
  )))
(assert (forall ((s@$ $Snap) (this@27@00 $Ref) (G@28@00 option<array>) (V@29@00 Int) (s@30@00 Int) (t@31@00 Int)) (!
  (implies
    (not (= this@27@00 $Ref.null))
    (= (value s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00) 0))
  :pattern ((value s@$ this@27@00 G@28@00 V@29@00 s@30@00 t@31@00))
  )))
(assert (forall ((s@$ $Snap) (this@33@00 $Ref) (p@34@00 option<array>) (V@35@00 Int)) (!
  (=
    (valid_graph_vertices%limited s@$ this@33@00 p@34@00 V@35@00)
    (valid_graph_vertices s@$ this@33@00 p@34@00 V@35@00))
  :pattern ((valid_graph_vertices s@$ this@33@00 p@34@00 V@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@33@00 $Ref) (p@34@00 option<array>) (V@35@00 Int)) (!
  (valid_graph_vertices%stateless this@33@00 p@34@00 V@35@00)
  :pattern ((valid_graph_vertices%limited s@$ this@33@00 p@34@00 V@35@00))
  )))
(assert (forall ((s@$ $Snap) (this@33@00 $Ref) (p@34@00 option<array>) (V@35@00 Int)) (!
  (and
    (forall ((i1@84@00 Int)) (!
      (implies
        (and (and (< i1@84@00 V@35@00) (<= 0 i1@84@00)) (< $Perm.No $k@85@00))
        (=
          (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit p@34@00) i1@84@00))
          i1@84@00))
      :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@34@00) i1@84@00))
      ))
    (forall ((r $Ref)) (!
      (implies
        (and
          (and
            (< (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r) V@35@00)
            (<= 0 (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r)))
          (< $Perm.No $k@85@00))
        (=
          (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@34@00) (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r))
          r))
      :pattern ((inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r))
      :qid |int-fctOfInv|))
    (forall ((r $Ref)) (!
      (implies
        (ite
          (and
            (< (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r) V@35@00)
            (<= 0 (inv@86@00 s@$ this@33@00 p@34@00 V@35@00 r)))
          (< $Perm.No $k@85@00)
          false)
        (=
          ($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) r)
          ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r)))
      :pattern (($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) r))
      :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r))
      :qid |qp.fvfValDef0|))
    (forall ((r $Ref)) (!
      ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second s@$)))) r) r)
      :pattern (($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) r))
      :qid |qp.fvfResTrgDef1|))
    ($Perm.isReadVar $k@85@00 $Perm.Write)
    (implies
      (and
        (not (= this@33@00 $Ref.null))
        (not (= p@34@00 (as None<option<array>>  option<array>)))
        (= (alen<Int> (opt_get1 $Snap.unit p@34@00)) V@35@00))
      (=
        (valid_graph_vertices s@$ this@33@00 p@34@00 V@35@00)
        (and
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@34@00))))
              (<=
                0
                ($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@34@00) unknown_))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@34@00) unknown_))
            ))
          (forall ((unknown_ Int)) (!
            (implies
              (and
                (<= 0 unknown_)
                (< unknown_ (alen<Int> (opt_get1 $Snap.unit p@34@00))))
              (<
                ($FVF.lookup_int (sm@87@00 s@$ this@33@00 p@34@00 V@35@00) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit p@34@00) unknown_))
                V@35@00))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit p@34@00) unknown_))
            ))))))
  :pattern ((valid_graph_vertices s@$ this@33@00 p@34@00 V@35@00))
  )))
(assert (forall ((s@$ $Snap) (amount@37@00 $Perm)) (!
  (= (scale%limited s@$ amount@37@00) (scale s@$ amount@37@00))
  :pattern ((scale s@$ amount@37@00))
  )))
(assert (forall ((s@$ $Snap) (amount@37@00 $Perm)) (!
  (scale%stateless amount@37@00)
  :pattern ((scale%limited s@$ amount@37@00))
  )))
(assert (forall ((s@$ $Snap) (amount@37@00 $Perm)) (!
  (implies (>= amount@37@00 $Perm.No) (= (scale s@$ amount@37@00) amount@37@00))
  :pattern ((scale s@$ amount@37@00))
  )))
(assert (forall ((s@$ $Snap) (t@39@00 any)) (!
  (= (as_any%limited s@$ t@39@00) (as_any s@$ t@39@00))
  :pattern ((as_any s@$ t@39@00))
  )))
(assert (forall ((s@$ $Snap) (t@39@00 any)) (!
  (as_any%stateless t@39@00)
  :pattern ((as_any%limited s@$ t@39@00))
  )))
(assert (forall ((s@$ $Snap) (t@39@00 any)) (!
  (let ((result@40@00 (as_any%limited s@$ t@39@00))) (=
    (any_as $Snap.unit result@40@00)
    t@39@00))
  :pattern ((as_any%limited s@$ t@39@00))
  )))
(assert (forall ((s@$ $Snap) (this@41@00 $Ref) (G@42@00 option<array>) (V@43@00 Int)) (!
  (=
    (ResidualNetwork%limited s@$ this@41@00 G@42@00 V@43@00)
    (ResidualNetwork s@$ this@41@00 G@42@00 V@43@00))
  :pattern ((ResidualNetwork s@$ this@41@00 G@42@00 V@43@00))
  )))
(assert (forall ((s@$ $Snap) (this@41@00 $Ref) (G@42@00 option<array>) (V@43@00 Int)) (!
  (ResidualNetwork%stateless this@41@00 G@42@00 V@43@00)
  :pattern ((ResidualNetwork%limited s@$ this@41@00 G@42@00 V@43@00))
  )))
(assert (forall ((s@$ $Snap) (this@41@00 $Ref) (G@42@00 option<array>) (V@43@00 Int)) (!
  (implies
    (not (= this@41@00 $Ref.null))
    (= (ResidualNetwork s@$ this@41@00 G@42@00 V@43@00) false))
  :pattern ((ResidualNetwork s@$ this@41@00 G@42@00 V@43@00))
  )))
(assert (forall ((s@$ $Snap) (type1@45@00 $Ref)) (!
  (= (type%limited s@$ type1@45@00) (type s@$ type1@45@00))
  :pattern ((type s@$ type1@45@00))
  )))
(assert (forall ((s@$ $Snap) (type1@45@00 $Ref)) (!
  (type%stateless type1@45@00)
  :pattern ((type%limited s@$ type1@45@00))
  )))
(assert (forall ((s@$ $Snap) (type1@45@00 $Ref)) (!
  (let ((result@46@00 (type%limited s@$ type1@45@00))) (and
    (<= 0 result@46@00)
    (< result@46@00 3)
    (implies (= type1@45@00 $Ref.null) (= result@46@00 0))
    (implies (not (= type1@45@00 $Ref.null)) (not (= result@46@00 0)))))
  :pattern ((type%limited s@$ type1@45@00))
  )))
(assert (forall ((s@$ $Snap) (this@47@00 $Ref) (G@48@00 option<array>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (=
    (lemma_max_flow_min_cut%limited s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00)
    (lemma_max_flow_min_cut s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00))
  :pattern ((lemma_max_flow_min_cut s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@47@00 $Ref) (G@48@00 option<array>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (lemma_max_flow_min_cut%stateless this@47@00 G@48@00 V@49@00 s@50@00 t@51@00)
  :pattern ((lemma_max_flow_min_cut%limited s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@47@00 $Ref) (G@48@00 option<array>) (V@49@00 Int) (s@50@00 Int) (t@51@00 Int)) (!
  (implies
    (not (= this@47@00 $Ref.null))
    (=
      (lemma_max_flow_min_cut s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00)
      false))
  :pattern ((lemma_max_flow_min_cut s@$ this@47@00 G@48@00 V@49@00 s@50@00 t@51@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (=
    (lemma_capacity_constrain%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
    (lemma_capacity_constrain s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  :pattern ((lemma_capacity_constrain s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (lemma_capacity_constrain%stateless this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
  :pattern ((lemma_capacity_constrain%limited s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (this@53@00 $Ref) (G@54@00 option<array>) (V@55@00 Int) (s@56@00 Int) (t@57@00 Int)) (!
  (implies
    (not (= this@53@00 $Ref.null))
    (=
      (lemma_capacity_constrain s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00)
      false))
  :pattern ((lemma_capacity_constrain s@$ this@53@00 G@54@00 V@55@00 s@56@00 t@57@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@59@00 option<any>) (alt@60@00 any)) (!
  (=
    (opt_or_else%limited s@$ opt1@59@00 alt@60@00)
    (opt_or_else s@$ opt1@59@00 alt@60@00))
  :pattern ((opt_or_else s@$ opt1@59@00 alt@60@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@59@00 option<any>) (alt@60@00 any)) (!
  (opt_or_else%stateless opt1@59@00 alt@60@00)
  :pattern ((opt_or_else%limited s@$ opt1@59@00 alt@60@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@59@00 option<any>) (alt@60@00 any)) (!
  (let ((result@61@00 (opt_or_else%limited s@$ opt1@59@00 alt@60@00))) (and
    (implies
      (= opt1@59@00 (as None<option<any>>  option<any>))
      (= result@61@00 alt@60@00))
    (implies
      (not (= opt1@59@00 (as None<option<any>>  option<any>)))
      (= result@61@00 (opt_get $Snap.unit opt1@59@00)))))
  :pattern ((opt_or_else%limited s@$ opt1@59@00 alt@60@00))
  )))
(assert (forall ((s@$ $Snap) (opt1@59@00 option<any>) (alt@60@00 any)) (!
  (=
    (opt_or_else s@$ opt1@59@00 alt@60@00)
    (ite
      (= opt1@59@00 (as None<option<any>>  option<any>))
      alt@60@00
      (opt_get $Snap.unit opt1@59@00)))
  :pattern ((opt_or_else s@$ opt1@59@00 alt@60@00))
  )))
(assert (forall ((s@$ $Snap) (this@62@00 $Ref) (p@63@00 Seq<Int>) (V@64@00 Int)) (!
  (=
    (valid_graph_vertices1%limited s@$ this@62@00 p@63@00 V@64@00)
    (valid_graph_vertices1 s@$ this@62@00 p@63@00 V@64@00))
  :pattern ((valid_graph_vertices1 s@$ this@62@00 p@63@00 V@64@00))
  )))
(assert (forall ((s@$ $Snap) (this@62@00 $Ref) (p@63@00 Seq<Int>) (V@64@00 Int)) (!
  (valid_graph_vertices1%stateless this@62@00 p@63@00 V@64@00)
  :pattern ((valid_graph_vertices1%limited s@$ this@62@00 p@63@00 V@64@00))
  )))
(assert (forall ((s@$ $Snap) (this@62@00 $Ref) (p@63@00 Seq<Int>) (V@64@00 Int)) (!
  (implies
    (not (= this@62@00 $Ref.null))
    (=
      (valid_graph_vertices1 s@$ this@62@00 p@63@00 V@64@00)
      (and
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@63@00)))
            (<= 0 (Seq_index p@63@00 unknown_)))
          :pattern ((Seq_index p@63@00 unknown_))
          ))
        (forall ((unknown_ Int)) (!
          (implies
            (and (<= 0 unknown_) (< unknown_ (Seq_length p@63@00)))
            (< (Seq_index p@63@00 unknown_) V@64@00))
          :pattern ((Seq_index p@63@00 unknown_))
          )))))
  :pattern ((valid_graph_vertices1 s@$ this@62@00 p@63@00 V@64@00))
  )))
(assert (forall ((s@$ $Snap) (this@66@00 $Ref) (G@67@00 option<array>) (V@68@00 Int) (s@69@00 Int) (t@70@00 Int)) (!
  (=
    (flow%limited s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00)
    (flow s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00))
  :pattern ((flow s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00))
  )))
(assert (forall ((s@$ $Snap) (this@66@00 $Ref) (G@67@00 option<array>) (V@68@00 Int) (s@69@00 Int) (t@70@00 Int)) (!
  (flow%stateless this@66@00 G@67@00 V@68@00 s@69@00 t@70@00)
  :pattern ((flow%limited s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00))
  )))
(assert (forall ((s@$ $Snap) (this@66@00 $Ref) (G@67@00 option<array>) (V@68@00 Int) (s@69@00 Int) (t@70@00 Int)) (!
  (implies
    (not (= this@66@00 $Ref.null))
    (= (flow s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00) 0))
  :pattern ((flow s@$ this@66@00 G@67@00 V@68@00 s@69@00 t@70@00))
  )))
(assert (forall ((s@$ $Snap) (this@72@00 $Ref) (G@73@00 option<array>) (V@74@00 Int) (s@75@00 Int) (t@76@00 Int)) (!
  (=
    (lemma_flow_conservation%limited s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00)
    (lemma_flow_conservation s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00))
  :pattern ((lemma_flow_conservation s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00))
  )))
(assert (forall ((s@$ $Snap) (this@72@00 $Ref) (G@73@00 option<array>) (V@74@00 Int) (s@75@00 Int) (t@76@00 Int)) (!
  (lemma_flow_conservation%stateless this@72@00 G@73@00 V@74@00 s@75@00 t@76@00)
  :pattern ((lemma_flow_conservation%limited s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00))
  )))
(assert (forall ((s@$ $Snap) (this@72@00 $Ref) (G@73@00 option<array>) (V@74@00 Int) (s@75@00 Int) (t@76@00 Int)) (!
  (implies
    (not (= this@72@00 $Ref.null))
    (=
      (lemma_flow_conservation s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00)
      false))
  :pattern ((lemma_flow_conservation s@$ this@72@00 G@73@00 V@74@00 s@75@00 t@76@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@78@00 Int) (subtype2@79@00 Int)) (!
  (=
    (subtype%limited s@$ subtype1@78@00 subtype2@79@00)
    (subtype s@$ subtype1@78@00 subtype2@79@00))
  :pattern ((subtype s@$ subtype1@78@00 subtype2@79@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@78@00 Int) (subtype2@79@00 Int)) (!
  (subtype%stateless subtype1@78@00 subtype2@79@00)
  :pattern ((subtype%limited s@$ subtype1@78@00 subtype2@79@00))
  )))
(assert (forall ((s@$ $Snap) (subtype1@78@00 Int) (subtype2@79@00 Int)) (!
  (implies
    (and
      (<= 0 subtype1@78@00)
      (< subtype1@78@00 3)
      (<= 0 subtype2@79@00)
      (<= subtype2@79@00 2))
    (=
      (subtype s@$ subtype1@78@00 subtype2@79@00)
      (and
        (implies (= subtype1@78@00 1) (= subtype2@79@00 1))
        (implies (= subtype1@78@00 2) (= subtype2@79@00 2)))))
  :pattern ((subtype s@$ subtype1@78@00 subtype2@79@00))
  )))
; End function- and predicate-related preamble
; ------------------------------------------------------------
; ---------- do_par_$unknown$2 ----------
(declare-const visited@0@01 option<array>)
(declare-const s@1@01 Int)
(declare-const V@2@01 Int)
(declare-const exc@3@01 $Ref)
(declare-const res@4@01 void)
(declare-const visited@5@01 option<array>)
(declare-const s@6@01 Int)
(declare-const V@7@01 Int)
(declare-const exc@8@01 $Ref)
(declare-const res@9@01 void)
(push) ; 1
(declare-const $t@10@01 $Snap)
(assert (= $t@10@01 ($Snap.combine ($Snap.first $t@10@01) ($Snap.second $t@10@01))))
(assert (= ($Snap.first $t@10@01) $Snap.unit))
; [eval] 0 < V ==> visited != (None(): option[array])
; [eval] 0 < V
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (< 0 V@7@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9
;  :arith-assert-lower      2
;  :arith-assert-upper      1
;  :arith-eq-adapter        1
;  :datatype-accessor-ax    2
;  :datatype-constructor-ax 1
;  :datatype-occurs-check   2
;  :datatype-splits         1
;  :decisions               1
;  :final-checks            2
;  :max-generation          1
;  :max-memory              4.14
;  :memory                  3.90
;  :mk-bool-var             302
;  :num-allocs              121757
;  :num-checks              1
;  :quant-instantiations    1
;  :rlimit-count            120240)
(push) ; 3
(assert (not (< 0 V@7@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11
;  :arith-assert-lower      2
;  :arith-assert-upper      2
;  :arith-eq-adapter        1
;  :datatype-accessor-ax    2
;  :datatype-constructor-ax 2
;  :datatype-occurs-check   4
;  :datatype-splits         2
;  :decisions               2
;  :final-checks            4
;  :max-generation          1
;  :max-memory              4.14
;  :memory                  3.90
;  :mk-bool-var             304
;  :num-allocs              122110
;  :num-checks              2
;  :quant-instantiations    1
;  :rlimit-count            120627)
; [then-branch: 0 | 0 < V@7@01 | live]
; [else-branch: 0 | !(0 < V@7@01) | live]
(push) ; 3
; [then-branch: 0 | 0 < V@7@01]
(assert (< 0 V@7@01))
; [eval] visited != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
(push) ; 3
; [else-branch: 0 | !(0 < V@7@01)]
(assert (not (< 0 V@7@01)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies
  (< 0 V@7@01)
  (not (= visited@5@01 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second $t@10@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@10@01))
    ($Snap.second ($Snap.second $t@10@01)))))
(assert (= ($Snap.first ($Snap.second $t@10@01)) $Snap.unit))
; [eval] 0 < V ==> alen(opt_get1(visited)) == V
; [eval] 0 < V
(push) ; 2
(push) ; 3
(assert (not (not (< 0 V@7@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               19
;  :arith-assert-lower      3
;  :arith-assert-upper      2
;  :arith-eq-adapter        1
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 3
;  :datatype-occurs-check   6
;  :datatype-splits         3
;  :decisions               3
;  :final-checks            6
;  :max-generation          1
;  :max-memory              4.14
;  :memory                  3.92
;  :mk-bool-var             309
;  :mk-clause               1
;  :num-allocs              122630
;  :num-checks              3
;  :propagations            1
;  :quant-instantiations    1
;  :rlimit-count            121285)
(push) ; 3
(assert (not (< 0 V@7@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21
;  :arith-assert-lower      3
;  :arith-assert-upper      3
;  :arith-eq-adapter        1
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          1
;  :max-memory              4.14
;  :memory                  3.92
;  :mk-bool-var             310
;  :mk-clause               1
;  :num-allocs              122977
;  :num-checks              4
;  :propagations            1
;  :quant-instantiations    1
;  :rlimit-count            121676)
; [then-branch: 1 | 0 < V@7@01 | live]
; [else-branch: 1 | !(0 < V@7@01) | live]
(push) ; 3
; [then-branch: 1 | 0 < V@7@01]
(assert (< 0 V@7@01))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 4
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 5
(assert (not (not (= visited@5@01 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21
;  :arith-assert-lower      4
;  :arith-assert-upper      3
;  :arith-eq-adapter        1
;  :conflicts               1
;  :datatype-accessor-ax    3
;  :datatype-constructor-ax 4
;  :datatype-occurs-check   8
;  :datatype-splits         4
;  :decisions               4
;  :final-checks            8
;  :max-generation          1
;  :max-memory              4.14
;  :memory                  3.92
;  :mk-bool-var             310
;  :mk-clause               1
;  :num-allocs              123119
;  :num-checks              5
;  :propagations            2
;  :quant-instantiations    1
;  :rlimit-count            121784)
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(pop) ; 4
; Joined path conditions
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(pop) ; 3
(push) ; 3
; [else-branch: 1 | !(0 < V@7@01)]
(assert (not (< 0 V@7@01)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
(assert (implies
  (< 0 V@7@01)
  (and
    (< 0 V@7@01)
    (not (= visited@5@01 (as None<option<array>>  option<array>))))))
; Joined path conditions
(assert (implies (< 0 V@7@01) (= (alen<Int> (opt_get1 $Snap.unit visited@5@01)) V@7@01)))
(assert (=
  ($Snap.second ($Snap.second $t@10@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@10@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@10@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@10@01))) $Snap.unit))
; [eval] 0 < V ==> 0 <= s
; [eval] 0 < V
(push) ; 2
(set-option :timeout 10)
(push) ; 3
(assert (not (not (< 0 V@7@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35
;  :arith-assert-lower      7
;  :arith-assert-upper      4
;  :arith-eq-adapter        2
;  :arith-fixed-eqs         1
;  :arith-pivots            2
;  :conflicts               1
;  :datatype-accessor-ax    4
;  :datatype-constructor-ax 5
;  :datatype-occurs-check   10
;  :datatype-splits         5
;  :decisions               5
;  :del-clause              1
;  :final-checks            10
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.95
;  :mk-bool-var             323
;  :mk-clause               7
;  :num-allocs              123888
;  :num-checks              6
;  :propagations            5
;  :quant-instantiations    6
;  :rlimit-count            122666)
(push) ; 3
(assert (not (< 0 V@7@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37
;  :arith-assert-lower      7
;  :arith-assert-upper      5
;  :arith-eq-adapter        2
;  :arith-fixed-eqs         1
;  :arith-pivots            2
;  :conflicts               1
;  :datatype-accessor-ax    4
;  :datatype-constructor-ax 6
;  :datatype-occurs-check   12
;  :datatype-splits         6
;  :decisions               6
;  :del-clause              1
;  :final-checks            12
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.95
;  :mk-bool-var             324
;  :mk-clause               7
;  :num-allocs              124247
;  :num-checks              7
;  :propagations            6
;  :quant-instantiations    6
;  :rlimit-count            123062)
; [then-branch: 2 | 0 < V@7@01 | live]
; [else-branch: 2 | !(0 < V@7@01) | live]
(push) ; 3
; [then-branch: 2 | 0 < V@7@01]
(assert (< 0 V@7@01))
; [eval] 0 <= s
(pop) ; 3
(push) ; 3
; [else-branch: 2 | !(0 < V@7@01)]
(assert (not (< 0 V@7@01)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies (< 0 V@7@01) (<= 0 s@6@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@10@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@10@01))))
  $Snap.unit))
; [eval] 0 < V ==> s < V
; [eval] 0 < V
(push) ; 2
(push) ; 3
(assert (not (not (< 0 V@7@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               51
;  :arith-assert-lower      11
;  :arith-assert-upper      6
;  :arith-eq-adapter        3
;  :arith-fixed-eqs         2
;  :arith-pivots            4
;  :conflicts               1
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 7
;  :datatype-occurs-check   14
;  :datatype-splits         7
;  :decisions               7
;  :del-clause              2
;  :final-checks            14
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.96
;  :mk-bool-var             336
;  :mk-clause               9
;  :num-allocs              124874
;  :num-checks              8
;  :propagations            10
;  :quant-instantiations    11
;  :rlimit-count            123832)
(push) ; 3
(assert (not (< 0 V@7@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               53
;  :arith-assert-lower      11
;  :arith-assert-upper      7
;  :arith-eq-adapter        3
;  :arith-fixed-eqs         2
;  :arith-pivots            4
;  :conflicts               1
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   16
;  :datatype-splits         8
;  :decisions               8
;  :del-clause              2
;  :final-checks            16
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.96
;  :mk-bool-var             337
;  :mk-clause               9
;  :num-allocs              125238
;  :num-checks              9
;  :propagations            11
;  :quant-instantiations    11
;  :rlimit-count            124231)
; [then-branch: 3 | 0 < V@7@01 | live]
; [else-branch: 3 | !(0 < V@7@01) | live]
(push) ; 3
; [then-branch: 3 | 0 < V@7@01]
(assert (< 0 V@7@01))
; [eval] s < V
(pop) ; 3
(push) ; 3
; [else-branch: 3 | !(0 < V@7@01)]
(assert (not (< 0 V@7@01)))
(pop) ; 3
(pop) ; 2
; Joined path conditions
; Joined path conditions
(assert (implies (< 0 V@7@01) (< s@6@01 V@7@01)))
(declare-const i1@11@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 4 | 0 <= i1@11@01 | live]
; [else-branch: 4 | !(0 <= i1@11@01) | live]
(push) ; 4
; [then-branch: 4 | 0 <= i1@11@01]
(assert (<= 0 i1@11@01))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 4 | !(0 <= i1@11@01)]
(assert (not (<= 0 i1@11@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@11@01 V@7@01) (<= 0 i1@11@01)))
; [eval] aloc(opt_get1(visited), i1)
; [eval] opt_get1(visited)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 4
(assert (not (not (= visited@5@01 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               59
;  :arith-add-rows          2
;  :arith-assert-lower      18
;  :arith-assert-upper      8
;  :arith-bound-prop        1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         3
;  :arith-pivots            6
;  :conflicts               2
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   16
;  :datatype-splits         8
;  :decisions               8
;  :del-clause              2
;  :final-checks            16
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.96
;  :mk-bool-var             348
;  :mk-clause               11
;  :num-allocs              125541
;  :num-checks              10
;  :propagations            16
;  :quant-instantiations    16
;  :rlimit-count            124705)
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@11@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               59
;  :arith-add-rows          3
;  :arith-assert-lower      18
;  :arith-assert-upper      9
;  :arith-bound-prop        1
;  :arith-conflicts         1
;  :arith-eq-adapter        4
;  :arith-fixed-eqs         3
;  :arith-pivots            6
;  :conflicts               3
;  :datatype-accessor-ax    5
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   16
;  :datatype-splits         8
;  :decisions               8
;  :del-clause              2
;  :final-checks            16
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.96
;  :mk-bool-var             349
;  :mk-clause               11
;  :num-allocs              125697
;  :num-checks              11
;  :propagations            16
;  :quant-instantiations    16
;  :rlimit-count            124867)
(assert (< i1@11@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01))))
(pop) ; 3
; Joined path conditions
(assert (< i1@11@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01))))
(pop) ; 2
(declare-fun inv@12@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@11@01 Int)) (!
  (and
    (not (= visited@5@01 (as None<option<array>>  option<array>)))
    (< i1@11@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) i1@11@01))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@11@01 Int) (i12@11@01 Int)) (!
  (implies
    (and
      (and (< i11@11@01 V@7@01) (<= 0 i11@11@01))
      (and (< i12@11@01 V@7@01) (<= 0 i12@11@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) i11@11@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) i12@11@01)))
    (= i11@11@01 i12@11@01))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               80
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      25
;  :arith-assert-upper      11
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        6
;  :arith-fixed-eqs         3
;  :arith-pivots            14
;  :conflicts               4
;  :datatype-accessor-ax    6
;  :datatype-constructor-ax 8
;  :datatype-occurs-check   16
;  :datatype-splits         8
;  :decisions               8
;  :del-clause              30
;  :final-checks            16
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  3.98
;  :mk-bool-var             388
;  :mk-clause               38
;  :num-allocs              126412
;  :num-checks              12
;  :propagations            34
;  :quant-instantiations    33
;  :rlimit-count            126127)
; Definitional axioms for inverse functions
(assert (forall ((i1@11@01 Int)) (!
  (implies
    (and (< i1@11@01 V@7@01) (<= 0 i1@11@01))
    (=
      (inv@12@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) i1@11@01))
      i1@11@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) i1@11@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@12@01 r) V@7@01) (<= 0 (inv@12@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) (inv@12@01 r))
      r))
  :pattern ((inv@12@01 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@11@01 Int)) (!
  (implies
    (and (< i1@11@01 V@7@01) (<= 0 i1@11@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) i1@11@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) i1@11@01))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@13@01 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@12@01 r) V@7@01) (<= 0 (inv@12@01 r)))
    (=
      ($FVF.lookup_bool (as sm@13@01  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@01))))) r)))
  :pattern (($FVF.lookup_bool (as sm@13@01  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@01))))) r))
  :qid |qp.fvfValDef0|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@10@01))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@13@01  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef1|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@12@01 r) V@7@01) (<= 0 (inv@12@01 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@13@01  $FVF<Bool>) r) r))
  :pattern ((inv@12@01 r))
  )))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@14@01 $Snap)
(assert (= $t@14@01 ($Snap.combine ($Snap.first $t@14@01) ($Snap.second $t@14@01))))
(assert (= ($Snap.first $t@14@01) $Snap.unit))
; [eval] exc == null
(assert (= exc@8@01 $Ref.null))
(assert (=
  ($Snap.second $t@14@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@14@01))
    ($Snap.second ($Snap.second $t@14@01)))))
(assert (= ($Snap.first ($Snap.second $t@14@01)) $Snap.unit))
; [eval] exc == null && 0 < V ==> visited != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 5 | exc@8@01 == Null | live]
; [else-branch: 5 | exc@8@01 != Null | live]
(push) ; 4
; [then-branch: 5 | exc@8@01 == Null]
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 5 | exc@8@01 != Null]
(assert (not (= exc@8@01 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               115
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      35
;  :arith-assert-upper      13
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        8
;  :arith-fixed-eqs         5
;  :arith-pivots            18
;  :conflicts               4
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 11
;  :datatype-occurs-check   23
;  :datatype-splits         11
;  :decisions               13
;  :del-clause              32
;  :final-checks            20
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             418
;  :mk-clause               40
;  :num-allocs              128400
;  :num-checks              14
;  :propagations            43
;  :quant-instantiations    43
;  :rlimit-count            129065)
(push) ; 4
(assert (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               122
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      35
;  :arith-assert-upper      14
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        8
;  :arith-fixed-eqs         5
;  :arith-pivots            18
;  :conflicts               4
;  :datatype-accessor-ax    8
;  :datatype-constructor-ax 13
;  :datatype-occurs-check   27
;  :datatype-splits         13
;  :decisions               15
;  :del-clause              32
;  :final-checks            22
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             420
;  :mk-clause               40
;  :num-allocs              128789
;  :num-checks              15
;  :propagations            44
;  :quant-instantiations    43
;  :rlimit-count            129497)
; [then-branch: 6 | 0 < V@7@01 && exc@8@01 == Null | live]
; [else-branch: 6 | !(0 < V@7@01 && exc@8@01 == Null) | live]
(push) ; 4
; [then-branch: 6 | 0 < V@7@01 && exc@8@01 == Null]
(assert (and (< 0 V@7@01) (= exc@8@01 $Ref.null)))
; [eval] visited != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 6 | !(0 < V@7@01 && exc@8@01 == Null)]
(assert (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (implies
  (and (< 0 V@7@01) (= exc@8@01 $Ref.null))
  (not (= visited@5@01 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@14@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@14@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@14@01))) $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(visited)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 7 | exc@8@01 == Null | live]
; [else-branch: 7 | exc@8@01 != Null | live]
(push) ; 4
; [then-branch: 7 | exc@8@01 == Null]
(assert (= exc@8@01 $Ref.null))
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 7 | exc@8@01 != Null]
(assert (not (= exc@8@01 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(push) ; 4
(assert (not (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               142
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      40
;  :arith-assert-upper      15
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        9
;  :arith-fixed-eqs         6
;  :arith-pivots            20
;  :conflicts               4
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 15
;  :datatype-occurs-check   31
;  :datatype-splits         15
;  :decisions               17
;  :del-clause              33
;  :final-checks            24
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             432
;  :mk-clause               41
;  :num-allocs              129407
;  :num-checks              16
;  :propagations            49
;  :quant-instantiations    48
;  :rlimit-count            130286)
(push) ; 4
(assert (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               150
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      40
;  :arith-assert-upper      16
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        9
;  :arith-fixed-eqs         6
;  :arith-pivots            20
;  :conflicts               4
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 17
;  :datatype-occurs-check   35
;  :datatype-splits         17
;  :decisions               19
;  :del-clause              33
;  :final-checks            26
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             434
;  :mk-clause               41
;  :num-allocs              129800
;  :num-checks              17
;  :propagations            50
;  :quant-instantiations    48
;  :rlimit-count            130721)
; [then-branch: 8 | 0 < V@7@01 && exc@8@01 == Null | live]
; [else-branch: 8 | !(0 < V@7@01 && exc@8@01 == Null) | live]
(push) ; 4
; [then-branch: 8 | 0 < V@7@01 && exc@8@01 == Null]
(assert (and (< 0 V@7@01) (= exc@8@01 $Ref.null)))
; [eval] alen(opt_get1(visited)) == V
; [eval] alen(opt_get1(visited))
; [eval] opt_get1(visited)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= visited@5@01 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               156
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      45
;  :arith-assert-upper      17
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        10
;  :arith-fixed-eqs         7
;  :arith-pivots            21
;  :conflicts               5
;  :datatype-accessor-ax    9
;  :datatype-constructor-ax 17
;  :datatype-occurs-check   35
;  :datatype-splits         17
;  :decisions               19
;  :del-clause              33
;  :final-checks            26
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             442
;  :mk-clause               41
;  :num-allocs              129972
;  :num-checks              18
;  :propagations            55
;  :quant-instantiations    53
;  :rlimit-count            130930)
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 8 | !(0 < V@7@01 && exc@8@01 == Null)]
(assert (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< 0 V@7@01) (= exc@8@01 $Ref.null))
  (and
    (< 0 V@7@01)
    (= exc@8@01 $Ref.null)
    (not (= visited@5@01 (as None<option<array>>  option<array>))))))
; Joined path conditions
(assert (implies
  (and (< 0 V@7@01) (= exc@8@01 $Ref.null))
  (= (alen<Int> (opt_get1 $Snap.unit visited@5@01)) V@7@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@14@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@14@01))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> 0 <= s
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 9 | exc@8@01 == Null | live]
; [else-branch: 9 | exc@8@01 != Null | live]
(push) ; 4
; [then-branch: 9 | exc@8@01 == Null]
(assert (= exc@8@01 $Ref.null))
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 9 | exc@8@01 != Null]
(assert (not (= exc@8@01 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               177
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      50
;  :arith-assert-upper      18
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        11
;  :arith-fixed-eqs         8
;  :arith-pivots            24
;  :conflicts               5
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 19
;  :datatype-occurs-check   41
;  :datatype-splits         19
;  :decisions               21
;  :del-clause              34
;  :final-checks            28
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.01
;  :mk-bool-var             454
;  :mk-clause               42
;  :num-allocs              130614
;  :num-checks              19
;  :propagations            60
;  :quant-instantiations    58
;  :rlimit-count            131813)
(push) ; 4
(assert (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               186
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      50
;  :arith-assert-upper      19
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        11
;  :arith-fixed-eqs         8
;  :arith-pivots            24
;  :conflicts               5
;  :datatype-accessor-ax    10
;  :datatype-constructor-ax 21
;  :datatype-occurs-check   47
;  :datatype-splits         21
;  :decisions               23
;  :del-clause              34
;  :final-checks            30
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             456
;  :mk-clause               42
;  :num-allocs              131012
;  :num-checks              20
;  :propagations            61
;  :quant-instantiations    58
;  :rlimit-count            132251)
; [then-branch: 10 | 0 < V@7@01 && exc@8@01 == Null | live]
; [else-branch: 10 | !(0 < V@7@01 && exc@8@01 == Null) | live]
(push) ; 4
; [then-branch: 10 | 0 < V@7@01 && exc@8@01 == Null]
(assert (and (< 0 V@7@01) (= exc@8@01 $Ref.null)))
; [eval] 0 <= s
(pop) ; 4
(push) ; 4
; [else-branch: 10 | !(0 < V@7@01 && exc@8@01 == Null)]
(assert (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (implies (and (< 0 V@7@01) (= exc@8@01 $Ref.null)) (<= 0 s@6@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> s < V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 3
; [then-branch: 11 | exc@8@01 == Null | live]
; [else-branch: 11 | exc@8@01 != Null | live]
(push) ; 4
; [then-branch: 11 | exc@8@01 == Null]
(assert (= exc@8@01 $Ref.null))
; [eval] 0 < V
(pop) ; 4
(push) ; 4
; [else-branch: 11 | exc@8@01 != Null]
(assert (not (= exc@8@01 $Ref.null)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
(push) ; 4
(assert (not (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               207
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      55
;  :arith-assert-upper      20
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        12
;  :arith-fixed-eqs         9
;  :arith-pivots            26
;  :conflicts               5
;  :datatype-accessor-ax    11
;  :datatype-constructor-ax 23
;  :datatype-occurs-check   53
;  :datatype-splits         23
;  :decisions               25
;  :del-clause              35
;  :final-checks            32
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.01
;  :mk-bool-var             468
;  :mk-clause               43
;  :num-allocs              131649
;  :num-checks              21
;  :propagations            66
;  :quant-instantiations    63
;  :rlimit-count            133061)
(push) ; 4
(assert (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               216
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      55
;  :arith-assert-upper      21
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        12
;  :arith-fixed-eqs         9
;  :arith-pivots            26
;  :conflicts               5
;  :datatype-accessor-ax    11
;  :datatype-constructor-ax 25
;  :datatype-occurs-check   59
;  :datatype-splits         25
;  :decisions               27
;  :del-clause              35
;  :final-checks            34
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.00
;  :mk-bool-var             470
;  :mk-clause               43
;  :num-allocs              132051
;  :num-checks              22
;  :propagations            67
;  :quant-instantiations    63
;  :rlimit-count            133501)
; [then-branch: 12 | 0 < V@7@01 && exc@8@01 == Null | live]
; [else-branch: 12 | !(0 < V@7@01 && exc@8@01 == Null) | live]
(push) ; 4
; [then-branch: 12 | 0 < V@7@01 && exc@8@01 == Null]
(assert (and (< 0 V@7@01) (= exc@8@01 $Ref.null)))
; [eval] s < V
(pop) ; 4
(push) ; 4
; [else-branch: 12 | !(0 < V@7@01 && exc@8@01 == Null)]
(assert (not (and (< 0 V@7@01) (= exc@8@01 $Ref.null))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (implies (and (< 0 V@7@01) (= exc@8@01 $Ref.null)) (< s@6@01 V@7@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01)))))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@8@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               238
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      60
;  :arith-assert-upper      22
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        13
;  :arith-fixed-eqs         10
;  :arith-pivots            28
;  :conflicts               5
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   65
;  :datatype-splits         28
;  :decisions               32
;  :del-clause              36
;  :final-checks            36
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.01
;  :mk-bool-var             482
;  :mk-clause               44
;  :num-allocs              132633
;  :num-checks              23
;  :propagations            71
;  :quant-instantiations    68
;  :rlimit-count            134259)
(push) ; 3
(assert (not (= exc@8@01 $Ref.null)))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               238
;  :arith-add-rows          10
;  :arith-assert-diseq      1
;  :arith-assert-lower      60
;  :arith-assert-upper      22
;  :arith-bound-prop        2
;  :arith-conflicts         1
;  :arith-eq-adapter        13
;  :arith-fixed-eqs         10
;  :arith-pivots            28
;  :conflicts               5
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   65
;  :datatype-splits         28
;  :decisions               32
;  :del-clause              36
;  :final-checks            36
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.01
;  :mk-bool-var             482
;  :mk-clause               44
;  :num-allocs              132649
;  :num-checks              24
;  :propagations            71
;  :quant-instantiations    68
;  :rlimit-count            134270)
; [then-branch: 13 | exc@8@01 == Null | live]
; [else-branch: 13 | exc@8@01 != Null | dead]
(push) ; 3
; [then-branch: 13 | exc@8@01 == Null]
(assert (= exc@8@01 $Ref.null))
(declare-const unknown@15@01 Int)
(push) ; 4
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 5
; [then-branch: 14 | 0 <= unknown@15@01 | live]
; [else-branch: 14 | !(0 <= unknown@15@01) | live]
(push) ; 6
; [then-branch: 14 | 0 <= unknown@15@01]
(assert (<= 0 unknown@15@01))
; [eval] unknown < V
(pop) ; 6
(push) ; 6
; [else-branch: 14 | !(0 <= unknown@15@01)]
(assert (not (<= 0 unknown@15@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< unknown@15@01 V@7@01) (<= 0 unknown@15@01)))
; [eval] aloc(opt_get1(visited), unknown)
; [eval] opt_get1(visited)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 6
(assert (not (not (= visited@5@01 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               244
;  :arith-add-rows          12
;  :arith-assert-diseq      1
;  :arith-assert-lower      67
;  :arith-assert-upper      23
;  :arith-bound-prop        3
;  :arith-conflicts         1
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         11
;  :arith-pivots            30
;  :conflicts               6
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   65
;  :datatype-splits         28
;  :decisions               32
;  :del-clause              36
;  :final-checks            36
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.02
;  :mk-bool-var             492
;  :mk-clause               45
;  :num-allocs              132829
;  :num-checks              25
;  :propagations            76
;  :quant-instantiations    73
;  :rlimit-count            134573)
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< unknown@15@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               244
;  :arith-add-rows          13
;  :arith-assert-diseq      1
;  :arith-assert-lower      67
;  :arith-assert-upper      24
;  :arith-bound-prop        3
;  :arith-conflicts         2
;  :arith-eq-adapter        14
;  :arith-fixed-eqs         11
;  :arith-pivots            30
;  :conflicts               7
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   65
;  :datatype-splits         28
;  :decisions               32
;  :del-clause              36
;  :final-checks            36
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.01
;  :mk-bool-var             493
;  :mk-clause               45
;  :num-allocs              132975
;  :num-checks              26
;  :propagations            76
;  :quant-instantiations    73
;  :rlimit-count            134727)
(assert (< unknown@15@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01))))
(pop) ; 5
; Joined path conditions
(assert (< unknown@15@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01))))
(pop) ; 4
(declare-fun inv@16@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@15@01 Int)) (!
  (and
    (not (= visited@5@01 (as None<option<array>>  option<array>)))
    (< unknown@15@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@15@01))
  :qid |bool-aux|)))
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((unknown1@15@01 Int) (unknown2@15@01 Int)) (!
  (implies
    (and
      (and (< unknown1@15@01 V@7@01) (<= 0 unknown1@15@01))
      (and (< unknown2@15@01 V@7@01) (<= 0 unknown2@15@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown1@15@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown2@15@01)))
    (= unknown1@15@01 unknown2@15@01))
  
  :qid |bool-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               255
;  :arith-add-rows          14
;  :arith-assert-diseq      2
;  :arith-assert-lower      70
;  :arith-assert-upper      25
;  :arith-bound-prop        4
;  :arith-conflicts         2
;  :arith-eq-adapter        15
;  :arith-fixed-eqs         11
;  :arith-pivots            32
;  :conflicts               8
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 28
;  :datatype-occurs-check   65
;  :datatype-splits         28
;  :decisions               32
;  :del-clause              51
;  :final-checks            36
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.01
;  :mk-bool-var             515
;  :mk-clause               59
;  :num-allocs              133500
;  :num-checks              27
;  :propagations            86
;  :quant-instantiations    86
;  :rlimit-count            135735)
; Definitional axioms for inverse functions
(assert (forall ((unknown@15@01 Int)) (!
  (implies
    (and (< unknown@15@01 V@7@01) (<= 0 unknown@15@01))
    (=
      (inv@16@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@15@01))
      unknown@15@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@15@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@16@01 r) V@7@01) (<= 0 (inv@16@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) (inv@16@01 r))
      r))
  :pattern ((inv@16@01 r))
  :qid |bool-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((unknown@15@01 Int)) (!
  (implies
    (and (< unknown@15@01 V@7@01) (<= 0 unknown@15@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@15@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@15@01))
  :qid |bool-permImpliesNonNull|)))
(declare-const sm@17@01 $FVF<Bool>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@16@01 r) V@7@01) (<= 0 (inv@16@01 r)))
    (=
      ($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) r)
      ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))) r)))
  :pattern (($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) r))
  :pattern (($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))) r))
  :qid |qp.fvfValDef2|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_bool ($FVF.lookup_bool ($SortWrappers.$SnapTo$FVF<Bool> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))) r) r)
  :pattern (($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) r))
  :qid |qp.fvfResTrgDef3|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@16@01 r) V@7@01) (<= 0 (inv@16@01 r)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) r) r))
  :pattern ((inv@16@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@14@01))))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: { aloc(opt_get1(visited), unknown) } 0 <= unknown && unknown < V ==> aloc(opt_get1(visited), unknown).bool == false)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@8@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               272
;  :arith-add-rows          14
;  :arith-assert-diseq      2
;  :arith-assert-lower      75
;  :arith-assert-upper      26
;  :arith-bound-prop        4
;  :arith-conflicts         2
;  :arith-eq-adapter        16
;  :arith-fixed-eqs         12
;  :arith-pivots            34
;  :conflicts               8
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               36
;  :del-clause              52
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.03
;  :mk-bool-var             532
;  :mk-clause               60
;  :num-allocs              134887
;  :num-checks              28
;  :propagations            90
;  :quant-instantiations    91
;  :rlimit-count            138028)
; [then-branch: 15 | exc@8@01 == Null | live]
; [else-branch: 15 | exc@8@01 != Null | dead]
(push) ; 5
; [then-branch: 15 | exc@8@01 == Null]
; [eval] (forall unknown: Int :: { aloc(opt_get1(visited), unknown) } 0 <= unknown && unknown < V ==> aloc(opt_get1(visited), unknown).bool == false)
(declare-const unknown@18@01 Int)
(push) ; 6
; [eval] 0 <= unknown && unknown < V ==> aloc(opt_get1(visited), unknown).bool == false
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 7
; [then-branch: 16 | 0 <= unknown@18@01 | live]
; [else-branch: 16 | !(0 <= unknown@18@01) | live]
(push) ; 8
; [then-branch: 16 | 0 <= unknown@18@01]
(assert (<= 0 unknown@18@01))
; [eval] unknown < V
(pop) ; 8
(push) ; 8
; [else-branch: 16 | !(0 <= unknown@18@01)]
(assert (not (<= 0 unknown@18@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 17 | unknown@18@01 < V@7@01 && 0 <= unknown@18@01 | live]
; [else-branch: 17 | !(unknown@18@01 < V@7@01 && 0 <= unknown@18@01) | live]
(push) ; 8
; [then-branch: 17 | unknown@18@01 < V@7@01 && 0 <= unknown@18@01]
(assert (and (< unknown@18@01 V@7@01) (<= 0 unknown@18@01)))
; [eval] aloc(opt_get1(visited), unknown).bool == false
; [eval] aloc(opt_get1(visited), unknown)
; [eval] opt_get1(visited)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(set-option :timeout 0)
(push) ; 10
(assert (not (not (= visited@5@01 (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               278
;  :arith-add-rows          14
;  :arith-assert-diseq      2
;  :arith-assert-lower      81
;  :arith-assert-upper      28
;  :arith-bound-prop        5
;  :arith-conflicts         2
;  :arith-eq-adapter        17
;  :arith-fixed-eqs         13
;  :arith-pivots            35
;  :conflicts               9
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               36
;  :del-clause              52
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.04
;  :mk-bool-var             542
;  :mk-clause               61
;  :num-allocs              135081
;  :num-checks              29
;  :propagations            95
;  :quant-instantiations    96
;  :rlimit-count            138307)
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not (= visited@5@01 (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (< unknown@18@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               278
;  :arith-add-rows          17
;  :arith-assert-diseq      2
;  :arith-assert-lower      82
;  :arith-assert-upper      28
;  :arith-bound-prop        5
;  :arith-conflicts         3
;  :arith-eq-adapter        17
;  :arith-fixed-eqs         13
;  :arith-pivots            37
;  :conflicts               10
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               36
;  :del-clause              52
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.03
;  :mk-bool-var             543
;  :mk-clause               61
;  :num-allocs              135232
;  :num-checks              30
;  :propagations            95
;  :quant-instantiations    96
;  :rlimit-count            138501)
(assert (< unknown@18@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01))))
(pop) ; 9
; Joined path conditions
(assert (< unknown@18@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01))))
(assert ($FVF.loc_bool ($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01)))
(push) ; 9
(assert (not (and
  (<
    (inv@16@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01))
    V@7@01)
  (<=
    0
    (inv@16@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               293
;  :arith-add-rows          25
;  :arith-assert-diseq      2
;  :arith-assert-lower      84
;  :arith-assert-upper      32
;  :arith-bound-prop        7
;  :arith-conflicts         4
;  :arith-eq-adapter        19
;  :arith-fixed-eqs         15
;  :arith-pivots            40
;  :conflicts               11
;  :datatype-accessor-ax    12
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               36
;  :del-clause              52
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.06
;  :mk-bool-var             575
;  :mk-clause               75
;  :num-allocs              135615
;  :num-checks              31
;  :propagations            99
;  :quant-instantiations    110
;  :rlimit-count            139420)
(pop) ; 8
(push) ; 8
; [else-branch: 17 | !(unknown@18@01 < V@7@01 && 0 <= unknown@18@01)]
(assert (not (and (< unknown@18@01 V@7@01) (<= 0 unknown@18@01))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< unknown@18@01 V@7@01) (<= 0 unknown@18@01))
  (and
    (< unknown@18@01 V@7@01)
    (<= 0 unknown@18@01)
    (not (= visited@5@01 (as None<option<array>>  option<array>)))
    (< unknown@18@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01)))
    ($FVF.loc_bool ($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@18@01 Int)) (!
  (implies
    (and (< unknown@18@01 V@7@01) (<= 0 unknown@18@01))
    (and
      (< unknown@18@01 V@7@01)
      (<= 0 unknown@18@01)
      (not (= visited@5@01 (as None<option<array>>  option<array>)))
      (< unknown@18@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01)))
      ($FVF.loc_bool ($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@8@01 $Ref.null)
  (forall ((unknown@18@01 Int)) (!
    (implies
      (and (< unknown@18@01 V@7@01) (<= 0 unknown@18@01))
      (and
        (< unknown@18@01 V@7@01)
        (<= 0 unknown@18@01)
        (not (= visited@5@01 (as None<option<array>>  option<array>)))
        (< unknown@18@01 (alen<Int> (opt_get1 $Snap.unit visited@5@01)))
        ($FVF.loc_bool ($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@8@01 $Ref.null)
  (forall ((unknown@18@01 Int)) (!
    (implies
      (and (< unknown@18@01 V@7@01) (<= 0 unknown@18@01))
      (=
        ($FVF.lookup_bool (as sm@17@01  $FVF<Bool>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01))
        false))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit visited@5@01) unknown@18@01))
    :qid |prog.l<no position>|))))
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; inhale false
(pop) ; 2
(pop) ; 1
; ---------- copy ----------
(declare-const this@19@01 $Ref)
(declare-const tid@20@01 Int)
(declare-const source@21@01 option<array>)
(declare-const target@22@01 option<array>)
(declare-const V@23@01 Int)
(declare-const exc@24@01 $Ref)
(declare-const res@25@01 void)
(declare-const this@26@01 $Ref)
(declare-const tid@27@01 Int)
(declare-const source@28@01 option<array>)
(declare-const target@29@01 option<array>)
(declare-const V@30@01 Int)
(declare-const exc@31@01 $Ref)
(declare-const res@32@01 void)
(push) ; 1
(declare-const $t@33@01 $Snap)
(assert (= $t@33@01 ($Snap.combine ($Snap.first $t@33@01) ($Snap.second $t@33@01))))
(assert (= ($Snap.first $t@33@01) $Snap.unit))
; [eval] this != null
(assert (not (= this@26@01 $Ref.null)))
(assert (=
  ($Snap.second $t@33@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@33@01))
    ($Snap.second ($Snap.second $t@33@01)))))
(assert (= ($Snap.first ($Snap.second $t@33@01)) $Snap.unit))
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= source@28@01 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second $t@33@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@33@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@33@01))) $Snap.unit))
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit source@28@01)) V@30@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@33@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))
(declare-const i1@34@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 18 | 0 <= i1@34@01 | live]
; [else-branch: 18 | !(0 <= i1@34@01) | live]
(push) ; 4
; [then-branch: 18 | 0 <= i1@34@01]
(assert (<= 0 i1@34@01))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 18 | !(0 <= i1@34@01)]
(assert (not (<= 0 i1@34@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@34@01 V@30@01) (<= 0 i1@34@01)))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@34@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               322
;  :arith-add-rows          29
;  :arith-assert-diseq      2
;  :arith-assert-lower      87
;  :arith-assert-upper      34
;  :arith-bound-prop        7
;  :arith-conflicts         4
;  :arith-eq-adapter        20
;  :arith-fixed-eqs         16
;  :arith-pivots            46
;  :conflicts               11
;  :datatype-accessor-ax    17
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               36
;  :del-clause              75
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.07
;  :mk-bool-var             595
;  :mk-clause               75
;  :num-allocs              136240
;  :num-checks              32
;  :propagations            99
;  :quant-instantiations    115
;  :rlimit-count            140650)
(assert (< i1@34@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 3
; Joined path conditions
(assert (< i1@34@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(declare-const $k@35@01 $Perm)
(assert ($Perm.isReadVar $k@35@01 $Perm.Write))
(pop) ; 2
(declare-fun inv@36@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@35@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@34@01 Int)) (!
  (< i1@34@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@34@01))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@34@01 Int)) (!
  (implies
    (and (< i1@34@01 V@30@01) (<= 0 i1@34@01))
    (or (= $k@35@01 $Perm.No) (< $Perm.No $k@35@01)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               324
;  :arith-add-rows          29
;  :arith-assert-diseq      3
;  :arith-assert-lower      89
;  :arith-assert-upper      35
;  :arith-bound-prop        7
;  :arith-conflicts         4
;  :arith-eq-adapter        21
;  :arith-fixed-eqs         16
;  :arith-pivots            48
;  :conflicts               12
;  :datatype-accessor-ax    18
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               36
;  :del-clause              75
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.07
;  :mk-bool-var             602
;  :mk-clause               77
;  :num-allocs              136728
;  :num-checks              33
;  :propagations            100
;  :quant-instantiations    115
;  :rlimit-count            141229)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@34@01 Int) (i12@34@01 Int)) (!
  (implies
    (and
      (and (and (< i11@34@01 V@30@01) (<= 0 i11@34@01)) (< $Perm.No $k@35@01))
      (and (and (< i12@34@01 V@30@01) (<= 0 i12@34@01)) (< $Perm.No $k@35@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@34@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@34@01)))
    (= i11@34@01 i12@34@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               354
;  :arith-add-rows          46
;  :arith-assert-diseq      7
;  :arith-assert-lower      98
;  :arith-assert-upper      37
;  :arith-bound-prop        7
;  :arith-conflicts         6
;  :arith-eq-adapter        23
;  :arith-fixed-eqs         17
;  :arith-pivots            56
;  :conflicts               15
;  :datatype-accessor-ax    18
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              93
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.07
;  :mk-bool-var             631
;  :mk-clause               95
;  :num-allocs              137118
;  :num-checks              34
;  :propagations            120
;  :quant-instantiations    126
;  :rlimit-count            142412)
; Definitional axioms for inverse functions
(assert (forall ((i1@34@01 Int)) (!
  (implies
    (and (and (< i1@34@01 V@30@01) (<= 0 i1@34@01)) (< $Perm.No $k@35@01))
    (=
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@34@01))
      i1@34@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@34@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
      (< $Perm.No $k@35@01))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@36@01 r))
      r))
  :pattern ((inv@36@01 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@34@01 Int)) (!
  (<= $Perm.No $k@35@01)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@34@01))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@34@01 Int)) (!
  (<= $k@35@01 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@34@01))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@34@01 Int)) (!
  (implies
    (and (and (< i1@34@01 V@30@01) (<= 0 i1@34@01)) (< $Perm.No $k@35@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@34@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@34@01))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@37@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
      (< $Perm.No $k@35@01)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef4|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef5|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) r) r))
  :pattern ((inv@36@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@38@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 19 | 0 <= i1@38@01 | live]
; [else-branch: 19 | !(0 <= i1@38@01) | live]
(push) ; 4
; [then-branch: 19 | 0 <= i1@38@01]
(assert (<= 0 i1@38@01))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 19 | !(0 <= i1@38@01)]
(assert (not (<= 0 i1@38@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 20 | i1@38@01 < V@30@01 && 0 <= i1@38@01 | live]
; [else-branch: 20 | !(i1@38@01 < V@30@01 && 0 <= i1@38@01) | live]
(push) ; 4
; [then-branch: 20 | i1@38@01 < V@30@01 && 0 <= i1@38@01]
(assert (and (< i1@38@01 V@30@01) (<= 0 i1@38@01)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@38@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               362
;  :arith-add-rows          46
;  :arith-assert-diseq      7
;  :arith-assert-lower      100
;  :arith-assert-upper      40
;  :arith-bound-prop        7
;  :arith-conflicts         6
;  :arith-eq-adapter        24
;  :arith-fixed-eqs         18
;  :arith-pivots            57
;  :conflicts               15
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              93
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.07
;  :mk-bool-var             645
;  :mk-clause               95
;  :num-allocs              138334
;  :num-checks              35
;  :propagations            120
;  :quant-instantiations    126
;  :rlimit-count            144762)
(assert (< i1@38@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 5
; Joined path conditions
(assert (< i1@38@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01))
      V@30@01)
    (<=
      0
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01))))
  (< $Perm.No $k@35@01)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               367
;  :arith-add-rows          51
;  :arith-assert-diseq      7
;  :arith-assert-lower      101
;  :arith-assert-upper      42
;  :arith-bound-prop        8
;  :arith-conflicts         7
;  :arith-eq-adapter        25
;  :arith-fixed-eqs         19
;  :arith-pivots            59
;  :conflicts               16
;  :datatype-accessor-ax    19
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              93
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.08
;  :mk-bool-var             663
;  :mk-clause               102
;  :num-allocs              138614
;  :num-checks              36
;  :propagations            120
;  :quant-instantiations    136
;  :rlimit-count            145440)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 20 | !(i1@38@01 < V@30@01 && 0 <= i1@38@01)]
(assert (not (and (< i1@38@01 V@30@01) (<= 0 i1@38@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@38@01 V@30@01) (<= 0 i1@38@01))
  (and
    (< i1@38@01 V@30@01)
    (<= 0 i1@38@01)
    (< i1@38@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@38@01 Int)) (!
  (implies
    (and (< i1@38@01 V@30@01) (<= 0 i1@38@01))
    (and
      (< i1@38@01 V@30@01)
      (<= 0 i1@38@01)
      (< i1@38@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@38@01 Int)) (!
  (implies
    (and (< i1@38@01 V@30@01) (<= 0 i1@38@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@38@01))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@39@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 21 | 0 <= i1@39@01 | live]
; [else-branch: 21 | !(0 <= i1@39@01) | live]
(push) ; 4
; [then-branch: 21 | 0 <= i1@39@01]
(assert (<= 0 i1@39@01))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 21 | !(0 <= i1@39@01)]
(assert (not (<= 0 i1@39@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 22 | i1@39@01 < V@30@01 && 0 <= i1@39@01 | live]
; [else-branch: 22 | !(i1@39@01 < V@30@01 && 0 <= i1@39@01) | live]
(push) ; 4
; [then-branch: 22 | i1@39@01 < V@30@01 && 0 <= i1@39@01]
(assert (and (< i1@39@01 V@30@01) (<= 0 i1@39@01)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@39@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               375
;  :arith-add-rows          58
;  :arith-assert-diseq      7
;  :arith-assert-lower      104
;  :arith-assert-upper      43
;  :arith-bound-prop        8
;  :arith-conflicts         7
;  :arith-eq-adapter        26
;  :arith-fixed-eqs         20
;  :arith-pivots            63
;  :conflicts               16
;  :datatype-accessor-ax    20
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              100
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.08
;  :mk-bool-var             672
;  :mk-clause               102
;  :num-allocs              139179
;  :num-checks              37
;  :propagations            120
;  :quant-instantiations    136
;  :rlimit-count            146664)
(assert (< i1@39@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 5
; Joined path conditions
(assert (< i1@39@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01)))
(push) ; 5
(assert (not (ite
  (and
    (<
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))
      V@30@01)
    (<=
      0
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))))
  (< $Perm.No $k@35@01)
  false)))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               380
;  :arith-add-rows          63
;  :arith-assert-diseq      7
;  :arith-assert-lower      105
;  :arith-assert-upper      45
;  :arith-bound-prop        9
;  :arith-conflicts         8
;  :arith-eq-adapter        27
;  :arith-fixed-eqs         21
;  :arith-pivots            65
;  :conflicts               17
;  :datatype-accessor-ax    20
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              100
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.11
;  :mk-bool-var             692
;  :mk-clause               109
;  :num-allocs              139458
;  :num-checks              38
;  :propagations            120
;  :quant-instantiations    148
;  :rlimit-count            147383)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               380
;  :arith-add-rows          63
;  :arith-assert-diseq      7
;  :arith-assert-lower      105
;  :arith-assert-upper      45
;  :arith-bound-prop        9
;  :arith-conflicts         8
;  :arith-eq-adapter        27
;  :arith-fixed-eqs         21
;  :arith-pivots            65
;  :conflicts               18
;  :datatype-accessor-ax    20
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              100
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.11
;  :mk-bool-var             692
;  :mk-clause               109
;  :num-allocs              139547
;  :num-checks              39
;  :propagations            120
;  :quant-instantiations    148
;  :rlimit-count            147478)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 22 | !(i1@39@01 < V@30@01 && 0 <= i1@39@01)]
(assert (not (and (< i1@39@01 V@30@01) (<= 0 i1@39@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@39@01 V@30@01) (<= 0 i1@39@01))
  (and
    (< i1@39@01 V@30@01)
    (<= 0 i1@39@01)
    (< i1@39@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@39@01 Int)) (!
  (implies
    (and (< i1@39@01 V@30@01) (<= 0 i1@39@01))
    (and
      (< i1@39@01 V@30@01)
      (<= 0 i1@39@01)
      (< i1@39@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@39@01 Int)) (!
  (implies
    (and (< i1@39@01 V@30@01) (<= 0 i1@39@01))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01))))
      V@30@01))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@39@01)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@40@01 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@41@01 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 23 | 0 <= i1@40@01 | live]
; [else-branch: 23 | !(0 <= i1@40@01) | live]
(push) ; 5
; [then-branch: 23 | 0 <= i1@40@01]
(assert (<= 0 i1@40@01))
; [eval] i1 < V
(push) ; 6
; [then-branch: 24 | i1@40@01 < V@30@01 | live]
; [else-branch: 24 | !(i1@40@01 < V@30@01) | live]
(push) ; 7
; [then-branch: 24 | i1@40@01 < V@30@01]
(assert (< i1@40@01 V@30@01))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 25 | 0 <= i2@41@01 | live]
; [else-branch: 25 | !(0 <= i2@41@01) | live]
(push) ; 9
; [then-branch: 25 | 0 <= i2@41@01]
(assert (<= 0 i2@41@01))
; [eval] i2 < V
(push) ; 10
; [then-branch: 26 | i2@41@01 < V@30@01 | live]
; [else-branch: 26 | !(i2@41@01 < V@30@01) | live]
(push) ; 11
; [then-branch: 26 | i2@41@01 < V@30@01]
(assert (< i2@41@01 V@30@01))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               388
;  :arith-add-rows          72
;  :arith-assert-diseq      7
;  :arith-assert-lower      109
;  :arith-assert-upper      47
;  :arith-bound-prop        9
;  :arith-conflicts         8
;  :arith-eq-adapter        28
;  :arith-fixed-eqs         22
;  :arith-pivots            70
;  :conflicts               18
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              107
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.11
;  :mk-bool-var             703
;  :mk-clause               109
;  :num-allocs              140382
;  :num-checks              40
;  :propagations            120
;  :quant-instantiations    148
;  :rlimit-count            148956)
(assert (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 12
; Joined path conditions
(assert (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
      V@30@01)
    (<=
      0
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))))
  (< $Perm.No $k@35@01)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               400
;  :arith-add-rows          75
;  :arith-assert-diseq      7
;  :arith-assert-lower      110
;  :arith-assert-upper      48
;  :arith-bound-prop        12
;  :arith-conflicts         8
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         23
;  :arith-offset-eqs        3
;  :arith-pivots            71
;  :conflicts               19
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              107
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.12
;  :mk-bool-var             722
;  :mk-clause               117
;  :num-allocs              140651
;  :num-checks              41
;  :propagations            124
;  :quant-instantiations    160
;  :rlimit-count            149629)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               400
;  :arith-add-rows          75
;  :arith-assert-diseq      7
;  :arith-assert-lower      110
;  :arith-assert-upper      48
;  :arith-bound-prop        12
;  :arith-conflicts         8
;  :arith-eq-adapter        29
;  :arith-fixed-eqs         23
;  :arith-offset-eqs        3
;  :arith-pivots            71
;  :conflicts               19
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              107
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.14
;  :memory                  4.12
;  :mk-bool-var             722
;  :mk-clause               117
;  :num-allocs              140682
;  :num-checks              42
;  :propagations            124
;  :quant-instantiations    160
;  :rlimit-count            149659)
(assert (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 12
; Joined path conditions
(assert (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
(push) ; 12
(assert (not (ite
  (and
    (<
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01))
      V@30@01)
    (<=
      0
      (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01))))
  (< $Perm.No $k@35@01)
  false)))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               404
;  :arith-add-rows          81
;  :arith-assert-diseq      7
;  :arith-assert-lower      111
;  :arith-assert-upper      50
;  :arith-bound-prop        13
;  :arith-conflicts         9
;  :arith-eq-adapter        30
;  :arith-fixed-eqs         24
;  :arith-offset-eqs        3
;  :arith-pivots            73
;  :conflicts               20
;  :datatype-accessor-ax    21
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              107
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.15
;  :memory                  4.14
;  :mk-bool-var             741
;  :mk-clause               124
;  :num-allocs              140989
;  :num-checks              43
;  :propagations            124
;  :quant-instantiations    171
;  :rlimit-count            150368)
(pop) ; 11
(push) ; 11
; [else-branch: 26 | !(i2@41@01 < V@30@01)]
(assert (not (< i2@41@01 V@30@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@41@01 V@30@01)
  (and
    (< i2@41@01 V@30@01)
    (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
    (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 25 | !(0 <= i2@41@01)]
(assert (not (<= 0 i2@41@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@41@01)
  (and
    (<= 0 i2@41@01)
    (implies
      (< i2@41@01 V@30@01)
      (and
        (< i2@41@01 V@30@01)
        (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
        (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 24 | !(i1@40@01 < V@30@01)]
(assert (not (< i1@40@01 V@30@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@40@01 V@30@01)
  (and
    (< i1@40@01 V@30@01)
    (implies
      (<= 0 i2@41@01)
      (and
        (<= 0 i2@41@01)
        (implies
          (< i2@41@01 V@30@01)
          (and
            (< i2@41@01 V@30@01)
            (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
            (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 23 | !(0 <= i1@40@01)]
(assert (not (<= 0 i1@40@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@40@01)
  (and
    (<= 0 i1@40@01)
    (implies
      (< i1@40@01 V@30@01)
      (and
        (< i1@40@01 V@30@01)
        (implies
          (<= 0 i2@41@01)
          (and
            (<= 0 i2@41@01)
            (implies
              (< i2@41@01 V@30@01)
              (and
                (< i2@41@01 V@30@01)
                (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
                (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 27 | Lookup(option$array$,sm@37@01,aloc((_, _), opt_get1(_, source@28@01), i1@40@01)) == Lookup(option$array$,sm@37@01,aloc((_, _), opt_get1(_, source@28@01), i2@41@01)) && i2@41@01 < V@30@01 && 0 <= i2@41@01 && i1@40@01 < V@30@01 && 0 <= i1@40@01 | live]
; [else-branch: 27 | !(Lookup(option$array$,sm@37@01,aloc((_, _), opt_get1(_, source@28@01), i1@40@01)) == Lookup(option$array$,sm@37@01,aloc((_, _), opt_get1(_, source@28@01), i2@41@01)) && i2@41@01 < V@30@01 && 0 <= i2@41@01 && i1@40@01 < V@30@01 && 0 <= i1@40@01) | live]
(push) ; 5
; [then-branch: 27 | Lookup(option$array$,sm@37@01,aloc((_, _), opt_get1(_, source@28@01), i1@40@01)) == Lookup(option$array$,sm@37@01,aloc((_, _), opt_get1(_, source@28@01), i2@41@01)) && i2@41@01 < V@30@01 && 0 <= i2@41@01 && i1@40@01 < V@30@01 && 0 <= i1@40@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
          ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
        (< i2@41@01 V@30@01))
      (<= 0 i2@41@01))
    (< i1@40@01 V@30@01))
  (<= 0 i1@40@01)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 27 | !(Lookup(option$array$,sm@37@01,aloc((_, _), opt_get1(_, source@28@01), i1@40@01)) == Lookup(option$array$,sm@37@01,aloc((_, _), opt_get1(_, source@28@01), i2@41@01)) && i2@41@01 < V@30@01 && 0 <= i2@41@01 && i1@40@01 < V@30@01 && 0 <= i1@40@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
            ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
          (< i2@41@01 V@30@01))
        (<= 0 i2@41@01))
      (< i1@40@01 V@30@01))
    (<= 0 i1@40@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
            ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
          (< i2@41@01 V@30@01))
        (<= 0 i2@41@01))
      (< i1@40@01 V@30@01))
    (<= 0 i1@40@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
      ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
    (< i2@41@01 V@30@01)
    (<= 0 i2@41@01)
    (< i1@40@01 V@30@01)
    (<= 0 i1@40@01))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@41@01 Int)) (!
  (and
    (implies
      (<= 0 i1@40@01)
      (and
        (<= 0 i1@40@01)
        (implies
          (< i1@40@01 V@30@01)
          (and
            (< i1@40@01 V@30@01)
            (implies
              (<= 0 i2@41@01)
              (and
                (<= 0 i2@41@01)
                (implies
                  (< i2@41@01 V@30@01)
                  (and
                    (< i2@41@01 V@30@01)
                    (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
                    (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
                ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
              (< i2@41@01 V@30@01))
            (<= 0 i2@41@01))
          (< i1@40@01 V@30@01))
        (<= 0 i1@40@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
          ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
        (< i2@41@01 V@30@01)
        (<= 0 i2@41@01)
        (< i1@40@01 V@30@01)
        (<= 0 i1@40@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@40@01 Int)) (!
  (forall ((i2@41@01 Int)) (!
    (and
      (implies
        (<= 0 i1@40@01)
        (and
          (<= 0 i1@40@01)
          (implies
            (< i1@40@01 V@30@01)
            (and
              (< i1@40@01 V@30@01)
              (implies
                (<= 0 i2@41@01)
                (and
                  (<= 0 i2@41@01)
                  (implies
                    (< i2@41@01 V@30@01)
                    (and
                      (< i2@41@01 V@30@01)
                      (< i1@40@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
                      (< i2@41@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
                  ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
                (< i2@41@01 V@30@01))
              (<= 0 i2@41@01))
            (< i1@40@01 V@30@01))
          (<= 0 i1@40@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
            ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
          (< i2@41@01 V@30@01)
          (<= 0 i2@41@01)
          (< i1@40@01 V@30@01)
          (<= 0 i1@40@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@40@01 Int)) (!
  (forall ((i2@41@01 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
                ($FVF.lookup_option$array$ (as sm@37@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01)))
              (< i2@41@01 V@30@01))
            (<= 0 i2@41@01))
          (< i1@40@01 V@30@01))
        (<= 0 i1@40@01))
      (= i1@40@01 i2@41@01))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@41@01))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@40@01))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))
  $Snap.unit))
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(assert (not (= target@29@01 (as None<option<array>>  option<array>))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))
  $Snap.unit))
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 2
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 2
; Joined path conditions
(assert (= (alen<Int> (opt_get1 $Snap.unit target@29@01)) V@30@01))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))))
(declare-const i1@42@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 28 | 0 <= i1@42@01 | live]
; [else-branch: 28 | !(0 <= i1@42@01) | live]
(push) ; 4
; [then-branch: 28 | 0 <= i1@42@01]
(assert (<= 0 i1@42@01))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 28 | !(0 <= i1@42@01)]
(assert (not (<= 0 i1@42@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and (< i1@42@01 V@30@01) (<= 0 i1@42@01)))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@42@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               431
;  :arith-add-rows          90
;  :arith-assert-diseq      7
;  :arith-assert-lower      117
;  :arith-assert-upper      53
;  :arith-bound-prop        13
;  :arith-conflicts         9
;  :arith-eq-adapter        33
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        3
;  :arith-pivots            83
;  :conflicts               20
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              146
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.15
;  :memory                  4.15
;  :mk-bool-var             779
;  :mk-clause               148
;  :num-allocs              142347
;  :num-checks              44
;  :propagations            124
;  :quant-instantiations    176
;  :rlimit-count            153721)
(assert (< i1@42@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 3
; Joined path conditions
(assert (< i1@42@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(declare-const $k@43@01 $Perm)
(assert ($Perm.isReadVar $k@43@01 $Perm.Write))
(pop) ; 2
(declare-fun inv@44@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@43@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@42@01 Int)) (!
  (< i1@42@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@42@01))
  :qid |option$array$-aux|)))
(push) ; 2
(assert (not (forall ((i1@42@01 Int)) (!
  (implies
    (and (< i1@42@01 V@30@01) (<= 0 i1@42@01))
    (or (= $k@43@01 $Perm.No) (< $Perm.No $k@43@01)))
  
  ))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               431
;  :arith-add-rows          91
;  :arith-assert-diseq      8
;  :arith-assert-lower      119
;  :arith-assert-upper      54
;  :arith-bound-prop        13
;  :arith-conflicts         9
;  :arith-eq-adapter        34
;  :arith-fixed-eqs         27
;  :arith-offset-eqs        3
;  :arith-pivots            85
;  :conflicts               21
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               38
;  :del-clause              146
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.16
;  :memory                  4.15
;  :mk-bool-var             786
;  :mk-clause               150
;  :num-allocs              142805
;  :num-checks              45
;  :propagations            125
;  :quant-instantiations    176
;  :rlimit-count            154312)
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@42@01 Int) (i12@42@01 Int)) (!
  (implies
    (and
      (and (and (< i11@42@01 V@30@01) (<= 0 i11@42@01)) (< $Perm.No $k@43@01))
      (and (and (< i12@42@01 V@30@01) (<= 0 i12@42@01)) (< $Perm.No $k@43@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@42@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@42@01)))
    (= i11@42@01 i12@42@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               461
;  :arith-add-rows          105
;  :arith-assert-diseq      11
;  :arith-assert-lower      127
;  :arith-assert-upper      57
;  :arith-bound-prop        13
;  :arith-conflicts         11
;  :arith-eq-adapter        36
;  :arith-fixed-eqs         28
;  :arith-offset-eqs        4
;  :arith-pivots            91
;  :conflicts               24
;  :datatype-accessor-ax    24
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               40
;  :del-clause              164
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.16
;  :memory                  4.16
;  :mk-bool-var             814
;  :mk-clause               168
;  :num-allocs              143213
;  :num-checks              46
;  :propagations            145
;  :quant-instantiations    187
;  :rlimit-count            155408)
; Definitional axioms for inverse functions
(assert (forall ((i1@42@01 Int)) (!
  (implies
    (and (and (< i1@42@01 V@30@01) (<= 0 i1@42@01)) (< $Perm.No $k@43@01))
    (=
      (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@42@01))
      i1@42@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@42@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
      (< $Perm.No $k@43@01))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@44@01 r))
      r))
  :pattern ((inv@44@01 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@42@01 Int)) (!
  (<= $Perm.No $k@43@01)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@42@01))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@42@01 Int)) (!
  (<= $k@43@01 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@42@01))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@42@01 Int)) (!
  (implies
    (and (and (< i1@42@01 V@30@01) (<= 0 i1@42@01)) (< $Perm.No $k@43@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@42@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@42@01))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@45@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
      (< $Perm.No $k@43@01)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef6|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
      (< $Perm.No $k@35@01)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef7|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef8|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) r) r))
  :pattern ((inv@44@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@46@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 29 | 0 <= i1@46@01 | live]
; [else-branch: 29 | !(0 <= i1@46@01) | live]
(push) ; 4
; [then-branch: 29 | 0 <= i1@46@01]
(assert (<= 0 i1@46@01))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 29 | !(0 <= i1@46@01)]
(assert (not (<= 0 i1@46@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 30 | i1@46@01 < V@30@01 && 0 <= i1@46@01 | live]
; [else-branch: 30 | !(i1@46@01 < V@30@01 && 0 <= i1@46@01) | live]
(push) ; 4
; [then-branch: 30 | i1@46@01 < V@30@01 && 0 <= i1@46@01]
(assert (and (< i1@46@01 V@30@01) (<= 0 i1@46@01)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@46@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               469
;  :arith-add-rows          107
;  :arith-assert-diseq      11
;  :arith-assert-lower      130
;  :arith-assert-upper      59
;  :arith-bound-prop        13
;  :arith-conflicts         11
;  :arith-eq-adapter        37
;  :arith-fixed-eqs         29
;  :arith-offset-eqs        4
;  :arith-pivots            93
;  :conflicts               24
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               40
;  :del-clause              164
;  :final-checks            38
;  :max-generation          2
;  :max-memory              4.18
;  :memory                  4.17
;  :mk-bool-var             829
;  :mk-clause               168
;  :num-allocs              144618
;  :num-checks              47
;  :propagations            145
;  :quant-instantiations    187
;  :rlimit-count            158659)
(assert (< i1@46@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 5
; Joined path conditions
(assert (< i1@46@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01)))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               504
;  :arith-add-rows          123
;  :arith-assert-diseq      15
;  :arith-assert-lower      143
;  :arith-assert-upper      66
;  :arith-bound-prop        20
;  :arith-conflicts         13
;  :arith-eq-adapter        49
;  :arith-fixed-eqs         32
;  :arith-offset-eqs        9
;  :arith-pivots            104
;  :conflicts               30
;  :datatype-accessor-ax    25
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               49
;  :del-clause              227
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.21
;  :memory                  4.21
;  :mk-bool-var             929
;  :mk-clause               251
;  :num-allocs              145336
;  :num-checks              48
;  :propagations            187
;  :quant-instantiations    208
;  :rlimit-count            160467)
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 30 | !(i1@46@01 < V@30@01 && 0 <= i1@46@01)]
(assert (not (and (< i1@46@01 V@30@01) (<= 0 i1@46@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@46@01 V@30@01) (<= 0 i1@46@01))
  (and
    (< i1@46@01 V@30@01)
    (<= 0 i1@46@01)
    (< i1@46@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01)))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@46@01 Int)) (!
  (implies
    (and (< i1@46@01 V@30@01) (<= 0 i1@46@01))
    (and
      (< i1@46@01 V@30@01)
      (<= 0 i1@46@01)
      (< i1@46@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@46@01 Int)) (!
  (implies
    (and (< i1@46@01 V@30@01) (<= 0 i1@46@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01))
        (as None<option<array>>  option<array>))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@46@01))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@47@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 31 | 0 <= i1@47@01 | live]
; [else-branch: 31 | !(0 <= i1@47@01) | live]
(push) ; 4
; [then-branch: 31 | 0 <= i1@47@01]
(assert (<= 0 i1@47@01))
; [eval] i1 < V
(pop) ; 4
(push) ; 4
; [else-branch: 31 | !(0 <= i1@47@01)]
(assert (not (<= 0 i1@47@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(push) ; 3
; [then-branch: 32 | i1@47@01 < V@30@01 && 0 <= i1@47@01 | live]
; [else-branch: 32 | !(i1@47@01 < V@30@01 && 0 <= i1@47@01) | live]
(push) ; 4
; [then-branch: 32 | i1@47@01 < V@30@01 && 0 <= i1@47@01]
(assert (and (< i1@47@01 V@30@01) (<= 0 i1@47@01)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@47@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               512
;  :arith-add-rows          128
;  :arith-assert-diseq      15
;  :arith-assert-lower      146
;  :arith-assert-upper      67
;  :arith-bound-prop        20
;  :arith-conflicts         13
;  :arith-eq-adapter        50
;  :arith-fixed-eqs         33
;  :arith-offset-eqs        9
;  :arith-pivots            110
;  :conflicts               30
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               49
;  :del-clause              247
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.21
;  :memory                  4.21
;  :mk-bool-var             938
;  :mk-clause               251
;  :num-allocs              145907
;  :num-checks              49
;  :propagations            187
;  :quant-instantiations    208
;  :rlimit-count            161750)
(assert (< i1@47@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 5
; Joined path conditions
(assert (< i1@47@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01)))
(push) ; 5
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               546
;  :arith-add-rows          144
;  :arith-assert-diseq      19
;  :arith-assert-lower      159
;  :arith-assert-upper      74
;  :arith-bound-prop        27
;  :arith-conflicts         15
;  :arith-eq-adapter        62
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        14
;  :arith-pivots            118
;  :conflicts               36
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               58
;  :del-clause              310
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.25
;  :memory                  4.23
;  :mk-bool-var             1039
;  :mk-clause               334
;  :num-allocs              146427
;  :num-checks              50
;  :propagations            229
;  :quant-instantiations    231
;  :rlimit-count            163460)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 6
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               546
;  :arith-add-rows          144
;  :arith-assert-diseq      19
;  :arith-assert-lower      159
;  :arith-assert-upper      74
;  :arith-bound-prop        27
;  :arith-conflicts         15
;  :arith-eq-adapter        62
;  :arith-fixed-eqs         36
;  :arith-offset-eqs        14
;  :arith-pivots            118
;  :conflicts               37
;  :datatype-accessor-ax    26
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               58
;  :del-clause              310
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.25
;  :memory                  4.23
;  :mk-bool-var             1039
;  :mk-clause               334
;  :num-allocs              146515
;  :num-checks              51
;  :propagations            229
;  :quant-instantiations    231
;  :rlimit-count            163555)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
    (as None<option<array>>  option<array>))))
(pop) ; 5
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
    (as None<option<array>>  option<array>))))
(pop) ; 4
(push) ; 4
; [else-branch: 32 | !(i1@47@01 < V@30@01 && 0 <= i1@47@01)]
(assert (not (and (< i1@47@01 V@30@01) (<= 0 i1@47@01))))
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (and (< i1@47@01 V@30@01) (<= 0 i1@47@01))
  (and
    (< i1@47@01 V@30@01)
    (<= 0 i1@47@01)
    (< i1@47@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@47@01 Int)) (!
  (implies
    (and (< i1@47@01 V@30@01) (<= 0 i1@47@01))
    (and
      (< i1@47@01 V@30@01)
      (<= 0 i1@47@01)
      (< i1@47@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@47@01 Int)) (!
  (implies
    (and (< i1@47@01 V@30@01) (<= 0 i1@47@01))
    (=
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01))))
      V@30@01))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@47@01)))))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))))
  $Snap.unit))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@48@01 Int)
(push) ; 2
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@49@01 Int)
(push) ; 3
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 4
; [then-branch: 33 | 0 <= i1@48@01 | live]
; [else-branch: 33 | !(0 <= i1@48@01) | live]
(push) ; 5
; [then-branch: 33 | 0 <= i1@48@01]
(assert (<= 0 i1@48@01))
; [eval] i1 < V
(push) ; 6
; [then-branch: 34 | i1@48@01 < V@30@01 | live]
; [else-branch: 34 | !(i1@48@01 < V@30@01) | live]
(push) ; 7
; [then-branch: 34 | i1@48@01 < V@30@01]
(assert (< i1@48@01 V@30@01))
; [eval] 0 <= i2
(push) ; 8
; [then-branch: 35 | 0 <= i2@49@01 | live]
; [else-branch: 35 | !(0 <= i2@49@01) | live]
(push) ; 9
; [then-branch: 35 | 0 <= i2@49@01]
(assert (<= 0 i2@49@01))
; [eval] i2 < V
(push) ; 10
; [then-branch: 36 | i2@49@01 < V@30@01 | live]
; [else-branch: 36 | !(i2@49@01 < V@30@01) | live]
(push) ; 11
; [then-branch: 36 | i2@49@01 < V@30@01]
(assert (< i2@49@01 V@30@01))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               554
;  :arith-add-rows          150
;  :arith-assert-diseq      19
;  :arith-assert-lower      164
;  :arith-assert-upper      75
;  :arith-bound-prop        27
;  :arith-conflicts         15
;  :arith-eq-adapter        63
;  :arith-fixed-eqs         37
;  :arith-offset-eqs        14
;  :arith-pivots            124
;  :conflicts               37
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               58
;  :del-clause              330
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.25
;  :memory                  4.24
;  :mk-bool-var             1050
;  :mk-clause               334
;  :num-allocs              147282
;  :num-checks              52
;  :propagations            229
;  :quant-instantiations    231
;  :rlimit-count            165079)
(assert (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 12
; Joined path conditions
(assert (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               588
;  :arith-add-rows          169
;  :arith-assert-diseq      23
;  :arith-assert-lower      177
;  :arith-assert-upper      82
;  :arith-bound-prop        34
;  :arith-conflicts         17
;  :arith-eq-adapter        75
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        19
;  :arith-pivots            132
;  :conflicts               43
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               67
;  :del-clause              393
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.26
;  :memory                  4.25
;  :mk-bool-var             1151
;  :mk-clause               417
;  :num-allocs              147820
;  :num-checks              53
;  :propagations            271
;  :quant-instantiations    254
;  :rlimit-count            166783)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 13
(assert (not (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               588
;  :arith-add-rows          169
;  :arith-assert-diseq      23
;  :arith-assert-lower      177
;  :arith-assert-upper      82
;  :arith-bound-prop        34
;  :arith-conflicts         17
;  :arith-eq-adapter        75
;  :arith-fixed-eqs         40
;  :arith-offset-eqs        19
;  :arith-pivots            132
;  :conflicts               43
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               67
;  :del-clause              393
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.26
;  :memory                  4.25
;  :mk-bool-var             1151
;  :mk-clause               417
;  :num-allocs              147845
;  :num-checks              54
;  :propagations            271
;  :quant-instantiations    254
;  :rlimit-count            166813)
(assert (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 12
; Joined path conditions
(assert (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               622
;  :arith-add-rows          190
;  :arith-assert-diseq      27
;  :arith-assert-lower      190
;  :arith-assert-upper      90
;  :arith-bound-prop        42
;  :arith-conflicts         19
;  :arith-eq-adapter        87
;  :arith-fixed-eqs         43
;  :arith-offset-eqs        24
;  :arith-pivots            139
;  :conflicts               53
;  :datatype-accessor-ax    27
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               76
;  :del-clause              453
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.32
;  :memory                  4.32
;  :mk-bool-var             1257
;  :mk-clause               489
;  :num-allocs              148580
;  :num-checks              55
;  :propagations            309
;  :quant-instantiations    273
;  :rlimit-count            168355)
(pop) ; 11
(push) ; 11
; [else-branch: 36 | !(i2@49@01 < V@30@01)]
(assert (not (< i2@49@01 V@30@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i2@49@01 V@30@01)
  (and
    (< i2@49@01 V@30@01)
    (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
    (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 35 | !(0 <= i2@49@01)]
(assert (not (<= 0 i2@49@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i2@49@01)
  (and
    (<= 0 i2@49@01)
    (implies
      (< i2@49@01 V@30@01)
      (and
        (< i2@49@01 V@30@01)
        (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
        (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))))))
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 34 | !(i1@48@01 < V@30@01)]
(assert (not (< i1@48@01 V@30@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (< i1@48@01 V@30@01)
  (and
    (< i1@48@01 V@30@01)
    (implies
      (<= 0 i2@49@01)
      (and
        (<= 0 i2@49@01)
        (implies
          (< i2@49@01 V@30@01)
          (and
            (< i2@49@01 V@30@01)
            (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
            (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))))))))
; Joined path conditions
(pop) ; 5
(push) ; 5
; [else-branch: 33 | !(0 <= i1@48@01)]
(assert (not (<= 0 i1@48@01)))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (<= 0 i1@48@01)
  (and
    (<= 0 i1@48@01)
    (implies
      (< i1@48@01 V@30@01)
      (and
        (< i1@48@01 V@30@01)
        (implies
          (<= 0 i2@49@01)
          (and
            (<= 0 i2@49@01)
            (implies
              (< i2@49@01 V@30@01)
              (and
                (< i2@49@01 V@30@01)
                (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
                (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))))))))))
; Joined path conditions
(push) ; 4
; [then-branch: 37 | Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i1@48@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i2@49@01)) && i2@49@01 < V@30@01 && 0 <= i2@49@01 && i1@48@01 < V@30@01 && 0 <= i1@48@01 | live]
; [else-branch: 37 | !(Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i1@48@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i2@49@01)) && i2@49@01 < V@30@01 && 0 <= i2@49@01 && i1@48@01 < V@30@01 && 0 <= i1@48@01) | live]
(push) ; 5
; [then-branch: 37 | Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i1@48@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i2@49@01)) && i2@49@01 < V@30@01 && 0 <= i2@49@01 && i1@48@01 < V@30@01 && 0 <= i1@48@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
        (< i2@49@01 V@30@01))
      (<= 0 i2@49@01))
    (< i1@48@01 V@30@01))
  (<= 0 i1@48@01)))
; [eval] i1 == i2
(pop) ; 5
(push) ; 5
; [else-branch: 37 | !(Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i1@48@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i2@49@01)) && i2@49@01 < V@30@01 && 0 <= i2@49@01 && i1@48@01 < V@30@01 && 0 <= i1@48@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
          (< i2@49@01 V@30@01))
        (<= 0 i2@49@01))
      (< i1@48@01 V@30@01))
    (<= 0 i1@48@01))))
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
          (< i2@49@01 V@30@01))
        (<= 0 i2@49@01))
      (< i1@48@01 V@30@01))
    (<= 0 i1@48@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
      ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
    (< i2@49@01 V@30@01)
    (<= 0 i2@49@01)
    (< i1@48@01 V@30@01)
    (<= 0 i1@48@01))))
; Joined path conditions
(pop) ; 3
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@49@01 Int)) (!
  (and
    (implies
      (<= 0 i1@48@01)
      (and
        (<= 0 i1@48@01)
        (implies
          (< i1@48@01 V@30@01)
          (and
            (< i1@48@01 V@30@01)
            (implies
              (<= 0 i2@49@01)
              (and
                (<= 0 i2@49@01)
                (implies
                  (< i2@49@01 V@30@01)
                  (and
                    (< i2@49@01 V@30@01)
                    (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
                    (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
                ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
              (< i2@49@01 V@30@01))
            (<= 0 i2@49@01))
          (< i1@48@01 V@30@01))
        (<= 0 i1@48@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
        (< i2@49@01 V@30@01)
        (<= 0 i2@49@01)
        (< i1@48@01 V@30@01)
        (<= 0 i1@48@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 2
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@48@01 Int)) (!
  (forall ((i2@49@01 Int)) (!
    (and
      (implies
        (<= 0 i1@48@01)
        (and
          (<= 0 i1@48@01)
          (implies
            (< i1@48@01 V@30@01)
            (and
              (< i1@48@01 V@30@01)
              (implies
                (<= 0 i2@49@01)
                (and
                  (<= 0 i2@49@01)
                  (implies
                    (< i2@49@01 V@30@01)
                    (and
                      (< i2@49@01 V@30@01)
                      (< i1@48@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
                      (< i2@49@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
                (< i2@49@01 V@30@01))
              (<= 0 i2@49@01))
            (< i1@48@01 V@30@01))
          (<= 0 i1@48@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
          (< i2@49@01 V@30@01)
          (<= 0 i2@49@01)
          (< i1@48@01 V@30@01)
          (<= 0 i1@48@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((i1@48@01 Int)) (!
  (forall ((i2@49@01 Int)) (!
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
                ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01)))
              (< i2@49@01 V@30@01))
            (<= 0 i2@49@01))
          (< i1@48@01 V@30@01))
        (<= 0 i1@48@01))
      (= i1@48@01 i2@49@01))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@49@01))
    :qid |prog.l<no position>|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@48@01))
  :qid |prog.l<no position>|)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01)))))))))))))))))
(declare-const i1@50@01 Int)
(declare-const j1@51@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 38 | 0 <= i1@50@01 | live]
; [else-branch: 38 | !(0 <= i1@50@01) | live]
(push) ; 4
; [then-branch: 38 | 0 <= i1@50@01]
(assert (<= 0 i1@50@01))
; [eval] i1 < V
(push) ; 5
; [then-branch: 39 | i1@50@01 < V@30@01 | live]
; [else-branch: 39 | !(i1@50@01 < V@30@01) | live]
(push) ; 6
; [then-branch: 39 | i1@50@01 < V@30@01]
(assert (< i1@50@01 V@30@01))
; [eval] 0 <= j1
(push) ; 7
; [then-branch: 40 | 0 <= j1@51@01 | live]
; [else-branch: 40 | !(0 <= j1@51@01) | live]
(push) ; 8
; [then-branch: 40 | 0 <= j1@51@01]
(assert (<= 0 j1@51@01))
; [eval] j1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 40 | !(0 <= j1@51@01)]
(assert (not (<= 0 j1@51@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 39 | !(i1@50@01 < V@30@01)]
(assert (not (< i1@50@01 V@30@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 38 | !(0 <= i1@50@01)]
(assert (not (<= 0 i1@50@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@51@01 V@30@01) (<= 0 j1@51@01)) (< i1@50@01 V@30@01))
  (<= 0 i1@50@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@50@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               633
;  :arith-add-rows          205
;  :arith-assert-diseq      27
;  :arith-assert-lower      199
;  :arith-assert-upper      93
;  :arith-bound-prop        42
;  :arith-conflicts         19
;  :arith-eq-adapter        90
;  :arith-fixed-eqs         46
;  :arith-offset-eqs        24
;  :arith-pivots            154
;  :conflicts               53
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               76
;  :del-clause              509
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.32
;  :memory                  4.32
;  :mk-bool-var             1288
;  :mk-clause               513
;  :num-allocs              149819
;  :num-checks              56
;  :propagations            309
;  :quant-instantiations    273
;  :rlimit-count            171499)
(assert (< i1@50@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 3
; Joined path conditions
(assert (< i1@50@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01)))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               677
;  :arith-add-rows          216
;  :arith-assert-diseq      30
;  :arith-assert-lower      211
;  :arith-assert-upper      101
;  :arith-bound-prop        49
;  :arith-conflicts         21
;  :arith-eq-adapter        100
;  :arith-fixed-eqs         49
;  :arith-offset-eqs        32
;  :arith-pivots            162
;  :conflicts               58
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               80
;  :del-clause              543
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.34
;  :memory                  4.33
;  :mk-bool-var             1370
;  :mk-clause               570
;  :num-allocs              150373
;  :num-checks              57
;  :propagations            339
;  :quant-instantiations    296
;  :rlimit-count            173270)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               687
;  :arith-add-rows          216
;  :arith-assert-diseq      30
;  :arith-assert-lower      211
;  :arith-assert-upper      103
;  :arith-bound-prop        50
;  :arith-conflicts         22
;  :arith-eq-adapter        100
;  :arith-fixed-eqs         49
;  :arith-offset-eqs        32
;  :arith-pivots            162
;  :conflicts               62
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               83
;  :del-clause              547
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.34
;  :memory                  4.33
;  :mk-bool-var             1375
;  :mk-clause               574
;  :num-allocs              150475
;  :num-checks              58
;  :propagations            344
;  :quant-instantiations    298
;  :rlimit-count            173492)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j1@51@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               717
;  :arith-add-rows          222
;  :arith-assert-diseq      30
;  :arith-assert-lower      216
;  :arith-assert-upper      106
;  :arith-bound-prop        52
;  :arith-conflicts         24
;  :arith-eq-adapter        102
;  :arith-fixed-eqs         50
;  :arith-offset-eqs        35
;  :arith-pivots            164
;  :conflicts               66
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               86
;  :del-clause              553
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.34
;  :memory                  4.33
;  :mk-bool-var             1397
;  :mk-clause               580
;  :num-allocs              150711
;  :num-checks              59
;  :propagations            352
;  :quant-instantiations    309
;  :rlimit-count            174137)
(assert (<
  j1@51@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j1@51@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))))))
(pop) ; 2
(declare-fun inv@52@01 ($Ref) Int)
(declare-fun inv@53@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@50@01 Int) (j1@51@01 Int)) (!
  (and
    (< i1@50@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))
        (as None<option<array>>  option<array>)))
    (<
      j1@51@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))) j1@51@01))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@50@01 Int) (j11@51@01 Int) (i12@50@01 Int) (j12@51@01 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@51@01 V@30@01) (<= 0 j11@51@01)) (< i11@50@01 V@30@01))
        (<= 0 i11@50@01))
      (and
        (and (and (< j12@51@01 V@30@01) (<= 0 j12@51@01)) (< i12@50@01 V@30@01))
        (<= 0 i12@50@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@50@01))) j11@51@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@50@01))) j12@51@01)))
    (and (= i11@50@01 i12@50@01) (= j11@51@01 j12@51@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               812
;  :arith-add-rows          271
;  :arith-assert-diseq      32
;  :arith-assert-lower      235
;  :arith-assert-upper      123
;  :arith-bound-prop        55
;  :arith-conflicts         27
;  :arith-eq-adapter        109
;  :arith-fixed-eqs         56
;  :arith-offset-eqs        42
;  :arith-pivots            193
;  :conflicts               71
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               95
;  :del-clause              668
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.44
;  :memory                  4.43
;  :mk-bool-var             1568
;  :mk-clause               672
;  :num-allocs              152080
;  :num-checks              60
;  :propagations            403
;  :quant-instantiations    382
;  :rlimit-count            179355
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@50@01 Int) (j1@51@01 Int)) (!
  (implies
    (and
      (and (and (< j1@51@01 V@30@01) (<= 0 j1@51@01)) (< i1@50@01 V@30@01))
      (<= 0 i1@50@01))
    (and
      (=
        (inv@52@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))) j1@51@01))
        i1@50@01)
      (=
        (inv@53@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))) j1@51@01))
        j1@51@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))) j1@51@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@53@01 r) V@30@01) (<= 0 (inv@53@01 r)))
        (< (inv@52@01 r) V@30@01))
      (<= 0 (inv@52@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@52@01 r)))) (inv@53@01 r))
      r))
  :pattern ((inv@52@01 r))
  :pattern ((inv@53@01 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@50@01 Int) (j1@51@01 Int)) (!
  (implies
    (and
      (and (and (< j1@51@01 V@30@01) (<= 0 j1@51@01)) (< i1@50@01 V@30@01))
      (<= 0 i1@50@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))) j1@51@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@50@01))) j1@51@01))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@54@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@53@01 r) V@30@01) (<= 0 (inv@53@01 r)))
        (< (inv@52@01 r) V@30@01))
      (<= 0 (inv@52@01 r)))
    (=
      ($FVF.lookup_int (as sm@54@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@54@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r))
  :qid |qp.fvfValDef9|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@54@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef10|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@53@01 r) V@30@01) (<= 0 (inv@53@01 r)))
        (< (inv@52@01 r) V@30@01))
      (<= 0 (inv@52@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@54@01  $FVF<Int>) r) r))
  :pattern ((inv@52@01 r) (inv@53@01 r))
  )))
(declare-const i1@55@01 Int)
(declare-const j1@56@01 Int)
(push) ; 2
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 3
; [then-branch: 41 | 0 <= i1@55@01 | live]
; [else-branch: 41 | !(0 <= i1@55@01) | live]
(push) ; 4
; [then-branch: 41 | 0 <= i1@55@01]
(assert (<= 0 i1@55@01))
; [eval] i1 < V
(push) ; 5
; [then-branch: 42 | i1@55@01 < V@30@01 | live]
; [else-branch: 42 | !(i1@55@01 < V@30@01) | live]
(push) ; 6
; [then-branch: 42 | i1@55@01 < V@30@01]
(assert (< i1@55@01 V@30@01))
; [eval] 0 <= j1
(push) ; 7
; [then-branch: 43 | 0 <= j1@56@01 | live]
; [else-branch: 43 | !(0 <= j1@56@01) | live]
(push) ; 8
; [then-branch: 43 | 0 <= j1@56@01]
(assert (<= 0 j1@56@01))
; [eval] j1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 43 | !(0 <= j1@56@01)]
(assert (not (<= 0 j1@56@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(pop) ; 6
(push) ; 6
; [else-branch: 42 | !(i1@55@01 < V@30@01)]
(assert (not (< i1@55@01 V@30@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 41 | !(0 <= i1@55@01)]
(assert (not (<= 0 i1@55@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@56@01 V@30@01) (<= 0 j1@56@01)) (< i1@55@01 V@30@01))
  (<= 0 i1@55@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 3
; Joined path conditions
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (< i1@55@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               816
;  :arith-add-rows          274
;  :arith-assert-diseq      32
;  :arith-assert-lower      243
;  :arith-assert-upper      125
;  :arith-bound-prop        55
;  :arith-conflicts         27
;  :arith-eq-adapter        111
;  :arith-fixed-eqs         58
;  :arith-offset-eqs        42
;  :arith-pivots            196
;  :conflicts               71
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               95
;  :del-clause              668
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.44
;  :memory                  4.43
;  :mk-bool-var             1586
;  :mk-clause               672
;  :num-allocs              153334
;  :num-checks              61
;  :propagations            403
;  :quant-instantiations    382
;  :rlimit-count            182612)
(assert (< i1@55@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 3
; Joined path conditions
(assert (< i1@55@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01)))
(push) ; 3
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               857
;  :arith-add-rows          285
;  :arith-assert-diseq      35
;  :arith-assert-lower      253
;  :arith-assert-upper      134
;  :arith-bound-prop        59
;  :arith-conflicts         30
;  :arith-eq-adapter        121
;  :arith-fixed-eqs         61
;  :arith-offset-eqs        45
;  :arith-pivots            202
;  :conflicts               76
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               99
;  :del-clause              694
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.45
;  :memory                  4.44
;  :mk-bool-var             1665
;  :mk-clause               718
;  :num-allocs              153856
;  :num-checks              62
;  :propagations            431
;  :quant-instantiations    406
;  :rlimit-count            184269)
(push) ; 3
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 4
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               857
;  :arith-add-rows          285
;  :arith-assert-diseq      35
;  :arith-assert-lower      253
;  :arith-assert-upper      134
;  :arith-bound-prop        59
;  :arith-conflicts         30
;  :arith-eq-adapter        121
;  :arith-fixed-eqs         61
;  :arith-offset-eqs        45
;  :arith-pivots            202
;  :conflicts               77
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               99
;  :del-clause              694
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.45
;  :memory                  4.44
;  :mk-bool-var             1665
;  :mk-clause               718
;  :num-allocs              153944
;  :num-checks              63
;  :propagations            431
;  :quant-instantiations    406
;  :rlimit-count            184364)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))
    (as None<option<array>>  option<array>))))
(pop) ; 3
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))
    (as None<option<array>>  option<array>))))
(push) ; 3
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 4
(assert (not (<
  j1@56@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01)))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               863
;  :arith-add-rows          290
;  :arith-assert-diseq      35
;  :arith-assert-lower      256
;  :arith-assert-upper      135
;  :arith-bound-prop        59
;  :arith-conflicts         31
;  :arith-eq-adapter        122
;  :arith-fixed-eqs         62
;  :arith-offset-eqs        45
;  :arith-pivots            206
;  :conflicts               78
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               99
;  :del-clause              698
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.45
;  :memory                  4.44
;  :mk-bool-var             1676
;  :mk-clause               722
;  :num-allocs              154138
;  :num-checks              64
;  :propagations            433
;  :quant-instantiations    413
;  :rlimit-count            184856)
(assert (<
  j1@56@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))))))
(pop) ; 3
; Joined path conditions
(assert (<
  j1@56@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))))))
(pop) ; 2
(declare-fun inv@57@01 ($Ref) Int)
(declare-fun inv@58@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@55@01 Int) (j1@56@01 Int)) (!
  (and
    (< i1@55@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))
        (as None<option<array>>  option<array>)))
    (<
      j1@56@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))) j1@56@01))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 2
(assert (not (forall ((i11@55@01 Int) (j11@56@01 Int) (i12@55@01 Int) (j12@56@01 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@56@01 V@30@01) (<= 0 j11@56@01)) (< i11@55@01 V@30@01))
        (<= 0 i11@55@01))
      (and
        (and (and (< j12@56@01 V@30@01) (<= 0 j12@56@01)) (< i12@55@01 V@30@01))
        (<= 0 i12@55@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@55@01))) j11@56@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@55@01))) j12@56@01)))
    (and (= i11@55@01 i12@55@01) (= j11@56@01 j12@56@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 2
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               909
;  :arith-add-rows          307
;  :arith-assert-diseq      35
;  :arith-assert-lower      269
;  :arith-assert-upper      140
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        129
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        48
;  :arith-pivots            219
;  :conflicts               79
;  :datatype-accessor-ax    28
;  :datatype-constructor-ax 30
;  :datatype-occurs-check   71
;  :datatype-splits         30
;  :decisions               99
;  :del-clause              796
;  :final-checks            38
;  :max-generation          3
;  :max-memory              4.52
;  :memory                  4.51
;  :mk-bool-var             1834
;  :mk-clause               800
;  :num-allocs              155314
;  :num-checks              65
;  :propagations            464
;  :quant-instantiations    478
;  :rlimit-count            188904
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@55@01 Int) (j1@56@01 Int)) (!
  (implies
    (and
      (and (and (< j1@56@01 V@30@01) (<= 0 j1@56@01)) (< i1@55@01 V@30@01))
      (<= 0 i1@55@01))
    (and
      (=
        (inv@57@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))) j1@56@01))
        i1@55@01)
      (=
        (inv@58@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))) j1@56@01))
        j1@56@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))) j1@56@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@58@01 r) V@30@01) (<= 0 (inv@58@01 r)))
        (< (inv@57@01 r) V@30@01))
      (<= 0 (inv@57@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@57@01 r)))) (inv@58@01 r))
      r))
  :pattern ((inv@57@01 r))
  :pattern ((inv@58@01 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@55@01 Int) (j1@56@01 Int)) (!
  (implies
    (and
      (and (and (< j1@56@01 V@30@01) (<= 0 j1@56@01)) (< i1@55@01 V@30@01))
      (<= 0 i1@55@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))) j1@56@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@55@01))) j1@56@01))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@59@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@58@01 r) V@30@01) (<= 0 (inv@58@01 r)))
        (< (inv@57@01 r) V@30@01))
      (<= 0 (inv@57@01 r)))
    (=
      ($FVF.lookup_int (as sm@59@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@59@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r))
  :qid |qp.fvfValDef11|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@53@01 r) V@30@01) (<= 0 (inv@53@01 r)))
        (< (inv@52@01 r) V@30@01))
      (<= 0 (inv@52@01 r)))
    (=
      ($FVF.lookup_int (as sm@59@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@59@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r))
  :qid |qp.fvfValDef12|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@59@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef13|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@58@01 r) V@30@01) (<= 0 (inv@58@01 r)))
        (< (inv@57@01 r) V@30@01))
      (<= 0 (inv@57@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@59@01  $FVF<Int>) r) r))
  :pattern ((inv@57@01 r) (inv@58@01 r))
  )))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
(push) ; 2
(declare-const $t@60@01 $Snap)
(assert (= $t@60@01 ($Snap.combine ($Snap.first $t@60@01) ($Snap.second $t@60@01))))
(assert (= ($Snap.first $t@60@01) $Snap.unit))
; [eval] exc == null
(assert (= exc@31@01 $Ref.null))
(assert (=
  ($Snap.second $t@60@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@60@01))
    ($Snap.second ($Snap.second $t@60@01)))))
(assert (= ($Snap.first ($Snap.second $t@60@01)) $Snap.unit))
; [eval] exc == null ==> source != (None(): option[array])
; [eval] exc == null
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               948
;  :arith-add-rows          307
;  :arith-assert-diseq      35
;  :arith-assert-lower      269
;  :arith-assert-upper      140
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        129
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        48
;  :arith-pivots            219
;  :conflicts               79
;  :datatype-accessor-ax    30
;  :datatype-constructor-ax 39
;  :datatype-occurs-check   77
;  :datatype-splits         35
;  :decisions               108
;  :del-clause              800
;  :final-checks            42
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             1851
;  :mk-clause               800
;  :num-allocs              157632
;  :num-checks              67
;  :propagations            464
;  :quant-instantiations    478
;  :rlimit-count            193609)
; [then-branch: 44 | exc@31@01 == Null | live]
; [else-branch: 44 | exc@31@01 != Null | dead]
(push) ; 4
; [then-branch: 44 | exc@31@01 == Null]
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (not (= source@28@01 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@60@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@60@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@60@01))) $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(source)) == V
; [eval] exc == null
(push) ; 3
(push) ; 4
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               970
;  :arith-add-rows          307
;  :arith-assert-diseq      35
;  :arith-assert-lower      269
;  :arith-assert-upper      140
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        129
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        48
;  :arith-pivots            219
;  :conflicts               79
;  :datatype-accessor-ax    31
;  :datatype-constructor-ax 44
;  :datatype-occurs-check   80
;  :datatype-splits         36
;  :decisions               113
;  :del-clause              800
;  :final-checks            44
;  :max-generation          3
;  :max-memory              4.53
;  :memory                  4.52
;  :mk-bool-var             1854
;  :mk-clause               800
;  :num-allocs              158250
;  :num-checks              68
;  :propagations            464
;  :quant-instantiations    478
;  :rlimit-count            194262)
; [then-branch: 45 | exc@31@01 == Null | live]
; [else-branch: 45 | exc@31@01 != Null | dead]
(push) ; 4
; [then-branch: 45 | exc@31@01 == Null]
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(pop) ; 3
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit source@28@01)) V@30@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@60@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@60@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))
; [eval] exc == null
(push) ; 3
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               994
;  :arith-add-rows          307
;  :arith-assert-diseq      35
;  :arith-assert-lower      269
;  :arith-assert-upper      140
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        129
;  :arith-fixed-eqs         65
;  :arith-offset-eqs        48
;  :arith-pivots            219
;  :conflicts               79
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   83
;  :datatype-splits         38
;  :decisions               119
;  :del-clause              800
;  :final-checks            46
;  :max-generation          3
;  :max-memory              4.54
;  :memory                  4.53
;  :mk-bool-var             1857
;  :mk-clause               800
;  :num-allocs              158873
;  :num-checks              69
;  :propagations            464
;  :quant-instantiations    478
;  :rlimit-count            194907)
; [then-branch: 46 | exc@31@01 == Null | live]
; [else-branch: 46 | exc@31@01 != Null | dead]
(push) ; 3
; [then-branch: 46 | exc@31@01 == Null]
(declare-const i1@61@01 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 47 | 0 <= i1@61@01 | live]
; [else-branch: 47 | !(0 <= i1@61@01) | live]
(push) ; 6
; [then-branch: 47 | 0 <= i1@61@01]
(assert (<= 0 i1@61@01))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 47 | !(0 <= i1@61@01)]
(assert (not (<= 0 i1@61@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@61@01 V@30@01) (<= 0 i1@61@01)))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 6
(assert (not (< i1@61@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               996
;  :arith-add-rows          309
;  :arith-assert-diseq      35
;  :arith-assert-lower      272
;  :arith-assert-upper      141
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        130
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        48
;  :arith-pivots            221
;  :conflicts               79
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   83
;  :datatype-splits         38
;  :decisions               119
;  :del-clause              800
;  :final-checks            46
;  :max-generation          3
;  :max-memory              4.54
;  :memory                  4.53
;  :mk-bool-var             1862
;  :mk-clause               800
;  :num-allocs              158989
;  :num-checks              70
;  :propagations            464
;  :quant-instantiations    478
;  :rlimit-count            195146)
(assert (< i1@61@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 5
; Joined path conditions
(assert (< i1@61@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(declare-const $k@62@01 $Perm)
(assert ($Perm.isReadVar $k@62@01 $Perm.Write))
(pop) ; 4
(declare-fun inv@63@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@62@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@61@01 Int)) (!
  (< i1@61@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@61@01))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@61@01 Int)) (!
  (implies
    (and (< i1@61@01 V@30@01) (<= 0 i1@61@01))
    (or (= $k@62@01 $Perm.No) (< $Perm.No $k@62@01)))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               996
;  :arith-add-rows          310
;  :arith-assert-diseq      36
;  :arith-assert-lower      274
;  :arith-assert-upper      142
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        131
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        48
;  :arith-pivots            223
;  :conflicts               80
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   83
;  :datatype-splits         38
;  :decisions               119
;  :del-clause              800
;  :final-checks            46
;  :max-generation          3
;  :max-memory              4.54
;  :memory                  4.53
;  :mk-bool-var             1869
;  :mk-clause               802
;  :num-allocs              159454
;  :num-checks              71
;  :propagations            465
;  :quant-instantiations    478
;  :rlimit-count            195738)
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@61@01 Int) (i12@61@01 Int)) (!
  (implies
    (and
      (and (and (< i11@61@01 V@30@01) (<= 0 i11@61@01)) (< $Perm.No $k@62@01))
      (and (and (< i12@61@01 V@30@01) (<= 0 i12@61@01)) (< $Perm.No $k@62@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@61@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@61@01)))
    (= i11@61@01 i12@61@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1003
;  :arith-add-rows          312
;  :arith-assert-diseq      37
;  :arith-assert-lower      278
;  :arith-assert-upper      142
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        133
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        48
;  :arith-pivots            225
;  :conflicts               81
;  :datatype-accessor-ax    32
;  :datatype-constructor-ax 50
;  :datatype-occurs-check   83
;  :datatype-splits         38
;  :decisions               119
;  :del-clause              807
;  :final-checks            46
;  :max-generation          3
;  :max-memory              4.54
;  :memory                  4.52
;  :mk-bool-var             1889
;  :mk-clause               809
;  :num-allocs              159823
;  :num-checks              72
;  :propagations            465
;  :quant-instantiations    489
;  :rlimit-count            196464)
; Definitional axioms for inverse functions
(assert (forall ((i1@61@01 Int)) (!
  (implies
    (and (and (< i1@61@01 V@30@01) (<= 0 i1@61@01)) (< $Perm.No $k@62@01))
    (=
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@61@01))
      i1@61@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@61@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@63@01 r) V@30@01) (<= 0 (inv@63@01 r)))
      (< $Perm.No $k@62@01))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@63@01 r))
      r))
  :pattern ((inv@63@01 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@61@01 Int)) (!
  (<= $Perm.No $k@62@01)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@61@01))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@61@01 Int)) (!
  (<= $k@62@01 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@61@01))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@61@01 Int)) (!
  (implies
    (and (and (< i1@61@01 V@30@01) (<= 0 i1@61@01)) (< $Perm.No $k@62@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@61@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@61@01))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@64@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@63@01 r) V@30@01) (<= 0 (inv@63@01 r)))
      (< $Perm.No $k@62@01)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@60@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@60@01))))) r))
  :qid |qp.fvfValDef14|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@60@01))))) r) r)
  :pattern (($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef15|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@63@01 r) V@30@01) (<= 0 (inv@63@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) r) r))
  :pattern ((inv@63@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1030
;  :arith-add-rows          312
;  :arith-assert-diseq      37
;  :arith-assert-lower      278
;  :arith-assert-upper      143
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        133
;  :arith-fixed-eqs         66
;  :arith-offset-eqs        48
;  :arith-pivots            225
;  :conflicts               81
;  :datatype-accessor-ax    33
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   86
;  :datatype-splits         40
;  :decisions               125
;  :del-clause              807
;  :final-checks            48
;  :max-generation          3
;  :max-memory              4.54
;  :memory                  4.53
;  :mk-bool-var             1900
;  :mk-clause               809
;  :num-allocs              161445
;  :num-checks              73
;  :propagations            465
;  :quant-instantiations    489
;  :rlimit-count            199134)
; [then-branch: 48 | exc@31@01 == Null | live]
; [else-branch: 48 | exc@31@01 != Null | dead]
(push) ; 5
; [then-branch: 48 | exc@31@01 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@65@01 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 49 | 0 <= i1@65@01 | live]
; [else-branch: 49 | !(0 <= i1@65@01) | live]
(push) ; 8
; [then-branch: 49 | 0 <= i1@65@01]
(assert (<= 0 i1@65@01))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 49 | !(0 <= i1@65@01)]
(assert (not (<= 0 i1@65@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 50 | i1@65@01 < V@30@01 && 0 <= i1@65@01 | live]
; [else-branch: 50 | !(i1@65@01 < V@30@01 && 0 <= i1@65@01) | live]
(push) ; 8
; [then-branch: 50 | i1@65@01 < V@30@01 && 0 <= i1@65@01]
(assert (and (< i1@65@01 V@30@01) (<= 0 i1@65@01)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@65@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1032
;  :arith-add-rows          314
;  :arith-assert-diseq      37
;  :arith-assert-lower      281
;  :arith-assert-upper      144
;  :arith-bound-prop        62
;  :arith-conflicts         31
;  :arith-eq-adapter        134
;  :arith-fixed-eqs         67
;  :arith-offset-eqs        48
;  :arith-pivots            227
;  :conflicts               81
;  :datatype-accessor-ax    33
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   86
;  :datatype-splits         40
;  :decisions               125
;  :del-clause              807
;  :final-checks            48
;  :max-generation          3
;  :max-memory              4.54
;  :memory                  4.53
;  :mk-bool-var             1905
;  :mk-clause               809
;  :num-allocs              161561
;  :num-checks              74
;  :propagations            465
;  :quant-instantiations    489
;  :rlimit-count            199383)
(assert (< i1@65@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 9
; Joined path conditions
(assert (< i1@65@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01))
      V@30@01)
    (<=
      0
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01))))
  (< $Perm.No $k@62@01)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1048
;  :arith-add-rows          326
;  :arith-assert-diseq      37
;  :arith-assert-lower      283
;  :arith-assert-upper      147
;  :arith-bound-prop        65
;  :arith-conflicts         32
;  :arith-eq-adapter        136
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        53
;  :arith-pivots            230
;  :conflicts               82
;  :datatype-accessor-ax    33
;  :datatype-constructor-ax 56
;  :datatype-occurs-check   86
;  :datatype-splits         40
;  :decisions               125
;  :del-clause              807
;  :final-checks            48
;  :max-generation          4
;  :max-memory              4.55
;  :memory                  4.54
;  :mk-bool-var             1953
;  :mk-clause               830
;  :num-allocs              161986
;  :num-checks              75
;  :propagations            469
;  :quant-instantiations    513
;  :rlimit-count            200821)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 50 | !(i1@65@01 < V@30@01 && 0 <= i1@65@01)]
(assert (not (and (< i1@65@01 V@30@01) (<= 0 i1@65@01))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@65@01 V@30@01) (<= 0 i1@65@01))
  (and
    (< i1@65@01 V@30@01)
    (<= 0 i1@65@01)
    (< i1@65@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@65@01 Int)) (!
  (implies
    (and (< i1@65@01 V@30@01) (<= 0 i1@65@01))
    (and
      (< i1@65@01 V@30@01)
      (<= 0 i1@65@01)
      (< i1@65@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@65@01 Int)) (!
    (implies
      (and (< i1@65@01 V@30@01) (<= 0 i1@65@01))
      (and
        (< i1@65@01 V@30@01)
        (<= 0 i1@65@01)
        (< i1@65@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@65@01 Int)) (!
    (implies
      (and (< i1@65@01 V@30@01) (<= 0 i1@65@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@65@01))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1076
;  :arith-add-rows          330
;  :arith-assert-diseq      37
;  :arith-assert-lower      283
;  :arith-assert-upper      147
;  :arith-bound-prop        65
;  :arith-conflicts         32
;  :arith-eq-adapter        136
;  :arith-fixed-eqs         69
;  :arith-offset-eqs        53
;  :arith-pivots            234
;  :conflicts               82
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 62
;  :datatype-occurs-check   89
;  :datatype-splits         42
;  :decisions               131
;  :del-clause              828
;  :final-checks            50
;  :max-generation          4
;  :max-memory              4.55
;  :memory                  4.54
;  :mk-bool-var             1959
;  :mk-clause               830
;  :num-allocs              162987
;  :num-checks              76
;  :propagations            469
;  :quant-instantiations    513
;  :rlimit-count            202379)
; [then-branch: 51 | exc@31@01 == Null | live]
; [else-branch: 51 | exc@31@01 != Null | dead]
(push) ; 5
; [then-branch: 51 | exc@31@01 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@66@01 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 52 | 0 <= i1@66@01 | live]
; [else-branch: 52 | !(0 <= i1@66@01) | live]
(push) ; 8
; [then-branch: 52 | 0 <= i1@66@01]
(assert (<= 0 i1@66@01))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 52 | !(0 <= i1@66@01)]
(assert (not (<= 0 i1@66@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 53 | i1@66@01 < V@30@01 && 0 <= i1@66@01 | live]
; [else-branch: 53 | !(i1@66@01 < V@30@01 && 0 <= i1@66@01) | live]
(push) ; 8
; [then-branch: 53 | i1@66@01 < V@30@01 && 0 <= i1@66@01]
(assert (and (< i1@66@01 V@30@01) (<= 0 i1@66@01)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@66@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1078
;  :arith-add-rows          332
;  :arith-assert-diseq      37
;  :arith-assert-lower      286
;  :arith-assert-upper      148
;  :arith-bound-prop        65
;  :arith-conflicts         32
;  :arith-eq-adapter        137
;  :arith-fixed-eqs         70
;  :arith-offset-eqs        53
;  :arith-pivots            236
;  :conflicts               82
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 62
;  :datatype-occurs-check   89
;  :datatype-splits         42
;  :decisions               131
;  :del-clause              828
;  :final-checks            50
;  :max-generation          4
;  :max-memory              4.55
;  :memory                  4.54
;  :mk-bool-var             1964
;  :mk-clause               830
;  :num-allocs              163103
;  :num-checks              77
;  :propagations            469
;  :quant-instantiations    513
;  :rlimit-count            202628)
(assert (< i1@66@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 9
; Joined path conditions
(assert (< i1@66@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01)))
(push) ; 9
(assert (not (ite
  (and
    (<
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
      V@30@01)
    (<=
      0
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))))
  (< $Perm.No $k@62@01)
  false)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1096
;  :arith-add-rows          344
;  :arith-assert-diseq      37
;  :arith-assert-lower      288
;  :arith-assert-upper      151
;  :arith-bound-prop        68
;  :arith-conflicts         33
;  :arith-eq-adapter        139
;  :arith-fixed-eqs         72
;  :arith-offset-eqs        58
;  :arith-pivots            239
;  :conflicts               83
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 62
;  :datatype-occurs-check   89
;  :datatype-splits         42
;  :decisions               131
;  :del-clause              828
;  :final-checks            50
;  :max-generation          4
;  :max-memory              4.55
;  :memory                  4.54
;  :mk-bool-var             2016
;  :mk-clause               851
;  :num-allocs              163523
;  :num-checks              78
;  :propagations            473
;  :quant-instantiations    539
;  :rlimit-count            204097)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1096
;  :arith-add-rows          344
;  :arith-assert-diseq      37
;  :arith-assert-lower      288
;  :arith-assert-upper      151
;  :arith-bound-prop        68
;  :arith-conflicts         33
;  :arith-eq-adapter        139
;  :arith-fixed-eqs         72
;  :arith-offset-eqs        58
;  :arith-pivots            239
;  :conflicts               84
;  :datatype-accessor-ax    34
;  :datatype-constructor-ax 62
;  :datatype-occurs-check   89
;  :datatype-splits         42
;  :decisions               131
;  :del-clause              828
;  :final-checks            50
;  :max-generation          4
;  :max-memory              4.55
;  :memory                  4.54
;  :mk-bool-var             2016
;  :mk-clause               851
;  :num-allocs              163611
;  :num-checks              79
;  :propagations            473
;  :quant-instantiations    539
;  :rlimit-count            204192)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 53 | !(i1@66@01 < V@30@01 && 0 <= i1@66@01)]
(assert (not (and (< i1@66@01 V@30@01) (<= 0 i1@66@01))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@66@01 V@30@01) (<= 0 i1@66@01))
  (and
    (< i1@66@01 V@30@01)
    (<= 0 i1@66@01)
    (< i1@66@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@66@01 Int)) (!
  (implies
    (and (< i1@66@01 V@30@01) (<= 0 i1@66@01))
    (and
      (< i1@66@01 V@30@01)
      (<= 0 i1@66@01)
      (< i1@66@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@66@01 Int)) (!
    (implies
      (and (< i1@66@01 V@30@01) (<= 0 i1@66@01))
      (and
        (< i1@66@01 V@30@01)
        (<= 0 i1@66@01)
        (< i1@66@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@66@01 Int)) (!
    (implies
      (and (< i1@66@01 V@30@01) (<= 0 i1@66@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@66@01)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1125
;  :arith-add-rows          348
;  :arith-assert-diseq      37
;  :arith-assert-lower      288
;  :arith-assert-upper      151
;  :arith-bound-prop        68
;  :arith-conflicts         33
;  :arith-eq-adapter        139
;  :arith-fixed-eqs         72
;  :arith-offset-eqs        58
;  :arith-pivots            243
;  :conflicts               84
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 68
;  :datatype-occurs-check   92
;  :datatype-splits         44
;  :decisions               137
;  :del-clause              849
;  :final-checks            52
;  :max-generation          4
;  :max-memory              4.56
;  :memory                  4.55
;  :mk-bool-var             2022
;  :mk-clause               851
;  :num-allocs              164641
;  :num-checks              80
;  :propagations            473
;  :quant-instantiations    539
;  :rlimit-count            205855)
; [then-branch: 54 | exc@31@01 == Null | live]
; [else-branch: 54 | exc@31@01 != Null | dead]
(push) ; 5
; [then-branch: 54 | exc@31@01 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@67@01 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@68@01 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 55 | 0 <= i1@67@01 | live]
; [else-branch: 55 | !(0 <= i1@67@01) | live]
(push) ; 9
; [then-branch: 55 | 0 <= i1@67@01]
(assert (<= 0 i1@67@01))
; [eval] i1 < V
(push) ; 10
; [then-branch: 56 | i1@67@01 < V@30@01 | live]
; [else-branch: 56 | !(i1@67@01 < V@30@01) | live]
(push) ; 11
; [then-branch: 56 | i1@67@01 < V@30@01]
(assert (< i1@67@01 V@30@01))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 57 | 0 <= i2@68@01 | live]
; [else-branch: 57 | !(0 <= i2@68@01) | live]
(push) ; 13
; [then-branch: 57 | 0 <= i2@68@01]
(assert (<= 0 i2@68@01))
; [eval] i2 < V
(push) ; 14
; [then-branch: 58 | i2@68@01 < V@30@01 | live]
; [else-branch: 58 | !(i2@68@01 < V@30@01) | live]
(push) ; 15
; [then-branch: 58 | i2@68@01 < V@30@01]
(assert (< i2@68@01 V@30@01))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1127
;  :arith-add-rows          350
;  :arith-assert-diseq      37
;  :arith-assert-lower      293
;  :arith-assert-upper      152
;  :arith-bound-prop        68
;  :arith-conflicts         33
;  :arith-eq-adapter        140
;  :arith-fixed-eqs         73
;  :arith-offset-eqs        58
;  :arith-pivots            244
;  :conflicts               84
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 68
;  :datatype-occurs-check   92
;  :datatype-splits         44
;  :decisions               137
;  :del-clause              849
;  :final-checks            52
;  :max-generation          4
;  :max-memory              4.56
;  :memory                  4.55
;  :mk-bool-var             2029
;  :mk-clause               851
;  :num-allocs              164935
;  :num-checks              81
;  :propagations            473
;  :quant-instantiations    539
;  :rlimit-count            206228)
(assert (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 16
; Joined path conditions
(assert (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
      V@30@01)
    (<=
      0
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))))
  (< $Perm.No $k@62@01)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1137
;  :arith-add-rows          359
;  :arith-assert-diseq      37
;  :arith-assert-lower      295
;  :arith-assert-upper      155
;  :arith-bound-prop        70
;  :arith-conflicts         34
;  :arith-eq-adapter        142
;  :arith-fixed-eqs         75
;  :arith-offset-eqs        58
;  :arith-pivots            247
;  :conflicts               85
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 68
;  :datatype-occurs-check   92
;  :datatype-splits         44
;  :decisions               137
;  :del-clause              849
;  :final-checks            52
;  :max-generation          4
;  :max-memory              4.59
;  :memory                  4.58
;  :mk-bool-var             2081
;  :mk-clause               872
;  :num-allocs              165354
;  :num-checks              82
;  :propagations            474
;  :quant-instantiations    565
;  :rlimit-count            207675)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1137
;  :arith-add-rows          359
;  :arith-assert-diseq      37
;  :arith-assert-lower      295
;  :arith-assert-upper      155
;  :arith-bound-prop        70
;  :arith-conflicts         34
;  :arith-eq-adapter        142
;  :arith-fixed-eqs         75
;  :arith-offset-eqs        58
;  :arith-pivots            247
;  :conflicts               85
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 68
;  :datatype-occurs-check   92
;  :datatype-splits         44
;  :decisions               137
;  :del-clause              849
;  :final-checks            52
;  :max-generation          4
;  :max-memory              4.59
;  :memory                  4.58
;  :mk-bool-var             2081
;  :mk-clause               872
;  :num-allocs              165379
;  :num-checks              83
;  :propagations            474
;  :quant-instantiations    565
;  :rlimit-count            207705)
(assert (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 16
; Joined path conditions
(assert (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
(push) ; 16
(assert (not (ite
  (and
    (<
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))
      V@30@01)
    (<=
      0
      (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))))
  (< $Perm.No $k@62@01)
  false)))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1146
;  :arith-add-rows          370
;  :arith-assert-diseq      37
;  :arith-assert-lower      297
;  :arith-assert-upper      158
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        145
;  :arith-fixed-eqs         77
;  :arith-offset-eqs        58
;  :arith-pivots            250
;  :conflicts               86
;  :datatype-accessor-ax    35
;  :datatype-constructor-ax 68
;  :datatype-occurs-check   92
;  :datatype-splits         44
;  :decisions               137
;  :del-clause              849
;  :final-checks            52
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.76
;  :mk-bool-var             2140
;  :mk-clause               905
;  :num-allocs              165835
;  :num-checks              84
;  :propagations            481
;  :quant-instantiations    591
;  :rlimit-count            209267)
(pop) ; 15
(push) ; 15
; [else-branch: 58 | !(i2@68@01 < V@30@01)]
(assert (not (< i2@68@01 V@30@01)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@68@01 V@30@01)
  (and
    (< i2@68@01 V@30@01)
    (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
    (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 57 | !(0 <= i2@68@01)]
(assert (not (<= 0 i2@68@01)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@68@01)
  (and
    (<= 0 i2@68@01)
    (implies
      (< i2@68@01 V@30@01)
      (and
        (< i2@68@01 V@30@01)
        (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
        (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 56 | !(i1@67@01 < V@30@01)]
(assert (not (< i1@67@01 V@30@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@67@01 V@30@01)
  (and
    (< i1@67@01 V@30@01)
    (implies
      (<= 0 i2@68@01)
      (and
        (<= 0 i2@68@01)
        (implies
          (< i2@68@01 V@30@01)
          (and
            (< i2@68@01 V@30@01)
            (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
            (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 55 | !(0 <= i1@67@01)]
(assert (not (<= 0 i1@67@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@67@01)
  (and
    (<= 0 i1@67@01)
    (implies
      (< i1@67@01 V@30@01)
      (and
        (< i1@67@01 V@30@01)
        (implies
          (<= 0 i2@68@01)
          (and
            (<= 0 i2@68@01)
            (implies
              (< i2@68@01 V@30@01)
              (and
                (< i2@68@01 V@30@01)
                (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
                (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 59 | Lookup(option$array$,sm@64@01,aloc((_, _), opt_get1(_, source@28@01), i1@67@01)) == Lookup(option$array$,sm@64@01,aloc((_, _), opt_get1(_, source@28@01), i2@68@01)) && i2@68@01 < V@30@01 && 0 <= i2@68@01 && i1@67@01 < V@30@01 && 0 <= i1@67@01 | live]
; [else-branch: 59 | !(Lookup(option$array$,sm@64@01,aloc((_, _), opt_get1(_, source@28@01), i1@67@01)) == Lookup(option$array$,sm@64@01,aloc((_, _), opt_get1(_, source@28@01), i2@68@01)) && i2@68@01 < V@30@01 && 0 <= i2@68@01 && i1@67@01 < V@30@01 && 0 <= i1@67@01) | live]
(push) ; 9
; [then-branch: 59 | Lookup(option$array$,sm@64@01,aloc((_, _), opt_get1(_, source@28@01), i1@67@01)) == Lookup(option$array$,sm@64@01,aloc((_, _), opt_get1(_, source@28@01), i2@68@01)) && i2@68@01 < V@30@01 && 0 <= i2@68@01 && i1@67@01 < V@30@01 && 0 <= i1@67@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
          ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
        (< i2@68@01 V@30@01))
      (<= 0 i2@68@01))
    (< i1@67@01 V@30@01))
  (<= 0 i1@67@01)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 59 | !(Lookup(option$array$,sm@64@01,aloc((_, _), opt_get1(_, source@28@01), i1@67@01)) == Lookup(option$array$,sm@64@01,aloc((_, _), opt_get1(_, source@28@01), i2@68@01)) && i2@68@01 < V@30@01 && 0 <= i2@68@01 && i1@67@01 < V@30@01 && 0 <= i1@67@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
            ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
          (< i2@68@01 V@30@01))
        (<= 0 i2@68@01))
      (< i1@67@01 V@30@01))
    (<= 0 i1@67@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
            ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
          (< i2@68@01 V@30@01))
        (<= 0 i2@68@01))
      (< i1@67@01 V@30@01))
    (<= 0 i1@67@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
      ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
    (< i2@68@01 V@30@01)
    (<= 0 i2@68@01)
    (< i1@67@01 V@30@01)
    (<= 0 i1@67@01))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@68@01 Int)) (!
  (and
    (implies
      (<= 0 i1@67@01)
      (and
        (<= 0 i1@67@01)
        (implies
          (< i1@67@01 V@30@01)
          (and
            (< i1@67@01 V@30@01)
            (implies
              (<= 0 i2@68@01)
              (and
                (<= 0 i2@68@01)
                (implies
                  (< i2@68@01 V@30@01)
                  (and
                    (< i2@68@01 V@30@01)
                    (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
                    (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
                ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
              (< i2@68@01 V@30@01))
            (<= 0 i2@68@01))
          (< i1@67@01 V@30@01))
        (<= 0 i1@67@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
          ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
        (< i2@68@01 V@30@01)
        (<= 0 i2@68@01)
        (< i1@67@01 V@30@01)
        (<= 0 i1@67@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@67@01 Int)) (!
  (forall ((i2@68@01 Int)) (!
    (and
      (implies
        (<= 0 i1@67@01)
        (and
          (<= 0 i1@67@01)
          (implies
            (< i1@67@01 V@30@01)
            (and
              (< i1@67@01 V@30@01)
              (implies
                (<= 0 i2@68@01)
                (and
                  (<= 0 i2@68@01)
                  (implies
                    (< i2@68@01 V@30@01)
                    (and
                      (< i2@68@01 V@30@01)
                      (< i1@67@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
                      (< i2@68@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
                  ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
                (< i2@68@01 V@30@01))
              (<= 0 i2@68@01))
            (< i1@67@01 V@30@01))
          (<= 0 i1@67@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
            ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
          (< i2@68@01 V@30@01)
          (<= 0 i2@68@01)
          (< i1@67@01 V@30@01)
          (<= 0 i1@67@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@67@01 Int)) (!
    (forall ((i2@68@01 Int)) (!
      (and
        (implies
          (<= 0 i1@67@01)
          (and
            (<= 0 i1@67@01)
            (implies
              (< i1@67@01 V@30@01)
              (and
                (< i1@67@01 V@30@01)
                (implies
                  (<= 0 i2@68@01)
                  (and
                    (<= 0 i2@68@01)
                    (implies
                      (< i2@68@01 V@30@01)
                      (and
                        (< i2@68@01 V@30@01)
                        (<
                          i1@67@01
                          (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
                        (<
                          i2@68@01
                          (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
                    ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
                  (< i2@68@01 V@30@01))
                (<= 0 i2@68@01))
              (< i1@67@01 V@30@01))
            (<= 0 i1@67@01))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
              ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
            (< i2@68@01 V@30@01)
            (<= 0 i2@68@01)
            (< i1@67@01 V@30@01)
            (<= 0 i1@67@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@67@01 Int)) (!
    (forall ((i2@68@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
                  ($FVF.lookup_option$array$ (as sm@64@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01)))
                (< i2@68@01 V@30@01))
              (<= 0 i2@68@01))
            (< i1@67@01 V@30@01))
          (<= 0 i1@67@01))
        (= i1@67@01 i2@68@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@68@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@67@01))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))
  $Snap.unit))
; [eval] exc == null ==> target != (None(): option[array])
; [eval] exc == null
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1178
;  :arith-add-rows          381
;  :arith-assert-diseq      37
;  :arith-assert-lower      298
;  :arith-assert-upper      159
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         78
;  :arith-offset-eqs        58
;  :arith-pivots            259
;  :conflicts               86
;  :datatype-accessor-ax    36
;  :datatype-constructor-ax 74
;  :datatype-occurs-check   95
;  :datatype-splits         46
;  :decisions               143
;  :del-clause              927
;  :final-checks            54
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.75
;  :mk-bool-var             2162
;  :mk-clause               929
;  :num-allocs              167426
;  :num-checks              85
;  :propagations            481
;  :quant-instantiations    591
;  :rlimit-count            212561)
; [then-branch: 60 | exc@31@01 == Null | live]
; [else-branch: 60 | exc@31@01 != Null | dead]
(push) ; 5
; [then-branch: 60 | exc@31@01 == Null]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (not (= target@29@01 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))
  $Snap.unit))
; [eval] exc == null ==> alen(opt_get1(target)) == V
; [eval] exc == null
(push) ; 4
(push) ; 5
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1209
;  :arith-add-rows          381
;  :arith-assert-diseq      37
;  :arith-assert-lower      298
;  :arith-assert-upper      159
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         78
;  :arith-offset-eqs        58
;  :arith-pivots            259
;  :conflicts               86
;  :datatype-accessor-ax    37
;  :datatype-constructor-ax 80
;  :datatype-occurs-check   98
;  :datatype-splits         48
;  :decisions               149
;  :del-clause              927
;  :final-checks            56
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.75
;  :mk-bool-var             2166
;  :mk-clause               929
;  :num-allocs              168080
;  :num-checks              86
;  :propagations            481
;  :quant-instantiations    591
;  :rlimit-count            213321)
; [then-branch: 61 | exc@31@01 == Null | live]
; [else-branch: 61 | exc@31@01 != Null | dead]
(push) ; 5
; [then-branch: 61 | exc@31@01 == Null]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit target@29@01)) V@30@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))
; [eval] exc == null
(push) ; 4
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1242
;  :arith-add-rows          381
;  :arith-assert-diseq      37
;  :arith-assert-lower      298
;  :arith-assert-upper      159
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        146
;  :arith-fixed-eqs         78
;  :arith-offset-eqs        58
;  :arith-pivots            259
;  :conflicts               86
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   101
;  :datatype-splits         51
;  :decisions               156
;  :del-clause              927
;  :final-checks            58
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.75
;  :mk-bool-var             2170
;  :mk-clause               929
;  :num-allocs              168736
;  :num-checks              87
;  :propagations            481
;  :quant-instantiations    591
;  :rlimit-count            214073)
; [then-branch: 62 | exc@31@01 == Null | live]
; [else-branch: 62 | exc@31@01 != Null | dead]
(push) ; 4
; [then-branch: 62 | exc@31@01 == Null]
(declare-const i1@69@01 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 63 | 0 <= i1@69@01 | live]
; [else-branch: 63 | !(0 <= i1@69@01) | live]
(push) ; 7
; [then-branch: 63 | 0 <= i1@69@01]
(assert (<= 0 i1@69@01))
; [eval] i1 < V
(pop) ; 7
(push) ; 7
; [else-branch: 63 | !(0 <= i1@69@01)]
(assert (not (<= 0 i1@69@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and (< i1@69@01 V@30@01) (<= 0 i1@69@01)))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< i1@69@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1244
;  :arith-add-rows          382
;  :arith-assert-diseq      37
;  :arith-assert-lower      301
;  :arith-assert-upper      160
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        147
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        58
;  :arith-pivots            260
;  :conflicts               86
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   101
;  :datatype-splits         51
;  :decisions               156
;  :del-clause              927
;  :final-checks            58
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.76
;  :mk-bool-var             2175
;  :mk-clause               929
;  :num-allocs              168852
;  :num-checks              88
;  :propagations            481
;  :quant-instantiations    591
;  :rlimit-count            214292)
(assert (< i1@69@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 6
; Joined path conditions
(assert (< i1@69@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(declare-const $k@70@01 $Perm)
(assert ($Perm.isReadVar $k@70@01 $Perm.Write))
(pop) ; 5
(declare-fun inv@71@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@70@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@69@01 Int)) (!
  (< i1@69@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@69@01))
  :qid |option$array$-aux|)))
(push) ; 5
(assert (not (forall ((i1@69@01 Int)) (!
  (implies
    (and (< i1@69@01 V@30@01) (<= 0 i1@69@01))
    (or (= $k@70@01 $Perm.No) (< $Perm.No $k@70@01)))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1244
;  :arith-add-rows          383
;  :arith-assert-diseq      38
;  :arith-assert-lower      303
;  :arith-assert-upper      161
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        148
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        58
;  :arith-pivots            261
;  :conflicts               87
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   101
;  :datatype-splits         51
;  :decisions               156
;  :del-clause              927
;  :final-checks            58
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.76
;  :mk-bool-var             2182
;  :mk-clause               931
;  :num-allocs              169318
;  :num-checks              89
;  :propagations            482
;  :quant-instantiations    591
;  :rlimit-count            214877)
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@69@01 Int) (i12@69@01 Int)) (!
  (implies
    (and
      (and (and (< i11@69@01 V@30@01) (<= 0 i11@69@01)) (< $Perm.No $k@70@01))
      (and (and (< i12@69@01 V@30@01) (<= 0 i12@69@01)) (< $Perm.No $k@70@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@69@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@69@01)))
    (= i11@69@01 i12@69@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1251
;  :arith-add-rows          389
;  :arith-assert-diseq      39
;  :arith-assert-lower      307
;  :arith-assert-upper      161
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        150
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               88
;  :datatype-accessor-ax    38
;  :datatype-constructor-ax 87
;  :datatype-occurs-check   101
;  :datatype-splits         51
;  :decisions               156
;  :del-clause              934
;  :final-checks            58
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.75
;  :mk-bool-var             2202
;  :mk-clause               938
;  :num-allocs              169689
;  :num-checks              90
;  :propagations            482
;  :quant-instantiations    602
;  :rlimit-count            215646)
; Definitional axioms for inverse functions
(assert (forall ((i1@69@01 Int)) (!
  (implies
    (and (and (< i1@69@01 V@30@01) (<= 0 i1@69@01)) (< $Perm.No $k@70@01))
    (=
      (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@69@01))
      i1@69@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@69@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@71@01 r) V@30@01) (<= 0 (inv@71@01 r)))
      (< $Perm.No $k@70@01))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@71@01 r))
      r))
  :pattern ((inv@71@01 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@69@01 Int)) (!
  (<= $Perm.No $k@70@01)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@69@01))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@69@01 Int)) (!
  (<= $k@70@01 $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@69@01))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@69@01 Int)) (!
  (implies
    (and (and (< i1@69@01 V@30@01) (<= 0 i1@69@01)) (< $Perm.No $k@70@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@69@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@69@01))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@72@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@71@01 r) V@30@01) (<= 0 (inv@71@01 r)))
      (< $Perm.No $k@70@01)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))) r))
  :qid |qp.fvfValDef16|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@63@01 r) V@30@01) (<= 0 (inv@63@01 r)))
      (< $Perm.No $k@62@01)
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@60@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@60@01))))) r))
  :qid |qp.fvfValDef17|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@60@01))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef18|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@71@01 r) V@30@01) (<= 0 (inv@71@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) r) r))
  :pattern ((inv@71@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1287
;  :arith-add-rows          389
;  :arith-assert-diseq      39
;  :arith-assert-lower      307
;  :arith-assert-upper      162
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        150
;  :arith-fixed-eqs         79
;  :arith-offset-eqs        58
;  :arith-pivots            265
;  :conflicts               88
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 94
;  :datatype-occurs-check   104
;  :datatype-splits         54
;  :decisions               163
;  :del-clause              934
;  :final-checks            60
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.78
;  :mk-bool-var             2215
;  :mk-clause               938
;  :num-allocs              171553
;  :num-checks              91
;  :propagations            482
;  :quant-instantiations    602
;  :rlimit-count            219224)
; [then-branch: 64 | exc@31@01 == Null | live]
; [else-branch: 64 | exc@31@01 != Null | dead]
(push) ; 6
; [then-branch: 64 | exc@31@01 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@73@01 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 65 | 0 <= i1@73@01 | live]
; [else-branch: 65 | !(0 <= i1@73@01) | live]
(push) ; 9
; [then-branch: 65 | 0 <= i1@73@01]
(assert (<= 0 i1@73@01))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 65 | !(0 <= i1@73@01)]
(assert (not (<= 0 i1@73@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 66 | i1@73@01 < V@30@01 && 0 <= i1@73@01 | live]
; [else-branch: 66 | !(i1@73@01 < V@30@01 && 0 <= i1@73@01) | live]
(push) ; 9
; [then-branch: 66 | i1@73@01 < V@30@01 && 0 <= i1@73@01]
(assert (and (< i1@73@01 V@30@01) (<= 0 i1@73@01)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@73@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1289
;  :arith-add-rows          391
;  :arith-assert-diseq      39
;  :arith-assert-lower      310
;  :arith-assert-upper      163
;  :arith-bound-prop        72
;  :arith-conflicts         35
;  :arith-eq-adapter        151
;  :arith-fixed-eqs         80
;  :arith-offset-eqs        58
;  :arith-pivots            267
;  :conflicts               88
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 94
;  :datatype-occurs-check   104
;  :datatype-splits         54
;  :decisions               163
;  :del-clause              934
;  :final-checks            60
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.78
;  :mk-bool-var             2220
;  :mk-clause               938
;  :num-allocs              171669
;  :num-checks              92
;  :propagations            482
;  :quant-instantiations    602
;  :rlimit-count            219473)
(assert (< i1@73@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 10
; Joined path conditions
(assert (< i1@73@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))
          V@30@01)
        (<=
          0
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))))
      $k@70@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))
          V@30@01)
        (<=
          0
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))))
      $k@62@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1391
;  :arith-add-rows          407
;  :arith-assert-diseq      42
;  :arith-assert-lower      322
;  :arith-assert-upper      172
;  :arith-bound-prop        79
;  :arith-conflicts         37
;  :arith-eq-adapter        161
;  :arith-fixed-eqs         84
;  :arith-offset-eqs        67
;  :arith-pivots            277
;  :conflicts               98
;  :datatype-accessor-ax    39
;  :datatype-constructor-ax 98
;  :datatype-occurs-check   104
;  :datatype-splits         54
;  :decisions               172
;  :del-clause              975
;  :final-checks            60
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.81
;  :mk-bool-var             2383
;  :mk-clause               1049
;  :num-allocs              172593
;  :num-checks              93
;  :propagations            514
;  :quant-instantiations    644
;  :rlimit-count            222209)
; [eval] (None(): option[array])
(pop) ; 9
(push) ; 9
; [else-branch: 66 | !(i1@73@01 < V@30@01 && 0 <= i1@73@01)]
(assert (not (and (< i1@73@01 V@30@01) (<= 0 i1@73@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and (< i1@73@01 V@30@01) (<= 0 i1@73@01))
  (and
    (< i1@73@01 V@30@01)
    (<= 0 i1@73@01)
    (< i1@73@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01)))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@73@01 Int)) (!
  (implies
    (and (< i1@73@01 V@30@01) (<= 0 i1@73@01))
    (and
      (< i1@73@01 V@30@01)
      (<= 0 i1@73@01)
      (< i1@73@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@73@01 Int)) (!
    (implies
      (and (< i1@73@01 V@30@01) (<= 0 i1@73@01))
      (and
        (< i1@73@01 V@30@01)
        (<= 0 i1@73@01)
        (< i1@73@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@73@01 Int)) (!
    (implies
      (and (< i1@73@01 V@30@01) (<= 0 i1@73@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@73@01))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1428
;  :arith-add-rows          414
;  :arith-assert-diseq      42
;  :arith-assert-lower      322
;  :arith-assert-upper      172
;  :arith-bound-prop        79
;  :arith-conflicts         37
;  :arith-eq-adapter        161
;  :arith-fixed-eqs         84
;  :arith-offset-eqs        67
;  :arith-pivots            282
;  :conflicts               98
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 105
;  :datatype-occurs-check   107
;  :datatype-splits         57
;  :decisions               179
;  :del-clause              1045
;  :final-checks            62
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.81
;  :mk-bool-var             2390
;  :mk-clause               1049
;  :num-allocs              173640
;  :num-checks              94
;  :propagations            514
;  :quant-instantiations    644
;  :rlimit-count            223932)
; [then-branch: 67 | exc@31@01 == Null | live]
; [else-branch: 67 | exc@31@01 != Null | dead]
(push) ; 6
; [then-branch: 67 | exc@31@01 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@74@01 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 68 | 0 <= i1@74@01 | live]
; [else-branch: 68 | !(0 <= i1@74@01) | live]
(push) ; 9
; [then-branch: 68 | 0 <= i1@74@01]
(assert (<= 0 i1@74@01))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 68 | !(0 <= i1@74@01)]
(assert (not (<= 0 i1@74@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 69 | i1@74@01 < V@30@01 && 0 <= i1@74@01 | live]
; [else-branch: 69 | !(i1@74@01 < V@30@01 && 0 <= i1@74@01) | live]
(push) ; 9
; [then-branch: 69 | i1@74@01 < V@30@01 && 0 <= i1@74@01]
(assert (and (< i1@74@01 V@30@01) (<= 0 i1@74@01)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@74@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1430
;  :arith-add-rows          416
;  :arith-assert-diseq      42
;  :arith-assert-lower      325
;  :arith-assert-upper      173
;  :arith-bound-prop        79
;  :arith-conflicts         37
;  :arith-eq-adapter        162
;  :arith-fixed-eqs         85
;  :arith-offset-eqs        67
;  :arith-pivots            284
;  :conflicts               98
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 105
;  :datatype-occurs-check   107
;  :datatype-splits         57
;  :decisions               179
;  :del-clause              1045
;  :final-checks            62
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.81
;  :mk-bool-var             2395
;  :mk-clause               1049
;  :num-allocs              173756
;  :num-checks              95
;  :propagations            514
;  :quant-instantiations    644
;  :rlimit-count            224183)
(assert (< i1@74@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 10
; Joined path conditions
(assert (< i1@74@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
          V@30@01)
        (<=
          0
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))))
      $k@70@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
          V@30@01)
        (<=
          0
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))))
      $k@62@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1529
;  :arith-add-rows          435
;  :arith-assert-diseq      45
;  :arith-assert-lower      339
;  :arith-assert-upper      180
;  :arith-bound-prop        85
;  :arith-conflicts         40
;  :arith-eq-adapter        172
;  :arith-fixed-eqs         89
;  :arith-offset-eqs        72
;  :arith-pivots            291
;  :conflicts               109
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 109
;  :datatype-occurs-check   107
;  :datatype-splits         57
;  :decisions               203
;  :del-clause              1169
;  :final-checks            62
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.83
;  :mk-bool-var             2644
;  :mk-clause               1243
;  :num-allocs              174826
;  :num-checks              96
;  :propagations            563
;  :quant-instantiations    698
;  :rlimit-count            227983)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1529
;  :arith-add-rows          435
;  :arith-assert-diseq      45
;  :arith-assert-lower      339
;  :arith-assert-upper      180
;  :arith-bound-prop        85
;  :arith-conflicts         40
;  :arith-eq-adapter        172
;  :arith-fixed-eqs         89
;  :arith-offset-eqs        72
;  :arith-pivots            291
;  :conflicts               110
;  :datatype-accessor-ax    40
;  :datatype-constructor-ax 109
;  :datatype-occurs-check   107
;  :datatype-splits         57
;  :decisions               203
;  :del-clause              1169
;  :final-checks            62
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.83
;  :mk-bool-var             2644
;  :mk-clause               1243
;  :num-allocs              174914
;  :num-checks              97
;  :propagations            563
;  :quant-instantiations    698
;  :rlimit-count            228078)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
    (as None<option<array>>  option<array>))))
(pop) ; 9
(push) ; 9
; [else-branch: 69 | !(i1@74@01 < V@30@01 && 0 <= i1@74@01)]
(assert (not (and (< i1@74@01 V@30@01) (<= 0 i1@74@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and (< i1@74@01 V@30@01) (<= 0 i1@74@01))
  (and
    (< i1@74@01 V@30@01)
    (<= 0 i1@74@01)
    (< i1@74@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@74@01 Int)) (!
  (implies
    (and (< i1@74@01 V@30@01) (<= 0 i1@74@01))
    (and
      (< i1@74@01 V@30@01)
      (<= 0 i1@74@01)
      (< i1@74@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@74@01 Int)) (!
    (implies
      (and (< i1@74@01 V@30@01) (<= 0 i1@74@01))
      (and
        (< i1@74@01 V@30@01)
        (<= 0 i1@74@01)
        (< i1@74@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01)))))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@74@01 Int)) (!
    (implies
      (and (< i1@74@01 V@30@01) (<= 0 i1@74@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@74@01)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1567
;  :arith-add-rows          441
;  :arith-assert-diseq      45
;  :arith-assert-lower      339
;  :arith-assert-upper      180
;  :arith-bound-prop        85
;  :arith-conflicts         40
;  :arith-eq-adapter        172
;  :arith-fixed-eqs         89
;  :arith-offset-eqs        72
;  :arith-pivots            295
;  :conflicts               110
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 116
;  :datatype-occurs-check   110
;  :datatype-splits         60
;  :decisions               210
;  :del-clause              1239
;  :final-checks            64
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.84
;  :mk-bool-var             2651
;  :mk-clause               1243
;  :num-allocs              175986
;  :num-checks              98
;  :propagations            563
;  :quant-instantiations    698
;  :rlimit-count            229890)
; [then-branch: 70 | exc@31@01 == Null | live]
; [else-branch: 70 | exc@31@01 != Null | dead]
(push) ; 6
; [then-branch: 70 | exc@31@01 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@75@01 Int)
(push) ; 7
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@76@01 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 71 | 0 <= i1@75@01 | live]
; [else-branch: 71 | !(0 <= i1@75@01) | live]
(push) ; 10
; [then-branch: 71 | 0 <= i1@75@01]
(assert (<= 0 i1@75@01))
; [eval] i1 < V
(push) ; 11
; [then-branch: 72 | i1@75@01 < V@30@01 | live]
; [else-branch: 72 | !(i1@75@01 < V@30@01) | live]
(push) ; 12
; [then-branch: 72 | i1@75@01 < V@30@01]
(assert (< i1@75@01 V@30@01))
; [eval] 0 <= i2
(push) ; 13
; [then-branch: 73 | 0 <= i2@76@01 | live]
; [else-branch: 73 | !(0 <= i2@76@01) | live]
(push) ; 14
; [then-branch: 73 | 0 <= i2@76@01]
(assert (<= 0 i2@76@01))
; [eval] i2 < V
(push) ; 15
; [then-branch: 74 | i2@76@01 < V@30@01 | live]
; [else-branch: 74 | !(i2@76@01 < V@30@01) | live]
(push) ; 16
; [then-branch: 74 | i2@76@01 < V@30@01]
(assert (< i2@76@01 V@30@01))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1569
;  :arith-add-rows          444
;  :arith-assert-diseq      45
;  :arith-assert-lower      344
;  :arith-assert-upper      181
;  :arith-bound-prop        85
;  :arith-conflicts         40
;  :arith-eq-adapter        173
;  :arith-fixed-eqs         90
;  :arith-offset-eqs        72
;  :arith-pivots            297
;  :conflicts               110
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 116
;  :datatype-occurs-check   110
;  :datatype-splits         60
;  :decisions               210
;  :del-clause              1239
;  :final-checks            64
;  :max-generation          4
;  :max-memory              4.91
;  :memory                  4.85
;  :mk-bool-var             2658
;  :mk-clause               1243
;  :num-allocs              176281
;  :num-checks              99
;  :propagations            563
;  :quant-instantiations    698
;  :rlimit-count            230286)
(assert (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 17
; Joined path conditions
(assert (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
          V@30@01)
        (<=
          0
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))))
      $k@70@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
          V@30@01)
        (<=
          0
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))))
      $k@62@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1670
;  :arith-add-rows          463
;  :arith-assert-diseq      48
;  :arith-assert-lower      355
;  :arith-assert-upper      191
;  :arith-bound-prop        92
;  :arith-conflicts         43
;  :arith-eq-adapter        184
;  :arith-fixed-eqs         94
;  :arith-offset-eqs        77
;  :arith-pivots            305
;  :conflicts               118
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 120
;  :datatype-occurs-check   110
;  :datatype-splits         60
;  :decisions               217
;  :del-clause              1266
;  :final-checks            64
;  :max-generation          4
;  :max-memory              4.92
;  :memory                  4.89
;  :mk-bool-var             2815
;  :mk-clause               1340
;  :num-allocs              177046
;  :num-checks              100
;  :propagations            596
;  :quant-instantiations    742
;  :rlimit-count            232975)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1670
;  :arith-add-rows          463
;  :arith-assert-diseq      48
;  :arith-assert-lower      355
;  :arith-assert-upper      191
;  :arith-bound-prop        92
;  :arith-conflicts         43
;  :arith-eq-adapter        184
;  :arith-fixed-eqs         94
;  :arith-offset-eqs        77
;  :arith-pivots            305
;  :conflicts               118
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 120
;  :datatype-occurs-check   110
;  :datatype-splits         60
;  :decisions               217
;  :del-clause              1266
;  :final-checks            64
;  :max-generation          4
;  :max-memory              4.92
;  :memory                  4.89
;  :mk-bool-var             2815
;  :mk-clause               1340
;  :num-allocs              177071
;  :num-checks              101
;  :propagations            596
;  :quant-instantiations    742
;  :rlimit-count            233005)
(assert (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 17
; Joined path conditions
(assert (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))
          V@30@01)
        (<=
          0
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))))
      $k@70@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))
          V@30@01)
        (<=
          0
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))))
      $k@62@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1779
;  :arith-add-rows          481
;  :arith-assert-diseq      53
;  :arith-assert-lower      372
;  :arith-assert-upper      203
;  :arith-bound-prop        104
;  :arith-conflicts         46
;  :arith-eq-adapter        196
;  :arith-fixed-eqs         98
;  :arith-offset-eqs        86
;  :arith-pivots            313
;  :conflicts               138
;  :datatype-accessor-ax    41
;  :datatype-constructor-ax 124
;  :datatype-occurs-check   110
;  :datatype-splits         60
;  :decisions               237
;  :del-clause              1391
;  :final-checks            64
;  :max-generation          4
;  :max-memory              5.00
;  :memory                  5.00
;  :mk-bool-var             3059
;  :mk-clause               1507
;  :num-allocs              178321
;  :num-checks              102
;  :propagations            655
;  :quant-instantiations    784
;  :rlimit-count            236113
;  :time                    0.00)
(pop) ; 16
(push) ; 16
; [else-branch: 74 | !(i2@76@01 < V@30@01)]
(assert (not (< i2@76@01 V@30@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i2@76@01 V@30@01)
  (and
    (< i2@76@01 V@30@01)
    (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
    (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 73 | !(0 <= i2@76@01)]
(assert (not (<= 0 i2@76@01)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i2@76@01)
  (and
    (<= 0 i2@76@01)
    (implies
      (< i2@76@01 V@30@01)
      (and
        (< i2@76@01 V@30@01)
        (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
        (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 72 | !(i1@75@01 < V@30@01)]
(assert (not (< i1@75@01 V@30@01)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (< i1@75@01 V@30@01)
  (and
    (< i1@75@01 V@30@01)
    (implies
      (<= 0 i2@76@01)
      (and
        (<= 0 i2@76@01)
        (implies
          (< i2@76@01 V@30@01)
          (and
            (< i2@76@01 V@30@01)
            (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
            (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))))))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 71 | !(0 <= i1@75@01)]
(assert (not (<= 0 i1@75@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (<= 0 i1@75@01)
  (and
    (<= 0 i1@75@01)
    (implies
      (< i1@75@01 V@30@01)
      (and
        (< i1@75@01 V@30@01)
        (implies
          (<= 0 i2@76@01)
          (and
            (<= 0 i2@76@01)
            (implies
              (< i2@76@01 V@30@01)
              (and
                (< i2@76@01 V@30@01)
                (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
                (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))))))))))
; Joined path conditions
(push) ; 9
; [then-branch: 75 | Lookup(option$array$,sm@72@01,aloc((_, _), opt_get1(_, target@29@01), i1@75@01)) == Lookup(option$array$,sm@72@01,aloc((_, _), opt_get1(_, target@29@01), i2@76@01)) && i2@76@01 < V@30@01 && 0 <= i2@76@01 && i1@75@01 < V@30@01 && 0 <= i1@75@01 | live]
; [else-branch: 75 | !(Lookup(option$array$,sm@72@01,aloc((_, _), opt_get1(_, target@29@01), i1@75@01)) == Lookup(option$array$,sm@72@01,aloc((_, _), opt_get1(_, target@29@01), i2@76@01)) && i2@76@01 < V@30@01 && 0 <= i2@76@01 && i1@75@01 < V@30@01 && 0 <= i1@75@01) | live]
(push) ; 10
; [then-branch: 75 | Lookup(option$array$,sm@72@01,aloc((_, _), opt_get1(_, target@29@01), i1@75@01)) == Lookup(option$array$,sm@72@01,aloc((_, _), opt_get1(_, target@29@01), i2@76@01)) && i2@76@01 < V@30@01 && 0 <= i2@76@01 && i1@75@01 < V@30@01 && 0 <= i1@75@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
        (< i2@76@01 V@30@01))
      (<= 0 i2@76@01))
    (< i1@75@01 V@30@01))
  (<= 0 i1@75@01)))
; [eval] i1 == i2
(pop) ; 10
(push) ; 10
; [else-branch: 75 | !(Lookup(option$array$,sm@72@01,aloc((_, _), opt_get1(_, target@29@01), i1@75@01)) == Lookup(option$array$,sm@72@01,aloc((_, _), opt_get1(_, target@29@01), i2@76@01)) && i2@76@01 < V@30@01 && 0 <= i2@76@01 && i1@75@01 < V@30@01 && 0 <= i1@75@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
            ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
          (< i2@76@01 V@30@01))
        (<= 0 i2@76@01))
      (< i1@75@01 V@30@01))
    (<= 0 i1@75@01))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
            ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
          (< i2@76@01 V@30@01))
        (<= 0 i2@76@01))
      (< i1@75@01 V@30@01))
    (<= 0 i1@75@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
      ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
    (< i2@76@01 V@30@01)
    (<= 0 i2@76@01)
    (< i1@75@01 V@30@01)
    (<= 0 i1@75@01))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@76@01 Int)) (!
  (and
    (implies
      (<= 0 i1@75@01)
      (and
        (<= 0 i1@75@01)
        (implies
          (< i1@75@01 V@30@01)
          (and
            (< i1@75@01 V@30@01)
            (implies
              (<= 0 i2@76@01)
              (and
                (<= 0 i2@76@01)
                (implies
                  (< i2@76@01 V@30@01)
                  (and
                    (< i2@76@01 V@30@01)
                    (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
                    (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
              (< i2@76@01 V@30@01))
            (<= 0 i2@76@01))
          (< i1@75@01 V@30@01))
        (<= 0 i1@75@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
        (< i2@76@01 V@30@01)
        (<= 0 i2@76@01)
        (< i1@75@01 V@30@01)
        (<= 0 i1@75@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@75@01 Int)) (!
  (forall ((i2@76@01 Int)) (!
    (and
      (implies
        (<= 0 i1@75@01)
        (and
          (<= 0 i1@75@01)
          (implies
            (< i1@75@01 V@30@01)
            (and
              (< i1@75@01 V@30@01)
              (implies
                (<= 0 i2@76@01)
                (and
                  (<= 0 i2@76@01)
                  (implies
                    (< i2@76@01 V@30@01)
                    (and
                      (< i2@76@01 V@30@01)
                      (< i1@75@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
                      (< i2@76@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
                  ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
                (< i2@76@01 V@30@01))
              (<= 0 i2@76@01))
            (< i1@75@01 V@30@01))
          (<= 0 i1@75@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
            ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
          (< i2@76@01 V@30@01)
          (<= 0 i2@76@01)
          (< i1@75@01 V@30@01)
          (<= 0 i1@75@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@75@01 Int)) (!
    (forall ((i2@76@01 Int)) (!
      (and
        (implies
          (<= 0 i1@75@01)
          (and
            (<= 0 i1@75@01)
            (implies
              (< i1@75@01 V@30@01)
              (and
                (< i1@75@01 V@30@01)
                (implies
                  (<= 0 i2@76@01)
                  (and
                    (<= 0 i2@76@01)
                    (implies
                      (< i2@76@01 V@30@01)
                      (and
                        (< i2@76@01 V@30@01)
                        (<
                          i1@75@01
                          (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
                        (<
                          i2@76@01
                          (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
                  (< i2@76@01 V@30@01))
                (<= 0 i2@76@01))
              (< i1@75@01 V@30@01))
            (<= 0 i1@75@01))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
              ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
            (< i2@76@01 V@30@01)
            (<= 0 i2@76@01)
            (< i1@75@01 V@30@01)
            (<= 0 i1@75@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
    :qid |prog.l<no position>-aux|))))
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((i1@75@01 Int)) (!
    (forall ((i2@76@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
                  ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01)))
                (< i2@76@01 V@30@01))
              (<= 0 i2@76@01))
            (< i1@75@01 V@30@01))
          (<= 0 i1@75@01))
        (= i1@75@01 i2@76@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@76@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@75@01))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 5
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1821
;  :arith-add-rows          496
;  :arith-assert-diseq      53
;  :arith-assert-lower      373
;  :arith-assert-upper      204
;  :arith-bound-prop        104
;  :arith-conflicts         46
;  :arith-eq-adapter        197
;  :arith-fixed-eqs         99
;  :arith-offset-eqs        86
;  :arith-pivots            325
;  :conflicts               138
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 132
;  :datatype-occurs-check   115
;  :datatype-splits         64
;  :decisions               245
;  :del-clause              1527
;  :final-checks            66
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  5.00
;  :mk-bool-var             3082
;  :mk-clause               1531
;  :num-allocs              179896
;  :num-checks              103
;  :propagations            655
;  :quant-instantiations    784
;  :rlimit-count            239436)
; [then-branch: 76 | exc@31@01 == Null | live]
; [else-branch: 76 | exc@31@01 != Null | dead]
(push) ; 5
; [then-branch: 76 | exc@31@01 == Null]
(declare-const i1@77@01 Int)
(declare-const j1@78@01 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 77 | 0 <= i1@77@01 | live]
; [else-branch: 77 | !(0 <= i1@77@01) | live]
(push) ; 8
; [then-branch: 77 | 0 <= i1@77@01]
(assert (<= 0 i1@77@01))
; [eval] i1 < V
(push) ; 9
; [then-branch: 78 | i1@77@01 < V@30@01 | live]
; [else-branch: 78 | !(i1@77@01 < V@30@01) | live]
(push) ; 10
; [then-branch: 78 | i1@77@01 < V@30@01]
(assert (< i1@77@01 V@30@01))
; [eval] 0 <= j1
(push) ; 11
; [then-branch: 79 | 0 <= j1@78@01 | live]
; [else-branch: 79 | !(0 <= j1@78@01) | live]
(push) ; 12
; [then-branch: 79 | 0 <= j1@78@01]
(assert (<= 0 j1@78@01))
; [eval] j1 < V
(pop) ; 12
(push) ; 12
; [else-branch: 79 | !(0 <= j1@78@01)]
(assert (not (<= 0 j1@78@01)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 78 | !(i1@77@01 < V@30@01)]
(assert (not (< i1@77@01 V@30@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(pop) ; 8
(push) ; 8
; [else-branch: 77 | !(0 <= i1@77@01)]
(assert (not (<= 0 i1@77@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@78@01 V@30@01) (<= 0 j1@78@01)) (< i1@77@01 V@30@01))
  (<= 0 i1@77@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@77@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1825
;  :arith-add-rows          500
;  :arith-assert-diseq      53
;  :arith-assert-lower      381
;  :arith-assert-upper      206
;  :arith-bound-prop        104
;  :arith-conflicts         46
;  :arith-eq-adapter        199
;  :arith-fixed-eqs         101
;  :arith-offset-eqs        86
;  :arith-pivots            330
;  :conflicts               138
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 132
;  :datatype-occurs-check   115
;  :datatype-splits         64
;  :decisions               245
;  :del-clause              1527
;  :final-checks            66
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  5.00
;  :mk-bool-var             3094
;  :mk-clause               1531
;  :num-allocs              180198
;  :num-checks              104
;  :propagations            655
;  :quant-instantiations    784
;  :rlimit-count            240015)
(assert (< i1@77@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 7
; Joined path conditions
(assert (< i1@77@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01)))
(push) ; 7
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))
          V@30@01)
        (<=
          0
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))))
      $k@70@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))
          V@30@01)
        (<=
          0
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))))
      $k@62@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1909
;  :arith-add-rows          512
;  :arith-assert-diseq      56
;  :arith-assert-lower      394
;  :arith-assert-upper      215
;  :arith-bound-prop        112
;  :arith-conflicts         48
;  :arith-eq-adapter        211
;  :arith-fixed-eqs         105
;  :arith-offset-eqs        98
;  :arith-pivots            338
;  :conflicts               148
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 136
;  :datatype-occurs-check   115
;  :datatype-splits         64
;  :decisions               254
;  :del-clause              1575
;  :final-checks            66
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  5.00
;  :mk-bool-var             3250
;  :mk-clause               1624
;  :num-allocs              181037
;  :num-checks              105
;  :propagations            697
;  :quant-instantiations    824
;  :rlimit-count            242712)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 8
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1935
;  :arith-add-rows          512
;  :arith-assert-diseq      56
;  :arith-assert-lower      394
;  :arith-assert-upper      217
;  :arith-bound-prop        112
;  :arith-conflicts         49
;  :arith-eq-adapter        211
;  :arith-fixed-eqs         105
;  :arith-offset-eqs        98
;  :arith-pivots            338
;  :conflicts               156
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 140
;  :datatype-occurs-check   115
;  :datatype-splits         64
;  :decisions               261
;  :del-clause              1579
;  :final-checks            66
;  :max-generation          4
;  :max-memory              5.01
;  :memory                  5.00
;  :mk-bool-var             3258
;  :mk-clause               1628
;  :num-allocs              181151
;  :num-checks              106
;  :propagations            703
;  :quant-instantiations    827
;  :rlimit-count            243024)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))
    (as None<option<array>>  option<array>))))
(pop) ; 7
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))
    (as None<option<array>>  option<array>))))
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 8
(assert (not (<
  j1@78@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01)))))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               1988
;  :arith-add-rows          524
;  :arith-assert-diseq      56
;  :arith-assert-lower      399
;  :arith-assert-upper      220
;  :arith-bound-prop        114
;  :arith-conflicts         51
;  :arith-eq-adapter        213
;  :arith-fixed-eqs         106
;  :arith-offset-eqs        103
;  :arith-pivots            342
;  :conflicts               165
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 144
;  :datatype-occurs-check   115
;  :datatype-splits         64
;  :decisions               269
;  :del-clause              1586
;  :final-checks            66
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.07
;  :mk-bool-var             3288
;  :mk-clause               1635
;  :num-allocs              181407
;  :num-checks              107
;  :propagations            715
;  :quant-instantiations    839
;  :rlimit-count            243859)
(assert (<
  j1@78@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))))))
(pop) ; 7
; Joined path conditions
(assert (<
  j1@78@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))))))
(pop) ; 6
(declare-fun inv@79@01 ($Ref) Int)
(declare-fun inv@80@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@77@01 Int) (j1@78@01 Int)) (!
  (and
    (< i1@77@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))
        (as None<option<array>>  option<array>)))
    (<
      j1@78@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))) j1@78@01))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@77@01 Int) (j11@78@01 Int) (i12@77@01 Int) (j12@78@01 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@78@01 V@30@01) (<= 0 j11@78@01)) (< i11@77@01 V@30@01))
        (<= 0 i11@77@01))
      (and
        (and (and (< j12@78@01 V@30@01) (<= 0 j12@78@01)) (< i12@77@01 V@30@01))
        (<= 0 i12@77@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@77@01))) j11@78@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@77@01))) j12@78@01)))
    (and (= i11@77@01 i12@77@01) (= j11@78@01 j12@78@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2078
;  :arith-add-rows          604
;  :arith-assert-diseq      58
;  :arith-assert-lower      418
;  :arith-assert-upper      230
;  :arith-bound-prop        124
;  :arith-conflicts         51
;  :arith-eq-adapter        221
;  :arith-fixed-eqs         113
;  :arith-offset-eqs        114
;  :arith-pivots            372
;  :conflicts               171
;  :datatype-accessor-ax    42
;  :datatype-constructor-ax 148
;  :datatype-occurs-check   115
;  :datatype-splits         64
;  :decisions               274
;  :del-clause              1749
;  :final-checks            66
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.12
;  :mk-bool-var             3527
;  :mk-clause               1753
;  :num-allocs              182930
;  :num-checks              108
;  :propagations            763
;  :quant-instantiations    937
;  :rlimit-count            250704
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@77@01 Int) (j1@78@01 Int)) (!
  (implies
    (and
      (and (and (< j1@78@01 V@30@01) (<= 0 j1@78@01)) (< i1@77@01 V@30@01))
      (<= 0 i1@77@01))
    (and
      (=
        (inv@79@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))) j1@78@01))
        i1@77@01)
      (=
        (inv@80@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))) j1@78@01))
        j1@78@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))) j1@78@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@01 r) V@30@01) (<= 0 (inv@80@01 r)))
        (< (inv@79@01 r) V@30@01))
      (<= 0 (inv@79@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@79@01 r)))) (inv@80@01 r))
      r))
  :pattern ((inv@79@01 r))
  :pattern ((inv@80@01 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@77@01 Int) (j1@78@01 Int)) (!
  (implies
    (and
      (and (and (< j1@78@01 V@30@01) (<= 0 j1@78@01)) (< i1@77@01 V@30@01))
      (<= 0 i1@77@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))) j1@78@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@77@01))) j1@78@01))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@81@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@01 r) V@30@01) (<= 0 (inv@80@01 r)))
        (< (inv@79@01 r) V@30@01))
      (<= 0 (inv@79@01 r)))
    (=
      ($FVF.lookup_int (as sm@81@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@81@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))) r))
  :qid |qp.fvfValDef19|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@81@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef20|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@01 r) V@30@01) (<= 0 (inv@80@01 r)))
        (< (inv@79@01 r) V@30@01))
      (<= 0 (inv@79@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@81@01  $FVF<Int>) r) r))
  :pattern ((inv@79@01 r) (inv@80@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 6
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2121
;  :arith-add-rows          604
;  :arith-assert-diseq      58
;  :arith-assert-lower      418
;  :arith-assert-upper      230
;  :arith-bound-prop        124
;  :arith-conflicts         51
;  :arith-eq-adapter        221
;  :arith-fixed-eqs         113
;  :arith-offset-eqs        114
;  :arith-pivots            372
;  :conflicts               171
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 157
;  :datatype-occurs-check   120
;  :datatype-splits         69
;  :decisions               283
;  :del-clause              1749
;  :final-checks            68
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.13
;  :mk-bool-var             3539
;  :mk-clause               1753
;  :num-allocs              184512
;  :num-checks              109
;  :propagations            763
;  :quant-instantiations    937
;  :rlimit-count            254256)
; [then-branch: 80 | exc@31@01 == Null | live]
; [else-branch: 80 | exc@31@01 != Null | dead]
(push) ; 6
; [then-branch: 80 | exc@31@01 == Null]
(declare-const i1@82@01 Int)
(declare-const j1@83@01 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 81 | 0 <= i1@82@01 | live]
; [else-branch: 81 | !(0 <= i1@82@01) | live]
(push) ; 9
; [then-branch: 81 | 0 <= i1@82@01]
(assert (<= 0 i1@82@01))
; [eval] i1 < V
(push) ; 10
; [then-branch: 82 | i1@82@01 < V@30@01 | live]
; [else-branch: 82 | !(i1@82@01 < V@30@01) | live]
(push) ; 11
; [then-branch: 82 | i1@82@01 < V@30@01]
(assert (< i1@82@01 V@30@01))
; [eval] 0 <= j1
(push) ; 12
; [then-branch: 83 | 0 <= j1@83@01 | live]
; [else-branch: 83 | !(0 <= j1@83@01) | live]
(push) ; 13
; [then-branch: 83 | 0 <= j1@83@01]
(assert (<= 0 j1@83@01))
; [eval] j1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 83 | !(0 <= j1@83@01)]
(assert (not (<= 0 j1@83@01)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 82 | !(i1@82@01 < V@30@01)]
(assert (not (< i1@82@01 V@30@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 81 | !(0 <= i1@82@01)]
(assert (not (<= 0 i1@82@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@83@01 V@30@01) (<= 0 j1@83@01)) (< i1@82@01 V@30@01))
  (<= 0 i1@82@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< i1@82@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2125
;  :arith-add-rows          610
;  :arith-assert-diseq      58
;  :arith-assert-lower      426
;  :arith-assert-upper      232
;  :arith-bound-prop        124
;  :arith-conflicts         51
;  :arith-eq-adapter        223
;  :arith-fixed-eqs         115
;  :arith-offset-eqs        114
;  :arith-pivots            378
;  :conflicts               171
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 157
;  :datatype-occurs-check   120
;  :datatype-splits         69
;  :decisions               283
;  :del-clause              1749
;  :final-checks            68
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.13
;  :mk-bool-var             3551
;  :mk-clause               1753
;  :num-allocs              184817
;  :num-checks              110
;  :propagations            763
;  :quant-instantiations    937
;  :rlimit-count            254881)
(assert (< i1@82@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 8
; Joined path conditions
(assert (< i1@82@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01)))
(push) ; 8
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))
          V@30@01)
        (<=
          0
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))))
      $k@70@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))
          V@30@01)
        (<=
          0
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))))
      $k@62@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2227
;  :arith-add-rows          626
;  :arith-assert-diseq      61
;  :arith-assert-lower      440
;  :arith-assert-upper      241
;  :arith-bound-prop        133
;  :arith-conflicts         53
;  :arith-eq-adapter        233
;  :arith-fixed-eqs         119
;  :arith-offset-eqs        123
;  :arith-pivots            385
;  :conflicts               181
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 161
;  :datatype-occurs-check   120
;  :datatype-splits         69
;  :decisions               292
;  :del-clause              1798
;  :final-checks            68
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.14
;  :mk-bool-var             3743
;  :mk-clause               1872
;  :num-allocs              185725
;  :num-checks              111
;  :propagations            795
;  :quant-instantiations    984
;  :rlimit-count            257932)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 9
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2227
;  :arith-add-rows          626
;  :arith-assert-diseq      61
;  :arith-assert-lower      440
;  :arith-assert-upper      241
;  :arith-bound-prop        133
;  :arith-conflicts         53
;  :arith-eq-adapter        233
;  :arith-fixed-eqs         119
;  :arith-offset-eqs        123
;  :arith-pivots            385
;  :conflicts               182
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 161
;  :datatype-occurs-check   120
;  :datatype-splits         69
;  :decisions               292
;  :del-clause              1798
;  :final-checks            68
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.14
;  :mk-bool-var             3743
;  :mk-clause               1872
;  :num-allocs              185814
;  :num-checks              112
;  :propagations            795
;  :quant-instantiations    984
;  :rlimit-count            258027)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))
    (as None<option<array>>  option<array>))))
(pop) ; 8
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))
    (as None<option<array>>  option<array>))))
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 9
(assert (not (<
  j1@83@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2231
;  :arith-add-rows          628
;  :arith-assert-diseq      61
;  :arith-assert-lower      442
;  :arith-assert-upper      241
;  :arith-bound-prop        135
;  :arith-conflicts         53
;  :arith-eq-adapter        234
;  :arith-fixed-eqs         119
;  :arith-offset-eqs        123
;  :arith-pivots            387
;  :conflicts               183
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 161
;  :datatype-occurs-check   120
;  :datatype-splits         69
;  :decisions               292
;  :del-clause              1804
;  :final-checks            68
;  :max-generation          4
;  :max-memory              5.15
;  :memory                  5.14
;  :mk-bool-var             3754
;  :mk-clause               1878
;  :num-allocs              186004
;  :num-checks              113
;  :propagations            795
;  :quant-instantiations    991
;  :rlimit-count            258440)
(assert (<
  j1@83@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))))))
(pop) ; 8
; Joined path conditions
(assert (<
  j1@83@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))))))
(pop) ; 7
(declare-fun inv@84@01 ($Ref) Int)
(declare-fun inv@85@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@82@01 Int) (j1@83@01 Int)) (!
  (and
    (< i1@82@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))
        (as None<option<array>>  option<array>)))
    (<
      j1@83@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))) j1@83@01))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((i11@82@01 Int) (j11@83@01 Int) (i12@82@01 Int) (j12@83@01 Int)) (!
  (implies
    (and
      (and
        (and (and (< j11@83@01 V@30@01) (<= 0 j11@83@01)) (< i11@82@01 V@30@01))
        (<= 0 i11@82@01))
      (and
        (and (and (< j12@83@01 V@30@01) (<= 0 j12@83@01)) (< i12@82@01 V@30@01))
        (<= 0 i12@82@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@82@01))) j11@83@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@82@01))) j12@83@01)))
    (and (= i11@82@01 i12@82@01) (= j11@83@01 j12@83@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2283
;  :arith-add-rows          657
;  :arith-assert-diseq      61
;  :arith-assert-lower      457
;  :arith-assert-upper      244
;  :arith-bound-prop        139
;  :arith-conflicts         53
;  :arith-eq-adapter        243
;  :arith-fixed-eqs         122
;  :arith-offset-eqs        129
;  :arith-pivots            407
;  :conflicts               184
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 161
;  :datatype-occurs-check   120
;  :datatype-splits         69
;  :decisions               292
;  :del-clause              1972
;  :final-checks            68
;  :max-generation          4
;  :max-memory              5.19
;  :memory                  5.17
;  :mk-bool-var             3975
;  :mk-clause               1976
;  :num-allocs              187461
;  :num-checks              114
;  :propagations            829
;  :quant-instantiations    1082
;  :rlimit-count            263936
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@82@01 Int) (j1@83@01 Int)) (!
  (implies
    (and
      (and (and (< j1@83@01 V@30@01) (<= 0 j1@83@01)) (< i1@82@01 V@30@01))
      (<= 0 i1@82@01))
    (and
      (=
        (inv@84@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))) j1@83@01))
        i1@82@01)
      (=
        (inv@85@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))) j1@83@01))
        j1@83@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))) j1@83@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@85@01 r) V@30@01) (<= 0 (inv@85@01 r)))
        (< (inv@84@01 r) V@30@01))
      (<= 0 (inv@84@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@84@01 r)))) (inv@85@01 r))
      r))
  :pattern ((inv@84@01 r))
  :pattern ((inv@85@01 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((i1@82@01 Int) (j1@83@01 Int)) (!
  (implies
    (and
      (and (and (< j1@83@01 V@30@01) (<= 0 j1@83@01)) (< i1@82@01 V@30@01))
      (<= 0 i1@82@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))) j1@83@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@82@01))) j1@83@01))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@86@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@85@01 r) V@30@01) (<= 0 (inv@85@01 r)))
        (< (inv@84@01 r) V@30@01))
      (<= 0 (inv@84@01 r)))
    (=
      ($FVF.lookup_int (as sm@86@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@86@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))))) r))
  :qid |qp.fvfValDef21|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@80@01 r) V@30@01) (<= 0 (inv@80@01 r)))
        (< (inv@79@01 r) V@30@01))
      (<= 0 (inv@79@01 r)))
    (=
      ($FVF.lookup_int (as sm@86@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@86@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))) r))
  :qid |qp.fvfValDef22|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@86@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef23|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@85@01 r) V@30@01) (<= 0 (inv@85@01 r)))
        (< (inv@84@01 r) V@30@01))
      (<= 0 (inv@84@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) r) r))
  :pattern ((inv@84@01 r) (inv@85@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@60@01)))))))))))))))
  $Snap.unit))
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@31@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2321
;  :arith-add-rows          657
;  :arith-assert-diseq      61
;  :arith-assert-lower      457
;  :arith-assert-upper      244
;  :arith-bound-prop        139
;  :arith-conflicts         53
;  :arith-eq-adapter        243
;  :arith-fixed-eqs         122
;  :arith-offset-eqs        129
;  :arith-pivots            407
;  :conflicts               184
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 169
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               300
;  :del-clause              1972
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.20
;  :memory                  5.18
;  :mk-bool-var             3987
;  :mk-clause               1976
;  :num-allocs              189196
;  :num-checks              115
;  :propagations            829
;  :quant-instantiations    1082
;  :rlimit-count            268244)
; [then-branch: 84 | exc@31@01 == Null | live]
; [else-branch: 84 | exc@31@01 != Null | dead]
(push) ; 8
; [then-branch: 84 | exc@31@01 == Null]
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@87@01 Int)
(push) ; 9
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 10
; [then-branch: 85 | 0 <= unknown@87@01 | live]
; [else-branch: 85 | !(0 <= unknown@87@01) | live]
(push) ; 11
; [then-branch: 85 | 0 <= unknown@87@01]
(assert (<= 0 unknown@87@01))
; [eval] unknown < V
(pop) ; 11
(push) ; 11
; [else-branch: 85 | !(0 <= unknown@87@01)]
(assert (not (<= 0 unknown@87@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 86 | unknown@87@01 < V@30@01 && 0 <= unknown@87@01 | live]
; [else-branch: 86 | !(unknown@87@01 < V@30@01 && 0 <= unknown@87@01) | live]
(push) ; 11
; [then-branch: 86 | unknown@87@01 < V@30@01 && 0 <= unknown@87@01]
(assert (and (< unknown@87@01 V@30@01) (<= 0 unknown@87@01)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@88@01 Int)
(push) ; 12
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 13
; [then-branch: 87 | 0 <= unknown1@88@01 | live]
; [else-branch: 87 | !(0 <= unknown1@88@01) | live]
(push) ; 14
; [then-branch: 87 | 0 <= unknown1@88@01]
(assert (<= 0 unknown1@88@01))
; [eval] unknown1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 87 | !(0 <= unknown1@88@01)]
(assert (not (<= 0 unknown1@88@01)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(push) ; 13
; [then-branch: 88 | unknown1@88@01 < V@30@01 && 0 <= unknown1@88@01 | live]
; [else-branch: 88 | !(unknown1@88@01 < V@30@01 && 0 <= unknown1@88@01) | live]
(push) ; 14
; [then-branch: 88 | unknown1@88@01 < V@30@01 && 0 <= unknown1@88@01]
(assert (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2323
;  :arith-add-rows          659
;  :arith-assert-diseq      61
;  :arith-assert-lower      462
;  :arith-assert-upper      245
;  :arith-bound-prop        139
;  :arith-conflicts         53
;  :arith-eq-adapter        244
;  :arith-fixed-eqs         123
;  :arith-offset-eqs        129
;  :arith-pivots            409
;  :conflicts               184
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 169
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               300
;  :del-clause              1972
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.20
;  :memory                  5.18
;  :mk-bool-var             3994
;  :mk-clause               1976
;  :num-allocs              189394
;  :num-checks              116
;  :propagations            829
;  :quant-instantiations    1082
;  :rlimit-count            268637)
(assert (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 15
; Joined path conditions
(assert (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
          V@30@01)
        (<=
          0
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))))
      $k@70@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
          V@30@01)
        (<=
          0
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))))
      $k@62@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2434
;  :arith-add-rows          684
;  :arith-assert-diseq      65
;  :arith-assert-lower      476
;  :arith-assert-upper      253
;  :arith-bound-prop        148
;  :arith-conflicts         55
;  :arith-eq-adapter        257
;  :arith-fixed-eqs         127
;  :arith-offset-eqs        136
;  :arith-pivots            416
;  :conflicts               195
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 173
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               326
;  :del-clause              2119
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.19
;  :mk-bool-var             4277
;  :mk-clause               2193
;  :num-allocs              190389
;  :num-checks              117
;  :propagations            896
;  :quant-instantiations    1141
;  :rlimit-count            272603
;  :time                    0.00)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2434
;  :arith-add-rows          684
;  :arith-assert-diseq      65
;  :arith-assert-lower      476
;  :arith-assert-upper      253
;  :arith-bound-prop        148
;  :arith-conflicts         55
;  :arith-eq-adapter        257
;  :arith-fixed-eqs         127
;  :arith-offset-eqs        136
;  :arith-pivots            416
;  :conflicts               196
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 173
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               326
;  :del-clause              2119
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.19
;  :mk-bool-var             4277
;  :mk-clause               2193
;  :num-allocs              190478
;  :num-checks              118
;  :propagations            896
;  :quant-instantiations    1141
;  :rlimit-count            272698)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  unknown1@88@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2440
;  :arith-add-rows          688
;  :arith-assert-diseq      65
;  :arith-assert-lower      478
;  :arith-assert-upper      255
;  :arith-bound-prop        148
;  :arith-conflicts         56
;  :arith-eq-adapter        258
;  :arith-fixed-eqs         128
;  :arith-offset-eqs        136
;  :arith-pivots            418
;  :conflicts               197
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 173
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               326
;  :del-clause              2123
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.19
;  :mk-bool-var             4288
;  :mk-clause               2197
;  :num-allocs              190674
;  :num-checks              119
;  :propagations            898
;  :quant-instantiations    1148
;  :rlimit-count            273156)
(assert (<
  unknown1@88@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))))))
(pop) ; 15
; Joined path conditions
(assert (<
  unknown1@88@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@85@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
              V@30@01)
            (<=
              0
              (inv@85@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))))
          (<
            (inv@84@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            V@30@01))
        (<=
          0
          (inv@84@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@80@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
              V@30@01)
            (<=
              0
              (inv@80@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))))
          (<
            (inv@79@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            V@30@01))
        (<=
          0
          (inv@79@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2551
;  :arith-add-rows          716
;  :arith-assert-diseq      67
;  :arith-assert-lower      497
;  :arith-assert-upper      272
;  :arith-bound-prop        154
;  :arith-conflicts         60
;  :arith-eq-adapter        270
;  :arith-fixed-eqs         131
;  :arith-offset-eqs        146
;  :arith-pivots            427
;  :conflicts               219
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 177
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               354
;  :del-clause              2247
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.21
;  :mk-bool-var             4484
;  :mk-clause               2349
;  :num-allocs              191498
;  :num-checks              120
;  :propagations            973
;  :quant-instantiations    1187
;  :rlimit-count            276761
;  :time                    0.00)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2551
;  :arith-add-rows          716
;  :arith-assert-diseq      67
;  :arith-assert-lower      497
;  :arith-assert-upper      272
;  :arith-bound-prop        154
;  :arith-conflicts         60
;  :arith-eq-adapter        270
;  :arith-fixed-eqs         131
;  :arith-offset-eqs        146
;  :arith-pivots            427
;  :conflicts               219
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 177
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               354
;  :del-clause              2247
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.21
;  :memory                  5.21
;  :mk-bool-var             4484
;  :mk-clause               2349
;  :num-allocs              191523
;  :num-checks              121
;  :propagations            973
;  :quant-instantiations    1187
;  :rlimit-count            276791)
(assert (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 15
; Joined path conditions
(assert (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
          V@30@01)
        (<=
          0
          (inv@71@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))))
      $k@70@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
          V@30@01)
        (<=
          0
          (inv@63@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))))
      $k@62@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2688
;  :arith-add-rows          766
;  :arith-assert-diseq      70
;  :arith-assert-lower      508
;  :arith-assert-upper      284
;  :arith-bound-prop        167
;  :arith-conflicts         63
;  :arith-eq-adapter        283
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        162
;  :arith-pivots            433
;  :conflicts               239
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 181
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               379
;  :del-clause              2384
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.27
;  :memory                  5.26
;  :mk-bool-var             4706
;  :mk-clause               2505
;  :num-allocs              192634
;  :num-checks              122
;  :propagations            1049
;  :quant-instantiations    1230
;  :rlimit-count            280556
;  :time                    0.00)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2769
;  :arith-add-rows          791
;  :arith-assert-diseq      70
;  :arith-assert-lower      509
;  :arith-assert-upper      289
;  :arith-bound-prop        172
;  :arith-conflicts         65
;  :arith-eq-adapter        283
;  :arith-fixed-eqs         135
;  :arith-offset-eqs        162
;  :arith-pivots            435
;  :conflicts               257
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 185
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               402
;  :del-clause              2460
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.27
;  :memory                  5.26
;  :mk-bool-var             4776
;  :mk-clause               2581
;  :num-allocs              192807
;  :num-checks              123
;  :propagations            1076
;  :quant-instantiations    1245
;  :rlimit-count            282335)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  unknown1@88@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               2874
;  :arith-add-rows          847
;  :arith-assert-diseq      70
;  :arith-assert-lower      514
;  :arith-assert-upper      296
;  :arith-bound-prop        184
;  :arith-conflicts         68
;  :arith-eq-adapter        285
;  :arith-fixed-eqs         136
;  :arith-offset-eqs        166
;  :arith-pivots            441
;  :conflicts               275
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 189
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               426
;  :del-clause              2544
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.28
;  :memory                  5.27
;  :mk-bool-var             4876
;  :mk-clause               2665
;  :num-allocs              193160
;  :num-checks              124
;  :propagations            1113
;  :quant-instantiations    1269
;  :rlimit-count            284851)
(assert (<
  unknown1@88@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))))))
(pop) ; 15
; Joined path conditions
(assert (<
  unknown1@88@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@85@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
              V@30@01)
            (<=
              0
              (inv@85@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
          (<
            (inv@84@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
            V@30@01))
        (<=
          0
          (inv@84@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@80@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
              V@30@01)
            (<=
              0
              (inv@80@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
          (<
            (inv@79@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
            V@30@01))
        (<=
          0
          (inv@79@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3020
;  :arith-add-rows          900
;  :arith-assert-diseq      70
;  :arith-assert-lower      532
;  :arith-assert-upper      312
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        296
;  :arith-fixed-eqs         139
;  :arith-offset-eqs        180
;  :arith-pivots            453
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 193
;  :datatype-occurs-check   125
;  :datatype-splits         73
;  :decisions               455
;  :del-clause              2653
;  :final-checks            70
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.32
;  :mk-bool-var             5042
;  :mk-clause               2790
;  :num-allocs              193938
;  :num-checks              125
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            288804
;  :time                    0.00)
(pop) ; 14
(push) ; 14
; [else-branch: 88 | !(unknown1@88@01 < V@30@01 && 0 <= unknown1@88@01)]
(assert (not (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
  (and
    (< unknown1@88@01 V@30@01)
    (<= 0 unknown1@88@01)
    (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@88@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
    (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@88@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)))))
; Joined path conditions
(pop) ; 12
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@88@01 Int)) (!
  (implies
    (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
    (and
      (< unknown1@88@01 V@30@01)
      (<= 0 unknown1@88@01)
      (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@88@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
      (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@88@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@88@01 Int)) (!
  (implies
    (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
    (and
      (< unknown1@88@01 V@30@01)
      (<= 0 unknown1@88@01)
      (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@88@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
      (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@88@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 11
(push) ; 11
; [else-branch: 86 | !(unknown@87@01 < V@30@01 && 0 <= unknown@87@01)]
(assert (not (and (< unknown@87@01 V@30@01) (<= 0 unknown@87@01))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< unknown@87@01 V@30@01) (<= 0 unknown@87@01))
  (and
    (< unknown@87@01 V@30@01)
    (<= 0 unknown@87@01)
    (forall ((unknown1@88@01 Int)) (!
      (implies
        (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
        (and
          (< unknown1@88@01 V@30@01)
          (<= 0 unknown1@88@01)
          (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@88@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
          (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@88@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@88@01 Int)) (!
      (implies
        (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
        (and
          (< unknown1@88@01 V@30@01)
          (<= 0 unknown1@88@01)
          (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@88@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
          (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@88@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@87@01 Int)) (!
  (implies
    (and (< unknown@87@01 V@30@01) (<= 0 unknown@87@01))
    (and
      (< unknown@87@01 V@30@01)
      (<= 0 unknown@87@01)
      (forall ((unknown1@88@01 Int)) (!
        (implies
          (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
          (and
            (< unknown1@88@01 V@30@01)
            (<= 0 unknown1@88@01)
            (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@88@01 Int)) (!
        (implies
          (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
          (and
            (< unknown1@88@01 V@30@01)
            (<= 0 unknown1@88@01)
            (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@87@01 Int)) (!
  (implies
    (and (< unknown@87@01 V@30@01) (<= 0 unknown@87@01))
    (and
      (< unknown@87@01 V@30@01)
      (<= 0 unknown@87@01)
      (forall ((unknown1@88@01 Int)) (!
        (implies
          (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
          (and
            (< unknown1@88@01 V@30@01)
            (<= 0 unknown1@88@01)
            (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@88@01 Int)) (!
        (implies
          (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
          (and
            (< unknown1@88@01 V@30@01)
            (<= 0 unknown1@88@01)
            (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@88@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (= exc@31@01 $Ref.null)
  (and
    (forall ((unknown@87@01 Int)) (!
      (implies
        (and (< unknown@87@01 V@30@01) (<= 0 unknown@87@01))
        (and
          (< unknown@87@01 V@30@01)
          (<= 0 unknown@87@01)
          (forall ((unknown1@88@01 Int)) (!
            (implies
              (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
              (and
                (< unknown1@88@01 V@30@01)
                (<= 0 unknown1@88@01)
                (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
                (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@88@01 Int)) (!
            (implies
              (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
              (and
                (< unknown1@88@01 V@30@01)
                (<= 0 unknown1@88@01)
                (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
                (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@87@01 Int)) (!
      (implies
        (and (< unknown@87@01 V@30@01) (<= 0 unknown@87@01))
        (and
          (< unknown@87@01 V@30@01)
          (<= 0 unknown@87@01)
          (forall ((unknown1@88@01 Int)) (!
            (implies
              (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
              (and
                (< unknown1@88@01 V@30@01)
                (<= 0 unknown1@88@01)
                (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
                (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@88@01 Int)) (!
            (implies
              (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
              (and
                (< unknown1@88@01 V@30@01)
                (<= 0 unknown1@88@01)
                (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
                (< unknown@87@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@88@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (= exc@31@01 $Ref.null)
  (forall ((unknown@87@01 Int)) (!
    (implies
      (and (< unknown@87@01 V@30@01) (<= 0 unknown@87@01))
      (forall ((unknown1@88@01 Int)) (!
        (implies
          (and (< unknown1@88@01 V@30@01) (<= 0 unknown1@88@01))
          (=
            ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
            ($FVF.lookup_int (as sm@86@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))) unknown1@88@01))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))) unknown1@88@01))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@87@01))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@72@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@87@01))))
    :qid |prog.l<no position>|))))
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(push) ; 2
; [exec]
; var return: void
(declare-const return@89@01 void)
; [exec]
; var res1: void
(declare-const res1@90@01 void)
; [exec]
; var evaluationDummy: void
(declare-const evaluationDummy@91@01 void)
; [exec]
; exc := null
; [exec]
; exc, res1 := do_par_$unknown$1(target, source, V)
; [eval] 0 < V ==> source != (None(): option[array])
; [eval] 0 < V
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3033
;  :arith-add-rows          930
;  :arith-assert-diseq      70
;  :arith-assert-lower      534
;  :arith-assert-upper      313
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        297
;  :arith-fixed-eqs         140
;  :arith-offset-eqs        180
;  :arith-pivots            469
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 197
;  :datatype-occurs-check   126
;  :datatype-splits         73
;  :decisions               459
;  :del-clause              2791
;  :final-checks            71
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :mk-bool-var             5046
;  :mk-clause               2791
;  :num-allocs              195538
;  :num-checks              126
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            291322)
(push) ; 4
(assert (not (< 0 V@30@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3046
;  :arith-add-rows          932
;  :arith-assert-diseq      70
;  :arith-assert-lower      535
;  :arith-assert-upper      315
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        298
;  :arith-fixed-eqs         141
;  :arith-offset-eqs        180
;  :arith-pivots            472
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 201
;  :datatype-occurs-check   127
;  :datatype-splits         73
;  :decisions               463
;  :del-clause              2792
;  :final-checks            72
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :mk-bool-var             5050
;  :mk-clause               2792
;  :num-allocs              196116
;  :num-checks              127
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            291870)
; [then-branch: 89 | 0 < V@30@01 | live]
; [else-branch: 89 | !(0 < V@30@01) | live]
(push) ; 4
; [then-branch: 89 | 0 < V@30@01]
(assert (< 0 V@30@01))
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 4
(push) ; 4
; [else-branch: 89 | !(0 < V@30@01)]
(assert (not (< 0 V@30@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
(assert (not (implies
  (< 0 V@30@01)
  (not (= source@28@01 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3046
;  :arith-add-rows          932
;  :arith-assert-diseq      70
;  :arith-assert-lower      535
;  :arith-assert-upper      315
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        298
;  :arith-fixed-eqs         141
;  :arith-offset-eqs        180
;  :arith-pivots            472
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 201
;  :datatype-occurs-check   127
;  :datatype-splits         73
;  :decisions               463
;  :del-clause              2792
;  :final-checks            72
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :mk-bool-var             5050
;  :mk-clause               2792
;  :num-allocs              196147
;  :num-checks              128
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            291915)
(assert (implies
  (< 0 V@30@01)
  (not (= source@28@01 (as None<option<array>>  option<array>)))))
; [eval] 0 < V ==> alen(opt_get1(source)) == V
; [eval] 0 < V
(push) ; 3
(set-option :timeout 10)
(push) ; 4
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3059
;  :arith-add-rows          934
;  :arith-assert-diseq      70
;  :arith-assert-lower      537
;  :arith-assert-upper      316
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        299
;  :arith-fixed-eqs         142
;  :arith-offset-eqs        180
;  :arith-pivots            474
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 205
;  :datatype-occurs-check   128
;  :datatype-splits         73
;  :decisions               467
;  :del-clause              2793
;  :final-checks            73
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :mk-bool-var             5054
;  :mk-clause               2793
;  :num-allocs              196715
;  :num-checks              129
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            292489)
(push) ; 4
(assert (not (< 0 V@30@01)))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3072
;  :arith-add-rows          936
;  :arith-assert-diseq      70
;  :arith-assert-lower      538
;  :arith-assert-upper      318
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        300
;  :arith-fixed-eqs         143
;  :arith-offset-eqs        180
;  :arith-pivots            476
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 209
;  :datatype-occurs-check   129
;  :datatype-splits         73
;  :decisions               471
;  :del-clause              2794
;  :final-checks            74
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :mk-bool-var             5058
;  :mk-clause               2794
;  :num-allocs              197293
;  :num-checks              130
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            293033)
; [then-branch: 90 | 0 < V@30@01 | live]
; [else-branch: 90 | !(0 < V@30@01) | live]
(push) ; 4
; [then-branch: 90 | 0 < V@30@01]
(assert (< 0 V@30@01))
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(pop) ; 4
(push) ; 4
; [else-branch: 90 | !(0 < V@30@01)]
(assert (not (< 0 V@30@01)))
(pop) ; 4
(pop) ; 3
; Joined path conditions
; Joined path conditions
(set-option :timeout 0)
(push) ; 3
(assert (not (implies
  (< 0 V@30@01)
  (= (alen<Int> (opt_get1 $Snap.unit source@28@01)) V@30@01))))
(check-sat)
; unsat
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3074
;  :arith-add-rows          938
;  :arith-assert-diseq      70
;  :arith-assert-lower      540
;  :arith-assert-upper      319
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        301
;  :arith-fixed-eqs         144
;  :arith-offset-eqs        180
;  :arith-pivots            478
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 209
;  :datatype-occurs-check   129
;  :datatype-splits         73
;  :decisions               471
;  :del-clause              2794
;  :final-checks            74
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :mk-bool-var             5062
;  :mk-clause               2794
;  :num-allocs              197397
;  :num-checks              131
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            293184)
(assert (implies
  (< 0 V@30@01)
  (= (alen<Int> (opt_get1 $Snap.unit source@28@01)) V@30@01)))
; [eval] 0 < V
(set-option :timeout 10)
(push) ; 3
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3087
;  :arith-add-rows          938
;  :arith-assert-diseq      70
;  :arith-assert-lower      542
;  :arith-assert-upper      320
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        302
;  :arith-fixed-eqs         145
;  :arith-offset-eqs        180
;  :arith-pivots            480
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 213
;  :datatype-occurs-check   130
;  :datatype-splits         73
;  :decisions               475
;  :del-clause              2795
;  :final-checks            75
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :mk-bool-var             5066
;  :mk-clause               2795
;  :num-allocs              197966
;  :num-checks              132
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            293721)
(push) ; 3
(assert (not (< 0 V@30@01)))
(check-sat)
; unknown
(pop) ; 3
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3100
;  :arith-add-rows          940
;  :arith-assert-diseq      70
;  :arith-assert-lower      543
;  :arith-assert-upper      322
;  :arith-bound-prop        199
;  :arith-conflicts         73
;  :arith-eq-adapter        303
;  :arith-fixed-eqs         146
;  :arith-offset-eqs        180
;  :arith-pivots            482
;  :conflicts               296
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 217
;  :datatype-occurs-check   131
;  :datatype-splits         73
;  :decisions               479
;  :del-clause              2796
;  :final-checks            76
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.30
;  :mk-bool-var             5070
;  :mk-clause               2796
;  :num-allocs              198544
;  :num-checks              133
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            294265)
; [then-branch: 91 | 0 < V@30@01 | live]
; [else-branch: 91 | !(0 < V@30@01) | live]
(push) ; 3
; [then-branch: 91 | 0 < V@30@01]
(assert (< 0 V@30@01))
(declare-const i1@92@01 Int)
(push) ; 4
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 5
; [then-branch: 92 | 0 <= i1@92@01 | live]
; [else-branch: 92 | !(0 <= i1@92@01) | live]
(push) ; 6
; [then-branch: 92 | 0 <= i1@92@01]
(assert (<= 0 i1@92@01))
; [eval] i1 < V
(pop) ; 6
(push) ; 6
; [else-branch: 92 | !(0 <= i1@92@01)]
(assert (not (<= 0 i1@92@01)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(assert (and (< i1@92@01 V@30@01) (<= 0 i1@92@01)))
; [eval] scale(V * V * write) * wildcard
; [eval] scale(V * V * write)
; [eval] V * V * write
; [eval] V * V
(push) ; 5
; [eval] amount >= 0 * write
; [eval] 0 * write
(set-option :timeout 0)
(push) ; 6
(assert (not (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No)))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3113
;  :arith-add-rows          941
;  :arith-assert-diseq      70
;  :arith-assert-lower      549
;  :arith-assert-upper      324
;  :arith-bound-prop        199
;  :arith-conflicts         74
;  :arith-eq-adapter        304
;  :arith-fixed-eqs         147
;  :arith-max-min           3
;  :arith-offset-eqs        180
;  :arith-pivots            484
;  :conflicts               297
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 221
;  :datatype-occurs-check   131
;  :datatype-splits         73
;  :decisions               483
;  :del-clause              2796
;  :final-checks            77
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.29
;  :mk-bool-var             5077
;  :mk-clause               2796
;  :num-allocs              198822
;  :num-checks              134
;  :propagations            1197
;  :quant-instantiations    1305
;  :rlimit-count            294696)
(assert (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
(pop) ; 5
; Joined path conditions
(assert (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
(declare-const $k@93@01 $Perm)
(assert ($Perm.isReadVar $k@93@01 $Perm.Write))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 5
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
; Joined path conditions
(push) ; 5
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 6
(assert (not (< i1@92@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3113
;  :arith-add-rows          941
;  :arith-assert-diseq      71
;  :arith-assert-lower      552
;  :arith-assert-upper      325
;  :arith-bound-prop        199
;  :arith-conflicts         74
;  :arith-eq-adapter        305
;  :arith-fixed-eqs         147
;  :arith-max-min           3
;  :arith-offset-eqs        180
;  :arith-pivots            484
;  :conflicts               297
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 221
;  :datatype-occurs-check   131
;  :datatype-splits         73
;  :decisions               483
;  :del-clause              2796
;  :final-checks            77
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.29
;  :mk-bool-var             5082
;  :mk-clause               2798
;  :num-allocs              199023
;  :num-checks              135
;  :propagations            1198
;  :quant-instantiations    1305
;  :rlimit-count            294951)
(assert (< i1@92@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 5
; Joined path conditions
(assert (< i1@92@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 4
(declare-fun inv@94@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@93@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@92@01 Int)) (!
  (and
    (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No)
    (< i1@92@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@92@01))
  :qid |option$array$-aux|)))
(push) ; 4
(assert (not (forall ((i1@92@01 Int)) (!
  (implies
    (and (< i1@92@01 V@30@01) (<= 0 i1@92@01))
    (or
      (=
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@93@01)
        $Perm.No)
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@93@01))))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3127
;  :arith-add-rows          941
;  :arith-assert-diseq      73
;  :arith-assert-lower      566
;  :arith-assert-upper      331
;  :arith-bound-prop        199
;  :arith-conflicts         76
;  :arith-eq-adapter        308
;  :arith-fixed-eqs         147
;  :arith-max-min           18
;  :arith-nonlinear-bounds  2
;  :arith-offset-eqs        181
;  :arith-pivots            486
;  :conflicts               303
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 225
;  :datatype-occurs-check   132
;  :datatype-splits         73
;  :decisions               488
;  :del-clause              2805
;  :final-checks            79
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.29
;  :mk-bool-var             5098
;  :mk-clause               2807
;  :num-allocs              199635
;  :num-checks              136
;  :propagations            1203
;  :quant-instantiations    1308
;  :rlimit-count            295916)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 4
(assert (not (forall ((i11@92@01 Int) (i12@92@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@92@01 V@30@01) (<= 0 i11@92@01))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@92@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@92@01)))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@93@01)))
      (and
        (and
          (and (< i12@92@01 V@30@01) (<= 0 i12@92@01))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@92@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@92@01)))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@93@01)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@92@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@92@01)))
    (= i11@92@01 i12@92@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3137
;  :arith-add-rows          947
;  :arith-assert-diseq      74
;  :arith-assert-lower      571
;  :arith-assert-upper      331
;  :arith-bound-prop        199
;  :arith-conflicts         76
;  :arith-eq-adapter        310
;  :arith-fixed-eqs         147
;  :arith-max-min           18
;  :arith-nonlinear-bounds  2
;  :arith-offset-eqs        181
;  :arith-pivots            490
;  :conflicts               304
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 225
;  :datatype-occurs-check   132
;  :datatype-splits         73
;  :decisions               488
;  :del-clause              2825
;  :final-checks            79
;  :max-generation          4
;  :max-memory              5.32
;  :memory                  5.29
;  :mk-bool-var             5134
;  :mk-clause               2827
;  :num-allocs              200091
;  :num-checks              137
;  :propagations            1209
;  :quant-instantiations    1324
;  :rlimit-count            296973)
; Definitional axioms for inverse functions
(assert (forall ((i1@92@01 Int)) (!
  (implies
    (and
      (and (< i1@92@01 V@30@01) (<= 0 i1@92@01))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@93@01)))
    (=
      (inv@94@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@92@01))
      i1@92@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@92@01))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@93@01)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@94@01 r))
      r))
  :pattern ((inv@94@01 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) r) r))
  :pattern ((inv@94@01 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@95@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
    ($Perm.min
      (ite
        (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
        $k@43@01
        $Perm.No)
      (*
        (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
        $k@93@01))
    $Perm.No))
(define-fun pTaken@96@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
    ($Perm.min
      (ite
        (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
        $k@35@01
        $Perm.No)
      (-
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@93@01)
        (pTaken@95@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions scale(_, V@30@01 * V@30@01 * W) * $k@93@01
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
          $k@43@01
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
      (<
        (ite
          (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@93@01)
          $Perm.No)
        $k@43@01)
      (<
        (ite
          (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@93@01)
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@44@01 r))
  :pattern ((inv@94@01 r))
  :qid |qp.srp24|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
    (=
      (-
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@93@01)
        (pTaken@95@01 r))
      $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3225
;  :arith-add-rows          979
;  :arith-assert-diseq      82
;  :arith-assert-lower      599
;  :arith-assert-upper      347
;  :arith-bound-prop        210
;  :arith-conflicts         79
;  :arith-eq-adapter        326
;  :arith-fixed-eqs         152
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        187
;  :arith-pivots            510
;  :conflicts               308
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 233
;  :datatype-occurs-check   135
;  :datatype-splits         73
;  :decisions               503
;  :del-clause              2906
;  :final-checks            83
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.31
;  :minimized-lits          2
;  :mk-bool-var             5258
;  :mk-clause               2906
;  :num-allocs              203010
;  :num-checks              139
;  :propagations            1243
;  :quant-instantiations    1359
;  :rlimit-count            302155
;  :time                    0.00)
; Constrain original permissions scale(_, V@30@01 * V@30@01 * W) * $k@93@01
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
          $k@35@01
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
      (<
        (ite
          (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@93@01)
          $Perm.No)
        $k@35@01)
      (<
        (ite
          (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@93@01)
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@36@01 r))
  :pattern ((inv@94@01 r))
  :qid |qp.srp25|)))
; Intermediate check if already taken enough permissions
(push) ; 4
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@94@01 r) V@30@01) (<= 0 (inv@94@01 r)))
    (=
      (-
        (-
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@93@01)
          (pTaken@95@01 r))
        (pTaken@96@01 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3361
;  :arith-add-rows          1097
;  :arith-assert-diseq      101
;  :arith-assert-lower      653
;  :arith-assert-upper      378
;  :arith-bound-prop        233
;  :arith-conflicts         86
;  :arith-eq-adapter        369
;  :arith-fixed-eqs         166
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        207
;  :arith-pivots            542
;  :conflicts               321
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 237
;  :datatype-occurs-check   135
;  :datatype-splits         73
;  :decisions               516
;  :del-clause              3103
;  :final-checks            83
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.31
;  :minimized-lits          14
;  :mk-bool-var             5538
;  :mk-clause               3103
;  :num-allocs              204725
;  :num-checks              140
;  :propagations            1311
;  :quant-instantiations    1411
;  :rlimit-count            307910
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3372
;  :arith-add-rows          1097
;  :arith-assert-diseq      101
;  :arith-assert-lower      653
;  :arith-assert-upper      378
;  :arith-bound-prop        233
;  :arith-conflicts         86
;  :arith-eq-adapter        369
;  :arith-fixed-eqs         166
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        207
;  :arith-pivots            542
;  :conflicts               321
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 241
;  :datatype-occurs-check   136
;  :datatype-splits         73
;  :decisions               520
;  :del-clause              3103
;  :final-checks            84
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5538
;  :mk-clause               3103
;  :num-allocs              205248
;  :num-checks              141
;  :propagations            1311
;  :quant-instantiations    1411
;  :rlimit-count            308381)
; [then-branch: 93 | 0 < V@30@01 | live]
; [else-branch: 93 | !(0 < V@30@01) | dead]
(push) ; 5
; [then-branch: 93 | 0 < V@30@01]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@97@01 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 94 | 0 <= i1@97@01 | live]
; [else-branch: 94 | !(0 <= i1@97@01) | live]
(push) ; 8
; [then-branch: 94 | 0 <= i1@97@01]
(assert (<= 0 i1@97@01))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 94 | !(0 <= i1@97@01)]
(assert (not (<= 0 i1@97@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 95 | i1@97@01 < V@30@01 && 0 <= i1@97@01 | live]
; [else-branch: 95 | !(i1@97@01 < V@30@01 && 0 <= i1@97@01) | live]
(push) ; 8
; [then-branch: 95 | i1@97@01 < V@30@01 && 0 <= i1@97@01]
(assert (and (< i1@97@01 V@30@01) (<= 0 i1@97@01)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@97@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3372
;  :arith-add-rows          1097
;  :arith-assert-diseq      101
;  :arith-assert-lower      655
;  :arith-assert-upper      378
;  :arith-bound-prop        233
;  :arith-conflicts         86
;  :arith-eq-adapter        369
;  :arith-fixed-eqs         166
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        207
;  :arith-pivots            542
;  :conflicts               321
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 241
;  :datatype-occurs-check   136
;  :datatype-splits         73
;  :decisions               520
;  :del-clause              3103
;  :final-checks            84
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5540
;  :mk-clause               3103
;  :num-allocs              205352
;  :num-checks              142
;  :propagations            1311
;  :quant-instantiations    1411
;  :rlimit-count            308576)
(assert (< i1@97@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 9
; Joined path conditions
(assert (< i1@97@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3452
;  :arith-add-rows          1116
;  :arith-assert-diseq      104
;  :arith-assert-lower      675
;  :arith-assert-upper      389
;  :arith-bound-prop        240
;  :arith-conflicts         88
;  :arith-eq-adapter        383
;  :arith-fixed-eqs         171
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        220
;  :arith-pivots            553
;  :conflicts               331
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 245
;  :datatype-occurs-check   136
;  :datatype-splits         73
;  :decisions               529
;  :del-clause              3159
;  :final-checks            84
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5675
;  :mk-clause               3200
;  :num-allocs              206092
;  :num-checks              143
;  :propagations            1352
;  :quant-instantiations    1441
;  :rlimit-count            310779)
; [eval] (None(): option[array])
(pop) ; 8
(push) ; 8
; [else-branch: 95 | !(i1@97@01 < V@30@01 && 0 <= i1@97@01)]
(assert (not (and (< i1@97@01 V@30@01) (<= 0 i1@97@01))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@97@01 V@30@01) (<= 0 i1@97@01))
  (and
    (< i1@97@01 V@30@01)
    (<= 0 i1@97@01)
    (< i1@97@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01)))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@97@01 Int)) (!
  (implies
    (and (< i1@97@01 V@30@01) (<= 0 i1@97@01))
    (and
      (< i1@97@01 V@30@01)
      (<= 0 i1@97@01)
      (< i1@97@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@97@01 Int)) (!
    (implies
      (and (< i1@97@01 V@30@01) (<= 0 i1@97@01))
      (and
        (< i1@97@01 V@30@01)
        (<= 0 i1@97@01)
        (< i1@97@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))
    :qid |prog.l<no position>-aux|))))
(push) ; 4
(assert (not (implies
  (< 0 V@30@01)
  (forall ((i1@97@01 Int)) (!
    (implies
      (and (< i1@97@01 V@30@01) (<= 0 i1@97@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3493
;  :arith-add-rows          1124
;  :arith-assert-diseq      104
;  :arith-assert-lower      679
;  :arith-assert-upper      391
;  :arith-bound-prop        241
;  :arith-conflicts         89
;  :arith-eq-adapter        384
;  :arith-fixed-eqs         172
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        220
;  :arith-pivots            560
;  :conflicts               337
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 249
;  :datatype-occurs-check   136
;  :datatype-splits         73
;  :decisions               534
;  :del-clause              3246
;  :final-checks            84
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.31
;  :minimized-lits          14
;  :mk-bool-var             5741
;  :mk-clause               3246
;  :num-allocs              206788
;  :num-checks              144
;  :propagations            1368
;  :quant-instantiations    1466
;  :rlimit-count            312810
;  :time                    0.00)
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@97@01 Int)) (!
    (implies
      (and (< i1@97@01 V@30@01) (<= 0 i1@97@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@97@01))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3504
;  :arith-add-rows          1124
;  :arith-assert-diseq      104
;  :arith-assert-lower      679
;  :arith-assert-upper      391
;  :arith-bound-prop        241
;  :arith-conflicts         89
;  :arith-eq-adapter        384
;  :arith-fixed-eqs         172
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        220
;  :arith-pivots            560
;  :conflicts               337
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 253
;  :datatype-occurs-check   137
;  :datatype-splits         73
;  :decisions               538
;  :del-clause              3246
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5742
;  :mk-clause               3246
;  :num-allocs              207497
;  :num-checks              145
;  :propagations            1368
;  :quant-instantiations    1466
;  :rlimit-count            313598)
; [then-branch: 96 | 0 < V@30@01 | live]
; [else-branch: 96 | !(0 < V@30@01) | dead]
(push) ; 5
; [then-branch: 96 | 0 < V@30@01]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@98@01 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 97 | 0 <= i1@98@01 | live]
; [else-branch: 97 | !(0 <= i1@98@01) | live]
(push) ; 8
; [then-branch: 97 | 0 <= i1@98@01]
(assert (<= 0 i1@98@01))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 97 | !(0 <= i1@98@01)]
(assert (not (<= 0 i1@98@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
; [then-branch: 98 | i1@98@01 < V@30@01 && 0 <= i1@98@01 | live]
; [else-branch: 98 | !(i1@98@01 < V@30@01 && 0 <= i1@98@01) | live]
(push) ; 8
; [then-branch: 98 | i1@98@01 < V@30@01 && 0 <= i1@98@01]
(assert (and (< i1@98@01 V@30@01) (<= 0 i1@98@01)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< i1@98@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3504
;  :arith-add-rows          1124
;  :arith-assert-diseq      104
;  :arith-assert-lower      681
;  :arith-assert-upper      391
;  :arith-bound-prop        241
;  :arith-conflicts         89
;  :arith-eq-adapter        384
;  :arith-fixed-eqs         172
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        220
;  :arith-pivots            560
;  :conflicts               337
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 253
;  :datatype-occurs-check   137
;  :datatype-splits         73
;  :decisions               538
;  :del-clause              3246
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5744
;  :mk-clause               3246
;  :num-allocs              207601
;  :num-checks              146
;  :propagations            1368
;  :quant-instantiations    1466
;  :rlimit-count            313793)
(assert (< i1@98@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 9
; Joined path conditions
(assert (< i1@98@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3586
;  :arith-add-rows          1145
;  :arith-assert-diseq      107
;  :arith-assert-lower      703
;  :arith-assert-upper      402
;  :arith-bound-prop        250
;  :arith-conflicts         91
;  :arith-eq-adapter        398
;  :arith-fixed-eqs         177
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        233
;  :arith-pivots            573
;  :conflicts               347
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   137
;  :datatype-splits         73
;  :decisions               547
;  :del-clause              3310
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5899
;  :mk-clause               3351
;  :num-allocs              208393
;  :num-checks              147
;  :propagations            1409
;  :quant-instantiations    1498
;  :rlimit-count            316124)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3586
;  :arith-add-rows          1145
;  :arith-assert-diseq      107
;  :arith-assert-lower      703
;  :arith-assert-upper      402
;  :arith-bound-prop        250
;  :arith-conflicts         91
;  :arith-eq-adapter        398
;  :arith-fixed-eqs         177
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        233
;  :arith-pivots            573
;  :conflicts               348
;  :datatype-accessor-ax    43
;  :datatype-constructor-ax 257
;  :datatype-occurs-check   137
;  :datatype-splits         73
;  :decisions               547
;  :del-clause              3310
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5899
;  :mk-clause               3351
;  :num-allocs              208484
;  :num-checks              148
;  :propagations            1409
;  :quant-instantiations    1498
;  :rlimit-count            316219)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
    (as None<option<array>>  option<array>))))
(pop) ; 8
(push) ; 8
; [else-branch: 98 | !(i1@98@01 < V@30@01 && 0 <= i1@98@01)]
(assert (not (and (< i1@98@01 V@30@01) (<= 0 i1@98@01))))
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< i1@98@01 V@30@01) (<= 0 i1@98@01))
  (and
    (< i1@98@01 V@30@01)
    (<= 0 i1@98@01)
    (< i1@98@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@98@01 Int)) (!
  (implies
    (and (< i1@98@01 V@30@01) (<= 0 i1@98@01))
    (and
      (< i1@98@01 V@30@01)
      (<= 0 i1@98@01)
      (< i1@98@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@98@01 Int)) (!
    (implies
      (and (< i1@98@01 V@30@01) (<= 0 i1@98@01))
      (and
        (< i1@98@01 V@30@01)
        (<= 0 i1@98@01)
        (< i1@98@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 4
(assert (not (implies
  (< 0 V@30@01)
  (forall ((i1@98@01 Int)) (!
    (implies
      (and (< i1@98@01 V@30@01) (<= 0 i1@98@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3653
;  :arith-add-rows          1164
;  :arith-assert-diseq      108
;  :arith-assert-lower      711
;  :arith-assert-upper      405
;  :arith-bound-prop        253
;  :arith-conflicts         92
;  :arith-eq-adapter        401
;  :arith-fixed-eqs         179
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        238
;  :arith-pivots            585
;  :conflicts               354
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 262
;  :datatype-occurs-check   137
;  :datatype-splits         73
;  :decisions               555
;  :del-clause              3416
;  :final-checks            85
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.31
;  :minimized-lits          14
;  :mk-bool-var             5992
;  :mk-clause               3416
;  :num-allocs              209321
;  :num-checks              149
;  :propagations            1436
;  :quant-instantiations    1534
;  :rlimit-count            318849
;  :time                    0.00)
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@98@01 Int)) (!
    (implies
      (and (< i1@98@01 V@30@01) (<= 0 i1@98@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@98@01)))))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3664
;  :arith-add-rows          1164
;  :arith-assert-diseq      108
;  :arith-assert-lower      711
;  :arith-assert-upper      405
;  :arith-bound-prop        253
;  :arith-conflicts         92
;  :arith-eq-adapter        401
;  :arith-fixed-eqs         179
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        238
;  :arith-pivots            585
;  :conflicts               354
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 266
;  :datatype-occurs-check   138
;  :datatype-splits         73
;  :decisions               559
;  :del-clause              3416
;  :final-checks            86
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5993
;  :mk-clause               3416
;  :num-allocs              210039
;  :num-checks              150
;  :propagations            1436
;  :quant-instantiations    1534
;  :rlimit-count            319639)
; [then-branch: 99 | 0 < V@30@01 | live]
; [else-branch: 99 | !(0 < V@30@01) | dead]
(push) ; 5
; [then-branch: 99 | 0 < V@30@01]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@99@01 Int)
(push) ; 6
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@100@01 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 100 | 0 <= i1@99@01 | live]
; [else-branch: 100 | !(0 <= i1@99@01) | live]
(push) ; 9
; [then-branch: 100 | 0 <= i1@99@01]
(assert (<= 0 i1@99@01))
; [eval] i1 < V
(push) ; 10
; [then-branch: 101 | i1@99@01 < V@30@01 | live]
; [else-branch: 101 | !(i1@99@01 < V@30@01) | live]
(push) ; 11
; [then-branch: 101 | i1@99@01 < V@30@01]
(assert (< i1@99@01 V@30@01))
; [eval] 0 <= i2
(push) ; 12
; [then-branch: 102 | 0 <= i2@100@01 | live]
; [else-branch: 102 | !(0 <= i2@100@01) | live]
(push) ; 13
; [then-branch: 102 | 0 <= i2@100@01]
(assert (<= 0 i2@100@01))
; [eval] i2 < V
(push) ; 14
; [then-branch: 103 | i2@100@01 < V@30@01 | live]
; [else-branch: 103 | !(i2@100@01 < V@30@01) | live]
(push) ; 15
; [then-branch: 103 | i2@100@01 < V@30@01]
(assert (< i2@100@01 V@30@01))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3664
;  :arith-add-rows          1164
;  :arith-assert-diseq      108
;  :arith-assert-lower      715
;  :arith-assert-upper      405
;  :arith-bound-prop        253
;  :arith-conflicts         92
;  :arith-eq-adapter        401
;  :arith-fixed-eqs         179
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        238
;  :arith-pivots            585
;  :conflicts               354
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 266
;  :datatype-occurs-check   138
;  :datatype-splits         73
;  :decisions               559
;  :del-clause              3416
;  :final-checks            86
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             5997
;  :mk-clause               3416
;  :num-allocs              210320
;  :num-checks              151
;  :propagations            1436
;  :quant-instantiations    1534
;  :rlimit-count            319978)
(assert (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 16
; Joined path conditions
(assert (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3739
;  :arith-add-rows          1189
;  :arith-assert-diseq      112
;  :arith-assert-lower      736
;  :arith-assert-upper      415
;  :arith-bound-prop        259
;  :arith-conflicts         95
;  :arith-eq-adapter        415
;  :arith-fixed-eqs         184
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        244
;  :arith-pivots            598
;  :conflicts               365
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 270
;  :datatype-occurs-check   138
;  :datatype-splits         73
;  :decisions               569
;  :del-clause              3464
;  :final-checks            86
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             6136
;  :mk-clause               3505
;  :num-allocs              211078
;  :num-checks              152
;  :propagations            1474
;  :quant-instantiations    1566
;  :rlimit-count            322259
;  :time                    0.00)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 17
(assert (not (< i2@100@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3739
;  :arith-add-rows          1189
;  :arith-assert-diseq      112
;  :arith-assert-lower      736
;  :arith-assert-upper      415
;  :arith-bound-prop        259
;  :arith-conflicts         95
;  :arith-eq-adapter        415
;  :arith-fixed-eqs         184
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        244
;  :arith-pivots            598
;  :conflicts               365
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 270
;  :datatype-occurs-check   138
;  :datatype-splits         73
;  :decisions               569
;  :del-clause              3464
;  :final-checks            86
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.33
;  :memory                  5.32
;  :minimized-lits          14
;  :mk-bool-var             6136
;  :mk-clause               3505
;  :num-allocs              211105
;  :num-checks              153
;  :propagations            1474
;  :quant-instantiations    1566
;  :rlimit-count            322289)
(assert (< i2@100@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 16
; Joined path conditions
(assert (< i2@100@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3862
;  :arith-add-rows          1247
;  :arith-assert-diseq      121
;  :arith-assert-lower      765
;  :arith-assert-upper      430
;  :arith-bound-prop        267
;  :arith-conflicts         98
;  :arith-eq-adapter        434
;  :arith-fixed-eqs         191
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        263
;  :arith-pivots            614
;  :conflicts               382
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 274
;  :datatype-occurs-check   138
;  :datatype-splits         73
;  :decisions               587
;  :del-clause              3552
;  :final-checks            86
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.34
;  :minimized-lits          14
;  :mk-bool-var             6328
;  :mk-clause               3644
;  :num-allocs              212011
;  :num-checks              154
;  :propagations            1542
;  :quant-instantiations    1600
;  :rlimit-count            325619
;  :time                    0.00)
(pop) ; 15
(push) ; 15
; [else-branch: 103 | !(i2@100@01 < V@30@01)]
(assert (not (< i2@100@01 V@30@01)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (< i2@100@01 V@30@01)
  (and
    (< i2@100@01 V@30@01)
    (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
    (< i2@100@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 102 | !(0 <= i2@100@01)]
(assert (not (<= 0 i2@100@01)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (<= 0 i2@100@01)
  (and
    (<= 0 i2@100@01)
    (implies
      (< i2@100@01 V@30@01)
      (and
        (< i2@100@01 V@30@01)
        (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
        (< i2@100@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 101 | !(i1@99@01 < V@30@01)]
(assert (not (< i1@99@01 V@30@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (< i1@99@01 V@30@01)
  (and
    (< i1@99@01 V@30@01)
    (implies
      (<= 0 i2@100@01)
      (and
        (<= 0 i2@100@01)
        (implies
          (< i2@100@01 V@30@01)
          (and
            (< i2@100@01 V@30@01)
            (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
            (< i2@100@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))))))))
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 100 | !(0 <= i1@99@01)]
(assert (not (<= 0 i1@99@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (<= 0 i1@99@01)
  (and
    (<= 0 i1@99@01)
    (implies
      (< i1@99@01 V@30@01)
      (and
        (< i1@99@01 V@30@01)
        (implies
          (<= 0 i2@100@01)
          (and
            (<= 0 i2@100@01)
            (implies
              (< i2@100@01 V@30@01)
              (and
                (< i2@100@01 V@30@01)
                (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                (< i2@100@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))))))))))
; Joined path conditions
(push) ; 8
; [then-branch: 104 | Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, source@28@01), i1@99@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, source@28@01), i2@100@01)) && i2@100@01 < V@30@01 && 0 <= i2@100@01 && i1@99@01 < V@30@01 && 0 <= i1@99@01 | live]
; [else-branch: 104 | !(Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, source@28@01), i1@99@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, source@28@01), i2@100@01)) && i2@100@01 < V@30@01 && 0 <= i2@100@01 && i1@99@01 < V@30@01 && 0 <= i1@99@01) | live]
(push) ; 9
; [then-branch: 104 | Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, source@28@01), i1@99@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, source@28@01), i2@100@01)) && i2@100@01 < V@30@01 && 0 <= i2@100@01 && i1@99@01 < V@30@01 && 0 <= i1@99@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
        (< i2@100@01 V@30@01))
      (<= 0 i2@100@01))
    (< i1@99@01 V@30@01))
  (<= 0 i1@99@01)))
; [eval] i1 == i2
(pop) ; 9
(push) ; 9
; [else-branch: 104 | !(Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, source@28@01), i1@99@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, source@28@01), i2@100@01)) && i2@100@01 < V@30@01 && 0 <= i2@100@01 && i1@99@01 < V@30@01 && 0 <= i1@99@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
          (< i2@100@01 V@30@01))
        (<= 0 i2@100@01))
      (< i1@99@01 V@30@01))
    (<= 0 i1@99@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
          (< i2@100@01 V@30@01))
        (<= 0 i2@100@01))
      (< i1@99@01 V@30@01))
    (<= 0 i1@99@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
      ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
    (< i2@100@01 V@30@01)
    (<= 0 i2@100@01)
    (< i1@99@01 V@30@01)
    (<= 0 i1@99@01))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@100@01 Int)) (!
  (and
    (implies
      (<= 0 i1@99@01)
      (and
        (<= 0 i1@99@01)
        (implies
          (< i1@99@01 V@30@01)
          (and
            (< i1@99@01 V@30@01)
            (implies
              (<= 0 i2@100@01)
              (and
                (<= 0 i2@100@01)
                (implies
                  (< i2@100@01 V@30@01)
                  (and
                    (< i2@100@01 V@30@01)
                    (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                    (< i2@100@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
              (< i2@100@01 V@30@01))
            (<= 0 i2@100@01))
          (< i1@99@01 V@30@01))
        (<= 0 i1@99@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
        (< i2@100@01 V@30@01)
        (<= 0 i2@100@01)
        (< i1@99@01 V@30@01)
        (<= 0 i1@99@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@99@01 Int)) (!
  (forall ((i2@100@01 Int)) (!
    (and
      (implies
        (<= 0 i1@99@01)
        (and
          (<= 0 i1@99@01)
          (implies
            (< i1@99@01 V@30@01)
            (and
              (< i1@99@01 V@30@01)
              (implies
                (<= 0 i2@100@01)
                (and
                  (<= 0 i2@100@01)
                  (implies
                    (< i2@100@01 V@30@01)
                    (and
                      (< i2@100@01 V@30@01)
                      (< i1@99@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                      (<
                        i2@100@01
                        (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
                (< i2@100@01 V@30@01))
              (<= 0 i2@100@01))
            (< i1@99@01 V@30@01))
          (<= 0 i1@99@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
          (< i2@100@01 V@30@01)
          (<= 0 i2@100@01)
          (< i1@99@01 V@30@01)
          (<= 0 i1@99@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 5
(pop) ; 4
; Joined path conditions
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@99@01 Int)) (!
    (forall ((i2@100@01 Int)) (!
      (and
        (implies
          (<= 0 i1@99@01)
          (and
            (<= 0 i1@99@01)
            (implies
              (< i1@99@01 V@30@01)
              (and
                (< i1@99@01 V@30@01)
                (implies
                  (<= 0 i2@100@01)
                  (and
                    (<= 0 i2@100@01)
                    (implies
                      (< i2@100@01 V@30@01)
                      (and
                        (< i2@100@01 V@30@01)
                        (<
                          i1@99@01
                          (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                        (<
                          i2@100@01
                          (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
                  (< i2@100@01 V@30@01))
                (<= 0 i2@100@01))
              (< i1@99@01 V@30@01))
            (<= 0 i1@99@01))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
              ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
            (< i2@100@01 V@30@01)
            (<= 0 i2@100@01)
            (< i1@99@01 V@30@01)
            (<= 0 i1@99@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
    :qid |prog.l<no position>-aux|))))
(push) ; 4
(assert (not (implies
  (< 0 V@30@01)
  (forall ((i1@99@01 Int)) (!
    (forall ((i2@100@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
                (< i2@100@01 V@30@01))
              (<= 0 i2@100@01))
            (< i1@99@01 V@30@01))
          (<= 0 i1@99@01))
        (= i1@99@01 i2@100@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3927
;  :arith-add-rows          1313
;  :arith-assert-diseq      124
;  :arith-assert-lower      775
;  :arith-assert-upper      435
;  :arith-bound-prop        271
;  :arith-conflicts         100
;  :arith-eq-adapter        437
;  :arith-fixed-eqs         193
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        266
;  :arith-pivots            633
;  :conflicts               391
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 278
;  :datatype-occurs-check   138
;  :datatype-splits         73
;  :decisions               595
;  :del-clause              3762
;  :final-checks            86
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.33
;  :minimized-lits          14
;  :mk-bool-var             6513
;  :mk-clause               3762
;  :num-allocs              213651
;  :num-checks              155
;  :propagations            1575
;  :quant-instantiations    1658
;  :rlimit-count            332083
;  :time                    0.00)
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@99@01 Int)) (!
    (forall ((i2@100@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01)))
                (< i2@100@01 V@30@01))
              (<= 0 i2@100@01))
            (< i1@99@01 V@30@01))
          (<= 0 i1@99@01))
        (= i1@99@01 i2@100@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@100@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@99@01))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> target != (None(): option[array])
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3938
;  :arith-add-rows          1313
;  :arith-assert-diseq      124
;  :arith-assert-lower      775
;  :arith-assert-upper      435
;  :arith-bound-prop        271
;  :arith-conflicts         100
;  :arith-eq-adapter        437
;  :arith-fixed-eqs         193
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        266
;  :arith-pivots            633
;  :conflicts               391
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 282
;  :datatype-occurs-check   139
;  :datatype-splits         73
;  :decisions               599
;  :del-clause              3762
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.34
;  :minimized-lits          14
;  :mk-bool-var             6514
;  :mk-clause               3762
;  :num-allocs              214499
;  :num-checks              156
;  :propagations            1575
;  :quant-instantiations    1658
;  :rlimit-count            333095)
; [then-branch: 105 | 0 < V@30@01 | live]
; [else-branch: 105 | !(0 < V@30@01) | dead]
(push) ; 5
; [then-branch: 105 | 0 < V@30@01]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 5
(pop) ; 4
; Joined path conditions
(set-option :timeout 0)
(push) ; 4
(assert (not (implies
  (< 0 V@30@01)
  (not (= target@29@01 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3938
;  :arith-add-rows          1313
;  :arith-assert-diseq      124
;  :arith-assert-lower      775
;  :arith-assert-upper      435
;  :arith-bound-prop        271
;  :arith-conflicts         100
;  :arith-eq-adapter        437
;  :arith-fixed-eqs         193
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        266
;  :arith-pivots            633
;  :conflicts               391
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 282
;  :datatype-occurs-check   139
;  :datatype-splits         73
;  :decisions               599
;  :del-clause              3762
;  :final-checks            87
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.34
;  :minimized-lits          14
;  :mk-bool-var             6514
;  :mk-clause               3762
;  :num-allocs              214524
;  :num-checks              157
;  :propagations            1575
;  :quant-instantiations    1658
;  :rlimit-count            333117)
(assert (implies
  (< 0 V@30@01)
  (not (= target@29@01 (as None<option<array>>  option<array>)))))
; [eval] 0 < V ==> alen(opt_get1(target)) == V
; [eval] 0 < V
(push) ; 4
(set-option :timeout 10)
(push) ; 5
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3949
;  :arith-add-rows          1313
;  :arith-assert-diseq      124
;  :arith-assert-lower      775
;  :arith-assert-upper      435
;  :arith-bound-prop        271
;  :arith-conflicts         100
;  :arith-eq-adapter        437
;  :arith-fixed-eqs         193
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        266
;  :arith-pivots            633
;  :conflicts               391
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 286
;  :datatype-occurs-check   140
;  :datatype-splits         73
;  :decisions               603
;  :del-clause              3762
;  :final-checks            88
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.34
;  :minimized-lits          14
;  :mk-bool-var             6514
;  :mk-clause               3762
;  :num-allocs              215041
;  :num-checks              158
;  :propagations            1575
;  :quant-instantiations    1658
;  :rlimit-count            333599)
; [then-branch: 106 | 0 < V@30@01 | live]
; [else-branch: 106 | !(0 < V@30@01) | dead]
(push) ; 5
; [then-branch: 106 | 0 < V@30@01]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(pop) ; 5
(pop) ; 4
; Joined path conditions
(set-option :timeout 0)
(push) ; 4
(assert (not (implies
  (< 0 V@30@01)
  (= (alen<Int> (opt_get1 $Snap.unit target@29@01)) V@30@01))))
(check-sat)
; unsat
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3949
;  :arith-add-rows          1313
;  :arith-assert-diseq      124
;  :arith-assert-lower      775
;  :arith-assert-upper      435
;  :arith-bound-prop        271
;  :arith-conflicts         100
;  :arith-eq-adapter        437
;  :arith-fixed-eqs         193
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        266
;  :arith-pivots            633
;  :conflicts               391
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 286
;  :datatype-occurs-check   140
;  :datatype-splits         73
;  :decisions               603
;  :del-clause              3762
;  :final-checks            88
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.34
;  :minimized-lits          14
;  :mk-bool-var             6514
;  :mk-clause               3762
;  :num-allocs              215060
;  :num-checks              159
;  :propagations            1575
;  :quant-instantiations    1658
;  :rlimit-count            333626)
(assert (implies
  (< 0 V@30@01)
  (= (alen<Int> (opt_get1 $Snap.unit target@29@01)) V@30@01)))
; [eval] 0 < V
(set-option :timeout 10)
(push) ; 4
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 4
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3960
;  :arith-add-rows          1313
;  :arith-assert-diseq      124
;  :arith-assert-lower      775
;  :arith-assert-upper      435
;  :arith-bound-prop        271
;  :arith-conflicts         100
;  :arith-eq-adapter        437
;  :arith-fixed-eqs         193
;  :arith-max-min           27
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        266
;  :arith-pivots            633
;  :conflicts               391
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 290
;  :datatype-occurs-check   141
;  :datatype-splits         73
;  :decisions               607
;  :del-clause              3762
;  :final-checks            89
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.34
;  :minimized-lits          14
;  :mk-bool-var             6514
;  :mk-clause               3762
;  :num-allocs              215577
;  :num-checks              160
;  :propagations            1575
;  :quant-instantiations    1658
;  :rlimit-count            334103)
; [then-branch: 107 | 0 < V@30@01 | live]
; [else-branch: 107 | !(0 < V@30@01) | dead]
(push) ; 4
; [then-branch: 107 | 0 < V@30@01]
(declare-const i1@101@01 Int)
(push) ; 5
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 6
; [then-branch: 108 | 0 <= i1@101@01 | live]
; [else-branch: 108 | !(0 <= i1@101@01) | live]
(push) ; 7
; [then-branch: 108 | 0 <= i1@101@01]
(assert (<= 0 i1@101@01))
; [eval] i1 < V
(pop) ; 7
(push) ; 7
; [else-branch: 108 | !(0 <= i1@101@01)]
(assert (not (<= 0 i1@101@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and (< i1@101@01 V@30@01) (<= 0 i1@101@01)))
; [eval] scale(V * V * write) * wildcard
; [eval] scale(V * V * write)
; [eval] V * V * write
; [eval] V * V
(push) ; 6
; [eval] amount >= 0 * write
; [eval] 0 * write
(set-option :timeout 0)
(push) ; 7
(assert (not (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3971
;  :arith-add-rows          1318
;  :arith-assert-diseq      124
;  :arith-assert-lower      779
;  :arith-assert-upper      436
;  :arith-bound-prop        271
;  :arith-conflicts         101
;  :arith-eq-adapter        437
;  :arith-fixed-eqs         193
;  :arith-max-min           30
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        266
;  :arith-pivots            634
;  :conflicts               392
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 294
;  :datatype-occurs-check   141
;  :datatype-splits         73
;  :decisions               611
;  :del-clause              3762
;  :final-checks            90
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.33
;  :minimized-lits          14
;  :mk-bool-var             6517
;  :mk-clause               3762
;  :num-allocs              215763
;  :num-checks              161
;  :propagations            1575
;  :quant-instantiations    1658
;  :rlimit-count            334474)
(assert (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
(pop) ; 6
; Joined path conditions
(assert (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
(declare-const $k@102@01 $Perm)
(assert ($Perm.isReadVar $k@102@01 $Perm.Write))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< i1@101@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3971
;  :arith-add-rows          1318
;  :arith-assert-diseq      125
;  :arith-assert-lower      782
;  :arith-assert-upper      437
;  :arith-bound-prop        271
;  :arith-conflicts         101
;  :arith-eq-adapter        438
;  :arith-fixed-eqs         193
;  :arith-max-min           30
;  :arith-nonlinear-bounds  3
;  :arith-offset-eqs        266
;  :arith-pivots            634
;  :conflicts               392
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 294
;  :datatype-occurs-check   141
;  :datatype-splits         73
;  :decisions               611
;  :del-clause              3762
;  :final-checks            90
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.33
;  :minimized-lits          14
;  :mk-bool-var             6522
;  :mk-clause               3764
;  :num-allocs              215965
;  :num-checks              162
;  :propagations            1576
;  :quant-instantiations    1658
;  :rlimit-count            334722)
(assert (< i1@101@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 6
; Joined path conditions
(assert (< i1@101@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 5
(declare-fun inv@103@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@102@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@101@01 Int)) (!
  (and
    (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No)
    (< i1@101@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@101@01))
  :qid |option$array$-aux|)))
(push) ; 5
(assert (not (forall ((i1@101@01 Int)) (!
  (implies
    (and (< i1@101@01 V@30@01) (<= 0 i1@101@01))
    (or
      (=
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@102@01)
        $Perm.No)
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@102@01))))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3985
;  :arith-add-rows          1318
;  :arith-assert-diseq      127
;  :arith-assert-lower      796
;  :arith-assert-upper      443
;  :arith-bound-prop        271
;  :arith-conflicts         103
;  :arith-eq-adapter        441
;  :arith-fixed-eqs         193
;  :arith-max-min           45
;  :arith-nonlinear-bounds  5
;  :arith-offset-eqs        267
;  :arith-pivots            636
;  :conflicts               398
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 298
;  :datatype-occurs-check   142
;  :datatype-splits         73
;  :decisions               616
;  :del-clause              3772
;  :final-checks            92
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.33
;  :minimized-lits          14
;  :mk-bool-var             6538
;  :mk-clause               3774
;  :num-allocs              216565
;  :num-checks              163
;  :propagations            1581
;  :quant-instantiations    1661
;  :rlimit-count            335670)
(declare-const sm@104@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@104@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@104@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef26|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
          $k@43@01
          $Perm.No)
        (pTaken@95@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@104@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@104@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef27|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@104@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef28|)))
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((i11@101@01 Int) (i12@101@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@101@01 V@30@01) (<= 0 i11@101@01))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@104@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@101@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@101@01)))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@102@01)))
      (and
        (and
          (and (< i12@101@01 V@30@01) (<= 0 i12@101@01))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@104@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@101@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@101@01)))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@102@01)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@101@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@101@01)))
    (= i11@101@01 i12@101@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               3996
;  :arith-add-rows          1320
;  :arith-assert-diseq      128
;  :arith-assert-lower      801
;  :arith-assert-upper      443
;  :arith-bound-prop        271
;  :arith-conflicts         103
;  :arith-eq-adapter        443
;  :arith-fixed-eqs         193
;  :arith-max-min           45
;  :arith-nonlinear-bounds  5
;  :arith-offset-eqs        267
;  :arith-pivots            636
;  :conflicts               399
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 298
;  :datatype-occurs-check   142
;  :datatype-splits         73
;  :decisions               616
;  :del-clause              3813
;  :final-checks            92
;  :interface-eqs           1
;  :max-generation          4
;  :max-memory              5.37
;  :memory                  5.33
;  :minimized-lits          14
;  :mk-bool-var             6599
;  :mk-clause               3815
;  :num-allocs              217735
;  :num-checks              164
;  :propagations            1587
;  :quant-instantiations    1677
;  :rlimit-count            339132)
; Definitional axioms for inverse functions
(assert (forall ((i1@101@01 Int)) (!
  (implies
    (and
      (and (< i1@101@01 V@30@01) (<= 0 i1@101@01))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@102@01)))
    (=
      (inv@103@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@101@01))
      i1@101@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@101@01))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@103@01 r) V@30@01) (<= 0 (inv@103@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@102@01)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@103@01 r))
      r))
  :pattern ((inv@103@01 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@103@01 r) V@30@01) (<= 0 (inv@103@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@104@01  $FVF<option<array>>) r) r))
  :pattern ((inv@103@01 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@105@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@103@01 r) V@30@01) (<= 0 (inv@103@01 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 r))
      (*
        (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
        $k@102@01))
    $Perm.No))
(define-fun pTaken@106@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@103@01 r) V@30@01) (<= 0 (inv@103@01 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
          $k@43@01
          $Perm.No)
        (pTaken@95@01 r))
      (-
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@102@01)
        (pTaken@105@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions scale(_, V@30@01 * V@30@01 * W) * $k@102@01
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@103@01 r) V@30@01) (<= 0 (inv@103@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@102@01)
        $Perm.No)
      (-
        (ite
          (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 r))))
  :pattern ((inv@36@01 r))
  :pattern ((inv@103@01 r))
  :qid |qp.srp29|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@103@01 r) V@30@01) (<= 0 (inv@103@01 r)))
    (=
      (-
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@102@01)
        (pTaken@105@01 r))
      $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 5
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4344
;  :arith-add-rows          1544
;  :arith-assert-diseq      153
;  :arith-assert-lower      942
;  :arith-assert-upper      510
;  :arith-bound-prop        303
;  :arith-conflicts         112
;  :arith-eq-adapter        517
;  :arith-fixed-eqs         230
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        308
;  :arith-pivots            711
;  :conflicts               417
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 306
;  :datatype-occurs-check   147
;  :datatype-splits         73
;  :decisions               673
;  :del-clause              4164
;  :final-checks            98
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.44
;  :minimized-lits          16
;  :mk-bool-var             7084
;  :mk-clause               4166
;  :num-allocs              222702
;  :num-checks              166
;  :propagations            1815
;  :quant-instantiations    1820
;  :rlimit-count            354486
;  :time                    0.01)
; Constrain original permissions scale(_, V@30@01 * V@30@01 * W) * $k@102@01
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@103@01 r) V@30@01) (<= 0 (inv@103@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@102@01)
        $Perm.No)
      (-
        (ite
          (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
          $k@43@01
          $Perm.No)
        (pTaken@95@01 r))))
  :pattern ((inv@44@01 r))
  :pattern ((inv@103@01 r))
  :qid |qp.srp30|)))
; Intermediate check if already taken enough permissions
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@103@01 r) V@30@01) (<= 0 (inv@103@01 r)))
    (=
      (-
        (-
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@102@01)
          (pTaken@105@01 r))
        (pTaken@106@01 r))
      $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4521
;  :arith-add-rows          1768
;  :arith-assert-diseq      177
;  :arith-assert-lower      1001
;  :arith-assert-upper      554
;  :arith-bound-prop        321
;  :arith-conflicts         120
;  :arith-eq-adapter        576
;  :arith-fixed-eqs         248
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        338
;  :arith-pivots            761
;  :conflicts               434
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 310
;  :datatype-occurs-check   147
;  :datatype-splits         73
;  :decisions               689
;  :del-clause              4408
;  :final-checks            98
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.43
;  :minimized-lits          18
;  :mk-bool-var             7385
;  :mk-clause               4410
;  :num-allocs              224597
;  :num-checks              167
;  :propagations            1932
;  :quant-instantiations    1856
;  :rlimit-count            362621
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] 0 < V
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4532
;  :arith-add-rows          1768
;  :arith-assert-diseq      177
;  :arith-assert-lower      1001
;  :arith-assert-upper      554
;  :arith-bound-prop        321
;  :arith-conflicts         120
;  :arith-eq-adapter        576
;  :arith-fixed-eqs         248
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        338
;  :arith-pivots            761
;  :conflicts               434
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 314
;  :datatype-occurs-check   148
;  :datatype-splits         73
;  :decisions               693
;  :del-clause              4408
;  :final-checks            99
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.44
;  :minimized-lits          18
;  :mk-bool-var             7385
;  :mk-clause               4410
;  :num-allocs              225127
;  :num-checks              168
;  :propagations            1932
;  :quant-instantiations    1856
;  :rlimit-count            363110)
; [then-branch: 109 | 0 < V@30@01 | live]
; [else-branch: 109 | !(0 < V@30@01) | dead]
(push) ; 6
; [then-branch: 109 | 0 < V@30@01]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@107@01 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 110 | 0 <= i1@107@01 | live]
; [else-branch: 110 | !(0 <= i1@107@01) | live]
(push) ; 9
; [then-branch: 110 | 0 <= i1@107@01]
(assert (<= 0 i1@107@01))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 110 | !(0 <= i1@107@01)]
(assert (not (<= 0 i1@107@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 111 | i1@107@01 < V@30@01 && 0 <= i1@107@01 | live]
; [else-branch: 111 | !(i1@107@01 < V@30@01 && 0 <= i1@107@01) | live]
(push) ; 9
; [then-branch: 111 | i1@107@01 < V@30@01 && 0 <= i1@107@01]
(assert (and (< i1@107@01 V@30@01) (<= 0 i1@107@01)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@107@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4532
;  :arith-add-rows          1768
;  :arith-assert-diseq      177
;  :arith-assert-lower      1003
;  :arith-assert-upper      554
;  :arith-bound-prop        321
;  :arith-conflicts         120
;  :arith-eq-adapter        576
;  :arith-fixed-eqs         248
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        338
;  :arith-pivots            762
;  :conflicts               434
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 314
;  :datatype-occurs-check   148
;  :datatype-splits         73
;  :decisions               693
;  :del-clause              4408
;  :final-checks            99
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.44
;  :minimized-lits          18
;  :mk-bool-var             7387
;  :mk-clause               4410
;  :num-allocs              225231
;  :num-checks              169
;  :propagations            1932
;  :quant-instantiations    1856
;  :rlimit-count            363309)
(assert (< i1@107@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 10
; Joined path conditions
(assert (< i1@107@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4627
;  :arith-add-rows          1818
;  :arith-assert-diseq      180
;  :arith-assert-lower      1033
;  :arith-assert-upper      576
;  :arith-bound-prop        329
;  :arith-conflicts         123
;  :arith-eq-adapter        597
;  :arith-fixed-eqs         258
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        345
;  :arith-pivots            778
;  :conflicts               443
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 318
;  :datatype-occurs-check   148
;  :datatype-splits         73
;  :decisions               709
;  :del-clause              4469
;  :final-checks            99
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.44
;  :minimized-lits          18
;  :mk-bool-var             7570
;  :mk-clause               4534
;  :num-allocs              226193
;  :num-checks              170
;  :propagations            1982
;  :quant-instantiations    1898
;  :rlimit-count            366709
;  :time                    0.00)
; [eval] (None(): option[array])
(pop) ; 9
(push) ; 9
; [else-branch: 111 | !(i1@107@01 < V@30@01 && 0 <= i1@107@01)]
(assert (not (and (< i1@107@01 V@30@01) (<= 0 i1@107@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and (< i1@107@01 V@30@01) (<= 0 i1@107@01))
  (and
    (< i1@107@01 V@30@01)
    (<= 0 i1@107@01)
    (< i1@107@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01)))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@107@01 Int)) (!
  (implies
    (and (< i1@107@01 V@30@01) (<= 0 i1@107@01))
    (and
      (< i1@107@01 V@30@01)
      (<= 0 i1@107@01)
      (< i1@107@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@107@01 Int)) (!
    (implies
      (and (< i1@107@01 V@30@01) (<= 0 i1@107@01))
      (and
        (< i1@107@01 V@30@01)
        (<= 0 i1@107@01)
        (< i1@107@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))
    :qid |prog.l<no position>-aux|))))
(push) ; 5
(assert (not (implies
  (< 0 V@30@01)
  (forall ((i1@107@01 Int)) (!
    (implies
      (and (< i1@107@01 V@30@01) (<= 0 i1@107@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4630
;  :arith-add-rows          1826
;  :arith-assert-diseq      180
;  :arith-assert-lower      1037
;  :arith-assert-upper      577
;  :arith-bound-prop        330
;  :arith-conflicts         123
;  :arith-eq-adapter        599
;  :arith-fixed-eqs         259
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        345
;  :arith-pivots            784
;  :conflicts               444
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 318
;  :datatype-occurs-check   148
;  :datatype-splits         73
;  :decisions               709
;  :del-clause              4593
;  :final-checks            99
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.43
;  :minimized-lits          18
;  :mk-bool-var             7641
;  :mk-clause               4595
;  :num-allocs              226952
;  :num-checks              171
;  :propagations            1987
;  :quant-instantiations    1923
;  :rlimit-count            368638)
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@107@01 Int)) (!
    (implies
      (and (< i1@107@01 V@30@01) (<= 0 i1@107@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@107@01))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] 0 < V
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4641
;  :arith-add-rows          1826
;  :arith-assert-diseq      180
;  :arith-assert-lower      1037
;  :arith-assert-upper      577
;  :arith-bound-prop        330
;  :arith-conflicts         123
;  :arith-eq-adapter        599
;  :arith-fixed-eqs         259
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        345
;  :arith-pivots            784
;  :conflicts               444
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 322
;  :datatype-occurs-check   149
;  :datatype-splits         73
;  :decisions               713
;  :del-clause              4593
;  :final-checks            100
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.44
;  :minimized-lits          18
;  :mk-bool-var             7642
;  :mk-clause               4595
;  :num-allocs              227670
;  :num-checks              172
;  :propagations            1987
;  :quant-instantiations    1923
;  :rlimit-count            369444)
; [then-branch: 112 | 0 < V@30@01 | live]
; [else-branch: 112 | !(0 < V@30@01) | dead]
(push) ; 6
; [then-branch: 112 | 0 < V@30@01]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@108@01 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 113 | 0 <= i1@108@01 | live]
; [else-branch: 113 | !(0 <= i1@108@01) | live]
(push) ; 9
; [then-branch: 113 | 0 <= i1@108@01]
(assert (<= 0 i1@108@01))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 113 | !(0 <= i1@108@01)]
(assert (not (<= 0 i1@108@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(push) ; 8
; [then-branch: 114 | i1@108@01 < V@30@01 && 0 <= i1@108@01 | live]
; [else-branch: 114 | !(i1@108@01 < V@30@01 && 0 <= i1@108@01) | live]
(push) ; 9
; [then-branch: 114 | i1@108@01 < V@30@01 && 0 <= i1@108@01]
(assert (and (< i1@108@01 V@30@01) (<= 0 i1@108@01)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< i1@108@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4641
;  :arith-add-rows          1826
;  :arith-assert-diseq      180
;  :arith-assert-lower      1039
;  :arith-assert-upper      577
;  :arith-bound-prop        330
;  :arith-conflicts         123
;  :arith-eq-adapter        599
;  :arith-fixed-eqs         259
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        345
;  :arith-pivots            784
;  :conflicts               444
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 322
;  :datatype-occurs-check   149
;  :datatype-splits         73
;  :decisions               713
;  :del-clause              4593
;  :final-checks            100
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.47
;  :memory                  5.44
;  :minimized-lits          18
;  :mk-bool-var             7644
;  :mk-clause               4595
;  :num-allocs              227774
;  :num-checks              173
;  :propagations            1987
;  :quant-instantiations    1923
;  :rlimit-count            369639)
(assert (< i1@108@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 10
; Joined path conditions
(assert (< i1@108@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4746
;  :arith-add-rows          1884
;  :arith-assert-diseq      184
;  :arith-assert-lower      1073
;  :arith-assert-upper      597
;  :arith-bound-prop        341
;  :arith-conflicts         126
;  :arith-eq-adapter        620
;  :arith-fixed-eqs         269
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        355
;  :arith-pivots            802
;  :conflicts               454
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 326
;  :datatype-occurs-check   149
;  :datatype-splits         73
;  :decisions               726
;  :del-clause              4662
;  :final-checks            100
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.52
;  :minimized-lits          18
;  :mk-bool-var             7840
;  :mk-clause               4727
;  :num-allocs              228759
;  :num-checks              174
;  :propagations            2053
;  :quant-instantiations    1967
;  :rlimit-count            373137)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4746
;  :arith-add-rows          1884
;  :arith-assert-diseq      184
;  :arith-assert-lower      1073
;  :arith-assert-upper      597
;  :arith-bound-prop        341
;  :arith-conflicts         126
;  :arith-eq-adapter        620
;  :arith-fixed-eqs         269
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        355
;  :arith-pivots            802
;  :conflicts               455
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 326
;  :datatype-occurs-check   149
;  :datatype-splits         73
;  :decisions               726
;  :del-clause              4662
;  :final-checks            100
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.52
;  :minimized-lits          18
;  :mk-bool-var             7840
;  :mk-clause               4727
;  :num-allocs              228849
;  :num-checks              175
;  :propagations            2053
;  :quant-instantiations    1967
;  :rlimit-count            373232)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
    (as None<option<array>>  option<array>))))
(pop) ; 9
(push) ; 9
; [else-branch: 114 | !(i1@108@01 < V@30@01 && 0 <= i1@108@01)]
(assert (not (and (< i1@108@01 V@30@01) (<= 0 i1@108@01))))
(pop) ; 9
(pop) ; 8
; Joined path conditions
(assert (implies
  (and (< i1@108@01 V@30@01) (<= 0 i1@108@01))
  (and
    (< i1@108@01 V@30@01)
    (<= 0 i1@108@01)
    (< i1@108@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@108@01 Int)) (!
  (implies
    (and (< i1@108@01 V@30@01) (<= 0 i1@108@01))
    (and
      (< i1@108@01 V@30@01)
      (<= 0 i1@108@01)
      (< i1@108@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@108@01 Int)) (!
    (implies
      (and (< i1@108@01 V@30@01) (<= 0 i1@108@01))
      (and
        (< i1@108@01 V@30@01)
        (<= 0 i1@108@01)
        (< i1@108@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 5
(assert (not (implies
  (< 0 V@30@01)
  (forall ((i1@108@01 Int)) (!
    (implies
      (and (< i1@108@01 V@30@01) (<= 0 i1@108@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4746
;  :arith-add-rows          1890
;  :arith-assert-diseq      184
;  :arith-assert-lower      1075
;  :arith-assert-upper      597
;  :arith-bound-prop        341
;  :arith-conflicts         126
;  :arith-eq-adapter        621
;  :arith-fixed-eqs         269
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        355
;  :arith-pivots            808
;  :conflicts               456
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 326
;  :datatype-occurs-check   149
;  :datatype-splits         73
;  :decisions               726
;  :del-clause              4742
;  :final-checks            100
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.51
;  :minimized-lits          18
;  :mk-bool-var             7871
;  :mk-clause               4744
;  :num-allocs              229421
;  :num-checks              176
;  :propagations            2053
;  :quant-instantiations    1983
;  :rlimit-count            374541)
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@108@01 Int)) (!
    (implies
      (and (< i1@108@01 V@30@01) (<= 0 i1@108@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@108@01)))))
    :qid |prog.l<no position>|))))
; [eval] 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] 0 < V
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (< 0 V@30@01))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4757
;  :arith-add-rows          1890
;  :arith-assert-diseq      184
;  :arith-assert-lower      1075
;  :arith-assert-upper      597
;  :arith-bound-prop        341
;  :arith-conflicts         126
;  :arith-eq-adapter        621
;  :arith-fixed-eqs         269
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        355
;  :arith-pivots            808
;  :conflicts               456
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 330
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               730
;  :del-clause              4742
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.51
;  :minimized-lits          18
;  :mk-bool-var             7872
;  :mk-clause               4744
;  :num-allocs              230146
;  :num-checks              177
;  :propagations            2053
;  :quant-instantiations    1983
;  :rlimit-count            375349)
; [then-branch: 115 | 0 < V@30@01 | live]
; [else-branch: 115 | !(0 < V@30@01) | dead]
(push) ; 6
; [then-branch: 115 | 0 < V@30@01]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@109@01 Int)
(push) ; 7
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@110@01 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 116 | 0 <= i1@109@01 | live]
; [else-branch: 116 | !(0 <= i1@109@01) | live]
(push) ; 10
; [then-branch: 116 | 0 <= i1@109@01]
(assert (<= 0 i1@109@01))
; [eval] i1 < V
(push) ; 11
; [then-branch: 117 | i1@109@01 < V@30@01 | live]
; [else-branch: 117 | !(i1@109@01 < V@30@01) | live]
(push) ; 12
; [then-branch: 117 | i1@109@01 < V@30@01]
(assert (< i1@109@01 V@30@01))
; [eval] 0 <= i2
(push) ; 13
; [then-branch: 118 | 0 <= i2@110@01 | live]
; [else-branch: 118 | !(0 <= i2@110@01) | live]
(push) ; 14
; [then-branch: 118 | 0 <= i2@110@01]
(assert (<= 0 i2@110@01))
; [eval] i2 < V
(push) ; 15
; [then-branch: 119 | i2@110@01 < V@30@01 | live]
; [else-branch: 119 | !(i2@110@01 < V@30@01) | live]
(push) ; 16
; [then-branch: 119 | i2@110@01 < V@30@01]
(assert (< i2@110@01 V@30@01))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@109@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4757
;  :arith-add-rows          1890
;  :arith-assert-diseq      184
;  :arith-assert-lower      1079
;  :arith-assert-upper      597
;  :arith-bound-prop        341
;  :arith-conflicts         126
;  :arith-eq-adapter        621
;  :arith-fixed-eqs         269
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        355
;  :arith-pivots            808
;  :conflicts               456
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 330
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               730
;  :del-clause              4742
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.52
;  :minimized-lits          18
;  :mk-bool-var             7876
;  :mk-clause               4744
;  :num-allocs              230427
;  :num-checks              178
;  :propagations            2053
;  :quant-instantiations    1983
;  :rlimit-count            375688)
(assert (< i1@109@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 17
; Joined path conditions
(assert (< i1@109@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4857
;  :arith-add-rows          1935
;  :arith-assert-diseq      188
;  :arith-assert-lower      1108
;  :arith-assert-upper      615
;  :arith-bound-prop        347
;  :arith-conflicts         130
;  :arith-eq-adapter        642
;  :arith-fixed-eqs         276
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        365
;  :arith-pivots            829
;  :conflicts               472
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 334
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               748
;  :del-clause              4795
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.52
;  :minimized-lits          18
;  :mk-bool-var             8073
;  :mk-clause               4860
;  :num-allocs              231410
;  :num-checks              179
;  :propagations            2098
;  :quant-instantiations    2021
;  :rlimit-count            379018
;  :time                    0.00)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 18
(assert (not (< i2@110@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               4857
;  :arith-add-rows          1935
;  :arith-assert-diseq      188
;  :arith-assert-lower      1108
;  :arith-assert-upper      615
;  :arith-bound-prop        347
;  :arith-conflicts         130
;  :arith-eq-adapter        642
;  :arith-fixed-eqs         276
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        365
;  :arith-pivots            829
;  :conflicts               472
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 334
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               748
;  :del-clause              4795
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.52
;  :minimized-lits          18
;  :mk-bool-var             8073
;  :mk-clause               4860
;  :num-allocs              231437
;  :num-checks              180
;  :propagations            2098
;  :quant-instantiations    2021
;  :rlimit-count            379048)
(assert (< i2@110@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 17
; Joined path conditions
(assert (< i2@110@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5043
;  :arith-add-rows          2118
;  :arith-assert-diseq      199
;  :arith-assert-lower      1168
;  :arith-assert-upper      649
;  :arith-bound-prop        364
;  :arith-conflicts         135
;  :arith-eq-adapter        680
;  :arith-fixed-eqs         295
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        380
;  :arith-pivots            855
;  :conflicts               495
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 338
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               784
;  :del-clause              4962
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.54
;  :minimized-lits          18
;  :mk-bool-var             8494
;  :mk-clause               5086
;  :num-allocs              233274
;  :num-checks              181
;  :propagations            2200
;  :quant-instantiations    2085
;  :rlimit-count            385218
;  :time                    0.00)
(pop) ; 16
(push) ; 16
; [else-branch: 119 | !(i2@110@01 < V@30@01)]
(assert (not (< i2@110@01 V@30@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (< i2@110@01 V@30@01)
  (and
    (< i2@110@01 V@30@01)
    (< i1@109@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
    (< i2@110@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 118 | !(0 <= i2@110@01)]
(assert (not (<= 0 i2@110@01)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (<= 0 i2@110@01)
  (and
    (<= 0 i2@110@01)
    (implies
      (< i2@110@01 V@30@01)
      (and
        (< i2@110@01 V@30@01)
        (< i1@109@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
        (< i2@110@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 117 | !(i1@109@01 < V@30@01)]
(assert (not (< i1@109@01 V@30@01)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (< i1@109@01 V@30@01)
  (and
    (< i1@109@01 V@30@01)
    (implies
      (<= 0 i2@110@01)
      (and
        (<= 0 i2@110@01)
        (implies
          (< i2@110@01 V@30@01)
          (and
            (< i2@110@01 V@30@01)
            (< i1@109@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
            (< i2@110@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))))))))
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 116 | !(0 <= i1@109@01)]
(assert (not (<= 0 i1@109@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (<= 0 i1@109@01)
  (and
    (<= 0 i1@109@01)
    (implies
      (< i1@109@01 V@30@01)
      (and
        (< i1@109@01 V@30@01)
        (implies
          (<= 0 i2@110@01)
          (and
            (<= 0 i2@110@01)
            (implies
              (< i2@110@01 V@30@01)
              (and
                (< i2@110@01 V@30@01)
                (< i1@109@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                (< i2@110@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))))))))))
; Joined path conditions
(push) ; 9
; [then-branch: 120 | Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i1@109@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i2@110@01)) && i2@110@01 < V@30@01 && 0 <= i2@110@01 && i1@109@01 < V@30@01 && 0 <= i1@109@01 | live]
; [else-branch: 120 | !(Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i1@109@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i2@110@01)) && i2@110@01 < V@30@01 && 0 <= i2@110@01 && i1@109@01 < V@30@01 && 0 <= i1@109@01) | live]
(push) ; 10
; [then-branch: 120 | Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i1@109@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i2@110@01)) && i2@110@01 < V@30@01 && 0 <= i2@110@01 && i1@109@01 < V@30@01 && 0 <= i1@109@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
        (< i2@110@01 V@30@01))
      (<= 0 i2@110@01))
    (< i1@109@01 V@30@01))
  (<= 0 i1@109@01)))
; [eval] i1 == i2
(pop) ; 10
(push) ; 10
; [else-branch: 120 | !(Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i1@109@01)) == Lookup(option$array$,sm@45@01,aloc((_, _), opt_get1(_, target@29@01), i2@110@01)) && i2@110@01 < V@30@01 && 0 <= i2@110@01 && i1@109@01 < V@30@01 && 0 <= i1@109@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
          (< i2@110@01 V@30@01))
        (<= 0 i2@110@01))
      (< i1@109@01 V@30@01))
    (<= 0 i1@109@01))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
          (< i2@110@01 V@30@01))
        (<= 0 i2@110@01))
      (< i1@109@01 V@30@01))
    (<= 0 i1@109@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
      ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
    (< i2@110@01 V@30@01)
    (<= 0 i2@110@01)
    (< i1@109@01 V@30@01)
    (<= 0 i1@109@01))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@110@01 Int)) (!
  (and
    (implies
      (<= 0 i1@109@01)
      (and
        (<= 0 i1@109@01)
        (implies
          (< i1@109@01 V@30@01)
          (and
            (< i1@109@01 V@30@01)
            (implies
              (<= 0 i2@110@01)
              (and
                (<= 0 i2@110@01)
                (implies
                  (< i2@110@01 V@30@01)
                  (and
                    (< i2@110@01 V@30@01)
                    (< i1@109@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                    (< i2@110@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
              (< i2@110@01 V@30@01))
            (<= 0 i2@110@01))
          (< i1@109@01 V@30@01))
        (<= 0 i1@109@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
          ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
        (< i2@110@01 V@30@01)
        (<= 0 i2@110@01)
        (< i1@109@01 V@30@01)
        (<= 0 i1@109@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@109@01 Int)) (!
  (forall ((i2@110@01 Int)) (!
    (and
      (implies
        (<= 0 i1@109@01)
        (and
          (<= 0 i1@109@01)
          (implies
            (< i1@109@01 V@30@01)
            (and
              (< i1@109@01 V@30@01)
              (implies
                (<= 0 i2@110@01)
                (and
                  (<= 0 i2@110@01)
                  (implies
                    (< i2@110@01 V@30@01)
                    (and
                      (< i2@110@01 V@30@01)
                      (<
                        i1@109@01
                        (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                      (<
                        i2@110@01
                        (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
                (< i2@110@01 V@30@01))
              (<= 0 i2@110@01))
            (< i1@109@01 V@30@01))
          (<= 0 i1@109@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
            ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
          (< i2@110@01 V@30@01)
          (<= 0 i2@110@01)
          (< i1@109@01 V@30@01)
          (<= 0 i1@109@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@109@01 Int)) (!
    (forall ((i2@110@01 Int)) (!
      (and
        (implies
          (<= 0 i1@109@01)
          (and
            (<= 0 i1@109@01)
            (implies
              (< i1@109@01 V@30@01)
              (and
                (< i1@109@01 V@30@01)
                (implies
                  (<= 0 i2@110@01)
                  (and
                    (<= 0 i2@110@01)
                    (implies
                      (< i2@110@01 V@30@01)
                      (and
                        (< i2@110@01 V@30@01)
                        (<
                          i1@109@01
                          (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                        (<
                          i2@110@01
                          (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
                  (< i2@110@01 V@30@01))
                (<= 0 i2@110@01))
              (< i1@109@01 V@30@01))
            (<= 0 i1@109@01))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
              ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
            (< i2@110@01 V@30@01)
            (<= 0 i2@110@01)
            (< i1@109@01 V@30@01)
            (<= 0 i1@109@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
    :qid |prog.l<no position>-aux|))))
(push) ; 5
(assert (not (implies
  (< 0 V@30@01)
  (forall ((i1@109@01 Int)) (!
    (forall ((i2@110@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
                (< i2@110@01 V@30@01))
              (<= 0 i2@110@01))
            (< i1@109@01 V@30@01))
          (<= 0 i1@109@01))
        (= i1@109@01 i2@110@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5062
;  :arith-add-rows          2163
;  :arith-assert-diseq      200
;  :arith-assert-lower      1175
;  :arith-assert-upper      651
;  :arith-bound-prop        368
;  :arith-conflicts         135
;  :arith-eq-adapter        685
;  :arith-fixed-eqs         297
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        386
;  :arith-pivots            877
;  :conflicts               496
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 338
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               784
;  :del-clause              5244
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.54
;  :minimized-lits          18
;  :mk-bool-var             8690
;  :mk-clause               5246
;  :num-allocs              235058
;  :num-checks              182
;  :propagations            2217
;  :quant-instantiations    2146
;  :rlimit-count            391534
;  :time                    0.00)
(assert (implies
  (< 0 V@30@01)
  (forall ((i1@109@01 Int)) (!
    (forall ((i2@110@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
                  ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01)))
                (< i2@110@01 V@30@01))
              (<= 0 i2@110@01))
            (< i1@109@01 V@30@01))
          (<= 0 i1@109@01))
        (= i1@109@01 i2@110@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@110@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@109@01))
    :qid |prog.l<no position>|))))
(declare-const unknown@111@01 Int)
(declare-const unknown1@112@01 Int)
(push) ; 5
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 6
; [then-branch: 121 | 0 <= unknown@111@01 | live]
; [else-branch: 121 | !(0 <= unknown@111@01) | live]
(push) ; 7
; [then-branch: 121 | 0 <= unknown@111@01]
(assert (<= 0 unknown@111@01))
; [eval] unknown < V
(push) ; 8
; [then-branch: 122 | unknown@111@01 < V@30@01 | live]
; [else-branch: 122 | !(unknown@111@01 < V@30@01) | live]
(push) ; 9
; [then-branch: 122 | unknown@111@01 < V@30@01]
(assert (< unknown@111@01 V@30@01))
; [eval] 0 <= unknown1
(push) ; 10
; [then-branch: 123 | 0 <= unknown1@112@01 | live]
; [else-branch: 123 | !(0 <= unknown1@112@01) | live]
(push) ; 11
; [then-branch: 123 | 0 <= unknown1@112@01]
(assert (<= 0 unknown1@112@01))
; [eval] unknown1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 123 | !(0 <= unknown1@112@01)]
(assert (not (<= 0 unknown1@112@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 122 | !(unknown@111@01 < V@30@01)]
(assert (not (< unknown@111@01 V@30@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 121 | !(0 <= unknown@111@01)]
(assert (not (<= 0 unknown@111@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@112@01 V@30@01) (<= 0 unknown1@112@01))
    (< unknown@111@01 V@30@01))
  (<= 0 unknown@111@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(target), unknown1).option$array$)
; [eval] aloc(opt_get1(target), unknown1)
; [eval] opt_get1(target)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (< unknown1@112@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5062
;  :arith-add-rows          2163
;  :arith-assert-diseq      200
;  :arith-assert-lower      1181
;  :arith-assert-upper      651
;  :arith-bound-prop        368
;  :arith-conflicts         135
;  :arith-eq-adapter        685
;  :arith-fixed-eqs         297
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        386
;  :arith-pivots            878
;  :conflicts               496
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 338
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               784
;  :del-clause              5244
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.56
;  :memory                  5.55
;  :minimized-lits          18
;  :mk-bool-var             8697
;  :mk-clause               5246
;  :num-allocs              235661
;  :num-checks              183
;  :propagations            2217
;  :quant-instantiations    2146
;  :rlimit-count            392540)
(assert (< unknown1@112@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 6
; Joined path conditions
(assert (< unknown1@112@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5167
;  :arith-add-rows          2241
;  :arith-assert-diseq      204
;  :arith-assert-lower      1217
;  :arith-assert-upper      669
;  :arith-bound-prop        379
;  :arith-conflicts         138
;  :arith-eq-adapter        706
;  :arith-fixed-eqs         307
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        398
;  :arith-pivots            897
;  :conflicts               506
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 342
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               797
;  :del-clause              5313
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.58
;  :memory                  5.56
;  :minimized-lits          18
;  :mk-bool-var             8893
;  :mk-clause               5378
;  :num-allocs              236737
;  :num-checks              184
;  :propagations            2283
;  :quant-instantiations    2193
;  :rlimit-count            396571)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5167
;  :arith-add-rows          2241
;  :arith-assert-diseq      204
;  :arith-assert-lower      1217
;  :arith-assert-upper      669
;  :arith-bound-prop        379
;  :arith-conflicts         138
;  :arith-eq-adapter        706
;  :arith-fixed-eqs         307
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        398
;  :arith-pivots            897
;  :conflicts               507
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 342
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               797
;  :del-clause              5313
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.58
;  :memory                  5.56
;  :minimized-lits          18
;  :mk-bool-var             8893
;  :mk-clause               5378
;  :num-allocs              236828
;  :num-checks              185
;  :propagations            2283
;  :quant-instantiations    2193
;  :rlimit-count            396666)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  unknown@111@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5171
;  :arith-add-rows          2243
;  :arith-assert-diseq      204
;  :arith-assert-lower      1219
;  :arith-assert-upper      669
;  :arith-bound-prop        381
;  :arith-conflicts         138
;  :arith-eq-adapter        707
;  :arith-fixed-eqs         307
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        398
;  :arith-pivots            899
;  :conflicts               508
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 342
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               797
;  :del-clause              5319
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.58
;  :memory                  5.56
;  :minimized-lits          18
;  :mk-bool-var             8904
;  :mk-clause               5384
;  :num-allocs              237031
;  :num-checks              186
;  :propagations            2283
;  :quant-instantiations    2202
;  :rlimit-count            397135)
(assert (<
  unknown@111@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))))))
(pop) ; 6
; Joined path conditions
(assert (<
  unknown@111@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))))))
(pop) ; 5
(declare-fun inv@113@01 ($Ref) Int)
(declare-fun inv@114@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@111@01 Int) (unknown1@112@01 Int)) (!
  (and
    (< unknown1@112@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown@111@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))) unknown@111@01))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((unknown1@111@01 Int) (unknown11@112@01 Int) (unknown2@111@01 Int) (unknown12@112@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< unknown11@112@01 V@30@01) (<= 0 unknown11@112@01))
            (< unknown1@111@01 V@30@01))
          (<= 0 unknown1@111@01))
        ($FVF.loc_int ($FVF.lookup_int (as sm@59@01  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown11@112@01))) unknown1@111@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown11@112@01))) unknown1@111@01)))
      (and
        (and
          (and
            (and (< unknown12@112@01 V@30@01) (<= 0 unknown12@112@01))
            (< unknown2@111@01 V@30@01))
          (<= 0 unknown2@111@01))
        ($FVF.loc_int ($FVF.lookup_int (as sm@59@01  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown12@112@01))) unknown2@111@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown12@112@01))) unknown2@111@01)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown11@112@01))) unknown1@111@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown12@112@01))) unknown2@111@01)))
    (and
      (= unknown1@111@01 unknown2@111@01)
      (= unknown11@112@01 unknown12@112@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5214
;  :arith-add-rows          2264
;  :arith-assert-diseq      204
;  :arith-assert-lower      1230
;  :arith-assert-upper      669
;  :arith-bound-prop        382
;  :arith-conflicts         138
;  :arith-eq-adapter        719
;  :arith-fixed-eqs         307
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        399
;  :arith-pivots            916
;  :conflicts               509
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 342
;  :datatype-occurs-check   150
;  :datatype-splits         73
;  :decisions               797
;  :del-clause              5497
;  :final-checks            101
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.72
;  :minimized-lits          18
;  :mk-bool-var             9081
;  :mk-clause               5499
;  :num-allocs              238443
;  :num-checks              187
;  :propagations            2306
;  :quant-instantiations    2268
;  :rlimit-count            401389
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((unknown@111@01 Int) (unknown1@112@01 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@112@01 V@30@01) (<= 0 unknown1@112@01))
        (< unknown@111@01 V@30@01))
      (<= 0 unknown@111@01))
    (and
      (=
        (inv@113@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))) unknown@111@01))
        unknown@111@01)
      (=
        (inv@114@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))) unknown@111@01))
        unknown1@112@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@112@01))) unknown@111@01))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@114@01 r) V@30@01) (<= 0 (inv@114@01 r)))
        (< (inv@113@01 r) V@30@01))
      (<= 0 (inv@113@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@114@01 r)))) (inv@113@01 r))
      r))
  :pattern ((inv@113@01 r))
  :pattern ((inv@114@01 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@114@01 r) V@30@01) (<= 0 (inv@114@01 r)))
        (< (inv@113@01 r) V@30@01))
      (<= 0 (inv@113@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@59@01  $FVF<Int>) r) r))
  :pattern ((inv@113@01 r) (inv@114@01 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@115@01 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@114@01 r) V@30@01) (<= 0 (inv@114@01 r)))
        (< (inv@113@01 r) V@30@01))
      (<= 0 (inv@113@01 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@58@01 r) V@30@01) (<= 0 (inv@58@01 r)))
            (< (inv@57@01 r) V@30@01))
          (<= 0 (inv@57@01 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@116@01 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@114@01 r) V@30@01) (<= 0 (inv@114@01 r)))
        (< (inv@113@01 r) V@30@01))
      (<= 0 (inv@113@01 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@53@01 r) V@30@01) (<= 0 (inv@53@01 r)))
            (< (inv@52@01 r) V@30@01))
          (<= 0 (inv@52@01 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@115@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@58@01 r) V@30@01) (<= 0 (inv@58@01 r)))
            (< (inv@57@01 r) V@30@01))
          (<= 0 (inv@57@01 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@115@01 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5401
;  :arith-add-rows          2319
;  :arith-assert-diseq      212
;  :arith-assert-lower      1278
;  :arith-assert-upper      690
;  :arith-bound-prop        392
;  :arith-conflicts         142
;  :arith-eq-adapter        758
;  :arith-fixed-eqs         320
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        399
;  :arith-pivots            951
;  :conflicts               520
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 350
;  :datatype-occurs-check   151
;  :datatype-splits         73
;  :decisions               811
;  :del-clause              5763
;  :final-checks            102
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.73
;  :minimized-lits          18
;  :mk-bool-var             9522
;  :mk-clause               5763
;  :num-allocs              241843
;  :num-checks              189
;  :propagations            2403
;  :quant-instantiations    2395
;  :rlimit-count            410217
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@114@01 r) V@30@01) (<= 0 (inv@114@01 r)))
        (< (inv@113@01 r) V@30@01))
      (<= 0 (inv@113@01 r)))
    (= (- $Perm.Write (pTaken@115@01 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5478
;  :arith-add-rows          2341
;  :arith-assert-diseq      214
;  :arith-assert-lower      1290
;  :arith-assert-upper      700
;  :arith-bound-prop        395
;  :arith-conflicts         144
;  :arith-eq-adapter        765
;  :arith-fixed-eqs         324
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        399
;  :arith-pivots            964
;  :conflicts               526
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 354
;  :datatype-occurs-check   151
;  :datatype-splits         73
;  :decisions               816
;  :del-clause              5874
;  :final-checks            102
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.73
;  :minimized-lits          18
;  :mk-bool-var             9686
;  :mk-clause               5874
;  :num-allocs              242840
;  :num-checks              190
;  :propagations            2430
;  :quant-instantiations    2452
;  :rlimit-count            414231
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const unknown@117@01 Int)
(declare-const unknown1@118@01 Int)
(push) ; 5
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 6
; [then-branch: 124 | 0 <= unknown@117@01 | live]
; [else-branch: 124 | !(0 <= unknown@117@01) | live]
(push) ; 7
; [then-branch: 124 | 0 <= unknown@117@01]
(assert (<= 0 unknown@117@01))
; [eval] unknown < V
(push) ; 8
; [then-branch: 125 | unknown@117@01 < V@30@01 | live]
; [else-branch: 125 | !(unknown@117@01 < V@30@01) | live]
(push) ; 9
; [then-branch: 125 | unknown@117@01 < V@30@01]
(assert (< unknown@117@01 V@30@01))
; [eval] 0 <= unknown1
(push) ; 10
; [then-branch: 126 | 0 <= unknown1@118@01 | live]
; [else-branch: 126 | !(0 <= unknown1@118@01) | live]
(push) ; 11
; [then-branch: 126 | 0 <= unknown1@118@01]
(assert (<= 0 unknown1@118@01))
; [eval] unknown1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 126 | !(0 <= unknown1@118@01)]
(assert (not (<= 0 unknown1@118@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(pop) ; 9
(push) ; 9
; [else-branch: 125 | !(unknown@117@01 < V@30@01)]
(assert (not (< unknown@117@01 V@30@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(pop) ; 7
(push) ; 7
; [else-branch: 124 | !(0 <= unknown@117@01)]
(assert (not (<= 0 unknown@117@01)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@118@01 V@30@01) (<= 0 unknown1@118@01))
    (< unknown@117@01 V@30@01))
  (<= 0 unknown@117@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(source), unknown1).option$array$)
; [eval] aloc(opt_get1(source), unknown1)
; [eval] opt_get1(source)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
; Joined path conditions
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 7
(assert (not (< unknown1@118@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5478
;  :arith-add-rows          2341
;  :arith-assert-diseq      214
;  :arith-assert-lower      1296
;  :arith-assert-upper      700
;  :arith-bound-prop        395
;  :arith-conflicts         144
;  :arith-eq-adapter        765
;  :arith-fixed-eqs         324
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        399
;  :arith-pivots            966
;  :conflicts               526
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 354
;  :datatype-occurs-check   151
;  :datatype-splits         73
;  :decisions               816
;  :del-clause              5874
;  :final-checks            102
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.73
;  :minimized-lits          18
;  :mk-bool-var             9692
;  :mk-clause               5874
;  :num-allocs              243121
;  :num-checks              191
;  :propagations            2430
;  :quant-instantiations    2452
;  :rlimit-count            414706)
(assert (< unknown1@118@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 6
; Joined path conditions
(assert (< unknown1@118@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01)))
(push) ; 6
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (<
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))
          V@30@01)
        (<=
          0
          (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))))
      $k@43@01
      $Perm.No)
    (ite
      (and
        (<
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))
          V@30@01)
        (<=
          0
          (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))))
      $k@35@01
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5573
;  :arith-add-rows          2420
;  :arith-assert-diseq      220
;  :arith-assert-lower      1324
;  :arith-assert-upper      717
;  :arith-bound-prop        405
;  :arith-conflicts         148
;  :arith-eq-adapter        794
;  :arith-fixed-eqs         332
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        410
;  :arith-pivots            982
;  :conflicts               538
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 358
;  :datatype-occurs-check   151
;  :datatype-splits         73
;  :decisions               828
;  :del-clause              5959
;  :final-checks            102
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.76
;  :minimized-lits          18
;  :mk-bool-var             9905
;  :mk-clause               6025
;  :num-allocs              244234
;  :num-checks              192
;  :propagations            2485
;  :quant-instantiations    2490
;  :rlimit-count            418351)
(push) ; 6
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 7
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5573
;  :arith-add-rows          2420
;  :arith-assert-diseq      220
;  :arith-assert-lower      1324
;  :arith-assert-upper      717
;  :arith-bound-prop        405
;  :arith-conflicts         148
;  :arith-eq-adapter        794
;  :arith-fixed-eqs         332
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        410
;  :arith-pivots            982
;  :conflicts               539
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 358
;  :datatype-occurs-check   151
;  :datatype-splits         73
;  :decisions               828
;  :del-clause              5959
;  :final-checks            102
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.76
;  :minimized-lits          18
;  :mk-bool-var             9905
;  :mk-clause               6025
;  :num-allocs              244325
;  :num-checks              193
;  :propagations            2485
;  :quant-instantiations    2490
;  :rlimit-count            418446)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))
    (as None<option<array>>  option<array>))))
(pop) ; 6
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))
    (as None<option<array>>  option<array>))))
(push) ; 6
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 7
(assert (not (<
  unknown@117@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01)))))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5577
;  :arith-add-rows          2422
;  :arith-assert-diseq      220
;  :arith-assert-lower      1326
;  :arith-assert-upper      717
;  :arith-bound-prop        407
;  :arith-conflicts         148
;  :arith-eq-adapter        795
;  :arith-fixed-eqs         332
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        410
;  :arith-pivots            984
;  :conflicts               540
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 358
;  :datatype-occurs-check   151
;  :datatype-splits         73
;  :decisions               828
;  :del-clause              5965
;  :final-checks            102
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.75
;  :minimized-lits          18
;  :mk-bool-var             9916
;  :mk-clause               6031
;  :num-allocs              244517
;  :num-checks              194
;  :propagations            2485
;  :quant-instantiations    2497
;  :rlimit-count            418861)
(assert (<
  unknown@117@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))))))
(pop) ; 6
; Joined path conditions
(assert (<
  unknown@117@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))))))
(pop) ; 5
(declare-fun inv@119@01 ($Ref) Int)
(declare-fun inv@120@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@117@01 Int) (unknown1@118@01 Int)) (!
  (and
    (< unknown1@118@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown@117@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))) unknown@117@01))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 5
(assert (not (forall ((unknown1@117@01 Int) (unknown11@118@01 Int) (unknown2@117@01 Int) (unknown12@118@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< unknown11@118@01 V@30@01) (<= 0 unknown11@118@01))
            (< unknown1@117@01 V@30@01))
          (<= 0 unknown1@117@01))
        ($FVF.loc_int ($FVF.lookup_int (as sm@54@01  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown11@118@01))) unknown1@117@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown11@118@01))) unknown1@117@01)))
      (and
        (and
          (and
            (and (< unknown12@118@01 V@30@01) (<= 0 unknown12@118@01))
            (< unknown2@117@01 V@30@01))
          (<= 0 unknown2@117@01))
        ($FVF.loc_int ($FVF.lookup_int (as sm@54@01  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown12@118@01))) unknown2@117@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown12@118@01))) unknown2@117@01)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown11@118@01))) unknown1@117@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown12@118@01))) unknown2@117@01)))
    (and
      (= unknown1@117@01 unknown2@117@01)
      (= unknown11@118@01 unknown12@118@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5619
;  :arith-add-rows          2439
;  :arith-assert-diseq      220
;  :arith-assert-lower      1335
;  :arith-assert-upper      719
;  :arith-bound-prop        408
;  :arith-conflicts         148
;  :arith-eq-adapter        807
;  :arith-fixed-eqs         332
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        411
;  :arith-pivots            1001
;  :conflicts               541
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 358
;  :datatype-occurs-check   151
;  :datatype-splits         73
;  :decisions               828
;  :del-clause              6144
;  :final-checks            102
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.75
;  :minimized-lits          18
;  :mk-bool-var             10087
;  :mk-clause               6144
;  :num-allocs              245851
;  :num-checks              195
;  :propagations            2506
;  :quant-instantiations    2561
;  :rlimit-count            422966
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((unknown@117@01 Int) (unknown1@118@01 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@118@01 V@30@01) (<= 0 unknown1@118@01))
        (< unknown@117@01 V@30@01))
      (<= 0 unknown@117@01))
    (and
      (=
        (inv@119@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))) unknown@117@01))
        unknown@117@01)
      (=
        (inv@120@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))) unknown@117@01))
        unknown1@118@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@118@01))) unknown@117@01))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@120@01 r) V@30@01) (<= 0 (inv@120@01 r)))
        (< (inv@119@01 r) V@30@01))
      (<= 0 (inv@119@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@45@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@120@01 r)))) (inv@119@01 r))
      r))
  :pattern ((inv@119@01 r))
  :pattern ((inv@120@01 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@120@01 r) V@30@01) (<= 0 (inv@120@01 r)))
        (< (inv@119@01 r) V@30@01))
      (<= 0 (inv@119@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@54@01  $FVF<Int>) r) r))
  :pattern ((inv@119@01 r) (inv@120@01 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@121@01 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@120@01 r) V@30@01) (<= 0 (inv@120@01 r)))
        (< (inv@119@01 r) V@30@01))
      (<= 0 (inv@119@01 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@53@01 r) V@30@01) (<= 0 (inv@53@01 r)))
            (< (inv@52@01 r) V@30@01))
          (<= 0 (inv@52@01 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@53@01 r) V@30@01) (<= 0 (inv@53@01 r)))
            (< (inv@52@01 r) V@30@01))
          (<= 0 (inv@52@01 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@121@01 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5824
;  :arith-add-rows          2511
;  :arith-assert-diseq      228
;  :arith-assert-lower      1388
;  :arith-assert-upper      747
;  :arith-bound-prop        424
;  :arith-conflicts         152
;  :arith-eq-adapter        850
;  :arith-fixed-eqs         351
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        411
;  :arith-pivots            1050
;  :conflicts               552
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 366
;  :datatype-occurs-check   152
;  :datatype-splits         73
;  :decisions               842
;  :del-clause              6414
;  :final-checks            103
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.78
;  :minimized-lits          18
;  :mk-bool-var             10587
;  :mk-clause               6414
;  :num-allocs              249350
;  :num-checks              197
;  :propagations            2599
;  :quant-instantiations    2687
;  :rlimit-count            432274
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 5
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@120@01 r) V@30@01) (<= 0 (inv@120@01 r)))
        (< (inv@119@01 r) V@30@01))
      (<= 0 (inv@119@01 r)))
    (= (- $Perm.Write (pTaken@121@01 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5898
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1400
;  :arith-assert-upper      757
;  :arith-bound-prop        428
;  :arith-conflicts         154
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1064
;  :conflicts               558
;  :datatype-accessor-ax    44
;  :datatype-constructor-ax 370
;  :datatype-occurs-check   152
;  :datatype-splits         73
;  :decisions               847
;  :del-clause              6517
;  :final-checks            103
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.78
;  :minimized-lits          18
;  :mk-bool-var             10748
;  :mk-clause               6517
;  :num-allocs              250325
;  :num-checks              198
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            436151
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
(declare-const exc@122@01 $Ref)
(declare-const res@123@01 void)
(declare-const $t@124@01 $Snap)
(assert (= $t@124@01 ($Snap.combine ($Snap.first $t@124@01) ($Snap.second $t@124@01))))
(assert (= ($Snap.first $t@124@01) $Snap.unit))
; [eval] exc == null
(assert (= exc@122@01 $Ref.null))
(assert (=
  ($Snap.second $t@124@01)
  ($Snap.combine
    ($Snap.first ($Snap.second $t@124@01))
    ($Snap.second ($Snap.second $t@124@01)))))
(assert (= ($Snap.first ($Snap.second $t@124@01)) $Snap.unit))
; [eval] exc == null && 0 < V ==> source != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 127 | exc@122@01 == Null | live]
; [else-branch: 127 | exc@122@01 != Null | live]
(push) ; 6
; [then-branch: 127 | exc@122@01 == Null]
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 127 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(set-option :timeout 10)
(push) ; 6
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5926
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1400
;  :arith-assert-upper      757
;  :arith-bound-prop        428
;  :arith-conflicts         154
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1064
;  :conflicts               558
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 375
;  :datatype-occurs-check   155
;  :datatype-splits         74
;  :decisions               852
;  :del-clause              6517
;  :final-checks            105
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10754
;  :mk-clause               6517
;  :num-allocs              251025
;  :num-checks              199
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            436992)
(push) ; 6
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5926
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1400
;  :arith-assert-upper      757
;  :arith-bound-prop        428
;  :arith-conflicts         154
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1064
;  :conflicts               558
;  :datatype-accessor-ax    46
;  :datatype-constructor-ax 375
;  :datatype-occurs-check   155
;  :datatype-splits         74
;  :decisions               852
;  :del-clause              6517
;  :final-checks            105
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10754
;  :mk-clause               6517
;  :num-allocs              251043
;  :num-checks              200
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            437009)
; [then-branch: 128 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 128 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 6
; [then-branch: 128 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (not (= source@28@01 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second $t@124@01))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second $t@124@01)))
    ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))
(assert (= ($Snap.first ($Snap.second ($Snap.second $t@124@01))) $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(source)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 129 | exc@122@01 == Null | live]
; [else-branch: 129 | exc@122@01 != Null | live]
(push) ; 6
; [then-branch: 129 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 129 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(push) ; 6
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5948
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1400
;  :arith-assert-upper      757
;  :arith-bound-prop        428
;  :arith-conflicts         154
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1064
;  :conflicts               558
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 380
;  :datatype-occurs-check   158
;  :datatype-splits         75
;  :decisions               857
;  :del-clause              6517
;  :final-checks            107
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10757
;  :mk-clause               6517
;  :num-allocs              251671
;  :num-checks              201
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            437748)
(push) ; 6
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5948
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1400
;  :arith-assert-upper      757
;  :arith-bound-prop        428
;  :arith-conflicts         154
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1064
;  :conflicts               558
;  :datatype-accessor-ax    47
;  :datatype-constructor-ax 380
;  :datatype-occurs-check   158
;  :datatype-splits         75
;  :decisions               857
;  :del-clause              6517
;  :final-checks            107
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10757
;  :mk-clause               6517
;  :num-allocs              251689
;  :num-checks              202
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            437765)
; [then-branch: 130 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 130 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 6
; [then-branch: 130 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(pop) ; 6
(pop) ; 5
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (= (alen<Int> (opt_get1 $Snap.unit source@28@01)) V@30@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second $t@124@01)))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 5
; [then-branch: 131 | exc@122@01 == Null | live]
; [else-branch: 131 | exc@122@01 != Null | live]
(push) ; 6
; [then-branch: 131 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 6
(push) ; 6
; [else-branch: 131 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 6
(pop) ; 5
; Joined path conditions
; Joined path conditions
(push) ; 5
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5972
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1400
;  :arith-assert-upper      757
;  :arith-bound-prop        428
;  :arith-conflicts         154
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1064
;  :conflicts               558
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 386
;  :datatype-occurs-check   161
;  :datatype-splits         77
;  :decisions               863
;  :del-clause              6517
;  :final-checks            109
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10760
;  :mk-clause               6517
;  :num-allocs              252319
;  :num-checks              203
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            438496)
(push) ; 5
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 5
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5972
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1400
;  :arith-assert-upper      757
;  :arith-bound-prop        428
;  :arith-conflicts         154
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1064
;  :conflicts               558
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 386
;  :datatype-occurs-check   161
;  :datatype-splits         77
;  :decisions               863
;  :del-clause              6517
;  :final-checks            109
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10760
;  :mk-clause               6517
;  :num-allocs              252337
;  :num-checks              204
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            438513)
; [then-branch: 132 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 132 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 5
; [then-branch: 132 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
(declare-const i1@125@01 Int)
(push) ; 6
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 7
; [then-branch: 133 | 0 <= i1@125@01 | live]
; [else-branch: 133 | !(0 <= i1@125@01) | live]
(push) ; 8
; [then-branch: 133 | 0 <= i1@125@01]
(assert (<= 0 i1@125@01))
; [eval] i1 < V
(pop) ; 8
(push) ; 8
; [else-branch: 133 | !(0 <= i1@125@01)]
(assert (not (<= 0 i1@125@01)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(assert (and (< i1@125@01 V@30@01) (<= 0 i1@125@01)))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 7
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
; Joined path conditions
(push) ; 7
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 8
(assert (not (< i1@125@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5972
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1402
;  :arith-assert-upper      757
;  :arith-bound-prop        428
;  :arith-conflicts         154
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           79
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1065
;  :conflicts               558
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 386
;  :datatype-occurs-check   161
;  :datatype-splits         77
;  :decisions               863
;  :del-clause              6517
;  :final-checks            109
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10762
;  :mk-clause               6517
;  :num-allocs              252442
;  :num-checks              205
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            438711)
(assert (< i1@125@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 7
; Joined path conditions
(assert (< i1@125@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
; [eval] scale(V * V * write) * wildcard
; [eval] scale(V * V * write)
; [eval] V * V * write
; [eval] V * V
(push) ; 7
; [eval] amount >= 0 * write
; [eval] 0 * write
(push) ; 8
(assert (not (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No)))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               5983
;  :arith-add-rows          2537
;  :arith-assert-diseq      230
;  :arith-assert-lower      1404
;  :arith-assert-upper      758
;  :arith-bound-prop        428
;  :arith-conflicts         155
;  :arith-eq-adapter        857
;  :arith-fixed-eqs         355
;  :arith-max-min           82
;  :arith-nonlinear-bounds  9
;  :arith-offset-eqs        417
;  :arith-pivots            1065
;  :conflicts               559
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 390
;  :datatype-occurs-check   161
;  :datatype-splits         77
;  :decisions               867
;  :del-clause              6517
;  :final-checks            110
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.78
;  :minimized-lits          18
;  :mk-bool-var             10763
;  :mk-clause               6517
;  :num-allocs              252606
;  :num-checks              206
;  :propagations            2626
;  :quant-instantiations    2741
;  :rlimit-count            438904)
(assert (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
(pop) ; 7
; Joined path conditions
(assert (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
(declare-const $k@126@01 $Perm)
(assert ($Perm.isReadVar $k@126@01 $Perm.Write))
(pop) ; 6
(declare-fun inv@127@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@126@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@125@01 Int)) (!
  (and
    (< i1@125@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@125@01))
  :qid |option$array$-aux|)))
(push) ; 6
(assert (not (forall ((i1@125@01 Int)) (!
  (implies
    (and (< i1@125@01 V@30@01) (<= 0 i1@125@01))
    (or
      (=
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)
        $Perm.No)
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))))
  
  ))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6005
;  :arith-add-rows          2537
;  :arith-assert-diseq      232
;  :arith-assert-lower      1418
;  :arith-assert-upper      764
;  :arith-bound-prop        428
;  :arith-conflicts         157
;  :arith-eq-adapter        860
;  :arith-fixed-eqs         355
;  :arith-max-min           97
;  :arith-nonlinear-bounds  11
;  :arith-offset-eqs        418
;  :arith-pivots            1068
;  :conflicts               565
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 396
;  :datatype-occurs-check   163
;  :datatype-splits         79
;  :decisions               874
;  :del-clause              6525
;  :final-checks            113
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.78
;  :minimized-lits          18
;  :mk-bool-var             10781
;  :mk-clause               6527
;  :num-allocs              253285
;  :num-checks              207
;  :propagations            2631
;  :quant-instantiations    2744
;  :rlimit-count            439924)
; Check receiver injectivity
(push) ; 6
(assert (not (forall ((i11@125@01 Int) (i12@125@01 Int)) (!
  (implies
    (and
      (and
        (and (< i11@125@01 V@30@01) (<= 0 i11@125@01))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)))
      (and
        (and (< i12@125@01 V@30@01) (<= 0 i12@125@01))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@125@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@125@01)))
    (= i11@125@01 i12@125@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6015
;  :arith-add-rows          2539
;  :arith-assert-diseq      233
;  :arith-assert-lower      1423
;  :arith-assert-upper      764
;  :arith-bound-prop        428
;  :arith-conflicts         157
;  :arith-eq-adapter        862
;  :arith-fixed-eqs         355
;  :arith-max-min           97
;  :arith-nonlinear-bounds  11
;  :arith-offset-eqs        418
;  :arith-pivots            1068
;  :conflicts               566
;  :datatype-accessor-ax    48
;  :datatype-constructor-ax 396
;  :datatype-occurs-check   163
;  :datatype-splits         79
;  :decisions               874
;  :del-clause              6544
;  :final-checks            113
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.78
;  :minimized-lits          18
;  :mk-bool-var             10811
;  :mk-clause               6546
;  :num-allocs              253717
;  :num-checks              208
;  :propagations            2635
;  :quant-instantiations    2761
;  :rlimit-count            440798)
; Definitional axioms for inverse functions
(assert (forall ((i1@125@01 Int)) (!
  (implies
    (and
      (and (< i1@125@01 V@30@01) (<= 0 i1@125@01))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)))
    (=
      (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@125@01))
      i1@125@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@125@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@127@01 r))
      r))
  :pattern ((inv@127@01 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@125@01 Int)) (!
  (<=
    $Perm.No
    (*
      (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
      $k@126@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@125@01))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@125@01 Int)) (!
  (<=
    (*
      (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
      $k@126@01)
    $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@125@01))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@125@01 Int)) (!
  (implies
    (and
      (and (< i1@125@01 V@30@01) (<= 0 i1@125@01))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@125@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@125@01))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@128@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef31|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef32|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef33|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef34|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) r) r))
  :pattern ((inv@127@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 134 | exc@122@01 == Null | live]
; [else-branch: 134 | exc@122@01 != Null | live]
(push) ; 7
; [then-branch: 134 | exc@122@01 == Null]
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 134 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6045
;  :arith-add-rows          2539
;  :arith-assert-diseq      233
;  :arith-assert-lower      1439
;  :arith-assert-upper      773
;  :arith-bound-prop        428
;  :arith-conflicts         158
;  :arith-eq-adapter        863
;  :arith-fixed-eqs         355
;  :arith-grobner           5
;  :arith-max-min           123
;  :arith-nonlinear-bounds  12
;  :arith-nonlinear-horner  4
;  :arith-offset-eqs        419
;  :arith-pivots            1069
;  :conflicts               567
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 402
;  :datatype-occurs-check   167
;  :datatype-splits         81
;  :decisions               881
;  :del-clause              6544
;  :final-checks            118
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10831
;  :mk-clause               6551
;  :num-allocs              256474
;  :num-checks              209
;  :propagations            2638
;  :quant-instantiations    2764
;  :rlimit-count            448228)
(push) ; 7
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6045
;  :arith-add-rows          2539
;  :arith-assert-diseq      233
;  :arith-assert-lower      1439
;  :arith-assert-upper      773
;  :arith-bound-prop        428
;  :arith-conflicts         158
;  :arith-eq-adapter        863
;  :arith-fixed-eqs         355
;  :arith-grobner           5
;  :arith-max-min           123
;  :arith-nonlinear-bounds  12
;  :arith-nonlinear-horner  4
;  :arith-offset-eqs        419
;  :arith-pivots            1069
;  :conflicts               567
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 402
;  :datatype-occurs-check   167
;  :datatype-splits         81
;  :decisions               881
;  :del-clause              6544
;  :final-checks            118
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10831
;  :mk-clause               6551
;  :num-allocs              256492
;  :num-checks              210
;  :propagations            2638
;  :quant-instantiations    2764
;  :rlimit-count            448245)
; [then-branch: 135 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 135 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 7
; [then-branch: 135 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@129@01 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 136 | 0 <= i1@129@01 | live]
; [else-branch: 136 | !(0 <= i1@129@01) | live]
(push) ; 10
; [then-branch: 136 | 0 <= i1@129@01]
(assert (<= 0 i1@129@01))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 136 | !(0 <= i1@129@01)]
(assert (not (<= 0 i1@129@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 137 | i1@129@01 < V@30@01 && 0 <= i1@129@01 | live]
; [else-branch: 137 | !(i1@129@01 < V@30@01 && 0 <= i1@129@01) | live]
(push) ; 10
; [then-branch: 137 | i1@129@01 < V@30@01 && 0 <= i1@129@01]
(assert (and (< i1@129@01 V@30@01) (<= 0 i1@129@01)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@129@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6045
;  :arith-add-rows          2539
;  :arith-assert-diseq      233
;  :arith-assert-lower      1441
;  :arith-assert-upper      773
;  :arith-bound-prop        428
;  :arith-conflicts         158
;  :arith-eq-adapter        863
;  :arith-fixed-eqs         355
;  :arith-grobner           5
;  :arith-max-min           123
;  :arith-nonlinear-bounds  12
;  :arith-nonlinear-horner  4
;  :arith-offset-eqs        419
;  :arith-pivots            1069
;  :conflicts               567
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 402
;  :datatype-occurs-check   167
;  :datatype-splits         81
;  :decisions               881
;  :del-clause              6544
;  :final-checks            118
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              5.87
;  :memory                  5.79
;  :minimized-lits          18
;  :mk-bool-var             10833
;  :mk-clause               6551
;  :num-allocs              256591
;  :num-checks              211
;  :propagations            2638
;  :quant-instantiations    2764
;  :rlimit-count            448449)
(assert (< i1@129@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 11
; Joined path conditions
(assert (< i1@129@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)))
(push) ; 11
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))
            V@30@01)
          (<=
            0
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6936
;  :arith-add-rows          3971
;  :arith-assert-diseq      325
;  :arith-assert-lower      1739
;  :arith-assert-upper      1010
;  :arith-bound-prop        500
;  :arith-conflicts         186
;  :arith-eq-adapter        1105
;  :arith-fixed-eqs         454
;  :arith-grobner           5
;  :arith-max-min           123
;  :arith-nonlinear-bounds  12
;  :arith-nonlinear-horner  4
;  :arith-offset-eqs        569
;  :arith-pivots            1240
;  :conflicts               614
;  :datatype-accessor-ax    49
;  :datatype-constructor-ax 406
;  :datatype-occurs-check   167
;  :datatype-splits         81
;  :decisions               982
;  :del-clause              7386
;  :final-checks            118
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.21
;  :minimized-lits          20
;  :mk-bool-var             12130
;  :mk-clause               7491
;  :num-allocs              262222
;  :num-checks              212
;  :propagations            3339
;  :quant-instantiations    3002
;  :rlimit-count            500719
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 10
(push) ; 10
; [else-branch: 137 | !(i1@129@01 < V@30@01 && 0 <= i1@129@01)]
(assert (not (and (< i1@129@01 V@30@01) (<= 0 i1@129@01))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@129@01 V@30@01) (<= 0 i1@129@01))
  (and
    (< i1@129@01 V@30@01)
    (<= 0 i1@129@01)
    (< i1@129@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@129@01 Int)) (!
  (implies
    (and (< i1@129@01 V@30@01) (<= 0 i1@129@01))
    (and
      (< i1@129@01 V@30@01)
      (<= 0 i1@129@01)
      (< i1@129@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (and
    (< 0 V@30@01)
    (= exc@122@01 $Ref.null)
    (forall ((i1@129@01 Int)) (!
      (implies
        (and (< i1@129@01 V@30@01) (<= 0 i1@129@01))
        (and
          (< i1@129@01 V@30@01)
          (<= 0 i1@129@01)
          (< i1@129@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (forall ((i1@129@01 Int)) (!
    (implies
      (and (< i1@129@01 V@30@01) (<= 0 i1@129@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@129@01))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 138 | exc@122@01 == Null | live]
; [else-branch: 138 | exc@122@01 != Null | live]
(push) ; 7
; [then-branch: 138 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 138 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6966
;  :arith-add-rows          3975
;  :arith-assert-diseq      325
;  :arith-assert-lower      1754
;  :arith-assert-upper      1018
;  :arith-bound-prop        500
;  :arith-conflicts         187
;  :arith-eq-adapter        1105
;  :arith-fixed-eqs         454
;  :arith-grobner           10
;  :arith-max-min           149
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        570
;  :arith-pivots            1251
;  :conflicts               615
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 412
;  :datatype-occurs-check   171
;  :datatype-splits         83
;  :decisions               989
;  :del-clause              7484
;  :final-checks            123
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.20
;  :minimized-lits          20
;  :mk-bool-var             12136
;  :mk-clause               7491
;  :num-allocs              263501
;  :num-checks              213
;  :propagations            3342
;  :quant-instantiations    3002
;  :rlimit-count            503008)
(push) ; 7
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6966
;  :arith-add-rows          3975
;  :arith-assert-diseq      325
;  :arith-assert-lower      1754
;  :arith-assert-upper      1018
;  :arith-bound-prop        500
;  :arith-conflicts         187
;  :arith-eq-adapter        1105
;  :arith-fixed-eqs         454
;  :arith-grobner           10
;  :arith-max-min           149
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        570
;  :arith-pivots            1251
;  :conflicts               615
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 412
;  :datatype-occurs-check   171
;  :datatype-splits         83
;  :decisions               989
;  :del-clause              7484
;  :final-checks            123
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.20
;  :minimized-lits          20
;  :mk-bool-var             12136
;  :mk-clause               7491
;  :num-allocs              263519
;  :num-checks              214
;  :propagations            3342
;  :quant-instantiations    3002
;  :rlimit-count            503025)
; [then-branch: 139 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 139 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 7
; [then-branch: 139 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@130@01 Int)
(push) ; 8
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 9
; [then-branch: 140 | 0 <= i1@130@01 | live]
; [else-branch: 140 | !(0 <= i1@130@01) | live]
(push) ; 10
; [then-branch: 140 | 0 <= i1@130@01]
(assert (<= 0 i1@130@01))
; [eval] i1 < V
(pop) ; 10
(push) ; 10
; [else-branch: 140 | !(0 <= i1@130@01)]
(assert (not (<= 0 i1@130@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(push) ; 9
; [then-branch: 141 | i1@130@01 < V@30@01 && 0 <= i1@130@01 | live]
; [else-branch: 141 | !(i1@130@01 < V@30@01 && 0 <= i1@130@01) | live]
(push) ; 10
; [then-branch: 141 | i1@130@01 < V@30@01 && 0 <= i1@130@01]
(assert (and (< i1@130@01 V@30@01) (<= 0 i1@130@01)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
; Joined path conditions
(push) ; 11
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 12
(assert (not (< i1@130@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               6966
;  :arith-add-rows          3975
;  :arith-assert-diseq      325
;  :arith-assert-lower      1756
;  :arith-assert-upper      1018
;  :arith-bound-prop        500
;  :arith-conflicts         187
;  :arith-eq-adapter        1105
;  :arith-fixed-eqs         454
;  :arith-grobner           10
;  :arith-max-min           149
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        570
;  :arith-pivots            1252
;  :conflicts               615
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 412
;  :datatype-occurs-check   171
;  :datatype-splits         83
;  :decisions               989
;  :del-clause              7484
;  :final-checks            123
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.20
;  :minimized-lits          20
;  :mk-bool-var             12138
;  :mk-clause               7491
;  :num-allocs              263618
;  :num-checks              215
;  :propagations            3342
;  :quant-instantiations    3002
;  :rlimit-count            503233)
(assert (< i1@130@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 11
; Joined path conditions
(assert (< i1@130@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)))
(push) ; 11
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
            V@30@01)
          (<=
            0
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7446
;  :arith-add-rows          4481
;  :arith-assert-diseq      370
;  :arith-assert-lower      1950
;  :arith-assert-upper      1133
;  :arith-bound-prop        530
;  :arith-conflicts         202
;  :arith-eq-adapter        1250
;  :arith-fixed-eqs         524
;  :arith-grobner           10
;  :arith-max-min           149
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        617
;  :arith-pivots            1337
;  :conflicts               646
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 416
;  :datatype-occurs-check   171
;  :datatype-splits         83
;  :decisions               1057
;  :del-clause              8008
;  :final-checks            123
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.21
;  :minimized-lits          25
;  :mk-bool-var             12878
;  :mk-clause               8113
;  :num-allocs              266706
;  :num-checks              216
;  :propagations            3759
;  :quant-instantiations    3114
;  :rlimit-count            521628
;  :time                    0.01)
(push) ; 11
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 12
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7446
;  :arith-add-rows          4481
;  :arith-assert-diseq      370
;  :arith-assert-lower      1950
;  :arith-assert-upper      1133
;  :arith-bound-prop        530
;  :arith-conflicts         202
;  :arith-eq-adapter        1250
;  :arith-fixed-eqs         524
;  :arith-grobner           10
;  :arith-max-min           149
;  :arith-nonlinear-bounds  13
;  :arith-nonlinear-horner  8
;  :arith-offset-eqs        617
;  :arith-pivots            1337
;  :conflicts               647
;  :datatype-accessor-ax    50
;  :datatype-constructor-ax 416
;  :datatype-occurs-check   171
;  :datatype-splits         83
;  :decisions               1057
;  :del-clause              8008
;  :final-checks            123
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.21
;  :minimized-lits          25
;  :mk-bool-var             12878
;  :mk-clause               8113
;  :num-allocs              266797
;  :num-checks              217
;  :propagations            3759
;  :quant-instantiations    3114
;  :rlimit-count            521723)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
    (as None<option<array>>  option<array>))))
(pop) ; 11
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
    (as None<option<array>>  option<array>))))
(pop) ; 10
(push) ; 10
; [else-branch: 141 | !(i1@130@01 < V@30@01 && 0 <= i1@130@01)]
(assert (not (and (< i1@130@01 V@30@01) (<= 0 i1@130@01))))
(pop) ; 10
(pop) ; 9
; Joined path conditions
(assert (implies
  (and (< i1@130@01 V@30@01) (<= 0 i1@130@01))
  (and
    (< i1@130@01 V@30@01)
    (<= 0 i1@130@01)
    (< i1@130@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@130@01 Int)) (!
  (implies
    (and (< i1@130@01 V@30@01) (<= 0 i1@130@01))
    (and
      (< i1@130@01 V@30@01)
      (<= 0 i1@130@01)
      (< i1@130@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (and
    (< 0 V@30@01)
    (= exc@122@01 $Ref.null)
    (forall ((i1@130@01 Int)) (!
      (implies
        (and (< i1@130@01 V@30@01) (<= 0 i1@130@01))
        (and
          (< i1@130@01 V@30@01)
          (<= 0 i1@130@01)
          (< i1@130@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))
              (as None<option<array>>  option<array>)))))
      :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)))))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (forall ((i1@130@01 Int)) (!
    (implies
      (and (< i1@130@01 V@30@01) (<= 0 i1@130@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@130@01)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 142 | exc@122@01 == Null | live]
; [else-branch: 142 | exc@122@01 != Null | live]
(push) ; 7
; [then-branch: 142 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 142 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7477
;  :arith-add-rows          4509
;  :arith-assert-diseq      370
;  :arith-assert-lower      1965
;  :arith-assert-upper      1141
;  :arith-bound-prop        530
;  :arith-conflicts         203
;  :arith-eq-adapter        1250
;  :arith-fixed-eqs         524
;  :arith-grobner           15
;  :arith-max-min           175
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        618
;  :arith-pivots            1348
;  :conflicts               648
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 422
;  :datatype-occurs-check   175
;  :datatype-splits         85
;  :decisions               1064
;  :del-clause              8106
;  :final-checks            128
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.20
;  :minimized-lits          25
;  :mk-bool-var             12884
;  :mk-clause               8113
;  :num-allocs              268088
;  :num-checks              218
;  :propagations            3762
;  :quant-instantiations    3114
;  :rlimit-count            524495)
(push) ; 7
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7477
;  :arith-add-rows          4509
;  :arith-assert-diseq      370
;  :arith-assert-lower      1965
;  :arith-assert-upper      1141
;  :arith-bound-prop        530
;  :arith-conflicts         203
;  :arith-eq-adapter        1250
;  :arith-fixed-eqs         524
;  :arith-grobner           15
;  :arith-max-min           175
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        618
;  :arith-pivots            1348
;  :conflicts               648
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 422
;  :datatype-occurs-check   175
;  :datatype-splits         85
;  :decisions               1064
;  :del-clause              8106
;  :final-checks            128
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.20
;  :minimized-lits          25
;  :mk-bool-var             12884
;  :mk-clause               8113
;  :num-allocs              268106
;  :num-checks              219
;  :propagations            3762
;  :quant-instantiations    3114
;  :rlimit-count            524512)
; [then-branch: 143 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 143 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 7
; [then-branch: 143 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@131@01 Int)
(push) ; 8
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@132@01 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 144 | 0 <= i1@131@01 | live]
; [else-branch: 144 | !(0 <= i1@131@01) | live]
(push) ; 11
; [then-branch: 144 | 0 <= i1@131@01]
(assert (<= 0 i1@131@01))
; [eval] i1 < V
(push) ; 12
; [then-branch: 145 | i1@131@01 < V@30@01 | live]
; [else-branch: 145 | !(i1@131@01 < V@30@01) | live]
(push) ; 13
; [then-branch: 145 | i1@131@01 < V@30@01]
(assert (< i1@131@01 V@30@01))
; [eval] 0 <= i2
(push) ; 14
; [then-branch: 146 | 0 <= i2@132@01 | live]
; [else-branch: 146 | !(0 <= i2@132@01) | live]
(push) ; 15
; [then-branch: 146 | 0 <= i2@132@01]
(assert (<= 0 i2@132@01))
; [eval] i2 < V
(push) ; 16
; [then-branch: 147 | i2@132@01 < V@30@01 | live]
; [else-branch: 147 | !(i2@132@01 < V@30@01) | live]
(push) ; 17
; [then-branch: 147 | i2@132@01 < V@30@01]
(assert (< i2@132@01 V@30@01))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 19
(assert (not (< i1@131@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               7477
;  :arith-add-rows          4509
;  :arith-assert-diseq      370
;  :arith-assert-lower      1969
;  :arith-assert-upper      1141
;  :arith-bound-prop        530
;  :arith-conflicts         203
;  :arith-eq-adapter        1250
;  :arith-fixed-eqs         524
;  :arith-grobner           15
;  :arith-max-min           175
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        618
;  :arith-pivots            1349
;  :conflicts               648
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 422
;  :datatype-occurs-check   175
;  :datatype-splits         85
;  :decisions               1064
;  :del-clause              8106
;  :final-checks            128
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.21
;  :minimized-lits          25
;  :mk-bool-var             12888
;  :mk-clause               8113
;  :num-allocs              268387
;  :num-checks              220
;  :propagations            3762
;  :quant-instantiations    3114
;  :rlimit-count            524865)
(assert (< i1@131@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 18
; Joined path conditions
(assert (< i1@131@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
            V@30@01)
          (<=
            0
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8111
;  :arith-add-rows          5423
;  :arith-assert-diseq      426
;  :arith-assert-lower      2204
;  :arith-assert-upper      1300
;  :arith-bound-prop        580
;  :arith-conflicts         223
;  :arith-eq-adapter        1433
;  :arith-fixed-eqs         605
;  :arith-grobner           15
;  :arith-max-min           175
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        698
;  :arith-pivots            1460
;  :conflicts               684
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 426
;  :datatype-occurs-check   175
;  :datatype-splits         85
;  :decisions               1131
;  :del-clause              8744
;  :final-checks            128
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.23
;  :minimized-lits          35
;  :mk-bool-var             13853
;  :mk-clause               8849
;  :num-allocs              272448
;  :num-checks              221
;  :propagations            4280
;  :quant-instantiations    3248
;  :rlimit-count            556425
;  :time                    0.01)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 18
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 18
; Joined path conditions
(push) ; 18
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 19
(assert (not (< i2@132@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 19
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               8111
;  :arith-add-rows          5423
;  :arith-assert-diseq      426
;  :arith-assert-lower      2204
;  :arith-assert-upper      1300
;  :arith-bound-prop        580
;  :arith-conflicts         223
;  :arith-eq-adapter        1433
;  :arith-fixed-eqs         605
;  :arith-grobner           15
;  :arith-max-min           175
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        698
;  :arith-pivots            1460
;  :conflicts               684
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 426
;  :datatype-occurs-check   175
;  :datatype-splits         85
;  :decisions               1131
;  :del-clause              8744
;  :final-checks            128
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.23
;  :minimized-lits          35
;  :mk-bool-var             13853
;  :mk-clause               8849
;  :num-allocs              272475
;  :num-checks              222
;  :propagations            4280
;  :quant-instantiations    3248
;  :rlimit-count            556455)
(assert (< i2@132@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 18
; Joined path conditions
(assert (< i2@132@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
(push) ; 18
(assert (not (<
  $Perm.No
  (+
    (+
      (ite
        (and
          (<
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))
            V@30@01)
          (<=
            0
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)
        $Perm.No)
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))))))
(check-sat)
; unsat
(pop) ; 18
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9551
;  :arith-add-rows          7840
;  :arith-assert-diseq      691
;  :arith-assert-lower      2817
;  :arith-assert-upper      1767
;  :arith-bound-prop        715
;  :arith-conflicts         260
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           15
;  :arith-max-min           175
;  :arith-nonlinear-bounds  14
;  :arith-nonlinear-horner  12
;  :arith-offset-eqs        914
;  :arith-pivots            1678
;  :conflicts               760
;  :datatype-accessor-ax    51
;  :datatype-constructor-ax 430
;  :datatype-occurs-check   175
;  :datatype-splits         85
;  :decisions               1372
;  :del-clause              10196
;  :final-checks            128
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.38
;  :minimized-lits          48
;  :mk-bool-var             15790
;  :mk-clause               10409
;  :num-allocs              280569
;  :num-checks              223
;  :propagations            5935
;  :quant-instantiations    3582
;  :rlimit-count            642661
;  :time                    0.02)
(pop) ; 17
(push) ; 17
; [else-branch: 147 | !(i2@132@01 < V@30@01)]
(assert (not (< i2@132@01 V@30@01)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (< i2@132@01 V@30@01)
  (and
    (< i2@132@01 V@30@01)
    (< i1@131@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
    (< i2@132@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))))
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 146 | !(0 <= i2@132@01)]
(assert (not (<= 0 i2@132@01)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (<= 0 i2@132@01)
  (and
    (<= 0 i2@132@01)
    (implies
      (< i2@132@01 V@30@01)
      (and
        (< i2@132@01 V@30@01)
        (< i1@131@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
        (< i2@132@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))))))
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 145 | !(i1@131@01 < V@30@01)]
(assert (not (< i1@131@01 V@30@01)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (< i1@131@01 V@30@01)
  (and
    (< i1@131@01 V@30@01)
    (implies
      (<= 0 i2@132@01)
      (and
        (<= 0 i2@132@01)
        (implies
          (< i2@132@01 V@30@01)
          (and
            (< i2@132@01 V@30@01)
            (< i1@131@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
            (< i2@132@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))))))))
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 144 | !(0 <= i1@131@01)]
(assert (not (<= 0 i1@131@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (<= 0 i1@131@01)
  (and
    (<= 0 i1@131@01)
    (implies
      (< i1@131@01 V@30@01)
      (and
        (< i1@131@01 V@30@01)
        (implies
          (<= 0 i2@132@01)
          (and
            (<= 0 i2@132@01)
            (implies
              (< i2@132@01 V@30@01)
              (and
                (< i2@132@01 V@30@01)
                (< i1@131@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                (< i2@132@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))))))))))
; Joined path conditions
(push) ; 10
; [then-branch: 148 | Lookup(option$array$,sm@128@01,aloc((_, _), opt_get1(_, source@28@01), i1@131@01)) == Lookup(option$array$,sm@128@01,aloc((_, _), opt_get1(_, source@28@01), i2@132@01)) && i2@132@01 < V@30@01 && 0 <= i2@132@01 && i1@131@01 < V@30@01 && 0 <= i1@131@01 | live]
; [else-branch: 148 | !(Lookup(option$array$,sm@128@01,aloc((_, _), opt_get1(_, source@28@01), i1@131@01)) == Lookup(option$array$,sm@128@01,aloc((_, _), opt_get1(_, source@28@01), i2@132@01)) && i2@132@01 < V@30@01 && 0 <= i2@132@01 && i1@131@01 < V@30@01 && 0 <= i1@131@01) | live]
(push) ; 11
; [then-branch: 148 | Lookup(option$array$,sm@128@01,aloc((_, _), opt_get1(_, source@28@01), i1@131@01)) == Lookup(option$array$,sm@128@01,aloc((_, _), opt_get1(_, source@28@01), i2@132@01)) && i2@132@01 < V@30@01 && 0 <= i2@132@01 && i1@131@01 < V@30@01 && 0 <= i1@131@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
          ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
        (< i2@132@01 V@30@01))
      (<= 0 i2@132@01))
    (< i1@131@01 V@30@01))
  (<= 0 i1@131@01)))
; [eval] i1 == i2
(pop) ; 11
(push) ; 11
; [else-branch: 148 | !(Lookup(option$array$,sm@128@01,aloc((_, _), opt_get1(_, source@28@01), i1@131@01)) == Lookup(option$array$,sm@128@01,aloc((_, _), opt_get1(_, source@28@01), i2@132@01)) && i2@132@01 < V@30@01 && 0 <= i2@132@01 && i1@131@01 < V@30@01 && 0 <= i1@131@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
            ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
          (< i2@132@01 V@30@01))
        (<= 0 i2@132@01))
      (< i1@131@01 V@30@01))
    (<= 0 i1@131@01))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
            ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
          (< i2@132@01 V@30@01))
        (<= 0 i2@132@01))
      (< i1@131@01 V@30@01))
    (<= 0 i1@131@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
      ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
    (< i2@132@01 V@30@01)
    (<= 0 i2@132@01)
    (< i1@131@01 V@30@01)
    (<= 0 i1@131@01))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@132@01 Int)) (!
  (and
    (implies
      (<= 0 i1@131@01)
      (and
        (<= 0 i1@131@01)
        (implies
          (< i1@131@01 V@30@01)
          (and
            (< i1@131@01 V@30@01)
            (implies
              (<= 0 i2@132@01)
              (and
                (<= 0 i2@132@01)
                (implies
                  (< i2@132@01 V@30@01)
                  (and
                    (< i2@132@01 V@30@01)
                    (< i1@131@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                    (< i2@132@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
              (< i2@132@01 V@30@01))
            (<= 0 i2@132@01))
          (< i1@131@01 V@30@01))
        (<= 0 i1@131@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
          ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
        (< i2@132@01 V@30@01)
        (<= 0 i2@132@01)
        (< i1@131@01 V@30@01)
        (<= 0 i1@131@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@131@01 Int)) (!
  (forall ((i2@132@01 Int)) (!
    (and
      (implies
        (<= 0 i1@131@01)
        (and
          (<= 0 i1@131@01)
          (implies
            (< i1@131@01 V@30@01)
            (and
              (< i1@131@01 V@30@01)
              (implies
                (<= 0 i2@132@01)
                (and
                  (<= 0 i2@132@01)
                  (implies
                    (< i2@132@01 V@30@01)
                    (and
                      (< i2@132@01 V@30@01)
                      (<
                        i1@131@01
                        (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                      (<
                        i2@132@01
                        (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                  ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
                (< i2@132@01 V@30@01))
              (<= 0 i2@132@01))
            (< i1@131@01 V@30@01))
          (<= 0 i1@131@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
            ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
          (< i2@132@01 V@30@01)
          (<= 0 i2@132@01)
          (< i1@131@01 V@30@01)
          (<= 0 i1@131@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (and
    (< 0 V@30@01)
    (= exc@122@01 $Ref.null)
    (forall ((i1@131@01 Int)) (!
      (forall ((i2@132@01 Int)) (!
        (and
          (implies
            (<= 0 i1@131@01)
            (and
              (<= 0 i1@131@01)
              (implies
                (< i1@131@01 V@30@01)
                (and
                  (< i1@131@01 V@30@01)
                  (implies
                    (<= 0 i2@132@01)
                    (and
                      (<= 0 i2@132@01)
                      (implies
                        (< i2@132@01 V@30@01)
                        (and
                          (< i2@132@01 V@30@01)
                          (<
                            i1@131@01
                            (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01)) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                          (<
                            i2@132@01
                            (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))))))))))
          (implies
            (and
              (and
                (and
                  (and
                    (=
                      ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                      ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
                    (< i2@132@01 V@30@01))
                  (<= 0 i2@132@01))
                (< i1@131@01 V@30@01))
              (<= 0 i1@131@01))
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
              (< i2@132@01 V@30@01)
              (<= 0 i2@132@01)
              (< i1@131@01 V@30@01)
              (<= 0 i1@131@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))
        :qid |prog.l<no position>-aux|))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (forall ((i1@131@01 Int)) (!
    (forall ((i2@132@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
                  ($FVF.lookup_option$array$ (as sm@128@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01)))
                (< i2@132@01 V@30@01))
              (<= 0 i2@132@01))
            (< i1@131@01 V@30@01))
          (<= 0 i1@131@01))
        (= i1@131@01 i2@132@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@132@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@131@01))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> target != (None(): option[array])
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 149 | exc@122@01 == Null | live]
; [else-branch: 149 | exc@122@01 != Null | live]
(push) ; 7
; [then-branch: 149 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 149 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(set-option :timeout 10)
(push) ; 7
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9583
;  :arith-add-rows          7865
;  :arith-assert-diseq      691
;  :arith-assert-lower      2832
;  :arith-assert-upper      1775
;  :arith-bound-prop        715
;  :arith-conflicts         261
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           20
;  :arith-max-min           201
;  :arith-nonlinear-bounds  15
;  :arith-nonlinear-horner  16
;  :arith-offset-eqs        915
;  :arith-pivots            1698
;  :conflicts               761
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   179
;  :datatype-splits         87
;  :decisions               1379
;  :del-clause              10426
;  :final-checks            133
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15809
;  :mk-clause               10433
;  :num-allocs              282414
;  :num-checks              224
;  :propagations            5938
;  :quant-instantiations    3582
;  :rlimit-count            646925)
(push) ; 7
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9583
;  :arith-add-rows          7865
;  :arith-assert-diseq      691
;  :arith-assert-lower      2832
;  :arith-assert-upper      1775
;  :arith-bound-prop        715
;  :arith-conflicts         261
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           20
;  :arith-max-min           201
;  :arith-nonlinear-bounds  15
;  :arith-nonlinear-horner  16
;  :arith-offset-eqs        915
;  :arith-pivots            1698
;  :conflicts               761
;  :datatype-accessor-ax    52
;  :datatype-constructor-ax 436
;  :datatype-occurs-check   179
;  :datatype-splits         87
;  :decisions               1379
;  :del-clause              10426
;  :final-checks            133
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15809
;  :mk-clause               10433
;  :num-allocs              282432
;  :num-checks              225
;  :propagations            5938
;  :quant-instantiations    3582
;  :rlimit-count            646942)
; [then-branch: 150 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 150 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 7
; [then-branch: 150 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (not (= target@29@01 (as None<option<array>>  option<array>)))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> alen(opt_get1(target)) == V
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 151 | exc@122@01 == Null | live]
; [else-branch: 151 | exc@122@01 != Null | live]
(push) ; 7
; [then-branch: 151 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 151 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(push) ; 7
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9616
;  :arith-add-rows          7865
;  :arith-assert-diseq      691
;  :arith-assert-lower      2847
;  :arith-assert-upper      1783
;  :arith-bound-prop        715
;  :arith-conflicts         262
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           25
;  :arith-max-min           227
;  :arith-nonlinear-bounds  16
;  :arith-nonlinear-horner  20
;  :arith-offset-eqs        916
;  :arith-pivots            1698
;  :conflicts               762
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 442
;  :datatype-occurs-check   183
;  :datatype-splits         89
;  :decisions               1386
;  :del-clause              10426
;  :final-checks            138
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15813
;  :mk-clause               10433
;  :num-allocs              283330
;  :num-checks              226
;  :propagations            5941
;  :quant-instantiations    3582
;  :rlimit-count            648398)
(push) ; 7
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9616
;  :arith-add-rows          7865
;  :arith-assert-diseq      691
;  :arith-assert-lower      2847
;  :arith-assert-upper      1783
;  :arith-bound-prop        715
;  :arith-conflicts         262
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           25
;  :arith-max-min           227
;  :arith-nonlinear-bounds  16
;  :arith-nonlinear-horner  20
;  :arith-offset-eqs        916
;  :arith-pivots            1698
;  :conflicts               762
;  :datatype-accessor-ax    53
;  :datatype-constructor-ax 442
;  :datatype-occurs-check   183
;  :datatype-splits         89
;  :decisions               1386
;  :del-clause              10426
;  :final-checks            138
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15813
;  :mk-clause               10433
;  :num-allocs              283348
;  :num-checks              227
;  :propagations            5941
;  :quant-instantiations    3582
;  :rlimit-count            648415)
; [then-branch: 152 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 152 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 7
; [then-branch: 152 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(pop) ; 7
(pop) ; 6
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (= (alen<Int> (opt_get1 $Snap.unit target@29@01)) V@30@01)))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 6
; [then-branch: 153 | exc@122@01 == Null | live]
; [else-branch: 153 | exc@122@01 != Null | live]
(push) ; 7
; [then-branch: 153 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 7
(push) ; 7
; [else-branch: 153 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 7
(pop) ; 6
; Joined path conditions
; Joined path conditions
(push) ; 6
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9651
;  :arith-add-rows          7865
;  :arith-assert-diseq      691
;  :arith-assert-lower      2862
;  :arith-assert-upper      1791
;  :arith-bound-prop        715
;  :arith-conflicts         263
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           30
;  :arith-max-min           253
;  :arith-nonlinear-bounds  17
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        917
;  :arith-pivots            1698
;  :conflicts               763
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 449
;  :datatype-occurs-check   187
;  :datatype-splits         92
;  :decisions               1394
;  :del-clause              10426
;  :final-checks            143
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15817
;  :mk-clause               10433
;  :num-allocs              284250
;  :num-checks              228
;  :propagations            5944
;  :quant-instantiations    3582
;  :rlimit-count            649863)
(push) ; 6
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 6
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9651
;  :arith-add-rows          7865
;  :arith-assert-diseq      691
;  :arith-assert-lower      2862
;  :arith-assert-upper      1791
;  :arith-bound-prop        715
;  :arith-conflicts         263
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           30
;  :arith-max-min           253
;  :arith-nonlinear-bounds  17
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        917
;  :arith-pivots            1698
;  :conflicts               763
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 449
;  :datatype-occurs-check   187
;  :datatype-splits         92
;  :decisions               1394
;  :del-clause              10426
;  :final-checks            143
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15817
;  :mk-clause               10433
;  :num-allocs              284268
;  :num-checks              229
;  :propagations            5944
;  :quant-instantiations    3582
;  :rlimit-count            649880)
; [then-branch: 154 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 154 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 6
; [then-branch: 154 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
(declare-const i1@133@01 Int)
(push) ; 7
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 8
; [then-branch: 155 | 0 <= i1@133@01 | live]
; [else-branch: 155 | !(0 <= i1@133@01) | live]
(push) ; 9
; [then-branch: 155 | 0 <= i1@133@01]
(assert (<= 0 i1@133@01))
; [eval] i1 < V
(pop) ; 9
(push) ; 9
; [else-branch: 155 | !(0 <= i1@133@01)]
(assert (not (<= 0 i1@133@01)))
(pop) ; 9
(pop) ; 8
; Joined path conditions
; Joined path conditions
(assert (and (< i1@133@01 V@30@01) (<= 0 i1@133@01)))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 8
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 8
; Joined path conditions
(push) ; 8
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 9
(assert (not (< i1@133@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9651
;  :arith-add-rows          7865
;  :arith-assert-diseq      691
;  :arith-assert-lower      2864
;  :arith-assert-upper      1791
;  :arith-bound-prop        715
;  :arith-conflicts         263
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           30
;  :arith-max-min           253
;  :arith-nonlinear-bounds  17
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        917
;  :arith-pivots            1699
;  :conflicts               763
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 449
;  :datatype-occurs-check   187
;  :datatype-splits         92
;  :decisions               1394
;  :del-clause              10426
;  :final-checks            143
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15819
;  :mk-clause               10433
;  :num-allocs              284373
;  :num-checks              230
;  :propagations            5944
;  :quant-instantiations    3582
;  :rlimit-count            650078)
(assert (< i1@133@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 8
; Joined path conditions
(assert (< i1@133@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
; [eval] scale(V * V * write) * wildcard
; [eval] scale(V * V * write)
; [eval] V * V * write
; [eval] V * V
(push) ; 8
; [eval] amount >= 0 * write
; [eval] 0 * write
(push) ; 9
(assert (not (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No)))
(check-sat)
; unsat
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9662
;  :arith-add-rows          7865
;  :arith-assert-diseq      691
;  :arith-assert-lower      2868
;  :arith-assert-upper      1794
;  :arith-bound-prop        715
;  :arith-conflicts         264
;  :arith-eq-adapter        1860
;  :arith-fixed-eqs         753
;  :arith-grobner           30
;  :arith-max-min           262
;  :arith-nonlinear-bounds  18
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        917
;  :arith-pivots            1699
;  :conflicts               764
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 453
;  :datatype-occurs-check   187
;  :datatype-splits         92
;  :decisions               1398
;  :del-clause              10426
;  :final-checks            144
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15819
;  :mk-clause               10433
;  :num-allocs              284547
;  :num-checks              231
;  :propagations            5944
;  :quant-instantiations    3582
;  :rlimit-count            650290)
(assert (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
(pop) ; 8
; Joined path conditions
(assert (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
(declare-const $k@134@01 $Perm)
(assert ($Perm.isReadVar $k@134@01 $Perm.Write))
(pop) ; 7
(declare-fun inv@135@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@134@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@133@01 Int)) (!
  (and
    (< i1@133@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    (>= (* (to_real (* V@30@01 V@30@01)) $Perm.Write) $Perm.No))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@133@01))
  :qid |option$array$-aux|)))
(push) ; 7
(assert (not (forall ((i1@133@01 Int)) (!
  (implies
    (and (< i1@133@01 V@30@01) (<= 0 i1@133@01))
    (or
      (=
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))))
  
  ))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9692
;  :arith-add-rows          7865
;  :arith-assert-diseq      693
;  :arith-assert-lower      2886
;  :arith-assert-upper      1804
;  :arith-bound-prop        715
;  :arith-conflicts         266
;  :arith-eq-adapter        1862
;  :arith-fixed-eqs         753
;  :arith-grobner           30
;  :arith-max-min           285
;  :arith-nonlinear-bounds  21
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        918
;  :arith-pivots            1702
;  :conflicts               770
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   189
;  :datatype-splits         95
;  :decisions               1406
;  :del-clause              10428
;  :final-checks            147
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15832
;  :mk-clause               10437
;  :num-allocs              285223
;  :num-checks              232
;  :propagations            5949
;  :quant-instantiations    3582
;  :rlimit-count            651325)
; Check receiver injectivity
(push) ; 7
(assert (not (forall ((i11@133@01 Int) (i12@133@01 Int)) (!
  (implies
    (and
      (and
        (and (< i11@133@01 V@30@01) (<= 0 i11@133@01))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)))
      (and
        (and (< i12@133@01 V@30@01) (<= 0 i12@133@01))
        (<
          $Perm.No
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@133@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@133@01)))
    (= i11@133@01 i12@133@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9701
;  :arith-add-rows          7869
;  :arith-assert-diseq      694
;  :arith-assert-lower      2891
;  :arith-assert-upper      1804
;  :arith-bound-prop        715
;  :arith-conflicts         266
;  :arith-eq-adapter        1863
;  :arith-fixed-eqs         753
;  :arith-grobner           30
;  :arith-max-min           285
;  :arith-nonlinear-bounds  21
;  :arith-nonlinear-horner  24
;  :arith-offset-eqs        918
;  :arith-pivots            1704
;  :conflicts               771
;  :datatype-accessor-ax    54
;  :datatype-constructor-ax 460
;  :datatype-occurs-check   189
;  :datatype-splits         95
;  :decisions               1406
;  :del-clause              10440
;  :final-checks            147
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.35
;  :minimized-lits          48
;  :mk-bool-var             15856
;  :mk-clause               10449
;  :num-allocs              285626
;  :num-checks              233
;  :propagations            5953
;  :quant-instantiations    3597
;  :rlimit-count            652193)
; Definitional axioms for inverse functions
(assert (forall ((i1@133@01 Int)) (!
  (implies
    (and
      (and (< i1@133@01 V@30@01) (<= 0 i1@133@01))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)))
    (=
      (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@133@01))
      i1@133@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@133@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@135@01 r))
      r))
  :pattern ((inv@135@01 r))
  :qid |option$array$-fctOfInv|)))
; Permissions are non-negative
(assert (forall ((i1@133@01 Int)) (!
  (<=
    $Perm.No
    (*
      (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
      $k@134@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@133@01))
  :qid |option$array$-permAtLeastZero|)))
; Field permissions are at most one
(assert (forall ((i1@133@01 Int)) (!
  (<=
    (*
      (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
      $k@134@01)
    $Perm.Write)
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@133@01))
  :qid |option$array$-permAtMostOne|)))
; Permission implies non-null receiver
(assert (forall ((i1@133@01 Int)) (!
  (implies
    (and
      (and (< i1@133@01 V@30@01) (<= 0 i1@133@01))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@133@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@133@01))
  :qid |option$array$-permImpliesNonNull|)))
(declare-const sm@136@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef35|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef36|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef37|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef38|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef39|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r))
  :pattern ((inv@135@01 r))
  )))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 156 | exc@122@01 == Null | live]
; [else-branch: 156 | exc@122@01 != Null | live]
(push) ; 8
; [then-branch: 156 | exc@122@01 == Null]
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 156 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9739
;  :arith-add-rows          7869
;  :arith-assert-diseq      694
;  :arith-assert-lower      2914
;  :arith-assert-upper      1819
;  :arith-bound-prop        715
;  :arith-conflicts         267
;  :arith-eq-adapter        1863
;  :arith-fixed-eqs         753
;  :arith-grobner           35
;  :arith-max-min           323
;  :arith-nonlinear-bounds  23
;  :arith-nonlinear-horner  28
;  :arith-offset-eqs        919
;  :arith-pivots            1704
;  :conflicts               772
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 467
;  :datatype-occurs-check   193
;  :datatype-splits         98
;  :decisions               1414
;  :del-clause              10440
;  :final-checks            152
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.36
;  :minimized-lits          48
;  :mk-bool-var             15872
;  :mk-clause               10449
;  :num-allocs              288634
;  :num-checks              234
;  :propagations            5956
;  :quant-instantiations    3597
;  :rlimit-count            660602)
(push) ; 8
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9739
;  :arith-add-rows          7869
;  :arith-assert-diseq      694
;  :arith-assert-lower      2914
;  :arith-assert-upper      1819
;  :arith-bound-prop        715
;  :arith-conflicts         267
;  :arith-eq-adapter        1863
;  :arith-fixed-eqs         753
;  :arith-grobner           35
;  :arith-max-min           323
;  :arith-nonlinear-bounds  23
;  :arith-nonlinear-horner  28
;  :arith-offset-eqs        919
;  :arith-pivots            1704
;  :conflicts               772
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 467
;  :datatype-occurs-check   193
;  :datatype-splits         98
;  :decisions               1414
;  :del-clause              10440
;  :final-checks            152
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.36
;  :minimized-lits          48
;  :mk-bool-var             15872
;  :mk-clause               10449
;  :num-allocs              288652
;  :num-checks              235
;  :propagations            5956
;  :quant-instantiations    3597
;  :rlimit-count            660619)
; [then-branch: 157 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 157 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 8
; [then-branch: 157 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@137@01 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 158 | 0 <= i1@137@01 | live]
; [else-branch: 158 | !(0 <= i1@137@01) | live]
(push) ; 11
; [then-branch: 158 | 0 <= i1@137@01]
(assert (<= 0 i1@137@01))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 158 | !(0 <= i1@137@01)]
(assert (not (<= 0 i1@137@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 159 | i1@137@01 < V@30@01 && 0 <= i1@137@01 | live]
; [else-branch: 159 | !(i1@137@01 < V@30@01 && 0 <= i1@137@01) | live]
(push) ; 11
; [then-branch: 159 | i1@137@01 < V@30@01 && 0 <= i1@137@01]
(assert (and (< i1@137@01 V@30@01) (<= 0 i1@137@01)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@137@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               9739
;  :arith-add-rows          7869
;  :arith-assert-diseq      694
;  :arith-assert-lower      2916
;  :arith-assert-upper      1819
;  :arith-bound-prop        715
;  :arith-conflicts         267
;  :arith-eq-adapter        1863
;  :arith-fixed-eqs         753
;  :arith-grobner           35
;  :arith-max-min           323
;  :arith-nonlinear-bounds  23
;  :arith-nonlinear-horner  28
;  :arith-offset-eqs        919
;  :arith-pivots            1705
;  :conflicts               772
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 467
;  :datatype-occurs-check   193
;  :datatype-splits         98
;  :decisions               1414
;  :del-clause              10440
;  :final-checks            152
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.37
;  :minimized-lits          48
;  :mk-bool-var             15874
;  :mk-clause               10449
;  :num-allocs              288753
;  :num-checks              236
;  :propagations            5956
;  :quant-instantiations    3597
;  :rlimit-count            660827)
(assert (< i1@137@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 12
; Joined path conditions
(assert (< i1@137@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10755
;  :arith-add-rows          9113
;  :arith-assert-diseq      754
;  :arith-assert-lower      3216
;  :arith-assert-upper      2038
;  :arith-bound-prop        789
;  :arith-conflicts         298
;  :arith-eq-adapter        2066
;  :arith-fixed-eqs         871
;  :arith-grobner           35
;  :arith-max-min           323
;  :arith-nonlinear-bounds  23
;  :arith-nonlinear-horner  28
;  :arith-offset-eqs        1076
;  :arith-pivots            1856
;  :conflicts               823
;  :datatype-accessor-ax    55
;  :datatype-constructor-ax 471
;  :datatype-occurs-check   193
;  :datatype-splits         98
;  :decisions               1596
;  :del-clause              11776
;  :final-checks            152
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.49
;  :minimized-lits          54
;  :mk-bool-var             17584
;  :mk-clause               11910
;  :num-allocs              294571
;  :num-checks              237
;  :propagations            6824
;  :quant-instantiations    3907
;  :rlimit-count            711862
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 11
(push) ; 11
; [else-branch: 159 | !(i1@137@01 < V@30@01 && 0 <= i1@137@01)]
(assert (not (and (< i1@137@01 V@30@01) (<= 0 i1@137@01))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@137@01 V@30@01) (<= 0 i1@137@01))
  (and
    (< i1@137@01 V@30@01)
    (<= 0 i1@137@01)
    (< i1@137@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@137@01 Int)) (!
  (implies
    (and (< i1@137@01 V@30@01) (<= 0 i1@137@01))
    (and
      (< i1@137@01 V@30@01)
      (<= 0 i1@137@01)
      (< i1@137@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (and
    (< 0 V@30@01)
    (= exc@122@01 $Ref.null)
    (forall ((i1@137@01 Int)) (!
      (implies
        (and (< i1@137@01 V@30@01) (<= 0 i1@137@01))
        (and
          (< i1@137@01 V@30@01)
          (<= 0 i1@137@01)
          (< i1@137@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (forall ((i1@137@01 Int)) (!
    (implies
      (and (< i1@137@01 V@30@01) (<= 0 i1@137@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@137@01))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 160 | exc@122@01 == Null | live]
; [else-branch: 160 | exc@122@01 != Null | live]
(push) ; 8
; [then-branch: 160 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 160 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10794
;  :arith-add-rows          9131
;  :arith-assert-diseq      754
;  :arith-assert-lower      3238
;  :arith-assert-upper      2052
;  :arith-bound-prop        789
;  :arith-conflicts         299
;  :arith-eq-adapter        2066
;  :arith-fixed-eqs         871
;  :arith-grobner           40
;  :arith-max-min           361
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        1077
;  :arith-pivots            1866
;  :conflicts               824
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 478
;  :datatype-occurs-check   197
;  :datatype-splits         101
;  :decisions               1604
;  :del-clause              11901
;  :final-checks            157
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.48
;  :minimized-lits          54
;  :mk-bool-var             17591
;  :mk-clause               11910
;  :num-allocs              295917
;  :num-checks              238
;  :propagations            6827
;  :quant-instantiations    3907
;  :rlimit-count            714525)
(push) ; 8
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10794
;  :arith-add-rows          9131
;  :arith-assert-diseq      754
;  :arith-assert-lower      3238
;  :arith-assert-upper      2052
;  :arith-bound-prop        789
;  :arith-conflicts         299
;  :arith-eq-adapter        2066
;  :arith-fixed-eqs         871
;  :arith-grobner           40
;  :arith-max-min           361
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        1077
;  :arith-pivots            1866
;  :conflicts               824
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 478
;  :datatype-occurs-check   197
;  :datatype-splits         101
;  :decisions               1604
;  :del-clause              11901
;  :final-checks            157
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.48
;  :minimized-lits          54
;  :mk-bool-var             17591
;  :mk-clause               11910
;  :num-allocs              295935
;  :num-checks              239
;  :propagations            6827
;  :quant-instantiations    3907
;  :rlimit-count            714542)
; [then-branch: 161 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 161 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 8
; [then-branch: 161 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@138@01 Int)
(push) ; 9
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 10
; [then-branch: 162 | 0 <= i1@138@01 | live]
; [else-branch: 162 | !(0 <= i1@138@01) | live]
(push) ; 11
; [then-branch: 162 | 0 <= i1@138@01]
(assert (<= 0 i1@138@01))
; [eval] i1 < V
(pop) ; 11
(push) ; 11
; [else-branch: 162 | !(0 <= i1@138@01)]
(assert (not (<= 0 i1@138@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(push) ; 10
; [then-branch: 163 | i1@138@01 < V@30@01 && 0 <= i1@138@01 | live]
; [else-branch: 163 | !(i1@138@01 < V@30@01 && 0 <= i1@138@01) | live]
(push) ; 11
; [then-branch: 163 | i1@138@01 < V@30@01 && 0 <= i1@138@01]
(assert (and (< i1@138@01 V@30@01) (<= 0 i1@138@01)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@138@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               10794
;  :arith-add-rows          9131
;  :arith-assert-diseq      754
;  :arith-assert-lower      3240
;  :arith-assert-upper      2052
;  :arith-bound-prop        789
;  :arith-conflicts         299
;  :arith-eq-adapter        2066
;  :arith-fixed-eqs         871
;  :arith-grobner           40
;  :arith-max-min           361
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        1077
;  :arith-pivots            1866
;  :conflicts               824
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 478
;  :datatype-occurs-check   197
;  :datatype-splits         101
;  :decisions               1604
;  :del-clause              11901
;  :final-checks            157
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.51
;  :memory                  6.48
;  :minimized-lits          54
;  :mk-bool-var             17593
;  :mk-clause               11910
;  :num-allocs              296034
;  :num-checks              240
;  :propagations            6827
;  :quant-instantiations    3907
;  :rlimit-count            714746)
(assert (< i1@138@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 12
; Joined path conditions
(assert (< i1@138@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)))
(push) ; 12
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)))))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11691
;  :arith-add-rows          9920
;  :arith-assert-diseq      813
;  :arith-assert-lower      3523
;  :arith-assert-upper      2328
;  :arith-bound-prop        843
;  :arith-conflicts         323
;  :arith-eq-adapter        2279
;  :arith-fixed-eqs         991
;  :arith-grobner           40
;  :arith-max-min           361
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        1198
;  :arith-pivots            1980
;  :conflicts               868
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 482
;  :datatype-occurs-check   197
;  :datatype-splits         101
;  :decisions               1786
;  :del-clause              13146
;  :final-checks            157
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.52
;  :memory                  6.50
;  :minimized-lits          60
;  :mk-bool-var             19090
;  :mk-clause               13280
;  :num-allocs              300716
;  :num-checks              241
;  :propagations            7796
;  :quant-instantiations    4172
;  :rlimit-count            747436
;  :time                    0.01)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 13
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11691
;  :arith-add-rows          9920
;  :arith-assert-diseq      813
;  :arith-assert-lower      3523
;  :arith-assert-upper      2328
;  :arith-bound-prop        843
;  :arith-conflicts         323
;  :arith-eq-adapter        2279
;  :arith-fixed-eqs         991
;  :arith-grobner           40
;  :arith-max-min           361
;  :arith-nonlinear-bounds  25
;  :arith-nonlinear-horner  32
;  :arith-offset-eqs        1198
;  :arith-pivots            1980
;  :conflicts               869
;  :datatype-accessor-ax    56
;  :datatype-constructor-ax 482
;  :datatype-occurs-check   197
;  :datatype-splits         101
;  :decisions               1786
;  :del-clause              13146
;  :final-checks            157
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.52
;  :memory                  6.50
;  :minimized-lits          60
;  :mk-bool-var             19090
;  :mk-clause               13280
;  :num-allocs              300807
;  :num-checks              242
;  :propagations            7796
;  :quant-instantiations    4172
;  :rlimit-count            747531)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
    (as None<option<array>>  option<array>))))
(pop) ; 12
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
    (as None<option<array>>  option<array>))))
(pop) ; 11
(push) ; 11
; [else-branch: 163 | !(i1@138@01 < V@30@01 && 0 <= i1@138@01)]
(assert (not (and (< i1@138@01 V@30@01) (<= 0 i1@138@01))))
(pop) ; 11
(pop) ; 10
; Joined path conditions
(assert (implies
  (and (< i1@138@01 V@30@01) (<= 0 i1@138@01))
  (and
    (< i1@138@01 V@30@01)
    (<= 0 i1@138@01)
    (< i1@138@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@138@01 Int)) (!
  (implies
    (and (< i1@138@01 V@30@01) (<= 0 i1@138@01))
    (and
      (< i1@138@01 V@30@01)
      (<= 0 i1@138@01)
      (< i1@138@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (and
    (< 0 V@30@01)
    (= exc@122@01 $Ref.null)
    (forall ((i1@138@01 Int)) (!
      (implies
        (and (< i1@138@01 V@30@01) (<= 0 i1@138@01))
        (and
          (< i1@138@01 V@30@01)
          (<= 0 i1@138@01)
          (< i1@138@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))
              (as None<option<array>>  option<array>)))))
      :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)))))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (forall ((i1@138@01 Int)) (!
    (implies
      (and (< i1@138@01 V@30@01) (<= 0 i1@138@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@138@01)))))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))))
(assert (=
  ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))))
  $Snap.unit))
; [eval] exc == null && 0 < V ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null && 0 < V
; [eval] exc == null
(push) ; 7
; [then-branch: 164 | exc@122@01 == Null | live]
; [else-branch: 164 | exc@122@01 != Null | live]
(push) ; 8
; [then-branch: 164 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
; [eval] 0 < V
(pop) ; 8
(push) ; 8
; [else-branch: 164 | exc@122@01 != Null]
(assert (not (= exc@122@01 $Ref.null)))
(pop) ; 8
(pop) ; 7
; Joined path conditions
; Joined path conditions
(push) ; 7
(set-option :timeout 10)
(push) ; 8
(assert (not (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11731
;  :arith-add-rows          9962
;  :arith-assert-diseq      813
;  :arith-assert-lower      3545
;  :arith-assert-upper      2342
;  :arith-bound-prop        843
;  :arith-conflicts         324
;  :arith-eq-adapter        2279
;  :arith-fixed-eqs         991
;  :arith-grobner           45
;  :arith-max-min           399
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        1199
;  :arith-pivots            1995
;  :conflicts               870
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 489
;  :datatype-occurs-check   201
;  :datatype-splits         104
;  :decisions               1794
;  :del-clause              13271
;  :final-checks            162
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.52
;  :memory                  6.49
;  :minimized-lits          60
;  :mk-bool-var             19097
;  :mk-clause               13280
;  :num-allocs              302174
;  :num-checks              243
;  :propagations            7799
;  :quant-instantiations    4172
;  :rlimit-count            750694)
(push) ; 8
(assert (not (and (< 0 V@30@01) (= exc@122@01 $Ref.null))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11731
;  :arith-add-rows          9962
;  :arith-assert-diseq      813
;  :arith-assert-lower      3545
;  :arith-assert-upper      2342
;  :arith-bound-prop        843
;  :arith-conflicts         324
;  :arith-eq-adapter        2279
;  :arith-fixed-eqs         991
;  :arith-grobner           45
;  :arith-max-min           399
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        1199
;  :arith-pivots            1995
;  :conflicts               870
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 489
;  :datatype-occurs-check   201
;  :datatype-splits         104
;  :decisions               1794
;  :del-clause              13271
;  :final-checks            162
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.52
;  :memory                  6.49
;  :minimized-lits          60
;  :mk-bool-var             19097
;  :mk-clause               13280
;  :num-allocs              302192
;  :num-checks              244
;  :propagations            7799
;  :quant-instantiations    4172
;  :rlimit-count            750711)
; [then-branch: 165 | 0 < V@30@01 && exc@122@01 == Null | live]
; [else-branch: 165 | !(0 < V@30@01 && exc@122@01 == Null) | dead]
(push) ; 8
; [then-branch: 165 | 0 < V@30@01 && exc@122@01 == Null]
(assert (and (< 0 V@30@01) (= exc@122@01 $Ref.null)))
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@139@01 Int)
(push) ; 9
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@140@01 Int)
(push) ; 10
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 11
; [then-branch: 166 | 0 <= i1@139@01 | live]
; [else-branch: 166 | !(0 <= i1@139@01) | live]
(push) ; 12
; [then-branch: 166 | 0 <= i1@139@01]
(assert (<= 0 i1@139@01))
; [eval] i1 < V
(push) ; 13
; [then-branch: 167 | i1@139@01 < V@30@01 | live]
; [else-branch: 167 | !(i1@139@01 < V@30@01) | live]
(push) ; 14
; [then-branch: 167 | i1@139@01 < V@30@01]
(assert (< i1@139@01 V@30@01))
; [eval] 0 <= i2
(push) ; 15
; [then-branch: 168 | 0 <= i2@140@01 | live]
; [else-branch: 168 | !(0 <= i2@140@01) | live]
(push) ; 16
; [then-branch: 168 | 0 <= i2@140@01]
(assert (<= 0 i2@140@01))
; [eval] i2 < V
(push) ; 17
; [then-branch: 169 | i2@140@01 < V@30@01 | live]
; [else-branch: 169 | !(i2@140@01 < V@30@01) | live]
(push) ; 18
; [then-branch: 169 | i2@140@01 < V@30@01]
(assert (< i2@140@01 V@30@01))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 20
(assert (not (< i1@139@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               11731
;  :arith-add-rows          9962
;  :arith-assert-diseq      813
;  :arith-assert-lower      3549
;  :arith-assert-upper      2342
;  :arith-bound-prop        843
;  :arith-conflicts         324
;  :arith-eq-adapter        2279
;  :arith-fixed-eqs         991
;  :arith-grobner           45
;  :arith-max-min           399
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        1199
;  :arith-pivots            1995
;  :conflicts               870
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 489
;  :datatype-occurs-check   201
;  :datatype-splits         104
;  :decisions               1794
;  :del-clause              13271
;  :final-checks            162
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.52
;  :memory                  6.49
;  :minimized-lits          60
;  :mk-bool-var             19101
;  :mk-clause               13280
;  :num-allocs              302468
;  :num-checks              245
;  :propagations            7799
;  :quant-instantiations    4172
;  :rlimit-count            751059)
(assert (< i1@139@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 19
; Joined path conditions
(assert (< i1@139@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12962
;  :arith-add-rows          11137
;  :arith-assert-diseq      877
;  :arith-assert-lower      3912
;  :arith-assert-upper      2646
;  :arith-bound-prop        914
;  :arith-conflicts         354
;  :arith-eq-adapter        2538
;  :arith-fixed-eqs         1161
;  :arith-grobner           45
;  :arith-max-min           399
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        1399
;  :arith-pivots            2156
;  :conflicts               926
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 493
;  :datatype-occurs-check   201
;  :datatype-splits         104
;  :decisions               2000
;  :del-clause              14877
;  :final-checks            162
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.56
;  :memory                  6.54
;  :minimized-lits          65
;  :mk-bool-var             21097
;  :mk-clause               15011
;  :num-allocs              308996
;  :num-checks              246
;  :propagations            8953
;  :quant-instantiations    4554
;  :rlimit-count            801177
;  :time                    0.01)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 19
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 19
; Joined path conditions
(push) ; 19
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 20
(assert (not (< i2@140@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 20
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               12962
;  :arith-add-rows          11137
;  :arith-assert-diseq      877
;  :arith-assert-lower      3912
;  :arith-assert-upper      2646
;  :arith-bound-prop        914
;  :arith-conflicts         354
;  :arith-eq-adapter        2538
;  :arith-fixed-eqs         1161
;  :arith-grobner           45
;  :arith-max-min           399
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        1399
;  :arith-pivots            2156
;  :conflicts               926
;  :datatype-accessor-ax    57
;  :datatype-constructor-ax 493
;  :datatype-occurs-check   201
;  :datatype-splits         104
;  :decisions               2000
;  :del-clause              14877
;  :final-checks            162
;  :interface-eqs           3
;  :max-generation          5
;  :max-memory              6.56
;  :memory                  6.54
;  :minimized-lits          65
;  :mk-bool-var             21097
;  :mk-clause               15011
;  :num-allocs              309023
;  :num-checks              247
;  :propagations            8953
;  :quant-instantiations    4554
;  :rlimit-count            801207)
(assert (< i2@140@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 19
; Joined path conditions
(assert (< i2@140@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
(push) ; 19
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))))))
(check-sat)
; unsat
(pop) ; 19
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16180
;  :arith-add-rows          13470
;  :arith-assert-diseq      1085
;  :arith-assert-lower      4773
;  :arith-assert-upper      3274
;  :arith-bound-prop        1089
;  :arith-conflicts         392
;  :arith-eq-adapter        3130
;  :arith-fixed-eqs         1488
;  :arith-grobner           45
;  :arith-max-min           399
;  :arith-nonlinear-bounds  27
;  :arith-nonlinear-horner  36
;  :arith-offset-eqs        1872
;  :arith-pivots            2417
;  :conflicts               1011
;  :datatype-accessor-ax    58
;  :datatype-constructor-ax 498
;  :datatype-occurs-check   201
;  :datatype-splits         104
;  :decisions               2313
;  :del-clause              18845
;  :final-checks            162
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              6.86
;  :memory                  6.84
;  :minimized-lits          115
;  :mk-bool-var             26272
;  :mk-clause               19076
;  :num-allocs              326404
;  :num-checks              248
;  :propagations            12172
;  :quant-instantiations    6059
;  :rlimit-count            919193
;  :time                    0.04)
(pop) ; 18
(push) ; 18
; [else-branch: 169 | !(i2@140@01 < V@30@01)]
(assert (not (< i2@140@01 V@30@01)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i2@140@01 V@30@01)
  (and
    (< i2@140@01 V@30@01)
    (< i1@139@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
    (< i2@140@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 168 | !(0 <= i2@140@01)]
(assert (not (<= 0 i2@140@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i2@140@01)
  (and
    (<= 0 i2@140@01)
    (implies
      (< i2@140@01 V@30@01)
      (and
        (< i2@140@01 V@30@01)
        (< i1@139@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
        (< i2@140@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))))))
; Joined path conditions
(pop) ; 14
(push) ; 14
; [else-branch: 167 | !(i1@139@01 < V@30@01)]
(assert (not (< i1@139@01 V@30@01)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
(assert (implies
  (< i1@139@01 V@30@01)
  (and
    (< i1@139@01 V@30@01)
    (implies
      (<= 0 i2@140@01)
      (and
        (<= 0 i2@140@01)
        (implies
          (< i2@140@01 V@30@01)
          (and
            (< i2@140@01 V@30@01)
            (< i1@139@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
            (< i2@140@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))))))))
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 166 | !(0 <= i1@139@01)]
(assert (not (<= 0 i1@139@01)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (<= 0 i1@139@01)
  (and
    (<= 0 i1@139@01)
    (implies
      (< i1@139@01 V@30@01)
      (and
        (< i1@139@01 V@30@01)
        (implies
          (<= 0 i2@140@01)
          (and
            (<= 0 i2@140@01)
            (implies
              (< i2@140@01 V@30@01)
              (and
                (< i2@140@01 V@30@01)
                (< i1@139@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                (< i2@140@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))))))))))
; Joined path conditions
(push) ; 11
; [then-branch: 170 | Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i1@139@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i2@140@01)) && i2@140@01 < V@30@01 && 0 <= i2@140@01 && i1@139@01 < V@30@01 && 0 <= i1@139@01 | live]
; [else-branch: 170 | !(Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i1@139@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i2@140@01)) && i2@140@01 < V@30@01 && 0 <= i2@140@01 && i1@139@01 < V@30@01 && 0 <= i1@139@01) | live]
(push) ; 12
; [then-branch: 170 | Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i1@139@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i2@140@01)) && i2@140@01 < V@30@01 && 0 <= i2@140@01 && i1@139@01 < V@30@01 && 0 <= i1@139@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
        (< i2@140@01 V@30@01))
      (<= 0 i2@140@01))
    (< i1@139@01 V@30@01))
  (<= 0 i1@139@01)))
; [eval] i1 == i2
(pop) ; 12
(push) ; 12
; [else-branch: 170 | !(Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i1@139@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i2@140@01)) && i2@140@01 < V@30@01 && 0 <= i2@140@01 && i1@139@01 < V@30@01 && 0 <= i1@139@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
          (< i2@140@01 V@30@01))
        (<= 0 i2@140@01))
      (< i1@139@01 V@30@01))
    (<= 0 i1@139@01))))
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
          (< i2@140@01 V@30@01))
        (<= 0 i2@140@01))
      (< i1@139@01 V@30@01))
    (<= 0 i1@139@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
    (< i2@140@01 V@30@01)
    (<= 0 i2@140@01)
    (< i1@139@01 V@30@01)
    (<= 0 i1@139@01))))
; Joined path conditions
(pop) ; 10
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@140@01 Int)) (!
  (and
    (implies
      (<= 0 i1@139@01)
      (and
        (<= 0 i1@139@01)
        (implies
          (< i1@139@01 V@30@01)
          (and
            (< i1@139@01 V@30@01)
            (implies
              (<= 0 i2@140@01)
              (and
                (<= 0 i2@140@01)
                (implies
                  (< i2@140@01 V@30@01)
                  (and
                    (< i2@140@01 V@30@01)
                    (< i1@139@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                    (< i2@140@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
              (< i2@140@01 V@30@01))
            (<= 0 i2@140@01))
          (< i1@139@01 V@30@01))
        (<= 0 i1@139@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
        (< i2@140@01 V@30@01)
        (<= 0 i2@140@01)
        (< i1@139@01 V@30@01)
        (<= 0 i1@139@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 9
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@139@01 Int)) (!
  (forall ((i2@140@01 Int)) (!
    (and
      (implies
        (<= 0 i1@139@01)
        (and
          (<= 0 i1@139@01)
          (implies
            (< i1@139@01 V@30@01)
            (and
              (< i1@139@01 V@30@01)
              (implies
                (<= 0 i2@140@01)
                (and
                  (<= 0 i2@140@01)
                  (implies
                    (< i2@140@01 V@30@01)
                    (and
                      (< i2@140@01 V@30@01)
                      (<
                        i1@139@01
                        (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                      (<
                        i2@140@01
                        (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
                (< i2@140@01 V@30@01))
              (<= 0 i2@140@01))
            (< i1@139@01 V@30@01))
          (<= 0 i1@139@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
          (< i2@140@01 V@30@01)
          (<= 0 i2@140@01)
          (< i1@139@01 V@30@01)
          (<= 0 i1@139@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 8
(pop) ; 7
; Joined path conditions
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (and
    (< 0 V@30@01)
    (= exc@122@01 $Ref.null)
    (forall ((i1@139@01 Int)) (!
      (forall ((i2@140@01 Int)) (!
        (and
          (implies
            (<= 0 i1@139@01)
            (and
              (<= 0 i1@139@01)
              (implies
                (< i1@139@01 V@30@01)
                (and
                  (< i1@139@01 V@30@01)
                  (implies
                    (<= 0 i2@140@01)
                    (and
                      (<= 0 i2@140@01)
                      (implies
                        (< i2@140@01 V@30@01)
                        (and
                          (< i2@140@01 V@30@01)
                          (<
                            i1@139@01
                            (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01)) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                          (<
                            i2@140@01
                            (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)) (aloc ($Snap.combine
                            $Snap.unit
                            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))))))))))
          (implies
            (and
              (and
                (and
                  (and
                    (=
                      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
                    (< i2@140@01 V@30@01))
                  (<= 0 i2@140@01))
                (< i1@139@01 V@30@01))
              (<= 0 i1@139@01))
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
              (< i2@140@01 V@30@01)
              (<= 0 i2@140@01)
              (< i1@139@01 V@30@01)
              (<= 0 i1@139@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))
        :qid |prog.l<no position>-aux|))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
      :qid |prog.l<no position>-aux|)))))
(assert (implies
  (and (< 0 V@30@01) (= exc@122@01 $Ref.null))
  (forall ((i1@139@01 Int)) (!
    (forall ((i2@140@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01)))
                (< i2@140@01 V@30@01))
              (<= 0 i2@140@01))
            (< i1@139@01 V@30@01))
          (<= 0 i1@139@01))
        (= i1@139@01 i2@140@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@140@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@139@01))
    :qid |prog.l<no position>|))))
(assert (=
  ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))))
  ($Snap.combine
    ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))
    ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01)))))))))))))))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 7
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16222
;  :arith-add-rows          13485
;  :arith-assert-diseq      1085
;  :arith-assert-lower      4795
;  :arith-assert-upper      3288
;  :arith-bound-prop        1089
;  :arith-conflicts         393
;  :arith-eq-adapter        3130
;  :arith-fixed-eqs         1488
;  :arith-grobner           50
;  :arith-max-min           437
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        1873
;  :arith-pivots            2441
;  :conflicts               1012
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 506
;  :datatype-occurs-check   209
;  :datatype-splits         108
;  :decisions               2322
;  :del-clause              19091
;  :final-checks            167
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.98
;  :minimized-lits          115
;  :mk-bool-var             26292
;  :mk-clause               19100
;  :num-allocs              328254
;  :num-checks              249
;  :propagations            12175
;  :quant-instantiations    6059
;  :rlimit-count            923271)
(push) ; 7
(assert (not (= exc@122@01 $Ref.null)))
(check-sat)
; unsat
(pop) ; 7
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16222
;  :arith-add-rows          13485
;  :arith-assert-diseq      1085
;  :arith-assert-lower      4795
;  :arith-assert-upper      3288
;  :arith-bound-prop        1089
;  :arith-conflicts         393
;  :arith-eq-adapter        3130
;  :arith-fixed-eqs         1488
;  :arith-grobner           50
;  :arith-max-min           437
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        1873
;  :arith-pivots            2441
;  :conflicts               1012
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 506
;  :datatype-occurs-check   209
;  :datatype-splits         108
;  :decisions               2322
;  :del-clause              19091
;  :final-checks            167
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.98
;  :minimized-lits          115
;  :mk-bool-var             26292
;  :mk-clause               19100
;  :num-allocs              328272
;  :num-checks              250
;  :propagations            12175
;  :quant-instantiations    6059
;  :rlimit-count            923282)
; [then-branch: 171 | exc@122@01 == Null | live]
; [else-branch: 171 | exc@122@01 != Null | dead]
(push) ; 7
; [then-branch: 171 | exc@122@01 == Null]
(assert (= exc@122@01 $Ref.null))
(declare-const unknown@141@01 Int)
(declare-const unknown1@142@01 Int)
(push) ; 8
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 9
; [then-branch: 172 | 0 <= unknown@141@01 | live]
; [else-branch: 172 | !(0 <= unknown@141@01) | live]
(push) ; 10
; [then-branch: 172 | 0 <= unknown@141@01]
(assert (<= 0 unknown@141@01))
; [eval] unknown < V
(push) ; 11
; [then-branch: 173 | unknown@141@01 < V@30@01 | live]
; [else-branch: 173 | !(unknown@141@01 < V@30@01) | live]
(push) ; 12
; [then-branch: 173 | unknown@141@01 < V@30@01]
(assert (< unknown@141@01 V@30@01))
; [eval] 0 <= unknown1
(push) ; 13
; [then-branch: 174 | 0 <= unknown1@142@01 | live]
; [else-branch: 174 | !(0 <= unknown1@142@01) | live]
(push) ; 14
; [then-branch: 174 | 0 <= unknown1@142@01]
(assert (<= 0 unknown1@142@01))
; [eval] unknown1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 174 | !(0 <= unknown1@142@01)]
(assert (not (<= 0 unknown1@142@01)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(pop) ; 12
(push) ; 12
; [else-branch: 173 | !(unknown@141@01 < V@30@01)]
(assert (not (< unknown@141@01 V@30@01)))
(pop) ; 12
(pop) ; 11
; Joined path conditions
; Joined path conditions
(pop) ; 10
(push) ; 10
; [else-branch: 172 | !(0 <= unknown@141@01)]
(assert (not (<= 0 unknown@141@01)))
(pop) ; 10
(pop) ; 9
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@142@01 V@30@01) (<= 0 unknown1@142@01))
    (< unknown@141@01 V@30@01))
  (<= 0 unknown@141@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(target), unknown1).option$array$)
; [eval] aloc(opt_get1(target), unknown1)
; [eval] opt_get1(target)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 9
; Joined path conditions
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 10
(assert (not (< unknown1@142@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               16222
;  :arith-add-rows          13485
;  :arith-assert-diseq      1085
;  :arith-assert-lower      4801
;  :arith-assert-upper      3288
;  :arith-bound-prop        1089
;  :arith-conflicts         393
;  :arith-eq-adapter        3130
;  :arith-fixed-eqs         1488
;  :arith-grobner           50
;  :arith-max-min           437
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        1873
;  :arith-pivots            2443
;  :conflicts               1012
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 506
;  :datatype-occurs-check   209
;  :datatype-splits         108
;  :decisions               2322
;  :del-clause              19091
;  :final-checks            167
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.98
;  :minimized-lits          115
;  :mk-bool-var             26298
;  :mk-clause               19100
;  :num-allocs              328546
;  :num-checks              251
;  :propagations            12175
;  :quant-instantiations    6059
;  :rlimit-count            923765)
(assert (< unknown1@142@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 9
; Joined path conditions
(assert (< unknown1@142@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01)))
(push) ; 9
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01)))))))
(check-sat)
; unsat
(pop) ; 9
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17444
;  :arith-add-rows          14923
;  :arith-assert-diseq      1149
;  :arith-assert-lower      5140
;  :arith-assert-upper      3603
;  :arith-bound-prop        1185
;  :arith-conflicts         418
;  :arith-eq-adapter        3402
;  :arith-fixed-eqs         1664
;  :arith-grobner           50
;  :arith-max-min           437
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        2047
;  :arith-pivots            2604
;  :conflicts               1070
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 510
;  :datatype-occurs-check   209
;  :datatype-splits         108
;  :decisions               2494
;  :del-clause              20588
;  :final-checks            167
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.99
;  :minimized-lits          121
;  :mk-bool-var             28184
;  :mk-clause               20722
;  :num-allocs              335218
;  :num-checks              252
;  :propagations            13324
;  :quant-instantiations    6395
;  :rlimit-count            975436
;  :time                    0.01)
(push) ; 9
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 10
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17444
;  :arith-add-rows          14923
;  :arith-assert-diseq      1149
;  :arith-assert-lower      5140
;  :arith-assert-upper      3603
;  :arith-bound-prop        1185
;  :arith-conflicts         418
;  :arith-eq-adapter        3402
;  :arith-fixed-eqs         1664
;  :arith-grobner           50
;  :arith-max-min           437
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        2047
;  :arith-pivots            2604
;  :conflicts               1071
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 510
;  :datatype-occurs-check   209
;  :datatype-splits         108
;  :decisions               2494
;  :del-clause              20588
;  :final-checks            167
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.99
;  :minimized-lits          121
;  :mk-bool-var             28184
;  :mk-clause               20722
;  :num-allocs              335309
;  :num-checks              253
;  :propagations            13324
;  :quant-instantiations    6395
;  :rlimit-count            975531)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
    (as None<option<array>>  option<array>))))
(pop) ; 9
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
    (as None<option<array>>  option<array>))))
(push) ; 9
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 10
(assert (not (<
  unknown@141@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17450
;  :arith-add-rows          14926
;  :arith-assert-diseq      1149
;  :arith-assert-lower      5142
;  :arith-assert-upper      3605
;  :arith-bound-prop        1185
;  :arith-conflicts         419
;  :arith-eq-adapter        3403
;  :arith-fixed-eqs         1665
;  :arith-grobner           50
;  :arith-max-min           437
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        2047
;  :arith-pivots            2606
;  :conflicts               1072
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 510
;  :datatype-occurs-check   209
;  :datatype-splits         108
;  :decisions               2494
;  :del-clause              20592
;  :final-checks            167
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.99
;  :minimized-lits          121
;  :mk-bool-var             28195
;  :mk-clause               20726
;  :num-allocs              335495
;  :num-checks              254
;  :propagations            13326
;  :quant-instantiations    6402
;  :rlimit-count            975980)
(assert (<
  unknown@141@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))))))
(pop) ; 9
; Joined path conditions
(assert (<
  unknown@141@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))))))
(pop) ; 8
(declare-fun inv@143@01 ($Ref) Int)
(declare-fun inv@144@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@141@01 Int) (unknown1@142@01 Int)) (!
  (and
    (< unknown1@142@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown@141@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))) unknown@141@01))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 8
(assert (not (forall ((unknown1@141@01 Int) (unknown11@142@01 Int) (unknown2@141@01 Int) (unknown12@142@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown11@142@01 V@30@01) (<= 0 unknown11@142@01))
          (< unknown1@141@01 V@30@01))
        (<= 0 unknown1@141@01))
      (and
        (and
          (and (< unknown12@142@01 V@30@01) (<= 0 unknown12@142@01))
          (< unknown2@141@01 V@30@01))
        (<= 0 unknown2@141@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown11@142@01))) unknown1@141@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown12@142@01))) unknown2@141@01)))
    (and
      (= unknown1@141@01 unknown2@141@01)
      (= unknown11@142@01 unknown12@142@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17503
;  :arith-add-rows          14941
;  :arith-assert-diseq      1149
;  :arith-assert-lower      5158
;  :arith-assert-upper      3608
;  :arith-bound-prop        1189
;  :arith-conflicts         419
;  :arith-eq-adapter        3411
;  :arith-fixed-eqs         1667
;  :arith-grobner           50
;  :arith-max-min           437
;  :arith-nonlinear-bounds  29
;  :arith-nonlinear-horner  40
;  :arith-offset-eqs        2054
;  :arith-pivots            2626
;  :conflicts               1073
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 510
;  :datatype-occurs-check   209
;  :datatype-splits         108
;  :decisions               2494
;  :del-clause              20968
;  :final-checks            167
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.98
;  :minimized-lits          121
;  :mk-bool-var             28576
;  :mk-clause               20977
;  :num-allocs              337653
;  :num-checks              255
;  :propagations            13370
;  :quant-instantiations    6539
;  :rlimit-count            984626
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((unknown@141@01 Int) (unknown1@142@01 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@142@01 V@30@01) (<= 0 unknown1@142@01))
        (< unknown@141@01 V@30@01))
      (<= 0 unknown@141@01))
    (and
      (=
        (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))) unknown@141@01))
        unknown@141@01)
      (=
        (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))) unknown@141@01))
        unknown1@142@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))) unknown@141@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@144@01 r)))) (inv@143@01 r))
      r))
  :pattern ((inv@143@01 r))
  :pattern ((inv@144@01 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((unknown@141@01 Int) (unknown1@142@01 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@142@01 V@30@01) (<= 0 unknown1@142@01))
        (< unknown@141@01 V@30@01))
      (<= 0 unknown@141@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))) unknown@141@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown1@142@01))) unknown@141@01))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@145@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@145@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@145@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef40|)))
(assert (forall ((r $Ref)) (!
  ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
  :pattern (($FVF.lookup_int (as sm@145@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef41|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@145@01  $FVF<Int>) r) r))
  :pattern ((inv@143@01 r) (inv@144@01 r))
  )))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 8
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 8
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17541
;  :arith-add-rows          14941
;  :arith-assert-diseq      1149
;  :arith-assert-lower      5180
;  :arith-assert-upper      3622
;  :arith-bound-prop        1189
;  :arith-conflicts         420
;  :arith-eq-adapter        3411
;  :arith-fixed-eqs         1667
;  :arith-grobner           55
;  :arith-max-min           475
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        2055
;  :arith-pivots            2626
;  :conflicts               1074
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 518
;  :datatype-occurs-check   217
;  :datatype-splits         112
;  :decisions               2503
;  :del-clause              20968
;  :final-checks            172
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.99
;  :minimized-lits          121
;  :mk-bool-var             28586
;  :mk-clause               20977
;  :num-allocs              339450
;  :num-checks              256
;  :propagations            13373
;  :quant-instantiations    6539
;  :rlimit-count            988654)
; [then-branch: 175 | exc@122@01 == Null | live]
; [else-branch: 175 | exc@122@01 != Null | dead]
(push) ; 8
; [then-branch: 175 | exc@122@01 == Null]
(declare-const unknown@146@01 Int)
(declare-const unknown1@147@01 Int)
(push) ; 9
; [eval] 0 <= unknown && unknown < V && (0 <= unknown1 && unknown1 < V)
; [eval] 0 <= unknown
(push) ; 10
; [then-branch: 176 | 0 <= unknown@146@01 | live]
; [else-branch: 176 | !(0 <= unknown@146@01) | live]
(push) ; 11
; [then-branch: 176 | 0 <= unknown@146@01]
(assert (<= 0 unknown@146@01))
; [eval] unknown < V
(push) ; 12
; [then-branch: 177 | unknown@146@01 < V@30@01 | live]
; [else-branch: 177 | !(unknown@146@01 < V@30@01) | live]
(push) ; 13
; [then-branch: 177 | unknown@146@01 < V@30@01]
(assert (< unknown@146@01 V@30@01))
; [eval] 0 <= unknown1
(push) ; 14
; [then-branch: 178 | 0 <= unknown1@147@01 | live]
; [else-branch: 178 | !(0 <= unknown1@147@01) | live]
(push) ; 15
; [then-branch: 178 | 0 <= unknown1@147@01]
(assert (<= 0 unknown1@147@01))
; [eval] unknown1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 178 | !(0 <= unknown1@147@01)]
(assert (not (<= 0 unknown1@147@01)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(pop) ; 13
(push) ; 13
; [else-branch: 177 | !(unknown@146@01 < V@30@01)]
(assert (not (< unknown@146@01 V@30@01)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(pop) ; 11
(push) ; 11
; [else-branch: 176 | !(0 <= unknown@146@01)]
(assert (not (<= 0 unknown@146@01)))
(pop) ; 11
(pop) ; 10
; Joined path conditions
; Joined path conditions
(assert (and
  (and
    (and (< unknown1@147@01 V@30@01) (<= 0 unknown1@147@01))
    (< unknown@146@01 V@30@01))
  (<= 0 unknown@146@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown1).option$array$), unknown)
; [eval] opt_get1(aloc(opt_get1(source), unknown1).option$array$)
; [eval] aloc(opt_get1(source), unknown1)
; [eval] opt_get1(source)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 10
; Joined path conditions
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 11
(assert (not (< unknown1@147@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               17541
;  :arith-add-rows          14941
;  :arith-assert-diseq      1149
;  :arith-assert-lower      5186
;  :arith-assert-upper      3622
;  :arith-bound-prop        1189
;  :arith-conflicts         420
;  :arith-eq-adapter        3411
;  :arith-fixed-eqs         1667
;  :arith-grobner           55
;  :arith-max-min           475
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        2055
;  :arith-pivots            2626
;  :conflicts               1074
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 518
;  :datatype-occurs-check   217
;  :datatype-splits         112
;  :decisions               2503
;  :del-clause              20968
;  :final-checks            172
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  6.99
;  :minimized-lits          121
;  :mk-bool-var             28592
;  :mk-clause               20977
;  :num-allocs              339724
;  :num-checks              257
;  :propagations            13373
;  :quant-instantiations    6539
;  :rlimit-count            989126)
(assert (< unknown1@147@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 10
; Joined path conditions
(assert (< unknown1@147@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01)))
(push) ; 10
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01)))))))
(check-sat)
; unsat
(pop) ; 10
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18343
;  :arith-add-rows          15886
;  :arith-assert-diseq      1221
;  :arith-assert-lower      5459
;  :arith-assert-upper      3821
;  :arith-bound-prop        1242
;  :arith-conflicts         444
;  :arith-eq-adapter        3625
;  :arith-fixed-eqs         1764
;  :arith-grobner           55
;  :arith-max-min           475
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        2176
;  :arith-pivots            2753
;  :conflicts               1113
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 522
;  :datatype-occurs-check   217
;  :datatype-splits         112
;  :decisions               2636
;  :del-clause              22074
;  :final-checks            172
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  7.00
;  :minimized-lits          130
;  :mk-bool-var             30065
;  :mk-clause               22212
;  :num-allocs              344757
;  :num-checks              258
;  :propagations            14070
;  :quant-instantiations    6787
;  :rlimit-count            1029118
;  :time                    0.01)
(push) ; 10
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 11
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18626
;  :arith-add-rows          16069
;  :arith-assert-diseq      1242
;  :arith-assert-lower      5552
;  :arith-assert-upper      3876
;  :arith-bound-prop        1257
;  :arith-conflicts         452
;  :arith-eq-adapter        3694
;  :arith-fixed-eqs         1790
;  :arith-grobner           55
;  :arith-max-min           475
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        2214
;  :arith-pivots            2774
;  :conflicts               1133
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 526
;  :datatype-occurs-check   217
;  :datatype-splits         112
;  :decisions               2664
;  :del-clause              22270
;  :final-checks            172
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  7.00
;  :minimized-lits          131
;  :mk-bool-var             30364
;  :mk-clause               22408
;  :num-allocs              345944
;  :num-checks              259
;  :propagations            14237
;  :quant-instantiations    6814
;  :rlimit-count            1033911
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
    (as None<option<array>>  option<array>))))
(pop) ; 10
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
    (as None<option<array>>  option<array>))))
(push) ; 10
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 11
(assert (not (<
  unknown@146@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01)))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               18886
;  :arith-add-rows          16251
;  :arith-assert-diseq      1256
;  :arith-assert-lower      5617
;  :arith-assert-upper      3912
;  :arith-bound-prop        1264
;  :arith-conflicts         460
;  :arith-eq-adapter        3751
;  :arith-fixed-eqs         1811
;  :arith-grobner           55
;  :arith-max-min           475
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        2242
;  :arith-pivots            2799
;  :conflicts               1154
;  :datatype-accessor-ax    59
;  :datatype-constructor-ax 530
;  :datatype-occurs-check   217
;  :datatype-splits         112
;  :decisions               2686
;  :del-clause              22405
;  :final-checks            172
;  :interface-eqs           3
;  :max-generation          6
;  :max-memory              7.04
;  :memory                  7.00
;  :minimized-lits          131
;  :mk-bool-var             30597
;  :mk-clause               22543
;  :num-allocs              346862
;  :num-checks              260
;  :propagations            14364
;  :quant-instantiations    6837
;  :rlimit-count            1037666
;  :time                    0.00)
(assert (<
  unknown@146@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))))))
(pop) ; 10
; Joined path conditions
(assert (<
  unknown@146@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))))))
(pop) ; 9
(declare-fun inv@148@01 ($Ref) Int)
(declare-fun inv@149@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((unknown@146@01 Int) (unknown1@147@01 Int)) (!
  (and
    (< unknown1@147@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown@146@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))) unknown@146@01))
  :qid |int-aux|)))
; Check receiver injectivity
(push) ; 9
(assert (not (forall ((unknown1@146@01 Int) (unknown11@147@01 Int) (unknown2@146@01 Int) (unknown12@147@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< unknown11@147@01 V@30@01) (<= 0 unknown11@147@01))
          (< unknown1@146@01 V@30@01))
        (<= 0 unknown1@146@01))
      (and
        (and
          (and (< unknown12@147@01 V@30@01) (<= 0 unknown12@147@01))
          (< unknown2@146@01 V@30@01))
        (<= 0 unknown2@146@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown11@147@01))) unknown1@146@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown12@147@01))) unknown2@146@01)))
    (and
      (= unknown1@146@01 unknown2@146@01)
      (= unknown11@147@01 unknown12@147@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 9
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20255
;  :arith-add-rows          17539
;  :arith-assert-diseq      1341
;  :arith-assert-lower      6066
;  :arith-assert-upper      4232
;  :arith-bound-prop        1381
;  :arith-conflicts         474
;  :arith-eq-adapter        4062
;  :arith-fixed-eqs         1970
;  :arith-grobner           55
;  :arith-max-min           475
;  :arith-nonlinear-bounds  31
;  :arith-nonlinear-horner  44
;  :arith-offset-eqs        2441
;  :arith-pivots            3032
;  :conflicts               1192
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 539
;  :datatype-occurs-check   217
;  :datatype-splits         112
;  :decisions               2937
;  :del-clause              24216
;  :final-checks            172
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32623
;  :mk-clause               24225
;  :num-allocs              354263
;  :num-checks              261
;  :propagations            15440
;  :quant-instantiations    7281
;  :rlimit-count            1090419
;  :time                    0.01)
; Definitional axioms for inverse functions
(assert (forall ((unknown@146@01 Int) (unknown1@147@01 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@147@01 V@30@01) (<= 0 unknown1@147@01))
        (< unknown@146@01 V@30@01))
      (<= 0 unknown@146@01))
    (and
      (=
        (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))) unknown@146@01))
        unknown@146@01)
      (=
        (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))) unknown@146@01))
        unknown1@147@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))) unknown@146@01))
  )))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@149@01 r)))) (inv@148@01 r))
      r))
  :pattern ((inv@148@01 r))
  :pattern ((inv@149@01 r))
  :qid |int-fctOfInv|)))
; Permissions are non-negative
; Field permissions are at most one
; Permission implies non-null receiver
(assert (forall ((unknown@146@01 Int) (unknown1@147@01 Int)) (!
  (implies
    (and
      (and
        (and (< unknown1@147@01 V@30@01) (<= 0 unknown1@147@01))
        (< unknown@146@01 V@30@01))
      (<= 0 unknown@146@01))
    (not
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))) unknown@146@01)
        $Ref.null)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown1@147@01))) unknown@146@01))
  :qid |int-permImpliesNonNull|)))
(declare-const sm@150@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@150@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef42|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@150@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef43|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@150@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef44|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r))
  :pattern ((inv@148@01 r) (inv@149@01 r))
  )))
; State saturation: after contract
(set-option :timeout 50)
(check-sat)
; unknown
; [eval] exc != null
; [then-branch: 179 | exc@122@01 != Null | dead]
; [else-branch: 179 | exc@122@01 == Null | live]
(push) ; 9
; [else-branch: 179 | exc@122@01 == Null]
(pop) ; 9
; [eval] !(exc != null)
; [eval] exc != null
(set-option :timeout 10)
(push) ; 9
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 9
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20333
;  :arith-add-rows          17539
;  :arith-assert-diseq      1341
;  :arith-assert-lower      6089
;  :arith-assert-upper      4247
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4062
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3032
;  :conflicts               1193
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 555
;  :datatype-occurs-check   230
;  :datatype-splits         120
;  :decisions               2954
;  :del-clause              24216
;  :final-checks            179
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32638
;  :mk-clause               24225
;  :num-allocs              356822
;  :num-checks              263
;  :propagations            15446
;  :quant-instantiations    7281
;  :rlimit-count            1095888)
; [then-branch: 180 | exc@122@01 == Null | live]
; [else-branch: 180 | exc@122@01 != Null | dead]
(push) ; 9
; [then-branch: 180 | exc@122@01 == Null]
; [exec]
; evaluationDummy := res1
; [exec]
; label end
; [exec]
; res := return
; [exec]
; label bubble
; [eval] exc == null
; [eval] exc == null ==> source != (None(): option[array])
; [eval] exc == null
(push) ; 10
(push) ; 11
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20370
;  :arith-add-rows          17539
;  :arith-assert-diseq      1341
;  :arith-assert-lower      6089
;  :arith-assert-upper      4247
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4062
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3032
;  :conflicts               1193
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 563
;  :datatype-occurs-check   235
;  :datatype-splits         124
;  :decisions               2962
;  :del-clause              24216
;  :final-checks            181
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32642
;  :mk-clause               24225
;  :num-allocs              357430
;  :num-checks              264
;  :propagations            15446
;  :quant-instantiations    7281
;  :rlimit-count            1096555)
; [then-branch: 181 | exc@122@01 == Null | live]
; [else-branch: 181 | exc@122@01 != Null | dead]
(push) ; 11
; [then-branch: 181 | exc@122@01 == Null]
; [eval] source != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (not (= source@28@01 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20370
;  :arith-add-rows          17539
;  :arith-assert-diseq      1341
;  :arith-assert-lower      6089
;  :arith-assert-upper      4247
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4062
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3032
;  :conflicts               1193
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 563
;  :datatype-occurs-check   235
;  :datatype-splits         124
;  :decisions               2962
;  :del-clause              24216
;  :final-checks            181
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32642
;  :mk-clause               24225
;  :num-allocs              357455
;  :num-checks              265
;  :propagations            15446
;  :quant-instantiations    7281
;  :rlimit-count            1096575)
(assert (implies
  (= exc@122@01 $Ref.null)
  (not (= source@28@01 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(source)) == V
; [eval] exc == null
(push) ; 10
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20407
;  :arith-add-rows          17539
;  :arith-assert-diseq      1341
;  :arith-assert-lower      6089
;  :arith-assert-upper      4247
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4062
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3032
;  :conflicts               1193
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 571
;  :datatype-occurs-check   240
;  :datatype-splits         128
;  :decisions               2970
;  :del-clause              24216
;  :final-checks            183
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32646
;  :mk-clause               24225
;  :num-allocs              358065
;  :num-checks              266
;  :propagations            15446
;  :quant-instantiations    7281
;  :rlimit-count            1097242)
; [then-branch: 182 | exc@122@01 == Null | live]
; [else-branch: 182 | exc@122@01 != Null | dead]
(push) ; 11
; [then-branch: 182 | exc@122@01 == Null]
; [eval] alen(opt_get1(source)) == V
; [eval] alen(opt_get1(source))
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(pop) ; 11
(pop) ; 10
; Joined path conditions
(set-option :timeout 0)
(push) ; 10
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit source@28@01)) V@30@01))))
(check-sat)
; unsat
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20407
;  :arith-add-rows          17539
;  :arith-assert-diseq      1341
;  :arith-assert-lower      6089
;  :arith-assert-upper      4247
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4062
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3032
;  :conflicts               1193
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 571
;  :datatype-occurs-check   240
;  :datatype-splits         128
;  :decisions               2970
;  :del-clause              24216
;  :final-checks            183
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32646
;  :mk-clause               24225
;  :num-allocs              358084
;  :num-checks              267
;  :propagations            15446
;  :quant-instantiations    7281
;  :rlimit-count            1097267)
(assert (implies
  (= exc@122@01 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit source@28@01)) V@30@01)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 10
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 10
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20444
;  :arith-add-rows          17539
;  :arith-assert-diseq      1341
;  :arith-assert-lower      6089
;  :arith-assert-upper      4247
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4062
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3032
;  :conflicts               1193
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 579
;  :datatype-occurs-check   245
;  :datatype-splits         132
;  :decisions               2978
;  :del-clause              24216
;  :final-checks            185
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32650
;  :mk-clause               24225
;  :num-allocs              358694
;  :num-checks              268
;  :propagations            15446
;  :quant-instantiations    7281
;  :rlimit-count            1097929)
; [then-branch: 183 | exc@122@01 == Null | live]
; [else-branch: 183 | exc@122@01 != Null | dead]
(push) ; 10
; [then-branch: 183 | exc@122@01 == Null]
(declare-const i1@151@01 Int)
(push) ; 11
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 12
; [then-branch: 184 | 0 <= i1@151@01 | live]
; [else-branch: 184 | !(0 <= i1@151@01) | live]
(push) ; 13
; [then-branch: 184 | 0 <= i1@151@01]
(assert (<= 0 i1@151@01))
; [eval] i1 < V
(pop) ; 13
(push) ; 13
; [else-branch: 184 | !(0 <= i1@151@01)]
(assert (not (<= 0 i1@151@01)))
(pop) ; 13
(pop) ; 12
; Joined path conditions
; Joined path conditions
(assert (and (< i1@151@01 V@30@01) (<= 0 i1@151@01)))
(declare-const $k@152@01 $Perm)
(assert ($Perm.isReadVar $k@152@01 $Perm.Write))
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 12
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
; Joined path conditions
(push) ; 12
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 13
(assert (not (< i1@151@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20444
;  :arith-add-rows          17539
;  :arith-assert-diseq      1342
;  :arith-assert-lower      6093
;  :arith-assert-upper      4248
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4063
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3033
;  :conflicts               1193
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 579
;  :datatype-occurs-check   245
;  :datatype-splits         132
;  :decisions               2978
;  :del-clause              24216
;  :final-checks            185
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32656
;  :mk-clause               24227
;  :num-allocs              358859
;  :num-checks              269
;  :propagations            15447
;  :quant-instantiations    7281
;  :rlimit-count            1098260)
(assert (< i1@151@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 12
; Joined path conditions
(assert (< i1@151@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 11
(declare-fun inv@153@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@152@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@151@01 Int)) (!
  (< i1@151@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@151@01))
  :qid |option$array$-aux|)))
(push) ; 11
(assert (not (forall ((i1@151@01 Int)) (!
  (implies
    (and (< i1@151@01 V@30@01) (<= 0 i1@151@01))
    (or (= $k@152@01 $Perm.No) (< $Perm.No $k@152@01)))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20444
;  :arith-add-rows          17539
;  :arith-assert-diseq      1343
;  :arith-assert-lower      6095
;  :arith-assert-upper      4249
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4064
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3034
;  :conflicts               1194
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 579
;  :datatype-occurs-check   245
;  :datatype-splits         132
;  :decisions               2978
;  :del-clause              24218
;  :final-checks            185
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32663
;  :mk-clause               24229
;  :num-allocs              359292
;  :num-checks              270
;  :propagations            15448
;  :quant-instantiations    7281
;  :rlimit-count            1098809)
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 11
(assert (not (forall ((i11@151@01 Int) (i12@151@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@151@01 V@30@01) (<= 0 i11@151@01))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@151@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@151@01)))
        (< $Perm.No $k@152@01))
      (and
        (and
          (and (< i12@151@01 V@30@01) (<= 0 i12@151@01))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@151@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@151@01)))
        (< $Perm.No $k@152@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@151@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@151@01)))
    (= i11@151@01 i12@151@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               20455
;  :arith-add-rows          17541
;  :arith-assert-diseq      1344
;  :arith-assert-lower      6099
;  :arith-assert-upper      4249
;  :arith-bound-prop        1381
;  :arith-conflicts         475
;  :arith-eq-adapter        4065
;  :arith-fixed-eqs         1970
;  :arith-grobner           60
;  :arith-max-min           513
;  :arith-nonlinear-bounds  33
;  :arith-nonlinear-horner  48
;  :arith-offset-eqs        2443
;  :arith-pivots            3034
;  :conflicts               1195
;  :datatype-accessor-ax    60
;  :datatype-constructor-ax 579
;  :datatype-occurs-check   245
;  :datatype-splits         132
;  :decisions               2978
;  :del-clause              24270
;  :final-checks            185
;  :interface-eqs           3
;  :max-generation          7
;  :max-memory              7.16
;  :memory                  7.10
;  :minimized-lits          159
;  :mk-bool-var             32743
;  :mk-clause               24281
;  :num-allocs              359887
;  :num-checks              271
;  :propagations            15452
;  :quant-instantiations    7306
;  :rlimit-count            1100283)
; Definitional axioms for inverse functions
(assert (forall ((i1@151@01 Int)) (!
  (implies
    (and (and (< i1@151@01 V@30@01) (<= 0 i1@151@01)) (< $Perm.No $k@152@01))
    (=
      (inv@153@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@151@01))
      i1@151@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@151@01))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
      (< $Perm.No $k@152@01))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@153@01 r))
      r))
  :pattern ((inv@153@01 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r))
  :pattern ((inv@153@01 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@154@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
    ($Perm.min
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)
      $k@152@01)
    $Perm.No))
(define-fun pTaken@155@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
    ($Perm.min
      (ite
        (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)
        $Perm.No)
      (- $k@152@01 (pTaken@154@01 r)))
    $Perm.No))
(define-fun pTaken@156@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r))
      (- (- $k@152@01 (pTaken@154@01 r)) (pTaken@155@01 r)))
    $Perm.No))
(define-fun pTaken@157@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r))
      (- (- (- $k@152@01 (pTaken@154@01 r)) (pTaken@155@01 r)) (pTaken@156@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@152@01
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        (ite
          (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
          $k@152@01
          $Perm.No)
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      (<
        (ite
          (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
          $k@152@01
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@135@01 r))
  :pattern ((inv@153@01 r))
  :qid |qp.srp45|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
    (= (- $k@152@01 (pTaken@154@01 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21519
;  :arith-add-rows          18155
;  :arith-assert-diseq      1425
;  :arith-assert-lower      6422
;  :arith-assert-upper      4475
;  :arith-bound-prop        1429
;  :arith-conflicts         490
;  :arith-eq-adapter        4220
;  :arith-fixed-eqs         2061
;  :arith-grobner           78
;  :arith-max-min           659
;  :arith-nonlinear-bounds  58
;  :arith-nonlinear-horner  65
;  :arith-offset-eqs        2609
;  :arith-pivots            3164
;  :arith-pseudo-nonlinear  4
;  :conflicts               1221
;  :datatype-accessor-ax    81
;  :datatype-constructor-ax 658
;  :datatype-occurs-check   306
;  :datatype-splits         207
;  :decisions               3271
;  :del-clause              25349
;  :final-checks            217
;  :interface-eqs           11
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          165
;  :mk-bool-var             34010
;  :mk-clause               25358
;  :num-allocs              368276
;  :num-checks              273
;  :propagations            16084
;  :quant-instantiations    7529
;  :rlimit-count            1141687
;  :time                    0.01)
; Constrain original permissions $k@152@01
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No)
        $Perm.No))
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        (ite
          (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
          $k@152@01
          $Perm.No)
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      (<
        (ite
          (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
          $k@152@01
          $Perm.No)
        $Perm.No)))
  :pattern ((inv@127@01 r))
  :pattern ((inv@153@01 r))
  :qid |qp.srp46|)))
; Intermediate check if already taken enough permissions
(push) ; 11
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@153@01 r) V@30@01) (<= 0 (inv@153@01 r)))
    (= (- (- $k@152@01 (pTaken@154@01 r)) (pTaken@155@01 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               21983
;  :arith-add-rows          18506
;  :arith-assert-diseq      1459
;  :arith-assert-lower      6550
;  :arith-assert-upper      4546
;  :arith-bound-prop        1463
;  :arith-conflicts         501
;  :arith-eq-adapter        4313
;  :arith-fixed-eqs         2094
;  :arith-grobner           78
;  :arith-max-min           675
;  :arith-nonlinear-bounds  62
;  :arith-nonlinear-horner  65
;  :arith-offset-eqs        2658
;  :arith-pivots            3240
;  :arith-pseudo-nonlinear  4
;  :conflicts               1247
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 675
;  :datatype-occurs-check   314
;  :datatype-splits         224
;  :decisions               3378
;  :del-clause              26046
;  :final-checks            226
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.15
;  :minimized-lits          174
;  :mk-bool-var             34964
;  :mk-clause               26055
;  :num-allocs              371413
;  :num-checks              274
;  :propagations            16359
;  :quant-instantiations    7631
;  :rlimit-count            1156219
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22020
;  :arith-add-rows          18506
;  :arith-assert-diseq      1459
;  :arith-assert-lower      6565
;  :arith-assert-upper      4554
;  :arith-bound-prop        1463
;  :arith-conflicts         501
;  :arith-eq-adapter        4313
;  :arith-fixed-eqs         2094
;  :arith-grobner           83
;  :arith-max-min           701
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  69
;  :arith-offset-eqs        2658
;  :arith-pivots            3240
;  :arith-pseudo-nonlinear  4
;  :conflicts               1247
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 683
;  :datatype-occurs-check   319
;  :datatype-splits         228
;  :decisions               3386
;  :del-clause              26046
;  :final-checks            230
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          174
;  :mk-bool-var             34968
;  :mk-clause               26055
;  :num-allocs              372237
;  :num-checks              275
;  :propagations            16359
;  :quant-instantiations    7631
;  :rlimit-count            1157462)
; [then-branch: 185 | exc@122@01 == Null | live]
; [else-branch: 185 | exc@122@01 != Null | dead]
(push) ; 12
; [then-branch: 185 | exc@122@01 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array]))
(declare-const i1@158@01 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 186 | 0 <= i1@158@01 | live]
; [else-branch: 186 | !(0 <= i1@158@01) | live]
(push) ; 15
; [then-branch: 186 | 0 <= i1@158@01]
(assert (<= 0 i1@158@01))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 186 | !(0 <= i1@158@01)]
(assert (not (<= 0 i1@158@01)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 187 | i1@158@01 < V@30@01 && 0 <= i1@158@01 | live]
; [else-branch: 187 | !(i1@158@01 < V@30@01 && 0 <= i1@158@01) | live]
(push) ; 15
; [then-branch: 187 | i1@158@01 < V@30@01 && 0 <= i1@158@01]
(assert (and (< i1@158@01 V@30@01) (<= 0 i1@158@01)))
; [eval] aloc(opt_get1(source), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@158@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22020
;  :arith-add-rows          18506
;  :arith-assert-diseq      1459
;  :arith-assert-lower      6567
;  :arith-assert-upper      4554
;  :arith-bound-prop        1463
;  :arith-conflicts         501
;  :arith-eq-adapter        4313
;  :arith-fixed-eqs         2094
;  :arith-grobner           83
;  :arith-max-min           701
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  69
;  :arith-offset-eqs        2658
;  :arith-pivots            3241
;  :arith-pseudo-nonlinear  4
;  :conflicts               1247
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 683
;  :datatype-occurs-check   319
;  :datatype-splits         228
;  :decisions               3386
;  :del-clause              26046
;  :final-checks            230
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          174
;  :mk-bool-var             34970
;  :mk-clause               26055
;  :num-allocs              372341
;  :num-checks              276
;  :propagations            16359
;  :quant-instantiations    7631
;  :rlimit-count            1157661)
(assert (< i1@158@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 16
; Joined path conditions
(assert (< i1@158@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               22891
;  :arith-add-rows          19614
;  :arith-assert-diseq      1541
;  :arith-assert-lower      6867
;  :arith-assert-upper      4775
;  :arith-bound-prop        1558
;  :arith-conflicts         526
;  :arith-eq-adapter        4562
;  :arith-fixed-eqs         2199
;  :arith-grobner           83
;  :arith-max-min           701
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  69
;  :arith-offset-eqs        2813
;  :arith-pivots            3363
;  :arith-pseudo-nonlinear  4
;  :conflicts               1293
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 687
;  :datatype-occurs-check   319
;  :datatype-splits         228
;  :decisions               3523
;  :del-clause              27243
;  :final-checks            230
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.18
;  :minimized-lits          177
;  :mk-bool-var             36607
;  :mk-clause               27405
;  :num-allocs              377633
;  :num-checks              277
;  :propagations            17089
;  :quant-instantiations    7804
;  :rlimit-count            1194076
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 15
(push) ; 15
; [else-branch: 187 | !(i1@158@01 < V@30@01 && 0 <= i1@158@01)]
(assert (not (and (< i1@158@01 V@30@01) (<= 0 i1@158@01))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@158@01 V@30@01) (<= 0 i1@158@01))
  (and
    (< i1@158@01 V@30@01)
    (<= 0 i1@158@01)
    (< i1@158@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@158@01 Int)) (!
  (implies
    (and (< i1@158@01 V@30@01) (<= 0 i1@158@01))
    (and
      (< i1@158@01 V@30@01)
      (<= 0 i1@158@01)
      (< i1@158@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@158@01 Int)) (!
    (implies
      (and (< i1@158@01 V@30@01) (<= 0 i1@158@01))
      (and
        (< i1@158@01 V@30@01)
        (<= 0 i1@158@01)
        (< i1@158@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@158@01 Int)) (!
    (implies
      (and (< i1@158@01 V@30@01) (<= 0 i1@158@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23113
;  :arith-add-rows          19806
;  :arith-assert-diseq      1550
;  :arith-assert-lower      6935
;  :arith-assert-upper      4810
;  :arith-bound-prop        1573
;  :arith-conflicts         533
;  :arith-eq-adapter        4611
;  :arith-fixed-eqs         2213
;  :arith-grobner           83
;  :arith-max-min           701
;  :arith-nonlinear-bounds  65
;  :arith-nonlinear-horner  69
;  :arith-offset-eqs        2842
;  :arith-pivots            3421
;  :arith-pseudo-nonlinear  4
;  :conflicts               1307
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 691
;  :datatype-occurs-check   319
;  :datatype-splits         228
;  :decisions               3579
;  :del-clause              27886
;  :final-checks            230
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.15
;  :minimized-lits          177
;  :mk-bool-var             37183
;  :mk-clause               27895
;  :num-allocs              379808
;  :num-checks              278
;  :propagations            17263
;  :quant-instantiations    7924
;  :rlimit-count            1204728
;  :time                    0.00)
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@158@01 Int)) (!
    (implies
      (and (< i1@158@01 V@30@01) (<= 0 i1@158@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@158@01))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23150
;  :arith-add-rows          19806
;  :arith-assert-diseq      1550
;  :arith-assert-lower      6950
;  :arith-assert-upper      4818
;  :arith-bound-prop        1573
;  :arith-conflicts         533
;  :arith-eq-adapter        4611
;  :arith-fixed-eqs         2213
;  :arith-grobner           88
;  :arith-max-min           727
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  73
;  :arith-offset-eqs        2842
;  :arith-pivots            3421
;  :arith-pseudo-nonlinear  4
;  :conflicts               1307
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 699
;  :datatype-occurs-check   324
;  :datatype-splits         232
;  :decisions               3587
;  :del-clause              27886
;  :final-checks            234
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          177
;  :mk-bool-var             37188
;  :mk-clause               27895
;  :num-allocs              380828
;  :num-checks              279
;  :propagations            17263
;  :quant-instantiations    7924
;  :rlimit-count            1206282)
; [then-branch: 188 | exc@122@01 == Null | live]
; [else-branch: 188 | exc@122@01 != Null | dead]
(push) ; 12
; [then-branch: 188 | exc@122@01 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V)
(declare-const i1@159@01 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 189 | 0 <= i1@159@01 | live]
; [else-branch: 189 | !(0 <= i1@159@01) | live]
(push) ; 15
; [then-branch: 189 | 0 <= i1@159@01]
(assert (<= 0 i1@159@01))
; [eval] i1 < V
(pop) ; 15
(push) ; 15
; [else-branch: 189 | !(0 <= i1@159@01)]
(assert (not (<= 0 i1@159@01)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(push) ; 14
; [then-branch: 190 | i1@159@01 < V@30@01 && 0 <= i1@159@01 | live]
; [else-branch: 190 | !(i1@159@01 < V@30@01 && 0 <= i1@159@01) | live]
(push) ; 15
; [then-branch: 190 | i1@159@01 < V@30@01 && 0 <= i1@159@01]
(assert (and (< i1@159@01 V@30@01) (<= 0 i1@159@01)))
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(source), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 16
; Joined path conditions
(push) ; 16
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 17
(assert (not (< i1@159@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               23150
;  :arith-add-rows          19806
;  :arith-assert-diseq      1550
;  :arith-assert-lower      6952
;  :arith-assert-upper      4818
;  :arith-bound-prop        1573
;  :arith-conflicts         533
;  :arith-eq-adapter        4611
;  :arith-fixed-eqs         2213
;  :arith-grobner           88
;  :arith-max-min           727
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  73
;  :arith-offset-eqs        2842
;  :arith-pivots            3421
;  :arith-pseudo-nonlinear  4
;  :conflicts               1307
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 699
;  :datatype-occurs-check   324
;  :datatype-splits         232
;  :decisions               3587
;  :del-clause              27886
;  :final-checks            234
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.16
;  :minimized-lits          177
;  :mk-bool-var             37190
;  :mk-clause               27895
;  :num-allocs              380932
;  :num-checks              280
;  :propagations            17263
;  :quant-instantiations    7924
;  :rlimit-count            1206477)
(assert (< i1@159@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 16
; Joined path conditions
(assert (< i1@159@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)))
(push) ; 16
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24336
;  :arith-add-rows          21454
;  :arith-assert-diseq      1664
;  :arith-assert-lower      7312
;  :arith-assert-upper      5111
;  :arith-bound-prop        1649
;  :arith-conflicts         566
;  :arith-eq-adapter        4903
;  :arith-fixed-eqs         2379
;  :arith-grobner           88
;  :arith-max-min           727
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  73
;  :arith-offset-eqs        3027
;  :arith-pivots            3596
;  :arith-pseudo-nonlinear  4
;  :conflicts               1365
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 703
;  :datatype-occurs-check   324
;  :datatype-splits         232
;  :decisions               3791
;  :del-clause              29149
;  :final-checks            234
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.20
;  :minimized-lits          178
;  :mk-bool-var             38858
;  :mk-clause               29311
;  :num-allocs              386553
;  :num-checks              281
;  :propagations            18229
;  :quant-instantiations    8164
;  :rlimit-count            1268487
;  :time                    0.01)
(push) ; 16
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 17
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 17
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24336
;  :arith-add-rows          21454
;  :arith-assert-diseq      1664
;  :arith-assert-lower      7312
;  :arith-assert-upper      5111
;  :arith-bound-prop        1649
;  :arith-conflicts         566
;  :arith-eq-adapter        4903
;  :arith-fixed-eqs         2379
;  :arith-grobner           88
;  :arith-max-min           727
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  73
;  :arith-offset-eqs        3027
;  :arith-pivots            3596
;  :arith-pseudo-nonlinear  4
;  :conflicts               1366
;  :datatype-accessor-ax    84
;  :datatype-constructor-ax 703
;  :datatype-occurs-check   324
;  :datatype-splits         232
;  :decisions               3791
;  :del-clause              29149
;  :final-checks            234
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.20
;  :minimized-lits          178
;  :mk-bool-var             38858
;  :mk-clause               29311
;  :num-allocs              386644
;  :num-checks              282
;  :propagations            18229
;  :quant-instantiations    8164
;  :rlimit-count            1268582)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
    (as None<option<array>>  option<array>))))
(pop) ; 16
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
    (as None<option<array>>  option<array>))))
(pop) ; 15
(push) ; 15
; [else-branch: 190 | !(i1@159@01 < V@30@01 && 0 <= i1@159@01)]
(assert (not (and (< i1@159@01 V@30@01) (<= 0 i1@159@01))))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (and (< i1@159@01 V@30@01) (<= 0 i1@159@01))
  (and
    (< i1@159@01 V@30@01)
    (<= 0 i1@159@01)
    (< i1@159@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@159@01 Int)) (!
  (implies
    (and (< i1@159@01 V@30@01) (<= 0 i1@159@01))
    (and
      (< i1@159@01 V@30@01)
      (<= 0 i1@159@01)
      (< i1@159@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@159@01 Int)) (!
    (implies
      (and (< i1@159@01 V@30@01) (<= 0 i1@159@01))
      (and
        (< i1@159@01 V@30@01)
        (<= 0 i1@159@01)
        (< i1@159@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@159@01 Int)) (!
    (implies
      (and (< i1@159@01 V@30@01) (<= 0 i1@159@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24701
;  :arith-add-rows          21693
;  :arith-assert-diseq      1681
;  :arith-assert-lower      7408
;  :arith-assert-upper      5176
;  :arith-bound-prop        1676
;  :arith-conflicts         572
;  :arith-eq-adapter        4965
;  :arith-fixed-eqs         2413
;  :arith-grobner           88
;  :arith-max-min           727
;  :arith-nonlinear-bounds  68
;  :arith-nonlinear-horner  73
;  :arith-offset-eqs        3074
;  :arith-pivots            3649
;  :arith-pseudo-nonlinear  4
;  :conflicts               1385
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 708
;  :datatype-occurs-check   324
;  :datatype-splits         232
;  :decisions               3890
;  :del-clause              29896
;  :final-checks            234
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.18
;  :minimized-lits          178
;  :mk-bool-var             39565
;  :mk-clause               29905
;  :num-allocs              388961
;  :num-checks              283
;  :propagations            18511
;  :quant-instantiations    8300
;  :rlimit-count            1281907
;  :time                    0.00)
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@159@01 Int)) (!
    (implies
      (and (< i1@159@01 V@30@01) (<= 0 i1@159@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@159@01)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24738
;  :arith-add-rows          21693
;  :arith-assert-diseq      1681
;  :arith-assert-lower      7423
;  :arith-assert-upper      5184
;  :arith-bound-prop        1676
;  :arith-conflicts         572
;  :arith-eq-adapter        4965
;  :arith-fixed-eqs         2413
;  :arith-grobner           93
;  :arith-max-min           753
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  77
;  :arith-offset-eqs        3074
;  :arith-pivots            3649
;  :arith-pseudo-nonlinear  4
;  :conflicts               1385
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 716
;  :datatype-occurs-check   329
;  :datatype-splits         236
;  :decisions               3898
;  :del-clause              29896
;  :final-checks            238
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.18
;  :minimized-lits          178
;  :mk-bool-var             39570
;  :mk-clause               29905
;  :num-allocs              389980
;  :num-checks              284
;  :propagations            18511
;  :quant-instantiations    8300
;  :rlimit-count            1283463)
; [then-branch: 191 | exc@122@01 == Null | live]
; [else-branch: 191 | exc@122@01 != Null | dead]
(push) ; 12
; [then-branch: 191 | exc@122@01 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(source), i1) } (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2))
(declare-const i1@160@01 Int)
(push) ; 13
; [eval] (forall i2: Int :: { aloc(opt_get1(source), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2)
(declare-const i2@161@01 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 192 | 0 <= i1@160@01 | live]
; [else-branch: 192 | !(0 <= i1@160@01) | live]
(push) ; 16
; [then-branch: 192 | 0 <= i1@160@01]
(assert (<= 0 i1@160@01))
; [eval] i1 < V
(push) ; 17
; [then-branch: 193 | i1@160@01 < V@30@01 | live]
; [else-branch: 193 | !(i1@160@01 < V@30@01) | live]
(push) ; 18
; [then-branch: 193 | i1@160@01 < V@30@01]
(assert (< i1@160@01 V@30@01))
; [eval] 0 <= i2
(push) ; 19
; [then-branch: 194 | 0 <= i2@161@01 | live]
; [else-branch: 194 | !(0 <= i2@161@01) | live]
(push) ; 20
; [then-branch: 194 | 0 <= i2@161@01]
(assert (<= 0 i2@161@01))
; [eval] i2 < V
(push) ; 21
; [then-branch: 195 | i2@161@01 < V@30@01 | live]
; [else-branch: 195 | !(i2@161@01 < V@30@01) | live]
(push) ; 22
; [then-branch: 195 | i2@161@01 < V@30@01]
(assert (< i2@161@01 V@30@01))
; [eval] aloc(opt_get1(source), i1).option$array$ == aloc(opt_get1(source), i2).option$array$
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 24
(assert (not (< i1@160@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               24738
;  :arith-add-rows          21693
;  :arith-assert-diseq      1681
;  :arith-assert-lower      7427
;  :arith-assert-upper      5184
;  :arith-bound-prop        1676
;  :arith-conflicts         572
;  :arith-eq-adapter        4965
;  :arith-fixed-eqs         2413
;  :arith-grobner           93
;  :arith-max-min           753
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  77
;  :arith-offset-eqs        3074
;  :arith-pivots            3651
;  :arith-pseudo-nonlinear  4
;  :conflicts               1385
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 716
;  :datatype-occurs-check   329
;  :datatype-splits         236
;  :decisions               3898
;  :del-clause              29896
;  :final-checks            238
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.21
;  :memory                  7.18
;  :minimized-lits          178
;  :mk-bool-var             39574
;  :mk-clause               29905
;  :num-allocs              390261
;  :num-checks              285
;  :propagations            18511
;  :quant-instantiations    8300
;  :rlimit-count            1283812)
(assert (< i1@160@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 23
; Joined path conditions
(assert (< i1@160@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25503
;  :arith-add-rows          22363
;  :arith-assert-diseq      1753
;  :arith-assert-lower      7684
;  :arith-assert-upper      5401
;  :arith-bound-prop        1734
;  :arith-conflicts         592
;  :arith-eq-adapter        5185
;  :arith-fixed-eqs         2500
;  :arith-grobner           93
;  :arith-max-min           753
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  77
;  :arith-offset-eqs        3148
;  :arith-pivots            3744
;  :arith-pseudo-nonlinear  4
;  :conflicts               1425
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 720
;  :datatype-occurs-check   329
;  :datatype-splits         236
;  :decisions               4024
;  :del-clause              30864
;  :final-checks            238
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.27
;  :memory                  7.24
;  :minimized-lits          180
;  :mk-bool-var             40928
;  :mk-clause               31026
;  :num-allocs              395084
;  :num-checks              286
;  :propagations            19244
;  :quant-instantiations    8541
;  :rlimit-count            1313631
;  :time                    0.01)
; [eval] aloc(opt_get1(source), i2)
; [eval] opt_get1(source)
(push) ; 23
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 23
; Joined path conditions
(push) ; 23
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 24
(assert (not (< i2@161@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 24
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               25503
;  :arith-add-rows          22363
;  :arith-assert-diseq      1753
;  :arith-assert-lower      7684
;  :arith-assert-upper      5401
;  :arith-bound-prop        1734
;  :arith-conflicts         592
;  :arith-eq-adapter        5185
;  :arith-fixed-eqs         2500
;  :arith-grobner           93
;  :arith-max-min           753
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  77
;  :arith-offset-eqs        3148
;  :arith-pivots            3744
;  :arith-pseudo-nonlinear  4
;  :conflicts               1425
;  :datatype-accessor-ax    85
;  :datatype-constructor-ax 720
;  :datatype-occurs-check   329
;  :datatype-splits         236
;  :decisions               4024
;  :del-clause              30864
;  :final-checks            238
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.27
;  :memory                  7.24
;  :minimized-lits          180
;  :mk-bool-var             40928
;  :mk-clause               31026
;  :num-allocs              395111
;  :num-checks              287
;  :propagations            19244
;  :quant-instantiations    8541
;  :rlimit-count            1313661)
(assert (< i2@161@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 23
; Joined path conditions
(assert (< i2@161@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
(push) ; 23
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29012
;  :arith-add-rows          24912
;  :arith-assert-diseq      2150
;  :arith-assert-lower      8811
;  :arith-assert-upper      6331
;  :arith-bound-prop        1903
;  :arith-conflicts         647
;  :arith-eq-adapter        5982
;  :arith-fixed-eqs         2832
;  :arith-grobner           93
;  :arith-max-min           753
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  77
;  :arith-offset-eqs        3583
;  :arith-pivots            4029
;  :arith-pseudo-nonlinear  4
;  :conflicts               1525
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 725
;  :datatype-occurs-check   329
;  :datatype-splits         236
;  :decisions               4425
;  :del-clause              35381
;  :final-checks            238
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              7.68
;  :memory                  7.65
;  :minimized-lits          238
;  :mk-bool-var             46432
;  :mk-clause               35700
;  :num-allocs              414002
;  :num-checks              288
;  :propagations            23233
;  :quant-instantiations    10207
;  :rlimit-count            1449594
;  :time                    0.03)
(pop) ; 22
(push) ; 22
; [else-branch: 195 | !(i2@161@01 < V@30@01)]
(assert (not (< i2@161@01 V@30@01)))
(pop) ; 22
(pop) ; 21
; Joined path conditions
(assert (implies
  (< i2@161@01 V@30@01)
  (and
    (< i2@161@01 V@30@01)
    (< i1@160@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
    (< i2@161@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))))
; Joined path conditions
(pop) ; 20
(push) ; 20
; [else-branch: 194 | !(0 <= i2@161@01)]
(assert (not (<= 0 i2@161@01)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
(assert (implies
  (<= 0 i2@161@01)
  (and
    (<= 0 i2@161@01)
    (implies
      (< i2@161@01 V@30@01)
      (and
        (< i2@161@01 V@30@01)
        (< i1@160@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
        (< i2@161@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))))))
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 193 | !(i1@160@01 < V@30@01)]
(assert (not (< i1@160@01 V@30@01)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (< i1@160@01 V@30@01)
  (and
    (< i1@160@01 V@30@01)
    (implies
      (<= 0 i2@161@01)
      (and
        (<= 0 i2@161@01)
        (implies
          (< i2@161@01 V@30@01)
          (and
            (< i2@161@01 V@30@01)
            (< i1@160@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
            (< i2@161@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))))))))
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 192 | !(0 <= i1@160@01)]
(assert (not (<= 0 i1@160@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (<= 0 i1@160@01)
  (and
    (<= 0 i1@160@01)
    (implies
      (< i1@160@01 V@30@01)
      (and
        (< i1@160@01 V@30@01)
        (implies
          (<= 0 i2@161@01)
          (and
            (<= 0 i2@161@01)
            (implies
              (< i2@161@01 V@30@01)
              (and
                (< i2@161@01 V@30@01)
                (< i1@160@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                (< i2@161@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))))))))))
; Joined path conditions
(push) ; 15
; [then-branch: 196 | Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, source@28@01), i1@160@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, source@28@01), i2@161@01)) && i2@161@01 < V@30@01 && 0 <= i2@161@01 && i1@160@01 < V@30@01 && 0 <= i1@160@01 | live]
; [else-branch: 196 | !(Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, source@28@01), i1@160@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, source@28@01), i2@161@01)) && i2@161@01 < V@30@01 && 0 <= i2@161@01 && i1@160@01 < V@30@01 && 0 <= i1@160@01) | live]
(push) ; 16
; [then-branch: 196 | Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, source@28@01), i1@160@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, source@28@01), i2@161@01)) && i2@161@01 < V@30@01 && 0 <= i2@161@01 && i1@160@01 < V@30@01 && 0 <= i1@160@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
        (< i2@161@01 V@30@01))
      (<= 0 i2@161@01))
    (< i1@160@01 V@30@01))
  (<= 0 i1@160@01)))
; [eval] i1 == i2
(pop) ; 16
(push) ; 16
; [else-branch: 196 | !(Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, source@28@01), i1@160@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, source@28@01), i2@161@01)) && i2@161@01 < V@30@01 && 0 <= i2@161@01 && i1@160@01 < V@30@01 && 0 <= i1@160@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
          (< i2@161@01 V@30@01))
        (<= 0 i2@161@01))
      (< i1@160@01 V@30@01))
    (<= 0 i1@160@01))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
          (< i2@161@01 V@30@01))
        (<= 0 i2@161@01))
      (< i1@160@01 V@30@01))
    (<= 0 i1@160@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
    (< i2@161@01 V@30@01)
    (<= 0 i2@161@01)
    (< i1@160@01 V@30@01)
    (<= 0 i1@160@01))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@161@01 Int)) (!
  (and
    (implies
      (<= 0 i1@160@01)
      (and
        (<= 0 i1@160@01)
        (implies
          (< i1@160@01 V@30@01)
          (and
            (< i1@160@01 V@30@01)
            (implies
              (<= 0 i2@161@01)
              (and
                (<= 0 i2@161@01)
                (implies
                  (< i2@161@01 V@30@01)
                  (and
                    (< i2@161@01 V@30@01)
                    (< i1@160@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                    (< i2@161@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
              (< i2@161@01 V@30@01))
            (<= 0 i2@161@01))
          (< i1@160@01 V@30@01))
        (<= 0 i1@160@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
        (< i2@161@01 V@30@01)
        (<= 0 i2@161@01)
        (< i1@160@01 V@30@01)
        (<= 0 i1@160@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@160@01 Int)) (!
  (forall ((i2@161@01 Int)) (!
    (and
      (implies
        (<= 0 i1@160@01)
        (and
          (<= 0 i1@160@01)
          (implies
            (< i1@160@01 V@30@01)
            (and
              (< i1@160@01 V@30@01)
              (implies
                (<= 0 i2@161@01)
                (and
                  (<= 0 i2@161@01)
                  (implies
                    (< i2@161@01 V@30@01)
                    (and
                      (< i2@161@01 V@30@01)
                      (<
                        i1@160@01
                        (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                      (<
                        i2@161@01
                        (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
                (< i2@161@01 V@30@01))
              (<= 0 i2@161@01))
            (< i1@160@01 V@30@01))
          (<= 0 i1@160@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
          (< i2@161@01 V@30@01)
          (<= 0 i2@161@01)
          (< i1@160@01 V@30@01)
          (<= 0 i1@160@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 12
(pop) ; 11
; Joined path conditions
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@160@01 Int)) (!
    (forall ((i2@161@01 Int)) (!
      (and
        (implies
          (<= 0 i1@160@01)
          (and
            (<= 0 i1@160@01)
            (implies
              (< i1@160@01 V@30@01)
              (and
                (< i1@160@01 V@30@01)
                (implies
                  (<= 0 i2@161@01)
                  (and
                    (<= 0 i2@161@01)
                    (implies
                      (< i2@161@01 V@30@01)
                      (and
                        (< i2@161@01 V@30@01)
                        (<
                          i1@160@01
                          (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                        (<
                          i2@161@01
                          (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
                  (< i2@161@01 V@30@01))
                (<= 0 i2@161@01))
              (< i1@160@01 V@30@01))
            (<= 0 i1@160@01))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
            (< i2@161@01 V@30@01)
            (<= 0 i2@161@01)
            (< i1@160@01 V@30@01)
            (<= 0 i1@160@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
    :qid |prog.l<no position>-aux|))))
(push) ; 11
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@160@01 Int)) (!
    (forall ((i2@161@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
                (< i2@161@01 V@30@01))
              (<= 0 i2@161@01))
            (< i1@160@01 V@30@01))
          (<= 0 i1@160@01))
        (= i1@160@01 i2@161@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 11
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               29997
;  :arith-add-rows          25727
;  :arith-assert-diseq      2219
;  :arith-assert-lower      9136
;  :arith-assert-upper      6495
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6178
;  :arith-fixed-eqs         2919
;  :arith-grobner           93
;  :arith-max-min           753
;  :arith-nonlinear-bounds  71
;  :arith-nonlinear-horner  77
;  :arith-offset-eqs        3699
;  :arith-pivots            4183
;  :arith-pseudo-nonlinear  4
;  :conflicts               1558
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 729
;  :datatype-occurs-check   329
;  :datatype-splits         236
;  :decisions               4667
;  :del-clause              37249
;  :final-checks            238
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.92
;  :minimized-lits          249
;  :mk-bool-var             48416
;  :mk-clause               37258
;  :num-allocs              421333
;  :num-checks              289
;  :propagations            24079
;  :quant-instantiations    10686
;  :rlimit-count            1495331
;  :time                    0.01)
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@160@01 Int)) (!
    (forall ((i2@161@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01)))
                (< i2@161@01 V@30@01))
              (<= 0 i2@161@01))
            (< i1@160@01 V@30@01))
          (<= 0 i1@160@01))
        (= i1@160@01 i2@161@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i2@161@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@160@01))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> target != (None(): option[array])
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30034
;  :arith-add-rows          25727
;  :arith-assert-diseq      2219
;  :arith-assert-lower      9151
;  :arith-assert-upper      6503
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6178
;  :arith-fixed-eqs         2919
;  :arith-grobner           98
;  :arith-max-min           779
;  :arith-nonlinear-bounds  74
;  :arith-nonlinear-horner  81
;  :arith-offset-eqs        3699
;  :arith-pivots            4183
;  :arith-pseudo-nonlinear  4
;  :conflicts               1558
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 737
;  :datatype-occurs-check   334
;  :datatype-splits         240
;  :decisions               4675
;  :del-clause              37249
;  :final-checks            242
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.93
;  :minimized-lits          249
;  :mk-bool-var             48421
;  :mk-clause               37258
;  :num-allocs              422482
;  :num-checks              290
;  :propagations            24079
;  :quant-instantiations    10686
;  :rlimit-count            1497113)
; [then-branch: 197 | exc@122@01 == Null | live]
; [else-branch: 197 | exc@122@01 != Null | dead]
(push) ; 12
; [then-branch: 197 | exc@122@01 == Null]
; [eval] target != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (not (= target@29@01 (as None<option<array>>  option<array>))))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30034
;  :arith-add-rows          25727
;  :arith-assert-diseq      2219
;  :arith-assert-lower      9151
;  :arith-assert-upper      6503
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6178
;  :arith-fixed-eqs         2919
;  :arith-grobner           98
;  :arith-max-min           779
;  :arith-nonlinear-bounds  74
;  :arith-nonlinear-horner  81
;  :arith-offset-eqs        3699
;  :arith-pivots            4183
;  :arith-pseudo-nonlinear  4
;  :conflicts               1558
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 737
;  :datatype-occurs-check   334
;  :datatype-splits         240
;  :decisions               4675
;  :del-clause              37249
;  :final-checks            242
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.93
;  :minimized-lits          249
;  :mk-bool-var             48421
;  :mk-clause               37258
;  :num-allocs              422507
;  :num-checks              291
;  :propagations            24079
;  :quant-instantiations    10686
;  :rlimit-count            1497133)
(assert (implies
  (= exc@122@01 $Ref.null)
  (not (= target@29@01 (as None<option<array>>  option<array>)))))
; [eval] exc == null ==> alen(opt_get1(target)) == V
; [eval] exc == null
(push) ; 11
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30071
;  :arith-add-rows          25727
;  :arith-assert-diseq      2219
;  :arith-assert-lower      9151
;  :arith-assert-upper      6503
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6178
;  :arith-fixed-eqs         2919
;  :arith-grobner           98
;  :arith-max-min           779
;  :arith-nonlinear-bounds  74
;  :arith-nonlinear-horner  81
;  :arith-offset-eqs        3699
;  :arith-pivots            4183
;  :arith-pseudo-nonlinear  4
;  :conflicts               1558
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 745
;  :datatype-occurs-check   339
;  :datatype-splits         244
;  :decisions               4683
;  :del-clause              37249
;  :final-checks            244
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.93
;  :minimized-lits          249
;  :mk-bool-var             48425
;  :mk-clause               37258
;  :num-allocs              423122
;  :num-checks              292
;  :propagations            24079
;  :quant-instantiations    10686
;  :rlimit-count            1497815)
; [then-branch: 198 | exc@122@01 == Null | live]
; [else-branch: 198 | exc@122@01 != Null | dead]
(push) ; 12
; [then-branch: 198 | exc@122@01 == Null]
; [eval] alen(opt_get1(target)) == V
; [eval] alen(opt_get1(target))
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(pop) ; 12
(pop) ; 11
; Joined path conditions
(set-option :timeout 0)
(push) ; 11
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit target@29@01)) V@30@01))))
(check-sat)
; unsat
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30071
;  :arith-add-rows          25727
;  :arith-assert-diseq      2219
;  :arith-assert-lower      9151
;  :arith-assert-upper      6503
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6178
;  :arith-fixed-eqs         2919
;  :arith-grobner           98
;  :arith-max-min           779
;  :arith-nonlinear-bounds  74
;  :arith-nonlinear-horner  81
;  :arith-offset-eqs        3699
;  :arith-pivots            4183
;  :arith-pseudo-nonlinear  4
;  :conflicts               1558
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 745
;  :datatype-occurs-check   339
;  :datatype-splits         244
;  :decisions               4683
;  :del-clause              37249
;  :final-checks            244
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.93
;  :minimized-lits          249
;  :mk-bool-var             48425
;  :mk-clause               37258
;  :num-allocs              423141
;  :num-checks              293
;  :propagations            24079
;  :quant-instantiations    10686
;  :rlimit-count            1497840)
(assert (implies
  (= exc@122@01 $Ref.null)
  (= (alen<Int> (opt_get1 $Snap.unit target@29@01)) V@30@01)))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 11
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 11
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30108
;  :arith-add-rows          25727
;  :arith-assert-diseq      2219
;  :arith-assert-lower      9151
;  :arith-assert-upper      6503
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6178
;  :arith-fixed-eqs         2919
;  :arith-grobner           98
;  :arith-max-min           779
;  :arith-nonlinear-bounds  74
;  :arith-nonlinear-horner  81
;  :arith-offset-eqs        3699
;  :arith-pivots            4183
;  :arith-pseudo-nonlinear  4
;  :conflicts               1558
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 753
;  :datatype-occurs-check   344
;  :datatype-splits         248
;  :decisions               4691
;  :del-clause              37249
;  :final-checks            246
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.93
;  :minimized-lits          249
;  :mk-bool-var             48429
;  :mk-clause               37258
;  :num-allocs              423756
;  :num-checks              294
;  :propagations            24079
;  :quant-instantiations    10686
;  :rlimit-count            1498517)
; [then-branch: 199 | exc@122@01 == Null | live]
; [else-branch: 199 | exc@122@01 != Null | dead]
(push) ; 11
; [then-branch: 199 | exc@122@01 == Null]
(declare-const i1@162@01 Int)
(push) ; 12
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 13
; [then-branch: 200 | 0 <= i1@162@01 | live]
; [else-branch: 200 | !(0 <= i1@162@01) | live]
(push) ; 14
; [then-branch: 200 | 0 <= i1@162@01]
(assert (<= 0 i1@162@01))
; [eval] i1 < V
(pop) ; 14
(push) ; 14
; [else-branch: 200 | !(0 <= i1@162@01)]
(assert (not (<= 0 i1@162@01)))
(pop) ; 14
(pop) ; 13
; Joined path conditions
; Joined path conditions
(assert (and (< i1@162@01 V@30@01) (<= 0 i1@162@01)))
(declare-const $k@163@01 $Perm)
(assert ($Perm.isReadVar $k@163@01 $Perm.Write))
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 13
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 13
; Joined path conditions
(push) ; 13
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 14
(assert (not (< i1@162@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30108
;  :arith-add-rows          25727
;  :arith-assert-diseq      2220
;  :arith-assert-lower      9155
;  :arith-assert-upper      6504
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6179
;  :arith-fixed-eqs         2919
;  :arith-grobner           98
;  :arith-max-min           779
;  :arith-nonlinear-bounds  74
;  :arith-nonlinear-horner  81
;  :arith-offset-eqs        3699
;  :arith-pivots            4184
;  :arith-pseudo-nonlinear  4
;  :conflicts               1558
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 753
;  :datatype-occurs-check   344
;  :datatype-splits         248
;  :decisions               4691
;  :del-clause              37249
;  :final-checks            246
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.93
;  :minimized-lits          249
;  :mk-bool-var             48435
;  :mk-clause               37260
;  :num-allocs              423921
;  :num-checks              295
;  :propagations            24080
;  :quant-instantiations    10686
;  :rlimit-count            1498847)
(assert (< i1@162@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 13
; Joined path conditions
(assert (< i1@162@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 12
(declare-fun inv@164@01 ($Ref) Int)
; Nested auxiliary terms: globals
(assert ($Perm.isReadVar $k@163@01 $Perm.Write))
; Nested auxiliary terms: non-globals
(assert (forall ((i1@162@01 Int)) (!
  (< i1@162@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@162@01))
  :qid |option$array$-aux|)))
(push) ; 12
(assert (not (forall ((i1@162@01 Int)) (!
  (implies
    (and (< i1@162@01 V@30@01) (<= 0 i1@162@01))
    (or (= $k@163@01 $Perm.No) (< $Perm.No $k@163@01)))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30108
;  :arith-add-rows          25727
;  :arith-assert-diseq      2221
;  :arith-assert-lower      9157
;  :arith-assert-upper      6505
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6180
;  :arith-fixed-eqs         2919
;  :arith-grobner           98
;  :arith-max-min           779
;  :arith-nonlinear-bounds  74
;  :arith-nonlinear-horner  81
;  :arith-offset-eqs        3699
;  :arith-pivots            4185
;  :arith-pseudo-nonlinear  4
;  :conflicts               1559
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 753
;  :datatype-occurs-check   344
;  :datatype-splits         248
;  :decisions               4691
;  :del-clause              37251
;  :final-checks            246
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.93
;  :minimized-lits          249
;  :mk-bool-var             48442
;  :mk-clause               37262
;  :num-allocs              424352
;  :num-checks              296
;  :propagations            24081
;  :quant-instantiations    10686
;  :rlimit-count            1499396)
(declare-const sm@165@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef47|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef48|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No)
        (pTaken@155@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef49|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (pTaken@154@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef50|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef51|)))
; Check receiver injectivity
(push) ; 12
(assert (not (forall ((i11@162@01 Int) (i12@162@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and (< i11@162@01 V@30@01) (<= 0 i11@162@01))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@162@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@162@01)))
        (< $Perm.No $k@163@01))
      (and
        (and
          (and (< i12@162@01 V@30@01) (<= 0 i12@162@01))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@162@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@162@01)))
        (< $Perm.No $k@163@01))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@162@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@162@01)))
    (= i11@162@01 i12@162@01))
  
  :qid |option$array$-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               30118
;  :arith-add-rows          25729
;  :arith-assert-diseq      2222
;  :arith-assert-lower      9161
;  :arith-assert-upper      6505
;  :arith-bound-prop        1945
;  :arith-conflicts         662
;  :arith-eq-adapter        6181
;  :arith-fixed-eqs         2919
;  :arith-grobner           98
;  :arith-max-min           779
;  :arith-nonlinear-bounds  74
;  :arith-nonlinear-horner  81
;  :arith-offset-eqs        3699
;  :arith-pivots            4185
;  :arith-pseudo-nonlinear  4
;  :conflicts               1560
;  :datatype-accessor-ax    86
;  :datatype-constructor-ax 753
;  :datatype-occurs-check   344
;  :datatype-splits         248
;  :decisions               4691
;  :del-clause              37324
;  :final-checks            246
;  :interface-eqs           15
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  7.93
;  :minimized-lits          249
;  :mk-bool-var             48546
;  :mk-clause               37335
;  :num-allocs              426420
;  :num-checks              297
;  :propagations            24085
;  :quant-instantiations    10711
;  :rlimit-count            1506556)
; Definitional axioms for inverse functions
(assert (forall ((i1@162@01 Int)) (!
  (implies
    (and (and (< i1@162@01 V@30@01) (<= 0 i1@162@01)) (< $Perm.No $k@163@01))
    (=
      (inv@164@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@162@01))
      i1@162@01))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@162@01))
  :qid |option$array$-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
      (< $Perm.No $k@163@01))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@164@01 r))
      r))
  :pattern ((inv@164@01 r))
  :qid |option$array$-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@165@01  $FVF<option<array>>) r) r))
  :pattern ((inv@164@01 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@166@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r))
      $k@163@01)
    $Perm.No))
(define-fun pTaken@167@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
    ($Perm.min
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r))
      (- $k@163@01 (pTaken@166@01 r)))
    $Perm.No))
(define-fun pTaken@168@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No)
        (pTaken@155@01 r))
      (- (- $k@163@01 (pTaken@166@01 r)) (pTaken@167@01 r)))
    $Perm.No))
(define-fun pTaken@169@01 ((r $Ref)) $Perm
  (ite
    (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
    ($Perm.min
      (-
        (ite
          (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (pTaken@154@01 r))
      (- (- (- $k@163@01 (pTaken@166@01 r)) (pTaken@167@01 r)) (pTaken@168@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Constrain original permissions $k@163@01
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
              $k@35@01
              $Perm.No)
            (pTaken@96@01 r))
          (pTaken@105@01 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
        $k@163@01
        $Perm.No)
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r))))
  :pattern ((inv@36@01 r))
  :pattern ((inv@164@01 r))
  :qid |qp.srp52|)))
; Intermediate check if already taken enough permissions
(set-option :timeout 500)
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
    (= (- $k@163@01 (pTaken@166@01 r)) $Perm.No))
  
  ))))
(check-sat)
; unknown
(pop) ; 12
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               32202
;  :arith-add-rows          27269
;  :arith-assert-diseq      2353
;  :arith-assert-lower      9721
;  :arith-assert-upper      6917
;  :arith-bound-prop        2033
;  :arith-conflicts         688
;  :arith-eq-adapter        6505
;  :arith-fixed-eqs         3137
;  :arith-grobner           129
;  :arith-max-min           933
;  :arith-nonlinear-bounds  90
;  :arith-nonlinear-horner  106
;  :arith-offset-eqs        3949
;  :arith-pivots            4410
;  :arith-pseudo-nonlinear  4
;  :conflicts               1606
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 825
;  :datatype-occurs-check   407
;  :datatype-splits         316
;  :decisions               5165
;  :del-clause              39612
;  :final-checks            284
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.05
;  :minimized-lits          259
;  :mk-bool-var             51466
;  :mk-clause               39621
;  :num-allocs              441191
;  :num-checks              299
;  :propagations            25384
;  :quant-instantiations    11360
;  :rlimit-count            1606181
;  :time                    0.02)
; Constrain original permissions $k@163@01
(assert (forall ((r $Ref)) (!
  (implies
    (not
      (=
        (-
          (-
            (ite
              (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
              $k@43@01
              $Perm.No)
            (pTaken@95@01 r))
          (pTaken@106@01 r))
        $Perm.No))
    (<
      (ite
        (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
        $k@163@01
        $Perm.No)
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r))))
  :pattern ((inv@44@01 r))
  :pattern ((inv@164@01 r))
  :qid |qp.srp53|)))
; Intermediate check if already taken enough permissions
(push) ; 12
(assert (not (forall ((r $Ref)) (!
  (implies
    (and (< (inv@164@01 r) V@30@01) (<= 0 (inv@164@01 r)))
    (= (- (- $k@163@01 (pTaken@166@01 r)) (pTaken@167@01 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 12
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33743
;  :arith-add-rows          29259
;  :arith-assert-diseq      2474
;  :arith-assert-lower      10152
;  :arith-assert-upper      7290
;  :arith-bound-prop        2159
;  :arith-conflicts         721
;  :arith-eq-adapter        6844
;  :arith-fixed-eqs         3327
;  :arith-grobner           129
;  :arith-max-min           933
;  :arith-nonlinear-bounds  90
;  :arith-nonlinear-horner  106
;  :arith-offset-eqs        4126
;  :arith-pivots            4610
;  :arith-pseudo-nonlinear  4
;  :conflicts               1666
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 829
;  :datatype-occurs-check   407
;  :datatype-splits         316
;  :decisions               5356
;  :del-clause              41669
;  :final-checks            284
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.09
;  :minimized-lits          312
;  :mk-bool-var             54158
;  :mk-clause               41678
;  :num-allocs              451500
;  :num-checks              300
;  :propagations            26432
;  :quant-instantiations    11811
;  :rlimit-count            1685994
;  :time                    0.01)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33780
;  :arith-add-rows          29259
;  :arith-assert-diseq      2474
;  :arith-assert-lower      10167
;  :arith-assert-upper      7298
;  :arith-bound-prop        2159
;  :arith-conflicts         721
;  :arith-eq-adapter        6844
;  :arith-fixed-eqs         3327
;  :arith-grobner           134
;  :arith-max-min           959
;  :arith-nonlinear-bounds  93
;  :arith-nonlinear-horner  110
;  :arith-offset-eqs        4126
;  :arith-pivots            4610
;  :arith-pseudo-nonlinear  4
;  :conflicts               1666
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 837
;  :datatype-occurs-check   412
;  :datatype-splits         320
;  :decisions               5364
;  :del-clause              41669
;  :final-checks            288
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.10
;  :minimized-lits          312
;  :mk-bool-var             54162
;  :mk-clause               41678
;  :num-allocs              452331
;  :num-checks              301
;  :propagations            26432
;  :quant-instantiations    11811
;  :rlimit-count            1687254)
; [then-branch: 201 | exc@122@01 == Null | live]
; [else-branch: 201 | exc@122@01 != Null | dead]
(push) ; 13
; [then-branch: 201 | exc@122@01 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array]))
(declare-const i1@170@01 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 202 | 0 <= i1@170@01 | live]
; [else-branch: 202 | !(0 <= i1@170@01) | live]
(push) ; 16
; [then-branch: 202 | 0 <= i1@170@01]
(assert (<= 0 i1@170@01))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 202 | !(0 <= i1@170@01)]
(assert (not (<= 0 i1@170@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 203 | i1@170@01 < V@30@01 && 0 <= i1@170@01 | live]
; [else-branch: 203 | !(i1@170@01 < V@30@01 && 0 <= i1@170@01) | live]
(push) ; 16
; [then-branch: 203 | i1@170@01 < V@30@01 && 0 <= i1@170@01]
(assert (and (< i1@170@01 V@30@01) (<= 0 i1@170@01)))
; [eval] aloc(opt_get1(target), i1).option$array$ != (None(): option[array])
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@170@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               33780
;  :arith-add-rows          29259
;  :arith-assert-diseq      2474
;  :arith-assert-lower      10169
;  :arith-assert-upper      7298
;  :arith-bound-prop        2159
;  :arith-conflicts         721
;  :arith-eq-adapter        6844
;  :arith-fixed-eqs         3327
;  :arith-grobner           134
;  :arith-max-min           959
;  :arith-nonlinear-bounds  93
;  :arith-nonlinear-horner  110
;  :arith-offset-eqs        4126
;  :arith-pivots            4610
;  :arith-pseudo-nonlinear  4
;  :conflicts               1666
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 837
;  :datatype-occurs-check   412
;  :datatype-splits         320
;  :decisions               5364
;  :del-clause              41669
;  :final-checks            288
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.10
;  :minimized-lits          312
;  :mk-bool-var             54164
;  :mk-clause               41678
;  :num-allocs              452435
;  :num-checks              302
;  :propagations            26432
;  :quant-instantiations    11811
;  :rlimit-count            1687449)
(assert (< i1@170@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 17
; Joined path conditions
(assert (< i1@170@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35738
;  :arith-add-rows          31197
;  :arith-assert-diseq      2575
;  :arith-assert-lower      10725
;  :arith-assert-upper      7680
;  :arith-bound-prop        2301
;  :arith-conflicts         751
;  :arith-eq-adapter        7216
;  :arith-fixed-eqs         3539
;  :arith-grobner           134
;  :arith-max-min           959
;  :arith-nonlinear-bounds  93
;  :arith-nonlinear-horner  110
;  :arith-offset-eqs        4477
;  :arith-pivots            4841
;  :arith-pseudo-nonlinear  4
;  :conflicts               1724
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 841
;  :datatype-occurs-check   412
;  :datatype-splits         320
;  :decisions               5595
;  :del-clause              43418
;  :final-checks            288
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.12
;  :minimized-lits          346
;  :mk-bool-var             56728
;  :mk-clause               43592
;  :num-allocs              461959
;  :num-checks              303
;  :propagations            27965
;  :quant-instantiations    12387
;  :rlimit-count            1767362
;  :time                    0.01)
; [eval] (None(): option[array])
(pop) ; 16
(push) ; 16
; [else-branch: 203 | !(i1@170@01 < V@30@01 && 0 <= i1@170@01)]
(assert (not (and (< i1@170@01 V@30@01) (<= 0 i1@170@01))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@170@01 V@30@01) (<= 0 i1@170@01))
  (and
    (< i1@170@01 V@30@01)
    (<= 0 i1@170@01)
    (< i1@170@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@170@01 Int)) (!
  (implies
    (and (< i1@170@01 V@30@01) (<= 0 i1@170@01))
    (and
      (< i1@170@01 V@30@01)
      (<= 0 i1@170@01)
      (< i1@170@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@170@01 Int)) (!
    (implies
      (and (< i1@170@01 V@30@01) (<= 0 i1@170@01))
      (and
        (< i1@170@01 V@30@01)
        (<= 0 i1@170@01)
        (< i1@170@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@170@01 Int)) (!
    (implies
      (and (< i1@170@01 V@30@01) (<= 0 i1@170@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35743
;  :arith-add-rows          31251
;  :arith-assert-diseq      2575
;  :arith-assert-lower      10729
;  :arith-assert-upper      7681
;  :arith-bound-prop        2302
;  :arith-conflicts         751
;  :arith-eq-adapter        7222
;  :arith-fixed-eqs         3540
;  :arith-grobner           134
;  :arith-max-min           959
;  :arith-nonlinear-bounds  93
;  :arith-nonlinear-horner  110
;  :arith-offset-eqs        4477
;  :arith-pivots            4858
;  :arith-pseudo-nonlinear  4
;  :conflicts               1725
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 841
;  :datatype-occurs-check   412
;  :datatype-splits         320
;  :decisions               5595
;  :del-clause              43713
;  :final-checks            288
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.09
;  :minimized-lits          346
;  :mk-bool-var             56878
;  :mk-clause               43722
;  :num-allocs              463225
;  :num-checks              304
;  :propagations            27971
;  :quant-instantiations    12440
;  :rlimit-count            1772183
;  :time                    0.00)
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@170@01 Int)) (!
    (implies
      (and (< i1@170@01 V@30@01) (<= 0 i1@170@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
          (as None<option<array>>  option<array>))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@170@01))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35780
;  :arith-add-rows          31253
;  :arith-assert-diseq      2575
;  :arith-assert-lower      10744
;  :arith-assert-upper      7689
;  :arith-bound-prop        2302
;  :arith-conflicts         751
;  :arith-eq-adapter        7222
;  :arith-fixed-eqs         3540
;  :arith-grobner           139
;  :arith-max-min           985
;  :arith-nonlinear-bounds  96
;  :arith-nonlinear-horner  114
;  :arith-offset-eqs        4477
;  :arith-pivots            4859
;  :arith-pseudo-nonlinear  4
;  :conflicts               1725
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 849
;  :datatype-occurs-check   417
;  :datatype-splits         324
;  :decisions               5603
;  :del-clause              43713
;  :final-checks            292
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.09
;  :minimized-lits          346
;  :mk-bool-var             56883
;  :mk-clause               43722
;  :num-allocs              464254
;  :num-checks              305
;  :propagations            27971
;  :quant-instantiations    12440
;  :rlimit-count            1773796)
; [then-branch: 204 | exc@122@01 == Null | live]
; [else-branch: 204 | exc@122@01 != Null | dead]
(push) ; 13
; [then-branch: 204 | exc@122@01 == Null]
; [eval] (forall i1: Int :: { alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) } 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V)
(declare-const i1@171@01 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V ==> alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] 0 <= i1 && i1 < V
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 205 | 0 <= i1@171@01 | live]
; [else-branch: 205 | !(0 <= i1@171@01) | live]
(push) ; 16
; [then-branch: 205 | 0 <= i1@171@01]
(assert (<= 0 i1@171@01))
; [eval] i1 < V
(pop) ; 16
(push) ; 16
; [else-branch: 205 | !(0 <= i1@171@01)]
(assert (not (<= 0 i1@171@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(push) ; 15
; [then-branch: 206 | i1@171@01 < V@30@01 && 0 <= i1@171@01 | live]
; [else-branch: 206 | !(i1@171@01 < V@30@01 && 0 <= i1@171@01) | live]
(push) ; 16
; [then-branch: 206 | i1@171@01 < V@30@01 && 0 <= i1@171@01]
(assert (and (< i1@171@01 V@30@01) (<= 0 i1@171@01)))
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$)) == V
; [eval] alen(opt_get1(aloc(opt_get1(target), i1).option$array$))
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 17
; Joined path conditions
(push) ; 17
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 18
(assert (not (< i1@171@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               35780
;  :arith-add-rows          31253
;  :arith-assert-diseq      2575
;  :arith-assert-lower      10746
;  :arith-assert-upper      7689
;  :arith-bound-prop        2302
;  :arith-conflicts         751
;  :arith-eq-adapter        7222
;  :arith-fixed-eqs         3540
;  :arith-grobner           139
;  :arith-max-min           985
;  :arith-nonlinear-bounds  96
;  :arith-nonlinear-horner  114
;  :arith-offset-eqs        4477
;  :arith-pivots            4859
;  :arith-pseudo-nonlinear  4
;  :conflicts               1725
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 849
;  :datatype-occurs-check   417
;  :datatype-splits         324
;  :decisions               5603
;  :del-clause              43713
;  :final-checks            292
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.09
;  :minimized-lits          346
;  :mk-bool-var             56885
;  :mk-clause               43722
;  :num-allocs              464359
;  :num-checks              306
;  :propagations            27971
;  :quant-instantiations    12440
;  :rlimit-count            1773991)
(assert (< i1@171@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 17
; Joined path conditions
(assert (< i1@171@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)))
(push) ; 17
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)))))))
(check-sat)
; unsat
(pop) ; 17
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37497
;  :arith-add-rows          32914
;  :arith-assert-diseq      2655
;  :arith-assert-lower      11239
;  :arith-assert-upper      8056
;  :arith-bound-prop        2407
;  :arith-conflicts         784
;  :arith-eq-adapter        7549
;  :arith-fixed-eqs         3735
;  :arith-grobner           139
;  :arith-max-min           985
;  :arith-nonlinear-bounds  96
;  :arith-nonlinear-horner  114
;  :arith-offset-eqs        4743
;  :arith-pivots            5071
;  :arith-pseudo-nonlinear  4
;  :conflicts               1787
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 853
;  :datatype-occurs-check   417
;  :datatype-splits         324
;  :decisions               5822
;  :del-clause              45007
;  :final-checks            292
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.11
;  :minimized-lits          364
;  :mk-bool-var             58987
;  :mk-clause               45181
;  :num-allocs              472488
;  :num-checks              307
;  :propagations            29311
;  :quant-instantiations    12927
;  :rlimit-count            1845665
;  :time                    0.01)
(push) ; 17
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 18
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 18
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37497
;  :arith-add-rows          32914
;  :arith-assert-diseq      2655
;  :arith-assert-lower      11239
;  :arith-assert-upper      8056
;  :arith-bound-prop        2407
;  :arith-conflicts         784
;  :arith-eq-adapter        7549
;  :arith-fixed-eqs         3735
;  :arith-grobner           139
;  :arith-max-min           985
;  :arith-nonlinear-bounds  96
;  :arith-nonlinear-horner  114
;  :arith-offset-eqs        4743
;  :arith-pivots            5071
;  :arith-pseudo-nonlinear  4
;  :conflicts               1788
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 853
;  :datatype-occurs-check   417
;  :datatype-splits         324
;  :decisions               5822
;  :del-clause              45007
;  :final-checks            292
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.11
;  :minimized-lits          364
;  :mk-bool-var             58987
;  :mk-clause               45181
;  :num-allocs              472578
;  :num-checks              308
;  :propagations            29311
;  :quant-instantiations    12927
;  :rlimit-count            1845760)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
    (as None<option<array>>  option<array>))))
(pop) ; 17
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
    (as None<option<array>>  option<array>))))
(pop) ; 16
(push) ; 16
; [else-branch: 206 | !(i1@171@01 < V@30@01 && 0 <= i1@171@01)]
(assert (not (and (< i1@171@01 V@30@01) (<= 0 i1@171@01))))
(pop) ; 16
(pop) ; 15
; Joined path conditions
(assert (implies
  (and (< i1@171@01 V@30@01) (<= 0 i1@171@01))
  (and
    (< i1@171@01 V@30@01)
    (<= 0 i1@171@01)
    (< i1@171@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
        (as None<option<array>>  option<array>))))))
; Joined path conditions
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@171@01 Int)) (!
  (implies
    (and (< i1@171@01 V@30@01) (<= 0 i1@171@01))
    (and
      (< i1@171@01 V@30@01)
      (<= 0 i1@171@01)
      (< i1@171@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
          (as None<option<array>>  option<array>)))))
  :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@171@01 Int)) (!
    (implies
      (and (< i1@171@01 V@30@01) (<= 0 i1@171@01))
      (and
        (< i1@171@01 V@30@01)
        (<= 0 i1@171@01)
        (< i1@171@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
        (not
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))
            (as None<option<array>>  option<array>)))))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)))))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@171@01 Int)) (!
    (implies
      (and (< i1@171@01 V@30@01) (<= 0 i1@171@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37497
;  :arith-add-rows          32936
;  :arith-assert-diseq      2655
;  :arith-assert-lower      11241
;  :arith-assert-upper      8056
;  :arith-bound-prop        2407
;  :arith-conflicts         784
;  :arith-eq-adapter        7552
;  :arith-fixed-eqs         3735
;  :arith-grobner           139
;  :arith-max-min           985
;  :arith-nonlinear-bounds  96
;  :arith-nonlinear-horner  114
;  :arith-offset-eqs        4743
;  :arith-pivots            5088
;  :arith-pseudo-nonlinear  4
;  :conflicts               1789
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 853
;  :datatype-occurs-check   417
;  :datatype-splits         324
;  :decisions               5822
;  :del-clause              45233
;  :final-checks            292
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.09
;  :minimized-lits          364
;  :mk-bool-var             59069
;  :mk-clause               45242
;  :num-allocs              473367
;  :num-checks              309
;  :propagations            29311
;  :quant-instantiations    12950
;  :rlimit-count            1847676)
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@171@01 Int)) (!
    (implies
      (and (< i1@171@01 V@30@01) (<= 0 i1@171@01))
      (=
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01))))
        V@30@01))
    :pattern ((alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@171@01)))))
    :qid |prog.l<no position>|))))
; [eval] exc == null ==> (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
; [eval] exc == null
(push) ; 12
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37534
;  :arith-add-rows          32938
;  :arith-assert-diseq      2655
;  :arith-assert-lower      11256
;  :arith-assert-upper      8064
;  :arith-bound-prop        2407
;  :arith-conflicts         784
;  :arith-eq-adapter        7552
;  :arith-fixed-eqs         3735
;  :arith-grobner           144
;  :arith-max-min           1011
;  :arith-nonlinear-bounds  99
;  :arith-nonlinear-horner  118
;  :arith-offset-eqs        4743
;  :arith-pivots            5089
;  :arith-pseudo-nonlinear  4
;  :conflicts               1789
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 861
;  :datatype-occurs-check   422
;  :datatype-splits         328
;  :decisions               5830
;  :del-clause              45233
;  :final-checks            296
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.09
;  :minimized-lits          364
;  :mk-bool-var             59074
;  :mk-clause               45242
;  :num-allocs              474395
;  :num-checks              310
;  :propagations            29311
;  :quant-instantiations    12950
;  :rlimit-count            1849292)
; [then-branch: 207 | exc@122@01 == Null | live]
; [else-branch: 207 | exc@122@01 != Null | dead]
(push) ; 13
; [then-branch: 207 | exc@122@01 == Null]
; [eval] (forall i1: Int :: { aloc(opt_get1(target), i1) } (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2))
(declare-const i1@172@01 Int)
(push) ; 14
; [eval] (forall i2: Int :: { aloc(opt_get1(target), i2) } 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2)
(declare-const i2@173@01 Int)
(push) ; 15
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$ ==> i1 == i2
; [eval] 0 <= i1 && i1 < V && 0 <= i2 && i2 < V && aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] 0 <= i1
(push) ; 16
; [then-branch: 208 | 0 <= i1@172@01 | live]
; [else-branch: 208 | !(0 <= i1@172@01) | live]
(push) ; 17
; [then-branch: 208 | 0 <= i1@172@01]
(assert (<= 0 i1@172@01))
; [eval] i1 < V
(push) ; 18
; [then-branch: 209 | i1@172@01 < V@30@01 | live]
; [else-branch: 209 | !(i1@172@01 < V@30@01) | live]
(push) ; 19
; [then-branch: 209 | i1@172@01 < V@30@01]
(assert (< i1@172@01 V@30@01))
; [eval] 0 <= i2
(push) ; 20
; [then-branch: 210 | 0 <= i2@173@01 | live]
; [else-branch: 210 | !(0 <= i2@173@01) | live]
(push) ; 21
; [then-branch: 210 | 0 <= i2@173@01]
(assert (<= 0 i2@173@01))
; [eval] i2 < V
(push) ; 22
; [then-branch: 211 | i2@173@01 < V@30@01 | live]
; [else-branch: 211 | !(i2@173@01 < V@30@01) | live]
(push) ; 23
; [then-branch: 211 | i2@173@01 < V@30@01]
(assert (< i2@173@01 V@30@01))
; [eval] aloc(opt_get1(target), i1).option$array$ == aloc(opt_get1(target), i2).option$array$
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 25
(assert (not (< i1@172@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               37534
;  :arith-add-rows          32938
;  :arith-assert-diseq      2655
;  :arith-assert-lower      11260
;  :arith-assert-upper      8064
;  :arith-bound-prop        2407
;  :arith-conflicts         784
;  :arith-eq-adapter        7552
;  :arith-fixed-eqs         3735
;  :arith-grobner           144
;  :arith-max-min           1011
;  :arith-nonlinear-bounds  99
;  :arith-nonlinear-horner  118
;  :arith-offset-eqs        4743
;  :arith-pivots            5090
;  :arith-pseudo-nonlinear  4
;  :conflicts               1789
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 861
;  :datatype-occurs-check   422
;  :datatype-splits         328
;  :decisions               5830
;  :del-clause              45233
;  :final-checks            296
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.10
;  :minimized-lits          364
;  :mk-bool-var             59078
;  :mk-clause               45242
;  :num-allocs              474676
;  :num-checks              311
;  :propagations            29311
;  :quant-instantiations    12950
;  :rlimit-count            1849636)
(assert (< i1@172@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 24
; Joined path conditions
(assert (< i1@172@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)))
(push) ; 24
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)))))))
(check-sat)
; unsat
(pop) ; 24
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               38224
;  :arith-add-rows          33692
;  :arith-assert-diseq      2689
;  :arith-assert-lower      11481
;  :arith-assert-upper      8213
;  :arith-bound-prop        2477
;  :arith-conflicts         802
;  :arith-eq-adapter        7691
;  :arith-fixed-eqs         3819
;  :arith-grobner           144
;  :arith-max-min           1011
;  :arith-nonlinear-bounds  99
;  :arith-nonlinear-horner  118
;  :arith-offset-eqs        4828
;  :arith-pivots            5185
;  :arith-pseudo-nonlinear  4
;  :conflicts               1819
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 865
;  :datatype-occurs-check   422
;  :datatype-splits         328
;  :decisions               5913
;  :del-clause              46120
;  :final-checks            296
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.14
;  :minimized-lits          367
;  :mk-bool-var             60421
;  :mk-clause               46294
;  :num-allocs              480354
;  :num-checks              312
;  :propagations            29876
;  :quant-instantiations    13269
;  :rlimit-count            1885609
;  :time                    0.01)
; [eval] aloc(opt_get1(target), i2)
; [eval] opt_get1(target)
(push) ; 24
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 24
; Joined path conditions
(push) ; 24
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 25
(assert (not (< i2@173@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 25
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               38224
;  :arith-add-rows          33692
;  :arith-assert-diseq      2689
;  :arith-assert-lower      11481
;  :arith-assert-upper      8213
;  :arith-bound-prop        2477
;  :arith-conflicts         802
;  :arith-eq-adapter        7691
;  :arith-fixed-eqs         3819
;  :arith-grobner           144
;  :arith-max-min           1011
;  :arith-nonlinear-bounds  99
;  :arith-nonlinear-horner  118
;  :arith-offset-eqs        4828
;  :arith-pivots            5185
;  :arith-pseudo-nonlinear  4
;  :conflicts               1819
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 865
;  :datatype-occurs-check   422
;  :datatype-splits         328
;  :decisions               5913
;  :del-clause              46120
;  :final-checks            296
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.14
;  :minimized-lits          367
;  :mk-bool-var             60421
;  :mk-clause               46294
;  :num-allocs              480381
;  :num-checks              313
;  :propagations            29876
;  :quant-instantiations    13269
;  :rlimit-count            1885639)
(assert (< i2@173@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 24
; Joined path conditions
(assert (< i2@173@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
(push) ; 24
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))))))
(check-sat)
; unsat
(pop) ; 24
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40267
;  :arith-add-rows          35194
;  :arith-assert-diseq      2833
;  :arith-assert-lower      12139
;  :arith-assert-upper      8678
;  :arith-bound-prop        2541
;  :arith-conflicts         828
;  :arith-eq-adapter        8084
;  :arith-fixed-eqs         4071
;  :arith-grobner           144
;  :arith-max-min           1011
;  :arith-nonlinear-bounds  99
;  :arith-nonlinear-horner  118
;  :arith-offset-eqs        5016
;  :arith-pivots            5356
;  :arith-pseudo-nonlinear  4
;  :conflicts               1868
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 869
;  :datatype-occurs-check   422
;  :datatype-splits         328
;  :decisions               6149
;  :del-clause              48553
;  :final-checks            296
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.24
;  :minimized-lits          371
;  :mk-bool-var             63972
;  :mk-clause               48868
;  :num-allocs              492337
;  :num-checks              314
;  :propagations            31671
;  :quant-instantiations    14219
;  :rlimit-count            1963787
;  :time                    0.02)
(pop) ; 23
(push) ; 23
; [else-branch: 211 | !(i2@173@01 < V@30@01)]
(assert (not (< i2@173@01 V@30@01)))
(pop) ; 23
(pop) ; 22
; Joined path conditions
(assert (implies
  (< i2@173@01 V@30@01)
  (and
    (< i2@173@01 V@30@01)
    (< i1@172@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
    (< i2@173@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))))
; Joined path conditions
(pop) ; 21
(push) ; 21
; [else-branch: 210 | !(0 <= i2@173@01)]
(assert (not (<= 0 i2@173@01)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (<= 0 i2@173@01)
  (and
    (<= 0 i2@173@01)
    (implies
      (< i2@173@01 V@30@01)
      (and
        (< i2@173@01 V@30@01)
        (< i1@172@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
        (< i2@173@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))))))
; Joined path conditions
(pop) ; 19
(push) ; 19
; [else-branch: 209 | !(i1@172@01 < V@30@01)]
(assert (not (< i1@172@01 V@30@01)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
(assert (implies
  (< i1@172@01 V@30@01)
  (and
    (< i1@172@01 V@30@01)
    (implies
      (<= 0 i2@173@01)
      (and
        (<= 0 i2@173@01)
        (implies
          (< i2@173@01 V@30@01)
          (and
            (< i2@173@01 V@30@01)
            (< i1@172@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
            (< i2@173@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))))))))
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 208 | !(0 <= i1@172@01)]
(assert (not (<= 0 i1@172@01)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (<= 0 i1@172@01)
  (and
    (<= 0 i1@172@01)
    (implies
      (< i1@172@01 V@30@01)
      (and
        (< i1@172@01 V@30@01)
        (implies
          (<= 0 i2@173@01)
          (and
            (<= 0 i2@173@01)
            (implies
              (< i2@173@01 V@30@01)
              (and
                (< i2@173@01 V@30@01)
                (< i1@172@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                (< i2@173@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))))))))))
; Joined path conditions
(push) ; 16
; [then-branch: 212 | Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i1@172@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i2@173@01)) && i2@173@01 < V@30@01 && 0 <= i2@173@01 && i1@172@01 < V@30@01 && 0 <= i1@172@01 | live]
; [else-branch: 212 | !(Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i1@172@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i2@173@01)) && i2@173@01 < V@30@01 && 0 <= i2@173@01 && i1@172@01 < V@30@01 && 0 <= i1@172@01) | live]
(push) ; 17
; [then-branch: 212 | Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i1@172@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i2@173@01)) && i2@173@01 < V@30@01 && 0 <= i2@173@01 && i1@172@01 < V@30@01 && 0 <= i1@172@01]
(assert (and
  (and
    (and
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
        (< i2@173@01 V@30@01))
      (<= 0 i2@173@01))
    (< i1@172@01 V@30@01))
  (<= 0 i1@172@01)))
; [eval] i1 == i2
(pop) ; 17
(push) ; 17
; [else-branch: 212 | !(Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i1@172@01)) == Lookup(option$array$,sm@136@01,aloc((_, _), opt_get1(_, target@29@01), i2@173@01)) && i2@173@01 < V@30@01 && 0 <= i2@173@01 && i1@172@01 < V@30@01 && 0 <= i1@172@01)]
(assert (not
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
          (< i2@173@01 V@30@01))
        (<= 0 i2@173@01))
      (< i1@172@01 V@30@01))
    (<= 0 i1@172@01))))
(pop) ; 17
(pop) ; 16
; Joined path conditions
(assert (implies
  (and
    (and
      (and
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
          (< i2@173@01 V@30@01))
        (<= 0 i2@173@01))
      (< i1@172@01 V@30@01))
    (<= 0 i1@172@01))
  (and
    (=
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
      ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
    (< i2@173@01 V@30@01)
    (<= 0 i2@173@01)
    (< i1@172@01 V@30@01)
    (<= 0 i1@172@01))))
; Joined path conditions
(pop) ; 15
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i2@173@01 Int)) (!
  (and
    (implies
      (<= 0 i1@172@01)
      (and
        (<= 0 i1@172@01)
        (implies
          (< i1@172@01 V@30@01)
          (and
            (< i1@172@01 V@30@01)
            (implies
              (<= 0 i2@173@01)
              (and
                (<= 0 i2@173@01)
                (implies
                  (< i2@173@01 V@30@01)
                  (and
                    (< i2@173@01 V@30@01)
                    (< i1@172@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                    (< i2@173@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))))))))))
    (implies
      (and
        (and
          (and
            (and
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
              (< i2@173@01 V@30@01))
            (<= 0 i2@173@01))
          (< i1@172@01 V@30@01))
        (<= 0 i1@172@01))
      (and
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
        (< i2@173@01 V@30@01)
        (<= 0 i2@173@01)
        (< i1@172@01 V@30@01)
        (<= 0 i1@172@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 14
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((i1@172@01 Int)) (!
  (forall ((i2@173@01 Int)) (!
    (and
      (implies
        (<= 0 i1@172@01)
        (and
          (<= 0 i1@172@01)
          (implies
            (< i1@172@01 V@30@01)
            (and
              (< i1@172@01 V@30@01)
              (implies
                (<= 0 i2@173@01)
                (and
                  (<= 0 i2@173@01)
                  (implies
                    (< i2@173@01 V@30@01)
                    (and
                      (< i2@173@01 V@30@01)
                      (<
                        i1@172@01
                        (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                      (<
                        i2@173@01
                        (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))))))))))
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
                (< i2@173@01 V@30@01))
              (<= 0 i2@173@01))
            (< i1@172@01 V@30@01))
          (<= 0 i1@172@01))
        (and
          (=
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
            ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
          (< i2@173@01 V@30@01)
          (<= 0 i2@173@01)
          (< i1@172@01 V@30@01)
          (<= 0 i1@172@01))))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
    :qid |prog.l<no position>-aux|))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 13
(pop) ; 12
; Joined path conditions
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@172@01 Int)) (!
    (forall ((i2@173@01 Int)) (!
      (and
        (implies
          (<= 0 i1@172@01)
          (and
            (<= 0 i1@172@01)
            (implies
              (< i1@172@01 V@30@01)
              (and
                (< i1@172@01 V@30@01)
                (implies
                  (<= 0 i2@173@01)
                  (and
                    (<= 0 i2@173@01)
                    (implies
                      (< i2@173@01 V@30@01)
                      (and
                        (< i2@173@01 V@30@01)
                        (<
                          i1@172@01
                          (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                        (<
                          i2@173@01
                          (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                        ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)) (aloc ($Snap.combine
                          $Snap.unit
                          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))))))))))
        (implies
          (and
            (and
              (and
                (and
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
                  (< i2@173@01 V@30@01))
                (<= 0 i2@173@01))
              (< i1@172@01 V@30@01))
            (<= 0 i1@172@01))
          (and
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
            (< i2@173@01 V@30@01)
            (<= 0 i2@173@01)
            (< i1@172@01 V@30@01)
            (<= 0 i1@172@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
      :qid |prog.l<no position>-aux|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
    :qid |prog.l<no position>-aux|))))
(push) ; 12
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@172@01 Int)) (!
    (forall ((i2@173@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
                (< i2@173@01 V@30@01))
              (<= 0 i2@173@01))
            (< i1@172@01 V@30@01))
          (<= 0 i1@172@01))
        (= i1@172@01 i2@173@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
    :qid |prog.l<no position>|)))))
(check-sat)
; unsat
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40290
;  :arith-add-rows          35245
;  :arith-assert-diseq      2834
;  :arith-assert-lower      12146
;  :arith-assert-upper      8680
;  :arith-bound-prop        2544
;  :arith-conflicts         828
;  :arith-eq-adapter        8099
;  :arith-fixed-eqs         4073
;  :arith-grobner           144
;  :arith-max-min           1011
;  :arith-nonlinear-bounds  99
;  :arith-nonlinear-horner  118
;  :arith-offset-eqs        5019
;  :arith-pivots            5395
;  :arith-pseudo-nonlinear  4
;  :conflicts               1869
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 869
;  :datatype-occurs-check   422
;  :datatype-splits         328
;  :decisions               6149
;  :del-clause              49197
;  :final-checks            296
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.20
;  :minimized-lits          371
;  :mk-bool-var             64408
;  :mk-clause               49206
;  :num-allocs              495156
;  :num-checks              315
;  :propagations            31690
;  :quant-instantiations    14353
;  :rlimit-count            1975497
;  :time                    0.00)
(assert (implies
  (= exc@122@01 $Ref.null)
  (forall ((i1@172@01 Int)) (!
    (forall ((i2@173@01 Int)) (!
      (implies
        (and
          (and
            (and
              (and
                (=
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
                  ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01)))
                (< i2@173@01 V@30@01))
              (<= 0 i2@173@01))
            (< i1@172@01 V@30@01))
          (<= 0 i1@172@01))
        (= i1@172@01 i2@173@01))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i2@173@01))
      :qid |prog.l<no position>|))
    :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@172@01))
    :qid |prog.l<no position>|))))
; [eval] exc == null
(set-option :timeout 10)
(push) ; 12
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 12
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40327
;  :arith-add-rows          35245
;  :arith-assert-diseq      2834
;  :arith-assert-lower      12161
;  :arith-assert-upper      8688
;  :arith-bound-prop        2544
;  :arith-conflicts         828
;  :arith-eq-adapter        8099
;  :arith-fixed-eqs         4073
;  :arith-grobner           149
;  :arith-max-min           1037
;  :arith-nonlinear-bounds  102
;  :arith-nonlinear-horner  122
;  :arith-offset-eqs        5019
;  :arith-pivots            5395
;  :arith-pseudo-nonlinear  4
;  :conflicts               1869
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 877
;  :datatype-occurs-check   427
;  :datatype-splits         332
;  :decisions               6157
;  :del-clause              49197
;  :final-checks            300
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.20
;  :minimized-lits          371
;  :mk-bool-var             64413
;  :mk-clause               49206
;  :num-allocs              496313
;  :num-checks              316
;  :propagations            31690
;  :quant-instantiations    14353
;  :rlimit-count            1977296)
; [then-branch: 213 | exc@122@01 == Null | live]
; [else-branch: 213 | exc@122@01 != Null | dead]
(push) ; 12
; [then-branch: 213 | exc@122@01 == Null]
(declare-const i1@174@01 Int)
(declare-const j1@175@01 Int)
(push) ; 13
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 14
; [then-branch: 214 | 0 <= i1@174@01 | live]
; [else-branch: 214 | !(0 <= i1@174@01) | live]
(push) ; 15
; [then-branch: 214 | 0 <= i1@174@01]
(assert (<= 0 i1@174@01))
; [eval] i1 < V
(push) ; 16
; [then-branch: 215 | i1@174@01 < V@30@01 | live]
; [else-branch: 215 | !(i1@174@01 < V@30@01) | live]
(push) ; 17
; [then-branch: 215 | i1@174@01 < V@30@01]
(assert (< i1@174@01 V@30@01))
; [eval] 0 <= j1
(push) ; 18
; [then-branch: 216 | 0 <= j1@175@01 | live]
; [else-branch: 216 | !(0 <= j1@175@01) | live]
(push) ; 19
; [then-branch: 216 | 0 <= j1@175@01]
(assert (<= 0 j1@175@01))
; [eval] j1 < V
(pop) ; 19
(push) ; 19
; [else-branch: 216 | !(0 <= j1@175@01)]
(assert (not (<= 0 j1@175@01)))
(pop) ; 19
(pop) ; 18
; Joined path conditions
; Joined path conditions
(pop) ; 17
(push) ; 17
; [else-branch: 215 | !(i1@174@01 < V@30@01)]
(assert (not (< i1@174@01 V@30@01)))
(pop) ; 17
(pop) ; 16
; Joined path conditions
; Joined path conditions
(pop) ; 15
(push) ; 15
; [else-branch: 214 | !(0 <= i1@174@01)]
(assert (not (<= 0 i1@174@01)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@175@01 V@30@01) (<= 0 j1@175@01)) (< i1@174@01 V@30@01))
  (<= 0 i1@174@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(source), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(source), i1).option$array$)
; [eval] aloc(opt_get1(source), i1)
; [eval] opt_get1(source)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 14
; Joined path conditions
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 15
(assert (not (< i1@174@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               40327
;  :arith-add-rows          35245
;  :arith-assert-diseq      2834
;  :arith-assert-lower      12167
;  :arith-assert-upper      8688
;  :arith-bound-prop        2544
;  :arith-conflicts         828
;  :arith-eq-adapter        8099
;  :arith-fixed-eqs         4073
;  :arith-grobner           149
;  :arith-max-min           1037
;  :arith-nonlinear-bounds  102
;  :arith-nonlinear-horner  122
;  :arith-offset-eqs        5019
;  :arith-pivots            5397
;  :arith-pseudo-nonlinear  4
;  :conflicts               1869
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 877
;  :datatype-occurs-check   427
;  :datatype-splits         332
;  :decisions               6157
;  :del-clause              49197
;  :final-checks            300
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.20
;  :minimized-lits          371
;  :mk-bool-var             64419
;  :mk-clause               49206
;  :num-allocs              496587
;  :num-checks              317
;  :propagations            31690
;  :quant-instantiations    14353
;  :rlimit-count            1977776)
(assert (< i1@174@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 14
; Joined path conditions
(assert (< i1@174@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01)))
(push) ; 14
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01)))))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41015
;  :arith-add-rows          35794
;  :arith-assert-diseq      2911
;  :arith-assert-lower      12422
;  :arith-assert-upper      8841
;  :arith-bound-prop        2597
;  :arith-conflicts         846
;  :arith-eq-adapter        8275
;  :arith-fixed-eqs         4151
;  :arith-grobner           149
;  :arith-max-min           1037
;  :arith-nonlinear-bounds  102
;  :arith-nonlinear-horner  122
;  :arith-offset-eqs        5123
;  :arith-pivots            5495
;  :arith-pseudo-nonlinear  4
;  :conflicts               1905
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 881
;  :datatype-occurs-check   427
;  :datatype-splits         332
;  :decisions               6246
;  :del-clause              49790
;  :final-checks            300
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.22
;  :minimized-lits          380
;  :mk-bool-var             65434
;  :mk-clause               49974
;  :num-allocs              501114
;  :num-checks              318
;  :propagations            32259
;  :quant-instantiations    14530
;  :rlimit-count            2002489
;  :time                    0.00)
(push) ; 14
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 15
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41015
;  :arith-add-rows          35794
;  :arith-assert-diseq      2911
;  :arith-assert-lower      12422
;  :arith-assert-upper      8841
;  :arith-bound-prop        2597
;  :arith-conflicts         846
;  :arith-eq-adapter        8275
;  :arith-fixed-eqs         4151
;  :arith-grobner           149
;  :arith-max-min           1037
;  :arith-nonlinear-bounds  102
;  :arith-nonlinear-horner  122
;  :arith-offset-eqs        5123
;  :arith-pivots            5495
;  :arith-pseudo-nonlinear  4
;  :conflicts               1906
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 881
;  :datatype-occurs-check   427
;  :datatype-splits         332
;  :decisions               6246
;  :del-clause              49790
;  :final-checks            300
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.21
;  :minimized-lits          380
;  :mk-bool-var             65434
;  :mk-clause               49974
;  :num-allocs              501205
;  :num-checks              319
;  :propagations            32259
;  :quant-instantiations    14530
;  :rlimit-count            2002584)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
    (as None<option<array>>  option<array>))))
(pop) ; 14
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
    (as None<option<array>>  option<array>))))
(push) ; 14
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 15
(assert (not (<
  j1@175@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41021
;  :arith-add-rows          35800
;  :arith-assert-diseq      2911
;  :arith-assert-lower      12424
;  :arith-assert-upper      8843
;  :arith-bound-prop        2597
;  :arith-conflicts         847
;  :arith-eq-adapter        8276
;  :arith-fixed-eqs         4152
;  :arith-grobner           149
;  :arith-max-min           1037
;  :arith-nonlinear-bounds  102
;  :arith-nonlinear-horner  122
;  :arith-offset-eqs        5123
;  :arith-pivots            5499
;  :arith-pseudo-nonlinear  4
;  :conflicts               1907
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 881
;  :datatype-occurs-check   427
;  :datatype-splits         332
;  :decisions               6246
;  :del-clause              49794
;  :final-checks            300
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.21
;  :minimized-lits          380
;  :mk-bool-var             65445
;  :mk-clause               49978
;  :num-allocs              501392
;  :num-checks              320
;  :propagations            32261
;  :quant-instantiations    14537
;  :rlimit-count            2003118)
(assert (<
  j1@175@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))))))
(pop) ; 14
; Joined path conditions
(assert (<
  j1@175@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))))))
(pop) ; 13
(declare-fun inv@176@01 ($Ref) Int)
(declare-fun inv@177@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@174@01 Int) (j1@175@01 Int)) (!
  (and
    (< i1@174@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))
        (as None<option<array>>  option<array>)))
    (<
      j1@175@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))) j1@175@01))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 13
(assert (not (forall ((i11@174@01 Int) (j11@175@01 Int) (i12@174@01 Int) (j12@175@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@175@01 V@30@01) (<= 0 j11@175@01))
            (< i11@174@01 V@30@01))
          (<= 0 i11@174@01))
        ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@174@01))) j11@175@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@174@01))) j11@175@01)))
      (and
        (and
          (and
            (and (< j12@175@01 V@30@01) (<= 0 j12@175@01))
            (< i12@174@01 V@30@01))
          (<= 0 i12@174@01))
        ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@174@01))) j12@175@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@174@01))) j12@175@01)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i11@174@01))) j11@175@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i12@174@01))) j12@175@01)))
    (and (= i11@174@01 i12@174@01) (= j11@175@01 j12@175@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41076
;  :arith-add-rows          35847
;  :arith-assert-diseq      2911
;  :arith-assert-lower      12434
;  :arith-assert-upper      8844
;  :arith-bound-prop        2598
;  :arith-conflicts         847
;  :arith-eq-adapter        8293
;  :arith-fixed-eqs         4152
;  :arith-grobner           149
;  :arith-max-min           1037
;  :arith-nonlinear-bounds  102
;  :arith-nonlinear-horner  122
;  :arith-offset-eqs        5124
;  :arith-pivots            5523
;  :arith-pseudo-nonlinear  4
;  :conflicts               1908
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 881
;  :datatype-occurs-check   427
;  :datatype-splits         332
;  :decisions               6246
;  :del-clause              50194
;  :final-checks            300
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.20
;  :minimized-lits          380
;  :mk-bool-var             65763
;  :mk-clause               50203
;  :num-allocs              503403
;  :num-checks              321
;  :propagations            32287
;  :quant-instantiations    14639
;  :rlimit-count            2010117
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@174@01 Int) (j1@175@01 Int)) (!
  (implies
    (and
      (and (and (< j1@175@01 V@30@01) (<= 0 j1@175@01)) (< i1@174@01 V@30@01))
      (<= 0 i1@174@01))
    (and
      (=
        (inv@176@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))) j1@175@01))
        i1@174@01)
      (=
        (inv@177@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))) j1@175@01))
        j1@175@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) i1@174@01))) j1@175@01))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@177@01 r) V@30@01) (<= 0 (inv@177@01 r)))
        (< (inv@176@01 r) V@30@01))
      (<= 0 (inv@176@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) (inv@176@01 r)))) (inv@177@01 r))
      r))
  :pattern ((inv@176@01 r))
  :pattern ((inv@177@01 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@177@01 r) V@30@01) (<= 0 (inv@177@01 r)))
        (< (inv@176@01 r) V@30@01))
      (<= 0 (inv@176@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r))
  :pattern ((inv@176@01 r) (inv@177@01 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@178@01 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@177@01 r) V@30@01) (<= 0 (inv@177@01 r)))
        (< (inv@176@01 r) V@30@01))
      (<= 0 (inv@176@01 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
(define-fun pTaken@179@01 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@177@01 r) V@30@01) (<= 0 (inv@177@01 r)))
        (< (inv@176@01 r) V@30@01))
      (<= 0 (inv@176@01 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (- $Perm.Write (pTaken@178@01 r)))
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@178@01 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41311
;  :arith-add-rows          35939
;  :arith-assert-diseq      2916
;  :arith-assert-lower      12482
;  :arith-assert-upper      8872
;  :arith-bound-prop        2605
;  :arith-conflicts         849
;  :arith-eq-adapter        8333
;  :arith-fixed-eqs         4166
;  :arith-grobner           154
;  :arith-max-min           1063
;  :arith-nonlinear-bounds  105
;  :arith-nonlinear-horner  126
;  :arith-offset-eqs        5142
;  :arith-pivots            5554
;  :arith-pseudo-nonlinear  4
;  :conflicts               1918
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 893
;  :datatype-occurs-check   432
;  :datatype-splits         336
;  :decisions               6264
;  :del-clause              50669
;  :final-checks            304
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.21
;  :minimized-lits          381
;  :mk-bool-var             66501
;  :mk-clause               50678
;  :num-allocs              508063
;  :num-checks              323
;  :propagations            32380
;  :quant-instantiations    14822
;  :rlimit-count            2022913
;  :time                    0.00)
; Intermediate check if already taken enough permissions
(push) ; 13
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@177@01 r) V@30@01) (<= 0 (inv@177@01 r)))
        (< (inv@176@01 r) V@30@01))
      (<= 0 (inv@176@01 r)))
    (= (- $Perm.Write (pTaken@178@01 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41423
;  :arith-add-rows          35968
;  :arith-assert-diseq      2918
;  :arith-assert-lower      12496
;  :arith-assert-upper      8882
;  :arith-bound-prop        2610
;  :arith-conflicts         851
;  :arith-eq-adapter        8342
;  :arith-fixed-eqs         4171
;  :arith-grobner           154
;  :arith-max-min           1063
;  :arith-nonlinear-bounds  105
;  :arith-nonlinear-horner  126
;  :arith-offset-eqs        5149
;  :arith-pivots            5569
;  :arith-pseudo-nonlinear  4
;  :conflicts               1924
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 897
;  :datatype-occurs-check   432
;  :datatype-splits         336
;  :decisions               6269
;  :del-clause              50893
;  :final-checks            304
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.23
;  :minimized-lits          381
;  :mk-bool-var             66820
;  :mk-clause               50902
;  :num-allocs              509592
;  :num-checks              324
;  :propagations            32412
;  :quant-instantiations    14920
;  :rlimit-count            2029793
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null
(set-option :timeout 10)
(push) ; 13
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 13
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41460
;  :arith-add-rows          35968
;  :arith-assert-diseq      2918
;  :arith-assert-lower      12496
;  :arith-assert-upper      8882
;  :arith-bound-prop        2610
;  :arith-conflicts         851
;  :arith-eq-adapter        8342
;  :arith-fixed-eqs         4171
;  :arith-grobner           154
;  :arith-max-min           1063
;  :arith-nonlinear-bounds  105
;  :arith-nonlinear-horner  126
;  :arith-offset-eqs        5149
;  :arith-pivots            5569
;  :arith-pseudo-nonlinear  4
;  :conflicts               1924
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 905
;  :datatype-occurs-check   437
;  :datatype-splits         340
;  :decisions               6277
;  :del-clause              50893
;  :final-checks            306
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.23
;  :minimized-lits          381
;  :mk-bool-var             66824
;  :mk-clause               50902
;  :num-allocs              510220
;  :num-checks              325
;  :propagations            32412
;  :quant-instantiations    14920
;  :rlimit-count            2030489)
; [then-branch: 217 | exc@122@01 == Null | live]
; [else-branch: 217 | exc@122@01 != Null | dead]
(push) ; 13
; [then-branch: 217 | exc@122@01 == Null]
(declare-const i1@180@01 Int)
(declare-const j1@181@01 Int)
(push) ; 14
; [eval] 0 <= i1 && i1 < V && (0 <= j1 && j1 < V)
; [eval] 0 <= i1
(push) ; 15
; [then-branch: 218 | 0 <= i1@180@01 | live]
; [else-branch: 218 | !(0 <= i1@180@01) | live]
(push) ; 16
; [then-branch: 218 | 0 <= i1@180@01]
(assert (<= 0 i1@180@01))
; [eval] i1 < V
(push) ; 17
; [then-branch: 219 | i1@180@01 < V@30@01 | live]
; [else-branch: 219 | !(i1@180@01 < V@30@01) | live]
(push) ; 18
; [then-branch: 219 | i1@180@01 < V@30@01]
(assert (< i1@180@01 V@30@01))
; [eval] 0 <= j1
(push) ; 19
; [then-branch: 220 | 0 <= j1@181@01 | live]
; [else-branch: 220 | !(0 <= j1@181@01) | live]
(push) ; 20
; [then-branch: 220 | 0 <= j1@181@01]
(assert (<= 0 j1@181@01))
; [eval] j1 < V
(pop) ; 20
(push) ; 20
; [else-branch: 220 | !(0 <= j1@181@01)]
(assert (not (<= 0 j1@181@01)))
(pop) ; 20
(pop) ; 19
; Joined path conditions
; Joined path conditions
(pop) ; 18
(push) ; 18
; [else-branch: 219 | !(i1@180@01 < V@30@01)]
(assert (not (< i1@180@01 V@30@01)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(pop) ; 16
(push) ; 16
; [else-branch: 218 | !(0 <= i1@180@01)]
(assert (not (<= 0 i1@180@01)))
(pop) ; 16
(pop) ; 15
; Joined path conditions
; Joined path conditions
(assert (and
  (and (and (< j1@181@01 V@30@01) (<= 0 j1@181@01)) (< i1@180@01 V@30@01))
  (<= 0 i1@180@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), i1).option$array$), j1)
; [eval] opt_get1(aloc(opt_get1(target), i1).option$array$)
; [eval] aloc(opt_get1(target), i1)
; [eval] opt_get1(target)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 15
; Joined path conditions
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 16
(assert (not (< i1@180@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               41460
;  :arith-add-rows          35968
;  :arith-assert-diseq      2918
;  :arith-assert-lower      12502
;  :arith-assert-upper      8882
;  :arith-bound-prop        2610
;  :arith-conflicts         851
;  :arith-eq-adapter        8342
;  :arith-fixed-eqs         4171
;  :arith-grobner           154
;  :arith-max-min           1063
;  :arith-nonlinear-bounds  105
;  :arith-nonlinear-horner  126
;  :arith-offset-eqs        5149
;  :arith-pivots            5572
;  :arith-pseudo-nonlinear  4
;  :conflicts               1924
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 905
;  :datatype-occurs-check   437
;  :datatype-splits         340
;  :decisions               6277
;  :del-clause              50893
;  :final-checks            306
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.26
;  :memory                  8.24
;  :minimized-lits          381
;  :mk-bool-var             66830
;  :mk-clause               50902
;  :num-allocs              510494
;  :num-checks              326
;  :propagations            32412
;  :quant-instantiations    14920
;  :rlimit-count            2030973)
(assert (< i1@180@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 15
; Joined path conditions
(assert (< i1@180@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01)))
(push) ; 15
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01)))))))
(check-sat)
; unsat
(pop) ; 15
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               43078
;  :arith-add-rows          38040
;  :arith-assert-diseq      2992
;  :arith-assert-lower      12945
;  :arith-assert-upper      9279
;  :arith-bound-prop        2735
;  :arith-conflicts         876
;  :arith-eq-adapter        8662
;  :arith-fixed-eqs         4387
;  :arith-grobner           154
;  :arith-max-min           1063
;  :arith-nonlinear-bounds  105
;  :arith-nonlinear-horner  126
;  :arith-offset-eqs        5389
;  :arith-pivots            5795
;  :arith-pseudo-nonlinear  4
;  :conflicts               1986
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 909
;  :datatype-occurs-check   437
;  :datatype-splits         340
;  :decisions               6471
;  :del-clause              52134
;  :final-checks            306
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.32
;  :memory                  8.30
;  :minimized-lits          408
;  :mk-bool-var             68801
;  :mk-clause               52308
;  :num-allocs              518458
;  :num-checks              327
;  :propagations            33714
;  :quant-instantiations    15318
;  :rlimit-count            2111292
;  :time                    0.01)
(push) ; 15
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 16
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               43078
;  :arith-add-rows          38040
;  :arith-assert-diseq      2992
;  :arith-assert-lower      12945
;  :arith-assert-upper      9279
;  :arith-bound-prop        2735
;  :arith-conflicts         876
;  :arith-eq-adapter        8662
;  :arith-fixed-eqs         4387
;  :arith-grobner           154
;  :arith-max-min           1063
;  :arith-nonlinear-bounds  105
;  :arith-nonlinear-horner  126
;  :arith-offset-eqs        5389
;  :arith-pivots            5795
;  :arith-pseudo-nonlinear  4
;  :conflicts               1987
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 909
;  :datatype-occurs-check   437
;  :datatype-splits         340
;  :decisions               6471
;  :del-clause              52134
;  :final-checks            306
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.32
;  :memory                  8.30
;  :minimized-lits          408
;  :mk-bool-var             68801
;  :mk-clause               52308
;  :num-allocs              518548
;  :num-checks              328
;  :propagations            33714
;  :quant-instantiations    15318
;  :rlimit-count            2111387)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
    (as None<option<array>>  option<array>))))
(pop) ; 15
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
    (as None<option<array>>  option<array>))))
(push) ; 15
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 16
(assert (not (<
  j1@181@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01)))))))
(check-sat)
; unsat
(pop) ; 16
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               43082
;  :arith-add-rows          38042
;  :arith-assert-diseq      2992
;  :arith-assert-lower      12947
;  :arith-assert-upper      9279
;  :arith-bound-prop        2737
;  :arith-conflicts         876
;  :arith-eq-adapter        8663
;  :arith-fixed-eqs         4387
;  :arith-grobner           154
;  :arith-max-min           1063
;  :arith-nonlinear-bounds  105
;  :arith-nonlinear-horner  126
;  :arith-offset-eqs        5389
;  :arith-pivots            5797
;  :arith-pseudo-nonlinear  4
;  :conflicts               1988
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 909
;  :datatype-occurs-check   437
;  :datatype-splits         340
;  :decisions               6471
;  :del-clause              52140
;  :final-checks            306
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.32
;  :memory                  8.30
;  :minimized-lits          408
;  :mk-bool-var             68812
;  :mk-clause               52314
;  :num-allocs              518750
;  :num-checks              329
;  :propagations            33714
;  :quant-instantiations    15327
;  :rlimit-count            2111856)
(assert (<
  j1@181@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))))))
(pop) ; 15
; Joined path conditions
(assert (<
  j1@181@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))))))
(pop) ; 14
(declare-fun inv@182@01 ($Ref) Int)
(declare-fun inv@183@01 ($Ref) Int)
; Nested auxiliary terms: globals
; Nested auxiliary terms: non-globals
(assert (forall ((i1@180@01 Int) (j1@181@01 Int)) (!
  (and
    (< i1@180@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))
        (as None<option<array>>  option<array>)))
    (<
      j1@181@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))))))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))) j1@181@01))
  :qid |int-aux|)))
; Definitional axioms for snapshot map values
; Check receiver injectivity
(push) ; 14
(assert (not (forall ((i11@180@01 Int) (j11@181@01 Int) (i12@180@01 Int) (j12@181@01 Int)) (!
  (implies
    (and
      (and
        (and
          (and
            (and (< j11@181@01 V@30@01) (<= 0 j11@181@01))
            (< i11@180@01 V@30@01))
          (<= 0 i11@180@01))
        ($FVF.loc_int ($FVF.lookup_int (as sm@145@01  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@180@01))) j11@181@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@180@01))) j11@181@01)))
      (and
        (and
          (and
            (and (< j12@181@01 V@30@01) (<= 0 j12@181@01))
            (< i12@180@01 V@30@01))
          (<= 0 i12@180@01))
        ($FVF.loc_int ($FVF.lookup_int (as sm@145@01  $FVF<Int>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@180@01))) j12@181@01)) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@180@01))) j12@181@01)))
      (=
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i11@180@01))) j11@181@01)
        (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i12@180@01))) j12@181@01)))
    (and (= i11@180@01 i12@180@01) (= j11@181@01 j12@181@01)))
  
  :qid |int-rcvrInj|))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               43136
;  :arith-add-rows          38079
;  :arith-assert-diseq      2992
;  :arith-assert-lower      12957
;  :arith-assert-upper      9280
;  :arith-bound-prop        2738
;  :arith-conflicts         876
;  :arith-eq-adapter        8681
;  :arith-fixed-eqs         4387
;  :arith-grobner           154
;  :arith-max-min           1063
;  :arith-nonlinear-bounds  105
;  :arith-nonlinear-horner  126
;  :arith-offset-eqs        5390
;  :arith-pivots            5817
;  :arith-pseudo-nonlinear  4
;  :conflicts               1989
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 909
;  :datatype-occurs-check   437
;  :datatype-splits         340
;  :decisions               6471
;  :del-clause              52516
;  :final-checks            306
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              8.32
;  :memory                  8.27
;  :minimized-lits          408
;  :mk-bool-var             69110
;  :mk-clause               52525
;  :num-allocs              520746
;  :num-checks              330
;  :propagations            33738
;  :quant-instantiations    15427
;  :rlimit-count            2118901
;  :time                    0.00)
; Definitional axioms for inverse functions
(assert (forall ((i1@180@01 Int) (j1@181@01 Int)) (!
  (implies
    (and
      (and (and (< j1@181@01 V@30@01) (<= 0 j1@181@01)) (< i1@180@01 V@30@01))
      (<= 0 i1@180@01))
    (and
      (=
        (inv@182@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))) j1@181@01))
        i1@180@01)
      (=
        (inv@183@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))) j1@181@01))
        j1@181@01)))
  :pattern ((aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) i1@180@01))) j1@181@01))
  :qid |int-invOfFct|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@183@01 r) V@30@01) (<= 0 (inv@183@01 r)))
        (< (inv@182@01 r) V@30@01))
      (<= 0 (inv@182@01 r)))
    (=
      (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) (inv@182@01 r)))) (inv@183@01 r))
      r))
  :pattern ((inv@182@01 r))
  :pattern ((inv@183@01 r))
  :qid |int-fctOfInv|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@183@01 r) V@30@01) (<= 0 (inv@183@01 r)))
        (< (inv@182@01 r) V@30@01))
      (<= 0 (inv@182@01 r)))
    ($FVF.loc_int ($FVF.lookup_int (as sm@145@01  $FVF<Int>) r) r))
  :pattern ((inv@182@01 r) (inv@183@01 r))
  )))
; Precomputing data for removing quantified permissions
(define-fun pTaken@184@01 ((r $Ref)) $Perm
  (ite
    (and
      (and
        (and (< (inv@183@01 r) V@30@01) (<= 0 (inv@183@01 r)))
        (< (inv@182@01 r) V@30@01))
      (<= 0 (inv@182@01 r)))
    ($Perm.min
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      $Perm.Write)
    $Perm.No))
; Done precomputing, updating quantified chunks
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Chunk depleted?
(set-option :timeout 500)
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (=
    (-
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (pTaken@184@01 r))
    $Perm.No)
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               43401
;  :arith-add-rows          38163
;  :arith-assert-diseq      3000
;  :arith-assert-lower      13029
;  :arith-assert-upper      9318
;  :arith-bound-prop        2757
;  :arith-conflicts         880
;  :arith-eq-adapter        8739
;  :arith-fixed-eqs         4409
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5390
;  :arith-pivots            5868
;  :arith-pseudo-nonlinear  4
;  :conflicts               2000
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 921
;  :datatype-occurs-check   442
;  :datatype-splits         344
;  :decisions               6489
;  :del-clause              53062
;  :final-checks            310
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  8.92
;  :minimized-lits          408
;  :mk-bool-var             69985
;  :mk-clause               53071
;  :num-allocs              526203
;  :num-checks              332
;  :propagations            33830
;  :quant-instantiations    15632
;  :rlimit-count            2134230
;  :time                    0.01)
; Intermediate check if already taken enough permissions
(push) ; 14
(assert (not (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@183@01 r) V@30@01) (<= 0 (inv@183@01 r)))
        (< (inv@182@01 r) V@30@01))
      (<= 0 (inv@182@01 r)))
    (= (- $Perm.Write (pTaken@184@01 r)) $Perm.No))
  
  ))))
(check-sat)
; unsat
(pop) ; 14
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               43513
;  :arith-add-rows          38192
;  :arith-assert-diseq      3002
;  :arith-assert-lower      13042
;  :arith-assert-upper      9329
;  :arith-bound-prop        2762
;  :arith-conflicts         882
;  :arith-eq-adapter        8749
;  :arith-fixed-eqs         4414
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5397
;  :arith-pivots            5883
;  :arith-pseudo-nonlinear  4
;  :conflicts               2006
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 925
;  :datatype-occurs-check   442
;  :datatype-splits         344
;  :decisions               6494
;  :del-clause              53264
;  :final-checks            310
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  8.92
;  :minimized-lits          408
;  :mk-bool-var             70265
;  :mk-clause               53273
;  :num-allocs              527743
;  :num-checks              333
;  :propagations            33858
;  :quant-instantiations    15726
;  :rlimit-count            2140866
;  :time                    0.00)
; Final check if taken enough permissions
; Done removing quantified permissions
; Definitional axioms for snapshot map values
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 14
(set-option :timeout 10)
(push) ; 15
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               43550
;  :arith-add-rows          38192
;  :arith-assert-diseq      3002
;  :arith-assert-lower      13042
;  :arith-assert-upper      9329
;  :arith-bound-prop        2762
;  :arith-conflicts         882
;  :arith-eq-adapter        8749
;  :arith-fixed-eqs         4414
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5397
;  :arith-pivots            5883
;  :arith-pseudo-nonlinear  4
;  :conflicts               2006
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 933
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6502
;  :del-clause              53264
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  8.93
;  :minimized-lits          408
;  :mk-bool-var             70269
;  :mk-clause               53273
;  :num-allocs              528371
;  :num-checks              334
;  :propagations            33858
;  :quant-instantiations    15726
;  :rlimit-count            2141571)
; [then-branch: 221 | exc@122@01 == Null | live]
; [else-branch: 221 | exc@122@01 != Null | dead]
(push) ; 15
; [then-branch: 221 | exc@122@01 == Null]
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@185@01 Int)
(push) ; 16
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 17
; [then-branch: 222 | 0 <= unknown@185@01 | live]
; [else-branch: 222 | !(0 <= unknown@185@01) | live]
(push) ; 18
; [then-branch: 222 | 0 <= unknown@185@01]
(assert (<= 0 unknown@185@01))
; [eval] unknown < V
(pop) ; 18
(push) ; 18
; [else-branch: 222 | !(0 <= unknown@185@01)]
(assert (not (<= 0 unknown@185@01)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 223 | unknown@185@01 < V@30@01 && 0 <= unknown@185@01 | live]
; [else-branch: 223 | !(unknown@185@01 < V@30@01 && 0 <= unknown@185@01) | live]
(push) ; 18
; [then-branch: 223 | unknown@185@01 < V@30@01 && 0 <= unknown@185@01]
(assert (and (< unknown@185@01 V@30@01) (<= 0 unknown@185@01)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@186@01 Int)
(push) ; 19
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 20
; [then-branch: 224 | 0 <= unknown1@186@01 | live]
; [else-branch: 224 | !(0 <= unknown1@186@01) | live]
(push) ; 21
; [then-branch: 224 | 0 <= unknown1@186@01]
(assert (<= 0 unknown1@186@01))
; [eval] unknown1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 224 | !(0 <= unknown1@186@01)]
(assert (not (<= 0 unknown1@186@01)))
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 225 | unknown1@186@01 < V@30@01 && 0 <= unknown1@186@01 | live]
; [else-branch: 225 | !(unknown1@186@01 < V@30@01 && 0 <= unknown1@186@01) | live]
(push) ; 21
; [then-branch: 225 | unknown1@186@01 < V@30@01 && 0 <= unknown1@186@01]
(assert (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01)))
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               43550
;  :arith-add-rows          38192
;  :arith-assert-diseq      3002
;  :arith-assert-lower      13046
;  :arith-assert-upper      9329
;  :arith-bound-prop        2762
;  :arith-conflicts         882
;  :arith-eq-adapter        8749
;  :arith-fixed-eqs         4414
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5397
;  :arith-pivots            5883
;  :arith-pseudo-nonlinear  4
;  :conflicts               2006
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 933
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6502
;  :del-clause              53264
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  8.93
;  :minimized-lits          408
;  :mk-bool-var             70273
;  :mk-clause               53273
;  :num-allocs              528557
;  :num-checks              335
;  :propagations            33858
;  :quant-instantiations    15726
;  :rlimit-count            2141926)
(assert (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44303
;  :arith-add-rows          38698
;  :arith-assert-diseq      3064
;  :arith-assert-lower      13293
;  :arith-assert-upper      9490
;  :arith-bound-prop        2817
;  :arith-conflicts         897
;  :arith-eq-adapter        8908
;  :arith-fixed-eqs         4498
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5529
;  :arith-pivots            5966
;  :arith-pseudo-nonlinear  4
;  :conflicts               2041
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 937
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6624
;  :del-clause              54029
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  8.99
;  :minimized-lits          410
;  :mk-bool-var             71426
;  :mk-clause               54203
;  :num-allocs              533074
;  :num-checks              336
;  :propagations            34556
;  :quant-instantiations    15962
;  :rlimit-count            2167404
;  :time                    0.00)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44303
;  :arith-add-rows          38698
;  :arith-assert-diseq      3064
;  :arith-assert-lower      13293
;  :arith-assert-upper      9490
;  :arith-bound-prop        2817
;  :arith-conflicts         897
;  :arith-eq-adapter        8908
;  :arith-fixed-eqs         4498
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5529
;  :arith-pivots            5966
;  :arith-pseudo-nonlinear  4
;  :conflicts               2042
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 937
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6624
;  :del-clause              54029
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  8.99
;  :minimized-lits          410
;  :mk-bool-var             71426
;  :mk-clause               54203
;  :num-allocs              533165
;  :num-checks              337
;  :propagations            34556
;  :quant-instantiations    15962
;  :rlimit-count            2167499)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@186@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44309
;  :arith-add-rows          38703
;  :arith-assert-diseq      3064
;  :arith-assert-lower      13296
;  :arith-assert-upper      9491
;  :arith-bound-prop        2817
;  :arith-conflicts         898
;  :arith-eq-adapter        8909
;  :arith-fixed-eqs         4499
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5529
;  :arith-pivots            5970
;  :arith-pseudo-nonlinear  4
;  :conflicts               2043
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 937
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6624
;  :del-clause              54033
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  8.99
;  :minimized-lits          410
;  :mk-bool-var             71437
;  :mk-clause               54207
;  :num-allocs              533368
;  :num-checks              338
;  :propagations            34558
;  :quant-instantiations    15971
;  :rlimit-count            2168056)
(assert (<
  unknown1@186@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@186@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
              V@30@01)
            (<=
              0
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))))
          (<
            (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            V@30@01))
        (<=
          0
          (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
              V@30@01)
            (<=
              0
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))))
          (<
            (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            V@30@01))
        (<=
          0
          (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44984
;  :arith-add-rows          39038
;  :arith-assert-diseq      3094
;  :arith-assert-lower      13530
;  :arith-assert-upper      9624
;  :arith-bound-prop        2854
;  :arith-conflicts         912
;  :arith-eq-adapter        9046
;  :arith-fixed-eqs         4584
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5583
;  :arith-pivots            6054
;  :arith-pseudo-nonlinear  4
;  :conflicts               2071
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 941
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6699
;  :del-clause              54661
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  9.00
;  :minimized-lits          411
;  :mk-bool-var             72563
;  :mk-clause               54869
;  :num-allocs              537705
;  :num-checks              339
;  :propagations            35020
;  :quant-instantiations    16214
;  :rlimit-count            2186176
;  :time                    0.01)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               44984
;  :arith-add-rows          39038
;  :arith-assert-diseq      3094
;  :arith-assert-lower      13530
;  :arith-assert-upper      9624
;  :arith-bound-prop        2854
;  :arith-conflicts         912
;  :arith-eq-adapter        9046
;  :arith-fixed-eqs         4584
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5583
;  :arith-pivots            6054
;  :arith-pseudo-nonlinear  4
;  :conflicts               2071
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 941
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6699
;  :del-clause              54661
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  9.00
;  :minimized-lits          411
;  :mk-bool-var             72563
;  :mk-clause               54869
;  :num-allocs              537732
;  :num-checks              340
;  :propagations            35020
;  :quant-instantiations    16214
;  :rlimit-count            2186206)
(assert (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               46341
;  :arith-add-rows          40042
;  :arith-assert-diseq      3162
;  :arith-assert-lower      13970
;  :arith-assert-upper      9892
;  :arith-bound-prop        2939
;  :arith-conflicts         929
;  :arith-eq-adapter        9323
;  :arith-fixed-eqs         4752
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5722
;  :arith-pivots            6217
;  :arith-pseudo-nonlinear  4
;  :conflicts               2110
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 945
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6853
;  :del-clause              56139
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  9.16
;  :minimized-lits          417
;  :mk-bool-var             74774
;  :mk-clause               56472
;  :num-allocs              546125
;  :num-checks              341
;  :propagations            36014
;  :quant-instantiations    16744
;  :rlimit-count            2235198
;  :time                    0.01)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               46341
;  :arith-add-rows          40042
;  :arith-assert-diseq      3162
;  :arith-assert-lower      13970
;  :arith-assert-upper      9892
;  :arith-bound-prop        2939
;  :arith-conflicts         929
;  :arith-eq-adapter        9323
;  :arith-fixed-eqs         4752
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5722
;  :arith-pivots            6217
;  :arith-pseudo-nonlinear  4
;  :conflicts               2111
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 945
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6853
;  :del-clause              56139
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  9.16
;  :minimized-lits          417
;  :mk-bool-var             74774
;  :mk-clause               56472
;  :num-allocs              546216
;  :num-checks              342
;  :propagations            36014
;  :quant-instantiations    16744
;  :rlimit-count            2235293)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@186@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               46347
;  :arith-add-rows          40058
;  :arith-assert-diseq      3162
;  :arith-assert-lower      13973
;  :arith-assert-upper      9893
;  :arith-bound-prop        2939
;  :arith-conflicts         930
;  :arith-eq-adapter        9324
;  :arith-fixed-eqs         4753
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5722
;  :arith-pivots            6221
;  :arith-pseudo-nonlinear  4
;  :conflicts               2112
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 945
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6853
;  :del-clause              56143
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  9.16
;  :minimized-lits          417
;  :mk-bool-var             74785
;  :mk-clause               56476
;  :num-allocs              546417
;  :num-checks              343
;  :propagations            36016
;  :quant-instantiations    16751
;  :rlimit-count            2235959)
(assert (<
  unknown1@186@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@186@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
              V@30@01)
            (<=
              0
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
          (<
            (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
            V@30@01))
        (<=
          0
          (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
              V@30@01)
            (<=
              0
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
          (<
            (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
            V@30@01))
        (<=
          0
          (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               47687
;  :arith-add-rows          40841
;  :arith-assert-diseq      3213
;  :arith-assert-lower      14353
;  :arith-assert-upper      10109
;  :arith-bound-prop        3007
;  :arith-conflicts         948
;  :arith-eq-adapter        9595
;  :arith-fixed-eqs         4892
;  :arith-grobner           159
;  :arith-max-min           1089
;  :arith-nonlinear-bounds  108
;  :arith-nonlinear-horner  130
;  :arith-offset-eqs        5829
;  :arith-pivots            6364
;  :arith-pseudo-nonlinear  4
;  :conflicts               2150
;  :datatype-accessor-ax    104
;  :datatype-constructor-ax 949
;  :datatype-occurs-check   447
;  :datatype-splits         348
;  :decisions               6979
;  :del-clause              57589
;  :final-checks            312
;  :interface-eqs           29
;  :max-generation          7
;  :max-memory              9.58
;  :memory                  9.28
;  :minimized-lits          418
;  :mk-bool-var             77176
;  :mk-clause               57945
;  :num-allocs              555182
;  :num-checks              344
;  :propagations            36757
;  :quant-instantiations    17294
;  :rlimit-count            2272386
;  :time                    0.01)
(pop) ; 21
(push) ; 21
; [else-branch: 225 | !(unknown1@186@01 < V@30@01 && 0 <= unknown1@186@01)]
(assert (not (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))))
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
  (and
    (< unknown1@186@01 V@30@01)
    (<= 0 unknown1@186@01)
    (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@186@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
    (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@186@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@186@01 Int)) (!
  (implies
    (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
    (and
      (< unknown1@186@01 V@30@01)
      (<= 0 unknown1@186@01)
      (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@186@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
      (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@186@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@186@01 Int)) (!
  (implies
    (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
    (and
      (< unknown1@186@01 V@30@01)
      (<= 0 unknown1@186@01)
      (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@186@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
      (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@186@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(push) ; 18
; [else-branch: 223 | !(unknown@185@01 < V@30@01 && 0 <= unknown@185@01)]
(assert (not (and (< unknown@185@01 V@30@01) (<= 0 unknown@185@01))))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< unknown@185@01 V@30@01) (<= 0 unknown@185@01))
  (and
    (< unknown@185@01 V@30@01)
    (<= 0 unknown@185@01)
    (forall ((unknown1@186@01 Int)) (!
      (implies
        (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
        (and
          (< unknown1@186@01 V@30@01)
          (<= 0 unknown1@186@01)
          (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@186@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
          (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@186@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@186@01 Int)) (!
      (implies
        (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
        (and
          (< unknown1@186@01 V@30@01)
          (<= 0 unknown1@186@01)
          (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@186@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
          (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@186@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@185@01 Int)) (!
  (implies
    (and (< unknown@185@01 V@30@01) (<= 0 unknown@185@01))
    (and
      (< unknown@185@01 V@30@01)
      (<= 0 unknown@185@01)
      (forall ((unknown1@186@01 Int)) (!
        (implies
          (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
          (and
            (< unknown1@186@01 V@30@01)
            (<= 0 unknown1@186@01)
            (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@186@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@186@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@186@01 Int)) (!
        (implies
          (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
          (and
            (< unknown1@186@01 V@30@01)
            (<= 0 unknown1@186@01)
            (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@186@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@186@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@185@01 Int)) (!
  (implies
    (and (< unknown@185@01 V@30@01) (<= 0 unknown@185@01))
    (and
      (< unknown@185@01 V@30@01)
      (<= 0 unknown@185@01)
      (forall ((unknown1@186@01 Int)) (!
        (implies
          (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
          (and
            (< unknown1@186@01 V@30@01)
            (<= 0 unknown1@186@01)
            (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@186@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@186@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@186@01 Int)) (!
        (implies
          (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
          (and
            (< unknown1@186@01 V@30@01)
            (<= 0 unknown1@186@01)
            (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@186@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@186@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (implies
  (= exc@122@01 $Ref.null)
  (and
    (forall ((unknown@185@01 Int)) (!
      (implies
        (and (< unknown@185@01 V@30@01) (<= 0 unknown@185@01))
        (and
          (< unknown@185@01 V@30@01)
          (<= 0 unknown@185@01)
          (forall ((unknown1@186@01 Int)) (!
            (implies
              (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
              (and
                (< unknown1@186@01 V@30@01)
                (<= 0 unknown1@186@01)
                (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@186@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
                (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@186@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@186@01 Int)) (!
            (implies
              (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
              (and
                (< unknown1@186@01 V@30@01)
                (<= 0 unknown1@186@01)
                (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@186@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
                (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@186@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@185@01 Int)) (!
      (implies
        (and (< unknown@185@01 V@30@01) (<= 0 unknown@185@01))
        (and
          (< unknown@185@01 V@30@01)
          (<= 0 unknown@185@01)
          (forall ((unknown1@186@01 Int)) (!
            (implies
              (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
              (and
                (< unknown1@186@01 V@30@01)
                (<= 0 unknown1@186@01)
                (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@186@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
                (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@186@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@186@01 Int)) (!
            (implies
              (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
              (and
                (< unknown1@186@01 V@30@01)
                (<= 0 unknown1@186@01)
                (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@186@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
                (< unknown@185@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@186@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))
      :qid |prog.l<no position>-aux|)))))
(push) ; 14
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((unknown@185@01 Int)) (!
    (implies
      (and (< unknown@185@01 V@30@01) (<= 0 unknown@185@01))
      (forall ((unknown1@186@01 Int)) (!
        (implies
          (and (< unknown1@186@01 V@30@01) (<= 0 unknown1@186@01))
          (=
            ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
            ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))) unknown1@186@01))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))) unknown1@186@01))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@185@01))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@185@01))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unknown
(pop) ; 14
; 0.06s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               51537
;  :arith-add-rows          43010
;  :arith-assert-diseq      3409
;  :arith-assert-lower      15542
;  :arith-assert-upper      10911
;  :arith-bound-prop        3149
;  :arith-conflicts         983
;  :arith-eq-adapter        10265
;  :arith-fixed-eqs         5209
;  :arith-grobner           285
;  :arith-max-min           1234
;  :arith-nonlinear-bounds  130
;  :arith-nonlinear-horner  244
;  :arith-offset-eqs        6602
;  :arith-pivots            6770
;  :arith-pseudo-nonlinear  8
;  :conflicts               2201
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1067
;  :datatype-occurs-check   537
;  :datatype-splits         474
;  :decisions               7874
;  :del-clause              61984
;  :final-checks            351
;  :interface-eqs           43
;  :max-generation          7
;  :max-memory              10.08
;  :memory                  9.95
;  :minimized-lits          421
;  :mk-bool-var             81904
;  :mk-clause               61993
;  :num-allocs              598075
;  :num-checks              345
;  :propagations            39333
;  :quant-instantiations    18440
;  :rlimit-count            2742355
;  :time                    0.06)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map values
(declare-const pm@187@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@187@01  $FPM) r)
    (+
      (+
        (+
          (ite
            (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
            (*
              (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
              $k@134@01)
            $Perm.No)
          (ite
            (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
            (*
              (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
              $k@126@01)
            $Perm.No))
        (-
          (-
            (ite
              (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
              $k@43@01
              $Perm.No)
            (pTaken@95@01 r))
          (pTaken@106@01 r)))
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r))))
  :pattern (($FVF.perm_option$array$ (as pm@187@01  $FPM) r))
  :qid |qp.resPrmSumDef54|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@187@01  $FPM) r))
  :qid |qp.resTrgDef55|)))
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@187@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
; Definitional axioms for snapshot map values
(declare-const pm@188@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@188@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@188@01  $FPM) r))
  :qid |qp.resPrmSumDef56|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@188@01  $FPM) r))
  :qid |qp.resTrgDef57|)))
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@188@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 14
(push) ; 15
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               51611
;  :arith-add-rows          43010
;  :arith-assert-diseq      3409
;  :arith-assert-lower      15557
;  :arith-assert-upper      10919
;  :arith-bound-prop        3149
;  :arith-conflicts         983
;  :arith-eq-adapter        10265
;  :arith-fixed-eqs         5209
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        6602
;  :arith-pivots            6770
;  :arith-pseudo-nonlinear  8
;  :conflicts               2201
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1083
;  :datatype-occurs-check   547
;  :datatype-splits         482
;  :decisions               7890
;  :del-clause              61984
;  :final-checks            357
;  :interface-eqs           43
;  :max-generation          7
;  :max-memory              10.08
;  :memory                  9.92
;  :minimized-lits          421
;  :mk-bool-var             81918
;  :mk-clause               61993
;  :num-allocs              600778
;  :num-checks              347
;  :propagations            39333
;  :quant-instantiations    18440
;  :rlimit-count            2748325)
; [then-branch: 226 | exc@122@01 == Null | live]
; [else-branch: 226 | exc@122@01 != Null | dead]
(push) ; 15
; [then-branch: 226 | exc@122@01 == Null]
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
(declare-const sm@189@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef62|)))
(declare-const pm@190@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@190@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@190@01  $FPM) r))
  :qid |qp.resPrmSumDef63|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@190@01  $FPM) r))
  :qid |qp.resTrgDef64|)))
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@190@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
(declare-const sm@191@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@191@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef65|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@191@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@191@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef67|)))
(declare-const pm@192@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@192@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@192@01  $FPM) r))
  :qid |qp.resPrmSumDef68|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@191@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@192@01  $FPM) r))
  :qid |qp.resTrgDef69|)))
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@192@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@191@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@193@01 Int)
(push) ; 16
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 17
; [then-branch: 227 | 0 <= unknown@193@01 | live]
; [else-branch: 227 | !(0 <= unknown@193@01) | live]
(push) ; 18
; [then-branch: 227 | 0 <= unknown@193@01]
(assert (<= 0 unknown@193@01))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] unknown < V
(pop) ; 18
(push) ; 18
; [else-branch: 227 | !(0 <= unknown@193@01)]
(assert (not (<= 0 unknown@193@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 228 | unknown@193@01 < V@30@01 && 0 <= unknown@193@01 | live]
; [else-branch: 228 | !(unknown@193@01 < V@30@01 && 0 <= unknown@193@01) | live]
(push) ; 18
; [then-branch: 228 | unknown@193@01 < V@30@01 && 0 <= unknown@193@01]
(assert (and (< unknown@193@01 V@30@01) (<= 0 unknown@193@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@194@01 Int)
(push) ; 19
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 20
; [then-branch: 229 | 0 <= unknown1@194@01 | live]
; [else-branch: 229 | !(0 <= unknown1@194@01) | live]
(push) ; 21
; [then-branch: 229 | 0 <= unknown1@194@01]
(assert (<= 0 unknown1@194@01))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] unknown1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 229 | !(0 <= unknown1@194@01)]
(assert (not (<= 0 unknown1@194@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 230 | unknown1@194@01 < V@30@01 && 0 <= unknown1@194@01 | live]
; [else-branch: 230 | !(unknown1@194@01 < V@30@01 && 0 <= unknown1@194@01) | live]
(push) ; 21
; [then-branch: 230 | unknown1@194@01 < V@30@01 && 0 <= unknown1@194@01]
(assert (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               51870
;  :arith-add-rows          43010
;  :arith-assert-diseq      3409
;  :arith-assert-lower      15563
;  :arith-assert-upper      10921
;  :arith-bound-prop        3149
;  :arith-conflicts         983
;  :arith-eq-adapter        10265
;  :arith-fixed-eqs         5209
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        6602
;  :arith-pivots            6772
;  :arith-pseudo-nonlinear  8
;  :conflicts               2201
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1139
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               7946
;  :del-clause              61984
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          7
;  :max-memory              10.08
;  :memory                  9.92
;  :minimized-lits          421
;  :mk-bool-var             81968
;  :mk-clause               61993
;  :num-allocs              608371
;  :num-checks              355
;  :propagations            39333
;  :quant-instantiations    18440
;  :rlimit-count            2764302)
(assert (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               52504
;  :arith-add-rows          43587
;  :arith-assert-diseq      3443
;  :arith-assert-lower      15800
;  :arith-assert-upper      11058
;  :arith-bound-prop        3192
;  :arith-conflicts         1000
;  :arith-eq-adapter        10394
;  :arith-fixed-eqs         5295
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        6713
;  :arith-pivots            6864
;  :arith-pseudo-nonlinear  8
;  :conflicts               2233
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1143
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8001
;  :del-clause              62329
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          7
;  :max-memory              10.08
;  :memory                  9.92
;  :minimized-lits          425
;  :mk-bool-var             82761
;  :mk-clause               62510
;  :num-allocs              612593
;  :num-checks              356
;  :propagations            39849
;  :quant-instantiations    18617
;  :rlimit-count            2788946
;  :time                    0.00)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               52504
;  :arith-add-rows          43587
;  :arith-assert-diseq      3443
;  :arith-assert-lower      15800
;  :arith-assert-upper      11058
;  :arith-bound-prop        3192
;  :arith-conflicts         1000
;  :arith-eq-adapter        10394
;  :arith-fixed-eqs         5295
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        6713
;  :arith-pivots            6864
;  :arith-pseudo-nonlinear  8
;  :conflicts               2234
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1143
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8001
;  :del-clause              62329
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          7
;  :max-memory              10.08
;  :memory                  9.92
;  :minimized-lits          425
;  :mk-bool-var             82761
;  :mk-clause               62510
;  :num-allocs              612684
;  :num-checks              357
;  :propagations            39849
;  :quant-instantiations    18617
;  :rlimit-count            2789041)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@194@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               52510
;  :arith-add-rows          43591
;  :arith-assert-diseq      3443
;  :arith-assert-lower      15802
;  :arith-assert-upper      11060
;  :arith-bound-prop        3192
;  :arith-conflicts         1001
;  :arith-eq-adapter        10395
;  :arith-fixed-eqs         5296
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        6713
;  :arith-pivots            6866
;  :arith-pseudo-nonlinear  8
;  :conflicts               2235
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1143
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8001
;  :del-clause              62336
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          7
;  :max-memory              10.08
;  :memory                  9.91
;  :minimized-lits          425
;  :mk-bool-var             82775
;  :mk-clause               62517
;  :num-allocs              612971
;  :num-checks              358
;  :propagations            39853
;  :quant-instantiations    18627
;  :rlimit-count            2789933)
(assert (<
  unknown1@194@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@194@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
              V@30@01)
            (<=
              0
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))))
          (<
            (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            V@30@01))
        (<=
          0
          (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
              V@30@01)
            (<=
              0
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))))
          (<
            (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            V@30@01))
        (<=
          0
          (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               53311
;  :arith-add-rows          44228
;  :arith-assert-diseq      3461
;  :arith-assert-lower      16037
;  :arith-assert-upper      11209
;  :arith-bound-prop        3259
;  :arith-conflicts         1011
;  :arith-eq-adapter        10559
;  :arith-fixed-eqs         5388
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        6802
;  :arith-pivots            6994
;  :arith-pseudo-nonlinear  8
;  :conflicts               2256
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1147
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8088
;  :del-clause              63258
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          7
;  :max-memory              10.36
;  :memory                  10.32
;  :minimized-lits          426
;  :mk-bool-var             84671
;  :mk-clause               63690
;  :num-allocs              621805
;  :num-checks              359
;  :propagations            40341
;  :quant-instantiations    19036
;  :rlimit-count            2827188
;  :time                    0.01)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               53311
;  :arith-add-rows          44228
;  :arith-assert-diseq      3461
;  :arith-assert-lower      16037
;  :arith-assert-upper      11209
;  :arith-bound-prop        3259
;  :arith-conflicts         1011
;  :arith-eq-adapter        10559
;  :arith-fixed-eqs         5388
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        6802
;  :arith-pivots            6994
;  :arith-pseudo-nonlinear  8
;  :conflicts               2256
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1147
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8088
;  :del-clause              63258
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          7
;  :max-memory              10.36
;  :memory                  10.32
;  :minimized-lits          426
;  :mk-bool-var             84671
;  :mk-clause               63690
;  :num-allocs              621832
;  :num-checks              360
;  :propagations            40341
;  :quant-instantiations    19036
;  :rlimit-count            2827218)
(assert (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.04s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               57354
;  :arith-add-rows          47653
;  :arith-assert-diseq      3657
;  :arith-assert-lower      17151
;  :arith-assert-upper      12160
;  :arith-bound-prop        3499
;  :arith-conflicts         1047
;  :arith-eq-adapter        11405
;  :arith-fixed-eqs         5854
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        7257
;  :arith-pivots            7492
;  :arith-pseudo-nonlinear  8
;  :conflicts               2340
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1151
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8639
;  :del-clause              67635
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          8
;  :max-memory              10.72
;  :memory                  10.66
;  :minimized-lits          437
;  :mk-bool-var             90568
;  :mk-clause               68067
;  :num-allocs              644302
;  :num-checks              361
;  :propagations            43223
;  :quant-instantiations    20438
;  :rlimit-count            2994000
;  :time                    0.03)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               57354
;  :arith-add-rows          47653
;  :arith-assert-diseq      3657
;  :arith-assert-lower      17151
;  :arith-assert-upper      12160
;  :arith-bound-prop        3499
;  :arith-conflicts         1047
;  :arith-eq-adapter        11405
;  :arith-fixed-eqs         5854
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        7257
;  :arith-pivots            7492
;  :arith-pseudo-nonlinear  8
;  :conflicts               2341
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1151
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8639
;  :del-clause              67635
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          8
;  :max-memory              10.72
;  :memory                  10.66
;  :minimized-lits          437
;  :mk-bool-var             90568
;  :mk-clause               68067
;  :num-allocs              644392
;  :num-checks              362
;  :propagations            43223
;  :quant-instantiations    20438
;  :rlimit-count            2994091)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@194@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               57354
;  :arith-add-rows          47653
;  :arith-assert-diseq      3657
;  :arith-assert-lower      17151
;  :arith-assert-upper      12160
;  :arith-bound-prop        3499
;  :arith-conflicts         1047
;  :arith-eq-adapter        11405
;  :arith-fixed-eqs         5854
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        7257
;  :arith-pivots            7492
;  :arith-pseudo-nonlinear  8
;  :conflicts               2342
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1151
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8639
;  :del-clause              67635
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          8
;  :max-memory              10.72
;  :memory                  10.66
;  :minimized-lits          437
;  :mk-bool-var             90568
;  :mk-clause               68067
;  :num-allocs              644536
;  :num-checks              363
;  :propagations            43223
;  :quant-instantiations    20438
;  :rlimit-count            2994334)
(assert (<
  unknown1@194@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@194@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
              V@30@01)
            (<=
              0
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
          (<
            (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
            V@30@01))
        (<=
          0
          (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
              V@30@01)
            (<=
              0
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
          (<
            (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
            V@30@01))
        (<=
          0
          (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               57979
;  :arith-add-rows          48099
;  :arith-assert-diseq      3677
;  :arith-assert-lower      17335
;  :arith-assert-upper      12281
;  :arith-bound-prop        3549
;  :arith-conflicts         1058
;  :arith-eq-adapter        11546
;  :arith-fixed-eqs         5934
;  :arith-grobner           290
;  :arith-max-min           1260
;  :arith-nonlinear-bounds  133
;  :arith-nonlinear-horner  248
;  :arith-offset-eqs        7283
;  :arith-pivots            7612
;  :arith-pseudo-nonlinear  8
;  :conflicts               2365
;  :datatype-accessor-ax    146
;  :datatype-constructor-ax 1155
;  :datatype-occurs-check   582
;  :datatype-splits         510
;  :decisions               8708
;  :del-clause              68491
;  :final-checks            371
;  :interface-eqs           43
;  :max-generation          8
;  :max-memory              10.72
;  :memory                  10.65
;  :minimized-lits          438
;  :mk-bool-var             92019
;  :mk-clause               68923
;  :num-allocs              650376
;  :num-checks              364
;  :propagations            43579
;  :quant-instantiations    20718
;  :rlimit-count            3019777
;  :time                    0.01)
(pop) ; 21
(push) ; 21
; [else-branch: 230 | !(unknown1@194@01 < V@30@01 && 0 <= unknown1@194@01)]
(assert (not (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
  (and
    (< unknown1@194@01 V@30@01)
    (<= 0 unknown1@194@01)
    (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@194@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
    (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@194@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@194@01 Int)) (!
  (implies
    (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
    (and
      (< unknown1@194@01 V@30@01)
      (<= 0 unknown1@194@01)
      (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@194@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
      (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@194@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@194@01 Int)) (!
  (implies
    (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
    (and
      (< unknown1@194@01 V@30@01)
      (<= 0 unknown1@194@01)
      (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@194@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
      (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@194@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(push) ; 18
; [else-branch: 228 | !(unknown@193@01 < V@30@01 && 0 <= unknown@193@01)]
(assert (not (and (< unknown@193@01 V@30@01) (<= 0 unknown@193@01))))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< unknown@193@01 V@30@01) (<= 0 unknown@193@01))
  (and
    (< unknown@193@01 V@30@01)
    (<= 0 unknown@193@01)
    (forall ((unknown1@194@01 Int)) (!
      (implies
        (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
        (and
          (< unknown1@194@01 V@30@01)
          (<= 0 unknown1@194@01)
          (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@194@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
          (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@194@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@194@01 Int)) (!
      (implies
        (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
        (and
          (< unknown1@194@01 V@30@01)
          (<= 0 unknown1@194@01)
          (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@194@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
          (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@194@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@193@01 Int)) (!
  (implies
    (and (< unknown@193@01 V@30@01) (<= 0 unknown@193@01))
    (and
      (< unknown@193@01 V@30@01)
      (<= 0 unknown@193@01)
      (forall ((unknown1@194@01 Int)) (!
        (implies
          (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
          (and
            (< unknown1@194@01 V@30@01)
            (<= 0 unknown1@194@01)
            (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@194@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@194@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@194@01 Int)) (!
        (implies
          (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
          (and
            (< unknown1@194@01 V@30@01)
            (<= 0 unknown1@194@01)
            (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@194@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@194@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@193@01 Int)) (!
  (implies
    (and (< unknown@193@01 V@30@01) (<= 0 unknown@193@01))
    (and
      (< unknown@193@01 V@30@01)
      (<= 0 unknown@193@01)
      (forall ((unknown1@194@01 Int)) (!
        (implies
          (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
          (and
            (< unknown1@194@01 V@30@01)
            (<= 0 unknown1@194@01)
            (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@194@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@194@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@194@01 Int)) (!
        (implies
          (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
          (and
            (< unknown1@194@01 V@30@01)
            (<= 0 unknown1@194@01)
            (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@194@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@194@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef58|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef59|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef60|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef61|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef62|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@190@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@190@01  $FPM) r))
  :qid |qp.resPrmSumDef63|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@190@01  $FPM) r))
  :qid |qp.resTrgDef64|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@191@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef65|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@191@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@191@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef66|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@191@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef67|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@192@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@192@01  $FPM) r))
  :qid |qp.resPrmSumDef68|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@191@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@192@01  $FPM) r))
  :qid |qp.resTrgDef69|)))
(assert (implies
  (= exc@122@01 $Ref.null)
  (and
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@190@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@189@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@192@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@191@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((unknown@193@01 Int)) (!
      (implies
        (and (< unknown@193@01 V@30@01) (<= 0 unknown@193@01))
        (and
          (< unknown@193@01 V@30@01)
          (<= 0 unknown@193@01)
          (forall ((unknown1@194@01 Int)) (!
            (implies
              (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
              (and
                (< unknown1@194@01 V@30@01)
                (<= 0 unknown1@194@01)
                (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@194@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
                (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@194@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@194@01 Int)) (!
            (implies
              (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
              (and
                (< unknown1@194@01 V@30@01)
                (<= 0 unknown1@194@01)
                (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@194@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
                (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@194@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@193@01 Int)) (!
      (implies
        (and (< unknown@193@01 V@30@01) (<= 0 unknown@193@01))
        (and
          (< unknown@193@01 V@30@01)
          (<= 0 unknown@193@01)
          (forall ((unknown1@194@01 Int)) (!
            (implies
              (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
              (and
                (< unknown1@194@01 V@30@01)
                (<= 0 unknown1@194@01)
                (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@194@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
                (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@194@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@194@01 Int)) (!
            (implies
              (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
              (and
                (< unknown1@194@01 V@30@01)
                (<= 0 unknown1@194@01)
                (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@194@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
                (< unknown@193@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@194@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))
      :qid |prog.l<no position>-aux|)))))
(set-option :timeout 0)
(push) ; 14
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((unknown@193@01 Int)) (!
    (implies
      (and (< unknown@193@01 V@30@01) (<= 0 unknown@193@01))
      (forall ((unknown1@194@01 Int)) (!
        (implies
          (and (< unknown1@194@01 V@30@01) (<= 0 unknown1@194@01))
          (=
            ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
            ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))) unknown1@194@01))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))) unknown1@194@01))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@193@01))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@193@01))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unknown
(pop) ; 14
; 0.09s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               62261
;  :arith-add-rows          50941
;  :arith-assert-diseq      3842
;  :arith-assert-lower      18447
;  :arith-assert-upper      13212
;  :arith-bound-prop        3710
;  :arith-conflicts         1082
;  :arith-eq-adapter        12201
;  :arith-fixed-eqs         6370
;  :arith-grobner           443
;  :arith-max-min           1433
;  :arith-nonlinear-bounds  157
;  :arith-nonlinear-horner  383
;  :arith-offset-eqs        8027
;  :arith-pivots            8078
;  :arith-pseudo-nonlinear  8
;  :conflicts               2405
;  :datatype-accessor-ax    182
;  :datatype-constructor-ax 1277
;  :datatype-occurs-check   686
;  :datatype-splits         632
;  :decisions               9556
;  :del-clause              72775
;  :final-checks            421
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.16
;  :memory                  11.00
;  :minimized-lits          443
;  :mk-bool-var             96669
;  :mk-clause               72784
;  :num-allocs              716194
;  :num-checks              367
;  :propagations            46149
;  :quant-instantiations    21960
;  :rlimit-count            3718154
;  :time                    0.09)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
(declare-const sm@195@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (pTaken@154@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef70|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No)
        (pTaken@155@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef71|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
              $k@43@01
              $Perm.No)
            (pTaken@95@01 r))
          (pTaken@106@01 r))
        (pTaken@167@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef72|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (-
            (ite
              (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
              $k@35@01
              $Perm.No)
            (pTaken@96@01 r))
          (pTaken@105@01 r))
        (pTaken@166@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef73|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef74|)))
(declare-const pm@196@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@196@01  $FPM) r)
    (+
      (+
        (+
          (-
            (ite
              (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
              (*
                (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
                $k@134@01)
              $Perm.No)
            (pTaken@154@01 r))
          (-
            (ite
              (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
              (*
                (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
                $k@126@01)
              $Perm.No)
            (pTaken@155@01 r)))
        (-
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r))
          (pTaken@167@01 r)))
      (-
        (-
          (-
            (ite
              (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
              $k@35@01
              $Perm.No)
            (pTaken@96@01 r))
          (pTaken@105@01 r))
        (pTaken@166@01 r))))
  :pattern (($FVF.perm_option$array$ (as pm@196@01  $FPM) r))
  :qid |qp.resPrmSumDef75|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@196@01  $FPM) r))
  :qid |qp.resTrgDef76|)))
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@196@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@195@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 14
(push) ; 15
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               62335
;  :arith-add-rows          50941
;  :arith-assert-diseq      3842
;  :arith-assert-lower      18462
;  :arith-assert-upper      13220
;  :arith-bound-prop        3710
;  :arith-conflicts         1082
;  :arith-eq-adapter        12201
;  :arith-fixed-eqs         6370
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        8027
;  :arith-pivots            8078
;  :arith-pseudo-nonlinear  8
;  :conflicts               2405
;  :datatype-accessor-ax    182
;  :datatype-constructor-ax 1293
;  :datatype-occurs-check   696
;  :datatype-splits         640
;  :decisions               9572
;  :del-clause              72775
;  :final-checks            427
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.16
;  :memory                  10.97
;  :minimized-lits          443
;  :mk-bool-var             96685
;  :mk-clause               72784
;  :num-allocs              720124
;  :num-checks              369
;  :propagations            46149
;  :quant-instantiations    21960
;  :rlimit-count            3730106)
; [then-branch: 231 | exc@122@01 == Null | live]
; [else-branch: 231 | exc@122@01 != Null | dead]
(push) ; 15
; [then-branch: 231 | exc@122@01 == Null]
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
(declare-const pm@197@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@01  $FPM) r)
    (+
      (+
        (+
          (ite
            (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
            (*
              (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
              $k@134@01)
            $Perm.No)
          (ite
            (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
            (*
              (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
              $k@126@01)
            $Perm.No))
        (-
          (-
            (ite
              (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
              $k@43@01
              $Perm.No)
            (pTaken@95@01 r))
          (pTaken@106@01 r)))
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r))))
  :pattern (($FVF.perm_option$array$ (as pm@197@01  $FPM) r))
  :qid |qp.resPrmSumDef77|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@01  $FPM) r))
  :qid |qp.resTrgDef78|)))
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@197@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
; Definitional axioms for snapshot map values
(declare-const pm@198@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@198@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@198@01  $FPM) r))
  :qid |qp.resPrmSumDef79|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@198@01  $FPM) r))
  :qid |qp.resTrgDef80|)))
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@198@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@199@01 Int)
(push) ; 16
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 17
; [then-branch: 232 | 0 <= unknown@199@01 | live]
; [else-branch: 232 | !(0 <= unknown@199@01) | live]
(push) ; 18
; [then-branch: 232 | 0 <= unknown@199@01]
(assert (<= 0 unknown@199@01))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
(declare-const sm@200@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef85|)))
(declare-const pm@201@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@201@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@201@01  $FPM) r))
  :qid |qp.resPrmSumDef86|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@201@01  $FPM) r))
  :qid |qp.resTrgDef87|)))
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@201@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
(declare-const sm@202@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef90|)))
(declare-const pm@203@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@203@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@203@01  $FPM) r))
  :qid |qp.resPrmSumDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@203@01  $FPM) r))
  :qid |qp.resTrgDef92|)))
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@203@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
; [eval] unknown < V
(pop) ; 18
(push) ; 18
; [else-branch: 232 | !(0 <= unknown@199@01)]
(assert (not (<= 0 unknown@199@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
(declare-const sm@204@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef97|)))
(declare-const pm@205@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@205@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@205@01  $FPM) r))
  :qid |qp.resPrmSumDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@205@01  $FPM) r))
  :qid |qp.resTrgDef99|)))
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
(declare-const sm@206@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef100|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef102|)))
(declare-const pm@207@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@207@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@207@01  $FPM) r))
  :qid |qp.resPrmSumDef103|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@207@01  $FPM) r))
  :qid |qp.resTrgDef104|)))
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@201@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@201@01  $FPM) r))
  :qid |qp.resPrmSumDef86|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@201@01  $FPM) r))
  :qid |qp.resTrgDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef90|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@203@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@203@01  $FPM) r))
  :qid |qp.resPrmSumDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@203@01  $FPM) r))
  :qid |qp.resTrgDef92|)))
(assert (implies
  (<= 0 unknown@199@01)
  (and
    (<= 0 unknown@199@01)
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@201@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@203@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|)))))
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef97|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@205@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@205@01  $FPM) r))
  :qid |qp.resPrmSumDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@205@01  $FPM) r))
  :qid |qp.resTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef100|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef102|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@207@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@207@01  $FPM) r))
  :qid |qp.resPrmSumDef103|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@207@01  $FPM) r))
  :qid |qp.resTrgDef104|)))
(assert (implies
  (not (<= 0 unknown@199@01))
  (and
    (not (<= 0 unknown@199@01))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|)))))
(push) ; 17
; [then-branch: 233 | unknown@199@01 < V@30@01 && 0 <= unknown@199@01 | live]
; [else-branch: 233 | !(unknown@199@01 < V@30@01 && 0 <= unknown@199@01) | live]
(push) ; 18
; [then-branch: 233 | unknown@199@01 < V@30@01 && 0 <= unknown@199@01]
(assert (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@208@01 Int)
(push) ; 19
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 20
; [then-branch: 234 | 0 <= unknown1@208@01 | live]
; [else-branch: 234 | !(0 <= unknown1@208@01) | live]
(push) ; 21
; [then-branch: 234 | 0 <= unknown1@208@01]
(assert (<= 0 unknown1@208@01))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] unknown1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 234 | !(0 <= unknown1@208@01)]
(assert (not (<= 0 unknown1@208@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 235 | unknown1@208@01 < V@30@01 && 0 <= unknown1@208@01 | live]
; [else-branch: 235 | !(unknown1@208@01 < V@30@01 && 0 <= unknown1@208@01) | live]
(push) ; 21
; [then-branch: 235 | unknown1@208@01 < V@30@01 && 0 <= unknown1@208@01]
(assert (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               62594
;  :arith-add-rows          50941
;  :arith-assert-diseq      3842
;  :arith-assert-lower      18468
;  :arith-assert-upper      13222
;  :arith-bound-prop        3710
;  :arith-conflicts         1082
;  :arith-eq-adapter        12201
;  :arith-fixed-eqs         6370
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        8027
;  :arith-pivots            8079
;  :arith-pseudo-nonlinear  8
;  :conflicts               2405
;  :datatype-accessor-ax    182
;  :datatype-constructor-ax 1349
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               9628
;  :del-clause              72775
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.16
;  :memory                  10.98
;  :minimized-lits          443
;  :mk-bool-var             96757
;  :mk-clause               72794
;  :num-allocs              734443
;  :num-checks              377
;  :propagations            46153
;  :quant-instantiations    21960
;  :rlimit-count            3764056)
(assert (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (-
          (-
            (ite
              (and
                (<
                  (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  V@30@01)
                (<=
                  0
                  (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))
              $k@35@01
              $Perm.No)
            (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))
          (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))
        (-
          (-
            (ite
              (and
                (<
                  (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  V@30@01)
                (<=
                  0
                  (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))
              $k@43@01
              $Perm.No)
            (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))
          (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))
      (ite
        (and
          (<
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
            V@30@01)
          (<=
            0
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)
        $Perm.No))
    (ite
      (and
        (<
          (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
          V@30@01)
        (<=
          0
          (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))
      (*
        (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
        $k@134@01)
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.01s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               64197
;  :arith-add-rows          53313
;  :arith-assert-diseq      3934
;  :arith-assert-lower      18875
;  :arith-assert-upper      13597
;  :arith-bound-prop        3818
;  :arith-conflicts         1105
;  :arith-eq-adapter        12529
;  :arith-fixed-eqs         6564
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        8272
;  :arith-pivots            8309
;  :arith-pseudo-nonlinear  8
;  :conflicts               2457
;  :datatype-accessor-ax    182
;  :datatype-constructor-ax 1353
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               9733
;  :del-clause              73876
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.16
;  :memory                  11.00
;  :minimized-lits          450
;  :mk-bool-var             98497
;  :mk-clause               74095
;  :num-allocs              742260
;  :num-checks              378
;  :propagations            47356
;  :quant-instantiations    22302
;  :rlimit-count            3858275
;  :time                    0.01)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               64407
;  :arith-add-rows          53493
;  :arith-assert-diseq      3947
;  :arith-assert-lower      18942
;  :arith-assert-upper      13632
;  :arith-bound-prop        3841
;  :arith-conflicts         1112
;  :arith-eq-adapter        12555
;  :arith-fixed-eqs         6584
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        8316
;  :arith-pivots            8340
;  :arith-pseudo-nonlinear  8
;  :conflicts               2468
;  :datatype-accessor-ax    183
;  :datatype-constructor-ax 1358
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               9751
;  :del-clause              73977
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.16
;  :memory                  11.00
;  :minimized-lits          450
;  :mk-bool-var             98605
;  :mk-clause               74196
;  :num-allocs              742753
;  :num-checks              379
;  :propagations            47462
;  :quant-instantiations    22310
;  :rlimit-count            3862751
;  :time                    0.00)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@208@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               64847
;  :arith-add-rows          53746
;  :arith-assert-diseq      3970
;  :arith-assert-lower      19058
;  :arith-assert-upper      13707
;  :arith-bound-prop        3867
;  :arith-conflicts         1120
;  :arith-eq-adapter        12630
;  :arith-fixed-eqs         6628
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        8404
;  :arith-pivots            8379
;  :arith-pseudo-nonlinear  8
;  :conflicts               2487
;  :datatype-accessor-ax    184
;  :datatype-constructor-ax 1369
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               9799
;  :del-clause              74201
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.16
;  :memory                  11.00
;  :minimized-lits          450
;  :mk-bool-var             98871
;  :mk-clause               74420
;  :num-allocs              743996
;  :num-checks              380
;  :propagations            47723
;  :quant-instantiations    22361
;  :rlimit-count            3871180
;  :time                    0.00)
(assert (<
  unknown1@208@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@208@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
              V@30@01)
            (<=
              0
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))))
          (<
            (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
            V@30@01))
        (<=
          0
          (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
              V@30@01)
            (<=
              0
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))))
          (<
            (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
            V@30@01))
        (<=
          0
          (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               67817
;  :arith-add-rows          55953
;  :arith-assert-diseq      4054
;  :arith-assert-lower      19789
;  :arith-assert-upper      14322
;  :arith-bound-prop        4024
;  :arith-conflicts         1142
;  :arith-eq-adapter        13223
;  :arith-fixed-eqs         6984
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        8845
;  :arith-pivots            8849
;  :arith-pseudo-nonlinear  8
;  :conflicts               2534
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 1382
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               9947
;  :del-clause              77023
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.20
;  :memory                  11.13
;  :minimized-lits          468
;  :mk-bool-var             102934
;  :mk-clause               77285
;  :num-allocs              760793
;  :num-checks              381
;  :propagations            49870
;  :quant-instantiations    23437
;  :rlimit-count            3960351
;  :time                    0.02)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               67817
;  :arith-add-rows          55953
;  :arith-assert-diseq      4054
;  :arith-assert-lower      19789
;  :arith-assert-upper      14322
;  :arith-bound-prop        4024
;  :arith-conflicts         1142
;  :arith-eq-adapter        13223
;  :arith-fixed-eqs         6984
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        8845
;  :arith-pivots            8849
;  :arith-pseudo-nonlinear  8
;  :conflicts               2534
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 1382
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               9947
;  :del-clause              77023
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.20
;  :memory                  11.13
;  :minimized-lits          468
;  :mk-bool-var             102934
;  :mk-clause               77285
;  :num-allocs              760820
;  :num-checks              382
;  :propagations            49870
;  :quant-instantiations    23437
;  :rlimit-count            3960381)
(assert (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (-
          (-
            (ite
              (and
                (<
                  (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  V@30@01)
                (<=
                  0
                  (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))
              $k@35@01
              $Perm.No)
            (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))
          (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))
        (-
          (-
            (ite
              (and
                (<
                  (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  V@30@01)
                (<=
                  0
                  (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))
              $k@43@01
              $Perm.No)
            (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))
          (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))
      (ite
        (and
          (<
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
            V@30@01)
          (<=
            0
            (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01)
        $Perm.No))
    (ite
      (and
        (<
          (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
          V@30@01)
        (<=
          0
          (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))
      (*
        (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
        $k@134@01)
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.05s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               74186
;  :arith-add-rows          61131
;  :arith-assert-diseq      4307
;  :arith-assert-lower      21580
;  :arith-assert-upper      15739
;  :arith-bound-prop        4269
;  :arith-conflicts         1197
;  :arith-eq-adapter        14511
;  :arith-fixed-eqs         7676
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        9680
;  :arith-pivots            9708
;  :arith-pseudo-nonlinear  8
;  :conflicts               2636
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 1386
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               10416
;  :del-clause              83834
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.66
;  :memory                  11.59
;  :minimized-lits          502
;  :mk-bool-var             112879
;  :mk-clause               84259
;  :num-allocs              799744
;  :num-checks              383
;  :propagations            54352
;  :quant-instantiations    26256
;  :rlimit-count            4189147
;  :time                    0.05)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               75932
;  :arith-add-rows          62497
;  :arith-assert-diseq      4391
;  :arith-assert-lower      22089
;  :arith-assert-upper      16133
;  :arith-bound-prop        4379
;  :arith-conflicts         1212
;  :arith-eq-adapter        14891
;  :arith-fixed-eqs         7874
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        9981
;  :arith-pivots            9997
;  :arith-pseudo-nonlinear  8
;  :conflicts               2671
;  :datatype-accessor-ax    185
;  :datatype-constructor-ax 1390
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               10533
;  :del-clause              86185
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              11.66
;  :memory                  11.59
;  :minimized-lits          506
;  :mk-bool-var             116505
;  :mk-clause               86610
;  :num-allocs              814147
;  :num-checks              384
;  :propagations            55496
;  :quant-instantiations    27076
;  :rlimit-count            4253302
;  :time                    0.02)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@208@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               79351
;  :arith-add-rows          64447
;  :arith-assert-diseq      4533
;  :arith-assert-lower      22977
;  :arith-assert-upper      16765
;  :arith-bound-prop        4538
;  :arith-conflicts         1238
;  :arith-eq-adapter        15559
;  :arith-fixed-eqs         8228
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        10537
;  :arith-pivots            10406
;  :arith-pseudo-nonlinear  8
;  :conflicts               2728
;  :datatype-accessor-ax    187
;  :datatype-constructor-ax 1398
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               10735
;  :del-clause              89957
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              12.87
;  :memory                  12.25
;  :minimized-lits          523
;  :mk-bool-var             122071
;  :mk-clause               90382
;  :num-allocs              835321
;  :num-checks              385
;  :propagations            57775
;  :quant-instantiations    28541
;  :rlimit-count            4344631
;  :time                    0.03)
(assert (<
  unknown1@208@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@208@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
              V@30@01)
            (<=
              0
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
          (<
            (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
            V@30@01))
        (<=
          0
          (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
              V@30@01)
            (<=
              0
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
          (<
            (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
            V@30@01))
        (<=
          0
          (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.03s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               83995
;  :arith-add-rows          68238
;  :arith-assert-diseq      4711
;  :arith-assert-lower      24096
;  :arith-assert-upper      17676
;  :arith-bound-prop        4788
;  :arith-conflicts         1269
;  :arith-eq-adapter        16393
;  :arith-fixed-eqs         8681
;  :arith-grobner           448
;  :arith-max-min           1459
;  :arith-nonlinear-bounds  160
;  :arith-nonlinear-horner  387
;  :arith-offset-eqs        11251
;  :arith-pivots            11010
;  :arith-pseudo-nonlinear  8
;  :conflicts               2793
;  :datatype-accessor-ax    187
;  :datatype-constructor-ax 1402
;  :datatype-occurs-check   731
;  :datatype-splits         668
;  :decisions               10957
;  :del-clause              94110
;  :final-checks            441
;  :interface-eqs           63
;  :max-generation          8
;  :max-memory              12.87
;  :memory                  12.62
;  :minimized-lits          548
;  :mk-bool-var             129776
;  :mk-clause               94570
;  :num-allocs              863916
;  :num-checks              386
;  :propagations            60133
;  :quant-instantiations    29657
;  :rlimit-count            4460711
;  :time                    0.03)
(pop) ; 21
(push) ; 21
; [else-branch: 235 | !(unknown1@208@01 < V@30@01 && 0 <= unknown1@208@01)]
(assert (not (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
  (and
    (< unknown1@208@01 V@30@01)
    (<= 0 unknown1@208@01)
    (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@208@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
    (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@208@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@208@01 Int)) (!
  (implies
    (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
    (and
      (< unknown1@208@01 V@30@01)
      (<= 0 unknown1@208@01)
      (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@208@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
      (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@208@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@208@01 Int)) (!
  (implies
    (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
    (and
      (< unknown1@208@01 V@30@01)
      (<= 0 unknown1@208@01)
      (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@208@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
      (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@208@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(push) ; 18
; [else-branch: 233 | !(unknown@199@01 < V@30@01 && 0 <= unknown@199@01)]
(assert (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01))))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01))
  (and
    (< unknown@199@01 V@30@01)
    (<= 0 unknown@199@01)
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((unknown1@208@01 Int)) (!
      (implies
        (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
        (and
          (< unknown1@208@01 V@30@01)
          (<= 0 unknown1@208@01)
          (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@208@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
          (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@208@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@208@01 Int)) (!
      (implies
        (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
        (and
          (< unknown1@208@01 V@30@01)
          (<= 0 unknown1@208@01)
          (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@208@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
          (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@208@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(assert (implies
  (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
  (and
    (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|)))))
(pop) ; 16
; Nested auxiliary terms: globals (aux)
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@201@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@201@01  $FPM) r))
  :qid |qp.resPrmSumDef86|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@201@01  $FPM) r))
  :qid |qp.resTrgDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef90|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@203@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@203@01  $FPM) r))
  :qid |qp.resPrmSumDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@203@01  $FPM) r))
  :qid |qp.resTrgDef92|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef97|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@205@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@205@01  $FPM) r))
  :qid |qp.resPrmSumDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@205@01  $FPM) r))
  :qid |qp.resTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef100|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef102|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@207@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@207@01  $FPM) r))
  :qid |qp.resPrmSumDef103|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@207@01  $FPM) r))
  :qid |qp.resTrgDef104|)))
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@199@01 Int)) (!
  (and
    (implies
      (<= 0 unknown@199@01)
      (and
        (<= 0 unknown@199@01)
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_option$array$ (as pm@201@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_int (as pm@203@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r))
          :qid |qp-fld-prm-bnd|))))
    (implies
      (not (<= 0 unknown@199@01))
      (and
        (not (<= 0 unknown@199@01))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
          :qid |qp-fld-prm-bnd|))))
    (implies
      (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01))
      (and
        (< unknown@199@01 V@30@01)
        (<= 0 unknown@199@01)
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((unknown1@208@01 Int)) (!
          (implies
            (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
            (and
              (< unknown1@208@01 V@30@01)
              (<= 0 unknown1@208@01)
              (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
              ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
              (not
                (=
                  ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  (as None<option<array>>  option<array>)))
              (<
                unknown1@208@01
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
              ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
              (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
              ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
              (not
                (=
                  ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  (as None<option<array>>  option<array>)))
              (<
                unknown1@208@01
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
              ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
          :qid |prog.l<no position>-aux|))
        (forall ((unknown1@208@01 Int)) (!
          (implies
            (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
            (and
              (< unknown1@208@01 V@30@01)
              (<= 0 unknown1@208@01)
              (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
              ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
              (not
                (=
                  ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  (as None<option<array>>  option<array>)))
              (<
                unknown1@208@01
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
              ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
              (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
              ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
              (not
                (=
                  ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  (as None<option<array>>  option<array>)))
              (<
                unknown1@208@01
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
              ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
          :qid |prog.l<no position>-aux|))))
    (implies
      (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
      (and
        (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
          :qid |qp-fld-prm-bnd|)))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@199@01 Int)) (!
  (and
    (implies
      (<= 0 unknown@199@01)
      (and
        (<= 0 unknown@199@01)
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_option$array$ (as pm@201@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_int (as pm@203@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r))
          :qid |qp-fld-prm-bnd|))))
    (implies
      (not (<= 0 unknown@199@01))
      (and
        (not (<= 0 unknown@199@01))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
          :qid |qp-fld-prm-bnd|))))
    (implies
      (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01))
      (and
        (< unknown@199@01 V@30@01)
        (<= 0 unknown@199@01)
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((unknown1@208@01 Int)) (!
          (implies
            (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
            (and
              (< unknown1@208@01 V@30@01)
              (<= 0 unknown1@208@01)
              (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
              ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
              (not
                (=
                  ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  (as None<option<array>>  option<array>)))
              (<
                unknown1@208@01
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
              ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
              (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
              ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
              (not
                (=
                  ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  (as None<option<array>>  option<array>)))
              (<
                unknown1@208@01
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
              ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
          :qid |prog.l<no position>-aux|))
        (forall ((unknown1@208@01 Int)) (!
          (implies
            (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
            (and
              (< unknown1@208@01 V@30@01)
              (<= 0 unknown1@208@01)
              (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
              ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
              (not
                (=
                  ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  (as None<option<array>>  option<array>)))
              (<
                unknown1@208@01
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
              ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
              (< unknown@199@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
              ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
              (not
                (=
                  ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  (as None<option<array>>  option<array>)))
              (<
                unknown1@208@01
                (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
              ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
          :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
          :qid |prog.l<no position>-aux|))))
    (implies
      (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
      (and
        (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
          :qid |qp-fld-prm-bnd|))
        (forall ((r $Ref)) (!
          (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
          :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
          :qid |qp-fld-prm-bnd|)))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@201@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@203@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@197@01  $FPM) r)
    (+
      (+
        (+
          (ite
            (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
            (*
              (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
              $k@134@01)
            $Perm.No)
          (ite
            (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
            (*
              (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
              $k@126@01)
            $Perm.No))
        (-
          (-
            (ite
              (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
              $k@43@01
              $Perm.No)
            (pTaken@95@01 r))
          (pTaken@106@01 r)))
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r))))
  :pattern (($FVF.perm_option$array$ (as pm@197@01  $FPM) r))
  :qid |qp.resPrmSumDef77|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@197@01  $FPM) r))
  :qid |qp.resTrgDef78|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@198@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@198@01  $FPM) r))
  :qid |qp.resPrmSumDef79|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@198@01  $FPM) r))
  :qid |qp.resTrgDef80|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef81|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef82|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef83|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef84|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef85|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@201@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@201@01  $FPM) r))
  :qid |qp.resPrmSumDef86|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@201@01  $FPM) r))
  :qid |qp.resTrgDef87|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef88|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef89|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@202@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef90|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@203@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@203@01  $FPM) r))
  :qid |qp.resPrmSumDef91|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@203@01  $FPM) r))
  :qid |qp.resTrgDef92|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef93|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef94|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef95|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef96|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef97|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@205@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@205@01  $FPM) r))
  :qid |qp.resPrmSumDef98|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@205@01  $FPM) r))
  :qid |qp.resTrgDef99|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef100|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef101|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@206@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef102|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@207@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@207@01  $FPM) r))
  :qid |qp.resPrmSumDef103|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@207@01  $FPM) r))
  :qid |qp.resTrgDef104|)))
(assert (implies
  (= exc@122@01 $Ref.null)
  (and
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@197@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@198@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((unknown@199@01 Int)) (!
      (and
        (implies
          (<= 0 unknown@199@01)
          (and
            (<= 0 unknown@199@01)
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_option$array$ (as pm@201@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_int (as pm@203@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r))
              :qid |qp-fld-prm-bnd|))))
        (implies
          (not (<= 0 unknown@199@01))
          (and
            (not (<= 0 unknown@199@01))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
              :qid |qp-fld-prm-bnd|))))
        (implies
          (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01))
          (and
            (< unknown@199@01 V@30@01)
            (<= 0 unknown@199@01)
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((unknown1@208@01 Int)) (!
              (implies
                (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
                (and
                  (< unknown1@208@01 V@30@01)
                  (<= 0 unknown1@208@01)
                  (<
                    unknown@199@01
                    (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  (not
                    (=
                      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                      (as None<option<array>>  option<array>)))
                  (<
                    unknown1@208@01
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
                  ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
                  (<
                    unknown@199@01
                    (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  (not
                    (=
                      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                      (as None<option<array>>  option<array>)))
                  (<
                    unknown1@208@01
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
                  ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
              :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
              :qid |prog.l<no position>-aux|))
            (forall ((unknown1@208@01 Int)) (!
              (implies
                (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
                (and
                  (< unknown1@208@01 V@30@01)
                  (<= 0 unknown1@208@01)
                  (<
                    unknown@199@01
                    (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  (not
                    (=
                      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                      (as None<option<array>>  option<array>)))
                  (<
                    unknown1@208@01
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
                  ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
                  (<
                    unknown@199@01
                    (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  (not
                    (=
                      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                      (as None<option<array>>  option<array>)))
                  (<
                    unknown1@208@01
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
                  ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
              :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
              :qid |prog.l<no position>-aux|))))
        (implies
          (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
          (and
            (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
              :qid |qp-fld-prm-bnd|)))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@199@01 Int)) (!
      (and
        (implies
          (<= 0 unknown@199@01)
          (and
            (<= 0 unknown@199@01)
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_option$array$ (as pm@201@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_int (as pm@203@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r))
              :qid |qp-fld-prm-bnd|))))
        (implies
          (not (<= 0 unknown@199@01))
          (and
            (not (<= 0 unknown@199@01))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
              :qid |qp-fld-prm-bnd|))))
        (implies
          (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01))
          (and
            (< unknown@199@01 V@30@01)
            (<= 0 unknown@199@01)
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((unknown1@208@01 Int)) (!
              (implies
                (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
                (and
                  (< unknown1@208@01 V@30@01)
                  (<= 0 unknown1@208@01)
                  (<
                    unknown@199@01
                    (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  (not
                    (=
                      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                      (as None<option<array>>  option<array>)))
                  (<
                    unknown1@208@01
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
                  ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
                  (<
                    unknown@199@01
                    (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  (not
                    (=
                      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                      (as None<option<array>>  option<array>)))
                  (<
                    unknown1@208@01
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
                  ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
              :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
              :qid |prog.l<no position>-aux|))
            (forall ((unknown1@208@01 Int)) (!
              (implies
                (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
                (and
                  (< unknown1@208@01 V@30@01)
                  (<= 0 unknown1@208@01)
                  (<
                    unknown@199@01
                    (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                  (not
                    (=
                      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))
                      (as None<option<array>>  option<array>)))
                  (<
                    unknown1@208@01
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01)))))
                  ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
                  (<
                    unknown@199@01
                    (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                  ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                  (not
                    (=
                      ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                        $Snap.unit
                        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))
                      (as None<option<array>>  option<array>)))
                  (<
                    unknown1@208@01
                    (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01)))))
                  ($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01)) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
              :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
              :qid |prog.l<no position>-aux|))))
        (implies
          (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
          (and
            (not (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01)))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
              :qid |qp-fld-prm-bnd|))
            (forall ((r $Ref)) (!
              (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
              :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
              :qid |qp-fld-prm-bnd|)))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))
      :qid |prog.l<no position>-aux|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@201@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@200@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@203@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@202@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@205@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@207@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@206@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|)))))
(set-option :timeout 0)
(push) ; 14
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((unknown@199@01 Int)) (!
    (implies
      (and (< unknown@199@01 V@30@01) (<= 0 unknown@199@01))
      (forall ((unknown1@208@01 Int)) (!
        (implies
          (and (< unknown1@208@01 V@30@01) (<= 0 unknown1@208@01))
          (=
            ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
            ($FVF.lookup_int (as sm@206@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))) unknown1@208@01))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))) unknown1@208@01))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@199@01))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@204@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@199@01))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unknown
(pop) ; 14
; 0.20s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               91980
;  :arith-add-rows          73361
;  :arith-assert-diseq      5041
;  :arith-assert-lower      26078
;  :arith-assert-upper      19278
;  :arith-bound-prop        5014
;  :arith-conflicts         1304
;  :arith-eq-adapter        17599
;  :arith-fixed-eqs         9457
;  :arith-grobner           653
;  :arith-max-min           1632
;  :arith-nonlinear-bounds  184
;  :arith-nonlinear-horner  576
;  :arith-offset-eqs        12701
;  :arith-pivots            11728
;  :arith-pseudo-nonlinear  8
;  :conflicts               2860
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1528
;  :datatype-occurs-check   829
;  :datatype-splits         790
;  :decisions               12067
;  :del-clause              100329
;  :final-checks            489
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              13.73
;  :memory                  13.53
;  :minimized-lits          560
;  :mk-bool-var             136747
;  :mk-clause               100338
;  :num-allocs              983289
;  :num-checks              389
;  :propagations            64934
;  :quant-instantiations    31510
;  :rlimit-count            5881327
;  :time                    0.20)
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map values
(declare-const pm@209@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@209@01  $FPM) r)
    (+
      (+
        (+
          (ite
            (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
            (*
              (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
              $k@134@01)
            $Perm.No)
          (ite
            (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
            (*
              (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
              $k@126@01)
            $Perm.No))
        (-
          (-
            (ite
              (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
              $k@43@01
              $Perm.No)
            (pTaken@95@01 r))
          (pTaken@106@01 r)))
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r))))
  :pattern (($FVF.perm_option$array$ (as pm@209@01  $FPM) r))
  :qid |qp.resPrmSumDef105|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@209@01  $FPM) r))
  :qid |qp.resTrgDef106|)))
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@209@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
; Definitional axioms for snapshot map values
(declare-const pm@210@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@210@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@210@01  $FPM) r))
  :qid |qp.resPrmSumDef107|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@210@01  $FPM) r))
  :qid |qp.resTrgDef108|)))
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@210@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
; [eval] exc == null ==> (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
; [eval] exc == null
(push) ; 14
(push) ; 15
(assert (not (not (= exc@122@01 $Ref.null))))
(check-sat)
; unknown
(pop) ; 15
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               92054
;  :arith-add-rows          73361
;  :arith-assert-diseq      5041
;  :arith-assert-lower      26093
;  :arith-assert-upper      19286
;  :arith-bound-prop        5014
;  :arith-conflicts         1304
;  :arith-eq-adapter        17599
;  :arith-fixed-eqs         9457
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        12701
;  :arith-pivots            11728
;  :arith-pseudo-nonlinear  8
;  :conflicts               2860
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1544
;  :datatype-occurs-check   839
;  :datatype-splits         798
;  :decisions               12083
;  :del-clause              100329
;  :final-checks            495
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              13.73
;  :memory                  13.49
;  :minimized-lits          560
;  :mk-bool-var             136761
;  :mk-clause               100338
;  :num-allocs              985986
;  :num-checks              391
;  :propagations            64934
;  :quant-instantiations    31510
;  :rlimit-count            5887425)
; [then-branch: 236 | exc@122@01 == Null | live]
; [else-branch: 236 | exc@122@01 != Null | dead]
(push) ; 15
; [then-branch: 236 | exc@122@01 == Null]
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
(declare-const sm@211@01 $FVF<option<array>>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef113|)))
(declare-const pm@212@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@212@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@212@01  $FPM) r))
  :qid |qp.resPrmSumDef114|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@212@01  $FPM) r))
  :qid |qp.resTrgDef115|)))
; Assume upper permission bound for field option$array$
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_option$array$ (as pm@212@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r) r))
  :qid |qp-fld-prm-bnd|)))
(declare-const sm@213@01 $FVF<Int>)
; Definitional axioms for snapshot map values
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@213@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@213@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef116|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@213@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@213@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@213@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef118|)))
(declare-const pm@214@01 $FPM)
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@214@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@214@01  $FPM) r))
  :qid |qp.resPrmSumDef119|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@213@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@214@01  $FPM) r))
  :qid |qp.resTrgDef120|)))
; Assume upper permission bound for field int
(assert (forall ((r $Ref)) (!
  (<= ($FVF.perm_int (as pm@214@01  $FPM) r) $Perm.Write)
  :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@213@01  $FVF<Int>) r) r))
  :qid |qp-fld-prm-bnd|)))
; [eval] (forall unknown: Int :: { opt_get1(aloc(opt_get1(target), unknown).option$array$) } { opt_get1(aloc(opt_get1(source), unknown).option$array$) } 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int))
(declare-const unknown@215@01 Int)
(push) ; 16
; [eval] 0 <= unknown && unknown < V ==> (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
; [eval] 0 <= unknown && unknown < V
; [eval] 0 <= unknown
(push) ; 17
; [then-branch: 237 | 0 <= unknown@215@01 | live]
; [else-branch: 237 | !(0 <= unknown@215@01) | live]
(push) ; 18
; [then-branch: 237 | 0 <= unknown@215@01]
(assert (<= 0 unknown@215@01))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] unknown < V
(pop) ; 18
(push) ; 18
; [else-branch: 237 | !(0 <= unknown@215@01)]
(assert (not (<= 0 unknown@215@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 18
(pop) ; 17
; Joined path conditions
; Joined path conditions
(push) ; 17
; [then-branch: 238 | unknown@215@01 < V@30@01 && 0 <= unknown@215@01 | live]
; [else-branch: 238 | !(unknown@215@01 < V@30@01 && 0 <= unknown@215@01) | live]
(push) ; 18
; [then-branch: 238 | unknown@215@01 < V@30@01 && 0 <= unknown@215@01]
(assert (and (< unknown@215@01 V@30@01) (<= 0 unknown@215@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] (forall unknown1: Int :: { aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1) } { aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1) } 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int)
(declare-const unknown1@216@01 Int)
(push) ; 19
; [eval] 0 <= unknown1 && unknown1 < V ==> aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] 0 <= unknown1 && unknown1 < V
; [eval] 0 <= unknown1
(push) ; 20
; [then-branch: 239 | 0 <= unknown1@216@01 | live]
; [else-branch: 239 | !(0 <= unknown1@216@01) | live]
(push) ; 21
; [then-branch: 239 | 0 <= unknown1@216@01]
(assert (<= 0 unknown1@216@01))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] unknown1 < V
(pop) ; 21
(push) ; 21
; [else-branch: 239 | !(0 <= unknown1@216@01)]
(assert (not (<= 0 unknown1@216@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 21
(pop) ; 20
; Joined path conditions
; Joined path conditions
(push) ; 20
; [then-branch: 240 | unknown1@216@01 < V@30@01 && 0 <= unknown1@216@01 | live]
; [else-branch: 240 | !(unknown1@216@01 < V@30@01 && 0 <= unknown1@216@01) | live]
(push) ; 21
; [then-branch: 240 | unknown1@216@01 < V@30@01 && 0 <= unknown1@216@01]
(assert (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01)))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1).int == aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1).int
; [eval] aloc(opt_get1(aloc(opt_get1(target), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(target), unknown).option$array$)
; [eval] aloc(opt_get1(target), unknown)
; [eval] opt_get1(target)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(set-option :timeout 0)
(push) ; 23
(assert (not (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               92313
;  :arith-add-rows          73361
;  :arith-assert-diseq      5041
;  :arith-assert-lower      26099
;  :arith-assert-upper      19288
;  :arith-bound-prop        5014
;  :arith-conflicts         1304
;  :arith-eq-adapter        17599
;  :arith-fixed-eqs         9457
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        12701
;  :arith-pivots            11730
;  :arith-pseudo-nonlinear  8
;  :conflicts               2860
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1600
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12139
;  :del-clause              100329
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              13.73
;  :memory                  13.49
;  :minimized-lits          560
;  :mk-bool-var             136811
;  :mk-clause               100338
;  :num-allocs              993642
;  :num-checks              399
;  :propagations            64934
;  :quant-instantiations    31510
;  :rlimit-count            5903859)
(assert (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               94242
;  :arith-add-rows          75752
;  :arith-assert-diseq      5197
;  :arith-assert-lower      26717
;  :arith-assert-upper      19714
;  :arith-bound-prop        5148
;  :arith-conflicts         1332
;  :arith-eq-adapter        17998
;  :arith-fixed-eqs         9692
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        13003
;  :arith-pivots            12037
;  :arith-pseudo-nonlinear  8
;  :conflicts               2919
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1604
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12256
;  :del-clause              101841
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              13.73
;  :memory                  13.49
;  :minimized-lits          571
;  :mk-bool-var             138941
;  :mk-clause               102052
;  :num-allocs              1004459
;  :num-checks              400
;  :propagations            66480
;  :quant-instantiations    32111
;  :rlimit-count            5996333
;  :time                    0.02)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               94242
;  :arith-add-rows          75752
;  :arith-assert-diseq      5197
;  :arith-assert-lower      26717
;  :arith-assert-upper      19714
;  :arith-bound-prop        5148
;  :arith-conflicts         1332
;  :arith-eq-adapter        17998
;  :arith-fixed-eqs         9692
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        13003
;  :arith-pivots            12037
;  :arith-pseudo-nonlinear  8
;  :conflicts               2920
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1604
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12256
;  :del-clause              101841
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              13.73
;  :memory                  13.49
;  :minimized-lits          571
;  :mk-bool-var             138941
;  :mk-clause               102052
;  :num-allocs              1004549
;  :num-checks              401
;  :propagations            66480
;  :quant-instantiations    32111
;  :rlimit-count            5996428)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@216@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               94246
;  :arith-add-rows          75754
;  :arith-assert-diseq      5197
;  :arith-assert-lower      26718
;  :arith-assert-upper      19715
;  :arith-bound-prop        5150
;  :arith-conflicts         1332
;  :arith-eq-adapter        17999
;  :arith-fixed-eqs         9692
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        13003
;  :arith-pivots            12039
;  :arith-pseudo-nonlinear  8
;  :conflicts               2921
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1604
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12256
;  :del-clause              101853
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              13.73
;  :memory                  13.48
;  :minimized-lits          571
;  :mk-bool-var             138958
;  :mk-clause               102064
;  :num-allocs              1004899
;  :num-checks              402
;  :propagations            66480
;  :quant-instantiations    32122
;  :rlimit-count            5997623)
(assert (<
  unknown1@216@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@216@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
              V@30@01)
            (<=
              0
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))))
          (<
            (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            V@30@01))
        (<=
          0
          (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
              V@30@01)
            (<=
              0
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))))
          (<
            (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            V@30@01))
        (<=
          0
          (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               95408
;  :arith-add-rows          77182
;  :arith-assert-diseq      5237
;  :arith-assert-lower      27067
;  :arith-assert-upper      19951
;  :arith-bound-prop        5256
;  :arith-conflicts         1345
;  :arith-eq-adapter        18210
;  :arith-fixed-eqs         9825
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        13177
;  :arith-pivots            12252
;  :arith-pseudo-nonlinear  8
;  :conflicts               2948
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1608
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12336
;  :del-clause              102933
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              13.73
;  :memory                  13.56
;  :minimized-lits          572
;  :mk-bool-var             141176
;  :mk-clause               103452
;  :num-allocs              1015338
;  :num-checks              403
;  :propagations            67114
;  :quant-instantiations    32548
;  :rlimit-count            6050689
;  :time                    0.01)
; [eval] aloc(opt_get1(aloc(opt_get1(source), unknown).option$array$), unknown1)
; [eval] opt_get1(aloc(opt_get1(source), unknown).option$array$)
; [eval] aloc(opt_get1(source), unknown)
; [eval] opt_get1(source)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(pop) ; 22
; Joined path conditions
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               95408
;  :arith-add-rows          77182
;  :arith-assert-diseq      5237
;  :arith-assert-lower      27067
;  :arith-assert-upper      19951
;  :arith-bound-prop        5256
;  :arith-conflicts         1345
;  :arith-eq-adapter        18210
;  :arith-fixed-eqs         9825
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        13177
;  :arith-pivots            12252
;  :arith-pseudo-nonlinear  8
;  :conflicts               2948
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1608
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12336
;  :del-clause              102933
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              13.73
;  :memory                  13.56
;  :minimized-lits          572
;  :mk-bool-var             141176
;  :mk-clause               103452
;  :num-allocs              1015365
;  :num-checks              404
;  :propagations            67114
;  :quant-instantiations    32548
;  :rlimit-count            6050719)
(assert (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(pop) ; 22
; Joined path conditions
(assert (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01))))
(assert ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (+
      (+
        (ite
          (and
            (<
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
              V@30@01)
            (<=
              0
              (inv@135@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@134@01)
          $Perm.No)
        (ite
          (and
            (<
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
              V@30@01)
            (<=
              0
              (inv@127@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (-
        (-
          (ite
            (and
              (<
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                V@30@01)
              (<=
                0
                (inv@44@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))
        (pTaken@106@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))
    (-
      (-
        (ite
          (and
            (<
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
              V@30@01)
            (<=
              0
              (inv@36@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))
          $k@35@01
          $Perm.No)
        (pTaken@96@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))
      (pTaken@105@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))))
(check-sat)
; unsat
(pop) ; 22
; 0.07s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               101288
;  :arith-add-rows          81549
;  :arith-assert-diseq      5461
;  :arith-assert-lower      28634
;  :arith-assert-upper      21098
;  :arith-bound-prop        5590
;  :arith-conflicts         1385
;  :arith-eq-adapter        19321
;  :arith-fixed-eqs         10477
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        13992
;  :arith-pivots            13038
;  :arith-pseudo-nonlinear  8
;  :conflicts               3028
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1612
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12723
;  :del-clause              108283
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              14.07
;  :memory                  13.96
;  :minimized-lits          587
;  :mk-bool-var             149353
;  :mk-clause               108802
;  :num-allocs              1049792
;  :num-checks              405
;  :propagations            70449
;  :quant-instantiations    34337
;  :rlimit-count            6225555
;  :time                    0.07)
(push) ; 22
; [eval] opt1 != (None(): option[array])
; [eval] (None(): option[array])
(push) ; 23
(assert (not (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
    (as None<option<array>>  option<array>)))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               101288
;  :arith-add-rows          81549
;  :arith-assert-diseq      5461
;  :arith-assert-lower      28634
;  :arith-assert-upper      21098
;  :arith-bound-prop        5590
;  :arith-conflicts         1385
;  :arith-eq-adapter        19321
;  :arith-fixed-eqs         10477
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        13992
;  :arith-pivots            13038
;  :arith-pseudo-nonlinear  8
;  :conflicts               3029
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1612
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12723
;  :del-clause              108283
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              14.07
;  :memory                  13.96
;  :minimized-lits          587
;  :mk-bool-var             149353
;  :mk-clause               108802
;  :num-allocs              1049882
;  :num-checks              406
;  :propagations            70449
;  :quant-instantiations    34337
;  :rlimit-count            6225646)
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
    (as None<option<array>>  option<array>))))
(pop) ; 22
; Joined path conditions
(assert (not
  (=
    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
    (as None<option<array>>  option<array>))))
(push) ; 22
; [eval] 0 <= i1
; [eval] i1 < alen(a2)
; [eval] alen(a2)
(push) ; 23
(assert (not (<
  unknown1@216@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))))
(check-sat)
; unsat
(pop) ; 23
; 0.00s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               101288
;  :arith-add-rows          81549
;  :arith-assert-diseq      5461
;  :arith-assert-lower      28634
;  :arith-assert-upper      21098
;  :arith-bound-prop        5590
;  :arith-conflicts         1385
;  :arith-eq-adapter        19321
;  :arith-fixed-eqs         10477
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        13992
;  :arith-pivots            13038
;  :arith-pseudo-nonlinear  8
;  :conflicts               3030
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1612
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12723
;  :del-clause              108283
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              14.07
;  :memory                  13.96
;  :minimized-lits          587
;  :mk-bool-var             149353
;  :mk-clause               108802
;  :num-allocs              1050025
;  :num-checks              407
;  :propagations            70449
;  :quant-instantiations    34337
;  :rlimit-count            6225889)
(assert (<
  unknown1@216@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))))
(pop) ; 22
; Joined path conditions
(assert (<
  unknown1@216@01
  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))))
(assert ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
  $Snap.unit
  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)))
(push) ; 22
(assert (not (<
  $Perm.No
  (+
    (ite
      (and
        (and
          (and
            (<
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
              V@30@01)
            (<=
              0
              (inv@149@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
          (<
            (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
            V@30@01))
        (<=
          0
          (inv@148@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
      $Perm.Write
      $Perm.No)
    (ite
      (and
        (and
          (and
            (<
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
              V@30@01)
            (<=
              0
              (inv@144@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
          (<
            (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
            V@30@01))
        (<=
          0
          (inv@143@01 (aloc ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
      $Perm.Write
      $Perm.No)))))
(check-sat)
; unsat
(pop) ; 22
; 0.02s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               103048
;  :arith-add-rows          82990
;  :arith-assert-diseq      5509
;  :arith-assert-lower      29104
;  :arith-assert-upper      21417
;  :arith-bound-prop        5678
;  :arith-conflicts         1403
;  :arith-eq-adapter        19598
;  :arith-fixed-eqs         10697
;  :arith-grobner           658
;  :arith-max-min           1658
;  :arith-nonlinear-bounds  187
;  :arith-nonlinear-horner  580
;  :arith-offset-eqs        14185
;  :arith-pivots            13265
;  :arith-pseudo-nonlinear  8
;  :conflicts               3068
;  :datatype-accessor-ax    227
;  :datatype-constructor-ax 1616
;  :datatype-occurs-check   874
;  :datatype-splits         826
;  :decisions               12849
;  :del-clause              109576
;  :final-checks            509
;  :interface-eqs           80
;  :max-generation          9
;  :max-memory              14.07
;  :memory                  13.95
;  :minimized-lits          593
;  :mk-bool-var             151455
;  :mk-clause               110095
;  :num-allocs              1058351
;  :num-checks              408
;  :propagations            71334
;  :quant-instantiations    34717
;  :rlimit-count            6274368
;  :time                    0.02)
(pop) ; 21
(push) ; 21
; [else-branch: 240 | !(unknown1@216@01 < V@30@01 && 0 <= unknown1@216@01)]
(assert (not (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))))
; [state consolidation]
; State saturation: before repetition
(set-option :timeout 10)
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 21
(pop) ; 20
; Joined path conditions
(assert (implies
  (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
  (and
    (< unknown1@216@01 V@30@01)
    (<= 0 unknown1@216@01)
    (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@216@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
    (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
    (not
      (=
        ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
        (as None<option<array>>  option<array>)))
    (<
      unknown1@216@01
      (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
    ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)))))
; Joined path conditions
(pop) ; 19
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown1@216@01 Int)) (!
  (implies
    (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
    (and
      (< unknown1@216@01 V@30@01)
      (<= 0 unknown1@216@01)
      (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@216@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
      (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@216@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown1@216@01 Int)) (!
  (implies
    (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
    (and
      (< unknown1@216@01 V@30@01)
      (<= 0 unknown1@216@01)
      (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@216@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
      (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
      ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
      (not
        (=
          ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
          (as None<option<array>>  option<array>)))
      (<
        unknown1@216@01
        (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
      ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
  :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 18
(push) ; 18
; [else-branch: 238 | !(unknown@215@01 < V@30@01 && 0 <= unknown@215@01)]
(assert (not (and (< unknown@215@01 V@30@01) (<= 0 unknown@215@01))))
; [state consolidation]
; State saturation: before repetition
(check-sat)
; unknown
; Definitional axioms for snapshot map values
; Assume upper permission bound for field option$array$
; Definitional axioms for snapshot map values
; Assume upper permission bound for field int
(pop) ; 18
(pop) ; 17
; Joined path conditions
(assert (implies
  (and (< unknown@215@01 V@30@01) (<= 0 unknown@215@01))
  (and
    (< unknown@215@01 V@30@01)
    (<= 0 unknown@215@01)
    (forall ((unknown1@216@01 Int)) (!
      (implies
        (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
        (and
          (< unknown1@216@01 V@30@01)
          (<= 0 unknown1@216@01)
          (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@216@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
          (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@216@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown1@216@01 Int)) (!
      (implies
        (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
        (and
          (< unknown1@216@01 V@30@01)
          (<= 0 unknown1@216@01)
          (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@216@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
          (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
          ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
          (not
            (=
              ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
              (as None<option<array>>  option<array>)))
          (<
            unknown1@216@01
            (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
          ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
            $Snap.unit
            $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
      :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
      :qid |prog.l<no position>-aux|)))))
; Joined path conditions
(pop) ; 16
; Nested auxiliary terms: globals (aux)
; Nested auxiliary terms: globals (tlq)
; Nested auxiliary terms: non-globals (aux)
(assert (forall ((unknown@215@01 Int)) (!
  (implies
    (and (< unknown@215@01 V@30@01) (<= 0 unknown@215@01))
    (and
      (< unknown@215@01 V@30@01)
      (<= 0 unknown@215@01)
      (forall ((unknown1@216@01 Int)) (!
        (implies
          (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
          (and
            (< unknown1@216@01 V@30@01)
            (<= 0 unknown1@216@01)
            (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@216@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@216@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@216@01 Int)) (!
        (implies
          (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
          (and
            (< unknown1@216@01 V@30@01)
            (<= 0 unknown1@216@01)
            (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@216@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@216@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))
  :qid |prog.l<no position>-aux|)))
(assert (forall ((unknown@215@01 Int)) (!
  (implies
    (and (< unknown@215@01 V@30@01) (<= 0 unknown@215@01))
    (and
      (< unknown@215@01 V@30@01)
      (<= 0 unknown@215@01)
      (forall ((unknown1@216@01 Int)) (!
        (implies
          (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
          (and
            (< unknown1@216@01 V@30@01)
            (<= 0 unknown1@216@01)
            (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@216@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@216@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
        :qid |prog.l<no position>-aux|))
      (forall ((unknown1@216@01 Int)) (!
        (implies
          (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
          (and
            (< unknown1@216@01 V@30@01)
            (<= 0 unknown1@216@01)
            (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@216@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
            ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
            (not
              (=
                ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                (as None<option<array>>  option<array>)))
            (<
              unknown1@216@01
              (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                $Snap.unit
                $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
            ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
        :qid |prog.l<no position>-aux|))))
  :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
    $Snap.unit
    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))
  :qid |prog.l<no position>-aux|)))
; Nested auxiliary terms: non-globals (tlq)
(pop) ; 15
(pop) ; 14
; Joined path conditions
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
            $k@35@01
            $Perm.No)
          (pTaken@96@01 r))
        (pTaken@105@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r))
  :qid |qp.fvfValDef109|)))
(assert (forall ((r $Ref)) (!
  (implies
    (<
      $Perm.No
      (-
        (-
          (ite
            (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
            $k@43@01
            $Perm.No)
          (pTaken@95@01 r))
        (pTaken@106@01 r)))
    (=
      ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r))
  :qid |qp.fvfValDef110|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@126@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r))
  :qid |qp.fvfValDef111|)))
(assert (forall ((r $Ref)) (!
  (implies
    (ite
      (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
      (<
        $Perm.No
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01))
      false)
    (=
      ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r)
      ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r)))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :pattern (($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r))
  :qid |qp.fvfValDef112|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r))
  :qid |qp.fvfResTrgDef113|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_option$array$ (as pm@212@01  $FPM) r)
    (+
      (+
        (+
          (-
            (-
              (ite
                (and (< (inv@36@01 r) V@30@01) (<= 0 (inv@36@01 r)))
                $k@35@01
                $Perm.No)
              (pTaken@96@01 r))
            (pTaken@105@01 r))
          (-
            (-
              (ite
                (and (< (inv@44@01 r) V@30@01) (<= 0 (inv@44@01 r)))
                $k@43@01
                $Perm.No)
              (pTaken@95@01 r))
            (pTaken@106@01 r)))
        (ite
          (and (< (inv@127@01 r) V@30@01) (<= 0 (inv@127@01 r)))
          (*
            (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
            $k@126@01)
          $Perm.No))
      (ite
        (and (< (inv@135@01 r) V@30@01) (<= 0 (inv@135@01 r)))
        (*
          (scale $Snap.unit (* (to_real (* V@30@01 V@30@01)) $Perm.Write))
          $k@134@01)
        $Perm.No)))
  :pattern (($FVF.perm_option$array$ (as pm@212@01  $FPM) r))
  :qid |qp.resPrmSumDef114|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@33@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@33@01))))))))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second $t@124@01))))) r) r)
    ($FVF.loc_option$array$ ($FVF.lookup_option$array$ ($SortWrappers.$SnapTo$FVF<option<array>> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))) r) r))
  :pattern (($FVF.perm_option$array$ (as pm@212@01  $FPM) r))
  :qid |qp.resTrgDef115|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
        (< (inv@143@01 r) V@30@01))
      (<= 0 (inv@143@01 r)))
    (=
      ($FVF.lookup_int (as sm@213@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@213@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef116|)))
(assert (forall ((r $Ref)) (!
  (implies
    (and
      (and
        (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
        (< (inv@148@01 r) V@30@01))
      (<= 0 (inv@148@01 r)))
    (=
      ($FVF.lookup_int (as sm@213@01  $FVF<Int>) r)
      ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r)))
  :pattern (($FVF.lookup_int (as sm@213@01  $FVF<Int>) r))
  :pattern (($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r))
  :qid |qp.fvfValDef117|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.lookup_int (as sm@213@01  $FVF<Int>) r))
  :qid |qp.fvfResTrgDef118|)))
(assert (forall ((r $Ref)) (!
  (=
    ($FVF.perm_int (as pm@214@01  $FPM) r)
    (+
      (ite
        (and
          (and
            (and (< (inv@144@01 r) V@30@01) (<= 0 (inv@144@01 r)))
            (< (inv@143@01 r) V@30@01))
          (<= 0 (inv@143@01 r)))
        $Perm.Write
        $Perm.No)
      (ite
        (and
          (and
            (and (< (inv@149@01 r) V@30@01) (<= 0 (inv@149@01 r)))
            (< (inv@148@01 r) V@30@01))
          (<= 0 (inv@148@01 r)))
        $Perm.Write
        $Perm.No)))
  :pattern (($FVF.perm_int (as pm@214@01  $FPM) r))
  :qid |qp.resPrmSumDef119|)))
(assert (forall ((r $Ref)) (!
  (and
    ($FVF.loc_int ($FVF.lookup_int (as sm@213@01  $FVF<Int>) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.first ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r)
    ($FVF.loc_int ($FVF.lookup_int ($SortWrappers.$SnapTo$FVF<Int> ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second ($Snap.second $t@124@01))))))))))))))) r) r))
  :pattern (($FVF.perm_int (as pm@214@01  $FPM) r))
  :qid |qp.resTrgDef120|)))
(assert (implies
  (= exc@122@01 $Ref.null)
  (and
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_option$array$ (as pm@212@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@211@01  $FVF<option<array>>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((r $Ref)) (!
      (<= ($FVF.perm_int (as pm@214@01  $FPM) r) $Perm.Write)
      :pattern (($FVF.loc_int ($FVF.lookup_int (as sm@213@01  $FVF<Int>) r) r))
      :qid |qp-fld-prm-bnd|))
    (forall ((unknown@215@01 Int)) (!
      (implies
        (and (< unknown@215@01 V@30@01) (<= 0 unknown@215@01))
        (and
          (< unknown@215@01 V@30@01)
          (<= 0 unknown@215@01)
          (forall ((unknown1@216@01 Int)) (!
            (implies
              (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
              (and
                (< unknown1@216@01 V@30@01)
                (<= 0 unknown1@216@01)
                (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@216@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
                (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@216@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@216@01 Int)) (!
            (implies
              (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
              (and
                (< unknown1@216@01 V@30@01)
                (<= 0 unknown1@216@01)
                (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@216@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
                (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@216@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))
      :qid |prog.l<no position>-aux|))
    (forall ((unknown@215@01 Int)) (!
      (implies
        (and (< unknown@215@01 V@30@01) (<= 0 unknown@215@01))
        (and
          (< unknown@215@01 V@30@01)
          (<= 0 unknown@215@01)
          (forall ((unknown1@216@01 Int)) (!
            (implies
              (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
              (and
                (< unknown1@216@01 V@30@01)
                (<= 0 unknown1@216@01)
                (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@216@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
                (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@216@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            :qid |prog.l<no position>-aux|))
          (forall ((unknown1@216@01 Int)) (!
            (implies
              (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
              (and
                (< unknown1@216@01 V@30@01)
                (<= 0 unknown1@216@01)
                (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit target@29@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@216@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
                (< unknown@215@01 (alen<Int> (opt_get1 $Snap.unit source@28@01)))
                ($FVF.loc_option$array$ ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                (not
                  (=
                    ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                      $Snap.unit
                      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))
                    (as None<option<array>>  option<array>)))
                (<
                  unknown1@216@01
                  (alen<Int> (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                    $Snap.unit
                    $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01)))))
                ($FVF.loc_int ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01)) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
                  $Snap.unit
                  $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
            :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
            :qid |prog.l<no position>-aux|))))
      :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
        $Snap.unit
        $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))
      :qid |prog.l<no position>-aux|)))))
(set-option :timeout 0)
(push) ; 14
(assert (not (implies
  (= exc@122@01 $Ref.null)
  (forall ((unknown@215@01 Int)) (!
    (implies
      (and (< unknown@215@01 V@30@01) (<= 0 unknown@215@01))
      (forall ((unknown1@216@01 Int)) (!
        (implies
          (and (< unknown1@216@01 V@30@01) (<= 0 unknown1@216@01))
          (=
            ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
            ($FVF.lookup_int (as sm@150@01  $FVF<Int>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
              $Snap.unit
              $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))) unknown1@216@01))
        :pattern ((aloc%limited ($Snap.combine $Snap.unit $Snap.unit) (opt_get1 $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
          $Snap.unit
          $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))) unknown1@216@01))
        :qid |prog.l<no position>|)))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit target@29@01) unknown@215@01))))
    :pattern ((opt_get1%limited $Snap.unit ($FVF.lookup_option$array$ (as sm@136@01  $FVF<option<array>>) (aloc ($Snap.combine
      $Snap.unit
      $Snap.unit) (opt_get1 $Snap.unit source@28@01) unknown@215@01))))
    :qid |prog.l<no position>|)))))
(check-sat)
; unknown
(pop) ; 14
; 0.21s
; (get-info :all-statistics)
(get-info :all-statistics)
; (:added-eqs               112823
;  :arith-add-rows          90217
;  :arith-assert-diseq      5978
;  :arith-assert-lower      31857
;  :arith-assert-upper      23594
;  :arith-bound-prop        5953
;  :arith-conflicts         1438
;  :arith-eq-adapter        21154
;  :arith-fixed-eqs         11675
;  :arith-gcd-tests         1
;  :arith-grobner           841
;  :arith-ineq-splits       1
;  :arith-max-min           1939
;  :arith-nonlinear-bounds  231
;  :arith-nonlinear-horner  751
;  :arith-offset-eqs        16080
;  :arith-patches           1
;  :arith-pivots            14349
;  :arith-pseudo-nonlinear  15
;  :conflicts               3121
;  :datatype-accessor-ax    296
;  :datatype-constructor-ax 1807
;  :datatype-occurs-check   1023
;  :datatype-splits         1013
;  :decisions               14523
;  :del-clause              117706
;  :final-checks            568
;  :interface-eqs           94
;  :max-generation          9
;  :max-memory              14.36
;  :memory                  14.06
;  :minimized-lits          600
;  :mk-bool-var             160827
;  :mk-clause               117715
;  :num-allocs              1219487
;  :num-checks              411
;  :propagations            76573
;  :quant-instantiations    37251
;  :rlimit-count            7687432
;  :time                    0.21)
(pop) ; 13
(pop) ; 12
(pop) ; 11
(pop) ; 10
(pop) ; 9
(pop) ; 8
(pop) ; 7
(pop) ; 6
(pop) ; 5
(pop) ; 4
(pop) ; 3
(pop) ; 2
(pop) ; 1
